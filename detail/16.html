<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by California Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by California Institute of Technology</h1>
    <div class="pagination">
        <span>[1]</span><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit aef5976fc52a497ac8161f54164c786c771d3ae8
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Jan 31 13:35:32 2014 -0800

    tools/liblockdep: Add include directory to allow tests to compile
    
    All of the programs in the tests directory require the
    liblockdep/mutex.h header in order to compile. Add the include directory
    to the compiler options so that the tests can be built with the provided
    Makefile.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Sasha Levin &lt;sasha.levin@oracle.com&gt;

diff --git a/tools/lib/lockdep/Makefile b/tools/lib/lockdep/Makefile
index da8b7aa3d351..e8dd7497f57a 100644
--- a/tools/lib/lockdep/Makefile
+++ b/tools/lib/lockdep/Makefile
@@ -112,7 +112,7 @@ export Q VERBOSE
 
 LIBLOCKDEP_VERSION = $(LL_VERSION).$(LL_PATCHLEVEL).$(LL_EXTRAVERSION)
 
-INCLUDES = -I. -I/usr/local/include -I./uinclude $(CONFIG_INCLUDES)
+INCLUDES = -I. -I/usr/local/include -I./uinclude -I./include $(CONFIG_INCLUDES)
 
 # Set compile option CFLAGS if not set elsewhere
 CFLAGS ?= -g -DCONFIG_LOCKDEP -DCONFIG_STACKTRACE -DCONFIG_PROVE_LOCKING -DBITS_PER_LONG=__WORDSIZE -DLIBLOCKDEP_VERSION='"$(LIBLOCKDEP_VERSION)"' -rdynamic -O0 -g</pre><hr><pre>commit 75759827bbe78e53330de2c5e061ecec7fa6f86e
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Jan 31 13:35:31 2014 -0800

    tools/liblockdep: Fix include of asm/hash.h
    
    Commit 71ae8aac ("lib: introduce arch optimized hash library")
    added an include to &lt;linux/hash.h&gt; for setting up an architecture
    specific fast hash.
    
    This patch mirrors the fix used for perf, titled "tools: perf: util: fix
    include for non x86 architectures".
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Sasha Levin &lt;sasha.levin@oracle.com&gt;

diff --git a/tools/lib/lockdep/uinclude/asm/hash.h b/tools/lib/lockdep/uinclude/asm/hash.h
new file mode 100644
index 000000000000..d82b170bb216
--- /dev/null
+++ b/tools/lib/lockdep/uinclude/asm/hash.h
@@ -0,0 +1,6 @@
+#ifndef __ASM_GENERIC_HASH_H
+#define __ASM_GENERIC_HASH_H
+
+/* Stub */
+
+#endif /* __ASM_GENERIC_HASH_H */</pre><hr><pre>commit 367d896dafe1b5f49bee75d3a419b9eb9936ae26
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Jan 31 15:30:54 2014 -0800

    tools/liblockdep: Fix initialization code path
    
    This makes initialization actually happen. Without it, initialization is
    always skipped due to an incorrect conditional statement.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Sasha Levin &lt;sasha.levin@oracle.com&gt;

diff --git a/tools/lib/lockdep/preload.c b/tools/lib/lockdep/preload.c
index f8465a811aa5..23bd69cb5ade 100644
--- a/tools/lib/lockdep/preload.c
+++ b/tools/lib/lockdep/preload.c
@@ -418,7 +418,7 @@ int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)
 
 __attribute__((constructor)) static void init_preload(void)
 {
-	if (__init_state != done)
+	if (__init_state == done)
 		return;
 
 #ifndef __GLIBC__</pre><hr><pre>commit 73615c8669ef1c497c942cae0d5079b95824332a
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Wed Jan 29 09:58:25 2014 -0800

    can: janz-ican3: fix uninitialized variable warnings
    
    Analysis of the code shows that the struct ican3_msg variable cannot be
    used uninitialized. Error conditions are checked and the loop terminates
    before calling the ican3_handle_message() function with an uninitialized
    value.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Acked-by: Oliver Hartkopp &lt;socketcan@hartkopp.net&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index e24e6690d672..07f0ba03cd59 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -1322,7 +1322,7 @@ static int ican3_napi(struct napi_struct *napi, int budget)
 
 	/* process all communication messages */
 	while (true) {
-		struct ican3_msg msg;
+		struct ican3_msg uninitialized_var(msg);
 		ret = ican3_recv_msg(mod, &amp;msg);
 		if (ret)
 			break;</pre><hr><pre>commit e21093ef6fb4cbecdf926102286dbe280ae965db
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Tue Sep 11 15:58:15 2012 -0700

    can: janz-ican3: fix support for older hardware revisions
    
    The Revision 1.0 Janz CMOD-IO Carrier Board does not have support for
    the reset registers. To support older hardware, the code is changed to
    use the hardware reset register on the Janz VMOD-ICAN3 hardware itself.
    
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index 98ee43819911..7edadee487ba 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -1391,7 +1391,6 @@ static irqreturn_t ican3_irq(int irq, void *dev_id)
  */
 static int ican3_reset_module(struct ican3_dev *mod)
 {
-	u8 val = 1 &lt;&lt; mod-&gt;num;
 	unsigned long start;
 	u8 runold, runnew;
 
@@ -1405,8 +1404,7 @@ static int ican3_reset_module(struct ican3_dev *mod)
 	runold = ioread8(mod-&gt;dpm + TARGET_RUNNING);
 
 	/* reset the module */
-	iowrite8(val, &amp;mod-&gt;ctrl-&gt;reset_assert);
-	iowrite8(val, &amp;mod-&gt;ctrl-&gt;reset_deassert);
+	iowrite8(0x00, &amp;mod-&gt;dpmctrl-&gt;hwreset);
 
 	/* wait until the module has finished resetting and is running */
 	start = jiffies;</pre><hr><pre>commit 3b5c6b9e49f78f07ebcd34b38c1185e57a0fd9eb
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Wed Jul 18 15:33:18 2012 -0700

    can: janz-ican3: add support for one shot mode
    
    The Janz VMOD-ICAN3 hardware has support for one shot packet
    transmission. This means that a packet will be attempted to be sent
    once, with no automatic retries.
    
    The SocketCAN core has a controller-wide setting for this mode:
    CAN_CTRLMODE_ONE_SHOT. The Janz VMOD-ICAN3 hardware supports this flag
    on a per-packet level, but the SocketCAN core does not.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index e06ec403521a..98ee43819911 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -116,6 +116,7 @@
 #define ICAN3_BUSERR_QUOTA_MAX	255
 
 /* Janz ICAN3 CAN Frame Conversion */
+#define ICAN3_SNGL	0x02
 #define ICAN3_ECHO	0x10
 #define ICAN3_EFF_RTR	0x40
 #define ICAN3_SFF_RTR	0x10
@@ -848,6 +849,10 @@ static void can_frame_to_ican3(struct ican3_dev *mod,
 	desc-&gt;data[0] |= cf-&gt;can_dlc;
 	desc-&gt;data[1] |= ICAN3_ECHO;
 
+	/* support single transmission (no retries) mode */
+	if (mod-&gt;can.ctrlmode &amp; CAN_CTRLMODE_ONE_SHOT)
+		desc-&gt;data[1] |= ICAN3_SNGL;
+
 	if (cf-&gt;can_id &amp; CAN_RTR_FLAG)
 		desc-&gt;data[0] |= ICAN3_EFF_RTR;
 
@@ -1810,7 +1815,8 @@ static int __devinit ican3_probe(struct platform_device *pdev)
 	mod-&gt;can.do_set_mode = ican3_set_mode;
 	mod-&gt;can.do_get_berr_counter = ican3_get_berr_counter;
 	mod-&gt;can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES
-				    | CAN_CTRLMODE_BERR_REPORTING;
+				    | CAN_CTRLMODE_BERR_REPORTING
+				    | CAN_CTRLMODE_ONE_SHOT;
 
 	/* find our IRQ number */
 	mod-&gt;irq = platform_get_irq(pdev, 0);</pre><hr><pre>commit 30df5888e4a244093c1b403b55ef889c97824f7b
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Wed Jul 18 15:33:17 2012 -0700

    can: janz-ican3: avoid firmware lockup caused by infinite bus error quota
    
    If the bus error quota is set to infinite and the host CPU cannot keep
    up, the Janz VMOD-ICAN3 firmware will stop responding to control
    messages until the controller is reset.
    
    The firmware will automatically stop sending bus error messages when the
    quota is reached, and will only resume sending bus error messages when
    the quota is re-set to a positive value.
    
    This limitation is worked around by setting the bus error quota to one
    message, and then re-setting the quota to one message every time a bus
    error message is received. By doing this, the firmware never stops
    responding to control messages. The CAN bus can be reset without a
    hard-reset of the controller card.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index 47f8f6b4fef9..e06ec403521a 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -972,6 +972,16 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 			stats-&gt;rx_errors++;
 		}
 
+		/*
+		 * The controller automatically disables bus-error interrupts
+		 * and therefore we must re-enable them.
+		 */
+		ret = ican3_set_buserror(mod, 1);
+		if (ret) {
+			dev_err(mod-&gt;dev, "unable to re-enable bus-error\n");
+			return ret;
+		}
+
 		/* bus error reporting is off, return immediately */
 		if (!(mod-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING))
 			return 0;
@@ -1451,7 +1461,7 @@ static int __devinit ican3_startup_module(struct ican3_dev *mod)
 	}
 
 	/* default to "bus errors enabled" */
-	ret = ican3_set_buserror(mod, ICAN3_BUSERR_QUOTA_MAX);
+	ret = ican3_set_buserror(mod, 1);
 	if (ret) {
 		dev_err(mod-&gt;dev, "unable to set bus-error\n");
 		return ret;</pre><hr><pre>commit 83702f69272e4591a91a27eb58eade1bcd361dae
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Jul 19 08:54:42 2012 -0700

    can: janz-ican3: fix support for CAN_RAW_RECV_OWN_MSGS
    
    The Janz VMOD-ICAN3 firmware does not support any sort of TX-done
    notification or interrupt. The driver previously used the hardware
    loopback to attempt to work around this deficiency, but this caused all
    sockets to receive all messages, even if CAN_RAW_RECV_OWN_MSGS is off.
    
    Using the new function ican3_cmp_echo_skb(), we can drop the loopback
    messages and return the original skbs. This fixes the issues with
    CAN_RAW_RECV_OWN_MSGS.
    
    A private skb queue is used to store the echo skbs. This avoids the need
    for any index management.
    
    Due to a lack of TX-error interrupts, bus errors are permanently
    enabled, and are used as a TX-error notification. This is used to drop
    an echo skb when transmission fails. Bus error packets are not generated
    if the user has not enabled bus error reporting.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index 4a5a8fb53a2f..47f8f6b4fef9 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -220,6 +220,9 @@ struct ican3_dev {
 	/* old and new style host interface */
 	unsigned int iftype;
 
+	/* queue for echo packets */
+	struct sk_buff_head echoq;
+
 	/*
 	 * Any function which changes the current DPM page must hold this
 	 * lock while it is performing data accesses. This ensures that the
@@ -925,7 +928,7 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 	struct net_device *dev = mod-&gt;ndev;
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	enum can_state state = mod-&gt;can.state;
-	u8 status, isrc, rxerr, txerr;
+	u8 isrc, ecc, status, rxerr, txerr;
 	struct can_frame *cf;
 	struct sk_buff *skb;
 
@@ -941,15 +944,43 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 		return -EINVAL;
 	}
 
-	skb = alloc_can_err_skb(dev, &amp;cf);
-	if (skb == NULL)
-		return -ENOMEM;
-
 	isrc = msg-&gt;data[0];
+	ecc = msg-&gt;data[2];
 	status = msg-&gt;data[3];
 	rxerr = msg-&gt;data[4];
 	txerr = msg-&gt;data[5];
 
+	/*
+	 * This hardware lacks any support other than bus error messages to
+	 * determine if packet transmission has failed.
+	 *
+	 * When TX errors happen, one echo skb needs to be dropped from the
+	 * front of the queue.
+	 *
+	 * A small bit of code is duplicated here and below, to avoid error
+	 * skb allocation when it will just be freed immediately.
+	 */
+	if (isrc == CEVTIND_BEI) {
+		int ret;
+		dev_dbg(mod-&gt;dev, "bus error interrupt\n");
+
+		/* TX error */
+		if (!(ecc &amp; ECC_DIR)) {
+			kfree_skb(skb_dequeue(&amp;mod-&gt;echoq));
+			stats-&gt;tx_errors++;
+		} else {
+			stats-&gt;rx_errors++;
+		}
+
+		/* bus error reporting is off, return immediately */
+		if (!(mod-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING))
+			return 0;
+	}
+
+	skb = alloc_can_err_skb(dev, &amp;cf);
+	if (skb == NULL)
+		return -ENOMEM;
+
 	/* data overrun interrupt */
 	if (isrc == CEVTIND_DOI || isrc == CEVTIND_LOST) {
 		dev_dbg(mod-&gt;dev, "data overrun interrupt\n");
@@ -978,9 +1009,6 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 
 	/* bus error interrupt */
 	if (isrc == CEVTIND_BEI) {
-		u8 ecc = msg-&gt;data[2];
-
-		dev_dbg(mod-&gt;dev, "bus error interrupt\n");
 		mod-&gt;can.can_stats.bus_error++;
 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
 
@@ -1000,12 +1028,8 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 			break;
 		}
 
-		if (!(ecc &amp; ECC_DIR)) {
+		if (!(ecc &amp; ECC_DIR))
 			cf-&gt;data[2] |= CAN_ERR_PROT_TX;
-			stats-&gt;tx_errors++;
-		} else {
-			stats-&gt;rx_errors++;
-		}
 
 		cf-&gt;data[6] = txerr;
 		cf-&gt;data[7] = rxerr;
@@ -1089,6 +1113,88 @@ static void ican3_handle_message(struct ican3_dev *mod, struct ican3_msg *msg)
 	}
 }
 
+/*
+ * The ican3 needs to store all echo skbs, and therefore cannot
+ * use the generic infrastructure for this.
+ */
+static void ican3_put_echo_skb(struct ican3_dev *mod, struct sk_buff *skb)
+{
+	struct sock *srcsk = skb-&gt;sk;
+
+	if (atomic_read(&amp;skb-&gt;users) != 1) {
+		struct sk_buff *old_skb = skb;
+
+		skb = skb_clone(old_skb, GFP_ATOMIC);
+		kfree_skb(old_skb);
+		if (!skb)
+			return;
+	} else {
+		skb_orphan(skb);
+	}
+
+	skb-&gt;sk = srcsk;
+
+	/* save this skb for tx interrupt echo handling */
+	skb_queue_tail(&amp;mod-&gt;echoq, skb);
+}
+
+static unsigned int ican3_get_echo_skb(struct ican3_dev *mod)
+{
+	struct sk_buff *skb = skb_dequeue(&amp;mod-&gt;echoq);
+	struct can_frame *cf;
+	u8 dlc;
+
+	/* this should never trigger unless there is a driver bug */
+	if (!skb) {
+		netdev_err(mod-&gt;ndev, "BUG: echo skb not occupied\n");
+		return 0;
+	}
+
+	cf = (struct can_frame *)skb-&gt;data;
+	dlc = cf-&gt;can_dlc;
+
+	/* check flag whether this packet has to be looped back */
+	if (skb-&gt;pkt_type != PACKET_LOOPBACK) {
+		kfree_skb(skb);
+		return dlc;
+	}
+
+	skb-&gt;protocol = htons(ETH_P_CAN);
+	skb-&gt;pkt_type = PACKET_BROADCAST;
+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
+	skb-&gt;dev = mod-&gt;ndev;
+	netif_receive_skb(skb);
+	return dlc;
+}
+
+/*
+ * Compare an skb with an existing echo skb
+ *
+ * This function will be used on devices which have a hardware loopback.
+ * On these devices, this function can be used to compare a received skb
+ * with the saved echo skbs so that the hardware echo skb can be dropped.
+ *
+ * Returns true if the skb's are identical, false otherwise.
+ */
+static bool ican3_echo_skb_matches(struct ican3_dev *mod, struct sk_buff *skb)
+{
+	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
+	struct sk_buff *echo_skb = skb_peek(&amp;mod-&gt;echoq);
+	struct can_frame *echo_cf;
+
+	if (!echo_skb)
+		return false;
+
+	echo_cf = (struct can_frame *)echo_skb-&gt;data;
+	if (cf-&gt;can_id != echo_cf-&gt;can_id)
+		return false;
+
+	if (cf-&gt;can_dlc != echo_cf-&gt;can_dlc)
+		return false;
+
+	return memcmp(cf-&gt;data, echo_cf-&gt;data, cf-&gt;can_dlc) == 0;
+}
+
 /*
  * Check that there is room in the TX ring to transmit another skb
  *
@@ -1099,6 +1205,10 @@ static bool ican3_txok(struct ican3_dev *mod)
 	struct ican3_fast_desc __iomem *desc;
 	u8 control;
 
+	/* check that we have echo queue space */
+	if (skb_queue_len(&amp;mod-&gt;echoq) &gt;= ICAN3_TX_BUFFERS)
+		return false;
+
 	/* copy the control bits of the descriptor */
 	ican3_set_page(mod, mod-&gt;fasttx_start + (mod-&gt;fasttx_num / 16));
 	desc = mod-&gt;dpm + ((mod-&gt;fasttx_num % 16) * sizeof(*desc));
@@ -1149,10 +1259,27 @@ static int ican3_recv_skb(struct ican3_dev *mod)
 	/* convert the ICAN3 frame into Linux CAN format */
 	ican3_to_can_frame(mod, &amp;desc, cf);
 
-	/* receive the skb, update statistics */
-	netif_receive_skb(skb);
+	/*
+	 * If this is an ECHO frame received from the hardware loopback
+	 * feature, use the skb saved in the ECHO stack instead. This allows
+	 * the Linux CAN core to support CAN_RAW_RECV_OWN_MSGS correctly.
+	 *
+	 * Since this is a confirmation of a successfully transmitted packet
+	 * sent from this host, update the transmit statistics.
+	 *
+	 * Also, the netdevice queue needs to be allowed to send packets again.
+	 */
+	if (ican3_echo_skb_matches(mod, skb)) {
+		stats-&gt;tx_packets++;
+		stats-&gt;tx_bytes += ican3_get_echo_skb(mod);
+		kfree_skb(skb);
+		goto err_noalloc;
+	}
+
+	/* update statistics, receive the skb */
 	stats-&gt;rx_packets++;
 	stats-&gt;rx_bytes += cf-&gt;can_dlc;
+	netif_receive_skb(skb);
 
 err_noalloc:
 	/* toggle the valid bit and return the descriptor to the ring */
@@ -1175,13 +1302,13 @@ static int ican3_recv_skb(struct ican3_dev *mod)
 static int ican3_napi(struct napi_struct *napi, int budget)
 {
 	struct ican3_dev *mod = container_of(napi, struct ican3_dev, napi);
-	struct ican3_msg msg;
 	unsigned long flags;
 	int received = 0;
 	int ret;
 
 	/* process all communication messages */
 	while (true) {
+		struct ican3_msg msg;
 		ret = ican3_recv_msg(mod, &amp;msg);
 		if (ret)
 			break;
@@ -1353,7 +1480,6 @@ static int __devinit ican3_startup_module(struct ican3_dev *mod)
 static int ican3_open(struct net_device *ndev)
 {
 	struct ican3_dev *mod = netdev_priv(ndev);
-	u8 quota;
 	int ret;
 
 	/* open the CAN layer */
@@ -1363,19 +1489,6 @@ static int ican3_open(struct net_device *ndev)
 		return ret;
 	}
 
-	/* set the bus error generation state appropriately */
-	if (mod-&gt;can.ctrlmode &amp; CAN_CTRLMODE_BERR_REPORTING)
-		quota = ICAN3_BUSERR_QUOTA_MAX;
-	else
-		quota = 0;
-
-	ret = ican3_set_buserror(mod, quota);
-	if (ret) {
-		dev_err(mod-&gt;dev, "unable to set bus-error\n");
-		close_candev(ndev);
-		return ret;
-	}
-
 	/* bring the bus online */
 	ret = ican3_set_bus_state(mod, true);
 	if (ret) {
@@ -1407,6 +1520,9 @@ static int ican3_stop(struct net_device *ndev)
 		return ret;
 	}
 
+	/* drop all outstanding echo skbs */
+	skb_queue_purge(&amp;mod-&gt;echoq);
+
 	/* close the CAN layer */
 	close_candev(ndev);
 	return 0;
@@ -1415,7 +1531,6 @@ static int ican3_stop(struct net_device *ndev)
 static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct ican3_dev *mod = netdev_priv(ndev);
-	struct net_device_stats *stats = &amp;ndev-&gt;stats;
 	struct can_frame *cf = (struct can_frame *)skb-&gt;data;
 	struct ican3_fast_desc desc;
 	void __iomem *desc_addr;
@@ -1428,8 +1543,7 @@ static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* check that we can actually transmit */
 	if (!ican3_txok(mod)) {
-		dev_err(mod-&gt;dev, "no free descriptors, stopping queue\n");
-		netif_stop_queue(ndev);
+		dev_err(mod-&gt;dev, "BUG: no free descriptors\n");
 		spin_unlock_irqrestore(&amp;mod-&gt;lock, flags);
 		return NETDEV_TX_BUSY;
 	}
@@ -1443,6 +1557,14 @@ static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
 	/* convert the Linux CAN frame into ICAN3 format */
 	can_frame_to_ican3(mod, cf, &amp;desc);
 
+	/*
+	 * This hardware doesn't have TX-done notifications, so we'll try and
+	 * emulate it the best we can using ECHO skbs. Add the skb to the ECHO
+	 * stack. Upon packet reception, check if the ECHO skb and received
+	 * skb match, and use that to wake the queue.
+	 */
+	ican3_put_echo_skb(mod, skb);
+
 	/*
 	 * the programming manual says that you must set the IVALID bit, then
 	 * interrupt, then set the valid bit. Quite weird, but it seems to be
@@ -1461,19 +1583,7 @@ static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
 	mod-&gt;fasttx_num = (desc.control &amp; DESC_WRAP) ? 0
 						     : (mod-&gt;fasttx_num + 1);
 
-	/* update statistics */
-	stats-&gt;tx_packets++;
-	stats-&gt;tx_bytes += cf-&gt;can_dlc;
-	kfree_skb(skb);
-
-	/*
-	 * This hardware doesn't have TX-done notifications, so we'll try and
-	 * emulate it the best we can using ECHO skbs. Get the next TX
-	 * descriptor, and see if we have room to send. If not, stop the queue.
-	 * It will be woken when the ECHO skb for the current packet is recv'd.
-	 */
-
-	/* copy the control bits of the descriptor */
+	/* if there is no free descriptor space, stop the transmit queue */
 	if (!ican3_txok(mod))
 		netif_stop_queue(ndev);
 
@@ -1669,6 +1779,7 @@ static int __devinit ican3_probe(struct platform_device *pdev)
 	mod-&gt;dev = &amp;pdev-&gt;dev;
 	mod-&gt;num = pdata-&gt;modno;
 	netif_napi_add(ndev, &amp;mod-&gt;napi, ican3_napi, ICAN3_RX_BUFFERS);
+	skb_queue_head_init(&amp;mod-&gt;echoq);
 	spin_lock_init(&amp;mod-&gt;lock);
 	init_completion(&amp;mod-&gt;termination_comp);
 	init_completion(&amp;mod-&gt;buserror_comp);</pre><hr><pre>commit 88b587039c1ad4e7a981bea3269eeb02a1a2a14b
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Jul 19 08:54:18 2012 -0700

    can: janz-ican3: fix error and byte counters
    
    The error and byte counter statistics were being incremented
    incorrectly. For example, a TX error would be counted both in tx_errors
    and rx_errors.
    
    This corrects the problem so that tx_errors and rx_errors are only
    incremented for errors caused by packets sent to the bus. Error packets
    generated by the driver are not counted.
    
    The byte counters are only increased for packets which are actually
    transmitted or received from the bus. Error packets generated by the
    driver are not counted.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index b19aca591c7a..4a5a8fb53a2f 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -907,8 +907,8 @@ static void ican3_handle_msglost(struct ican3_dev *mod, struct ican3_msg *msg)
 	if (skb) {
 		cf-&gt;can_id |= CAN_ERR_CRTL;
 		cf-&gt;data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+		stats-&gt;rx_over_errors++;
 		stats-&gt;rx_errors++;
-		stats-&gt;rx_bytes += cf-&gt;can_dlc;
 		netif_rx(skb);
 	}
 }
@@ -982,7 +982,6 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 
 		dev_dbg(mod-&gt;dev, "bus error interrupt\n");
 		mod-&gt;can.can_stats.bus_error++;
-		stats-&gt;rx_errors++;
 		cf-&gt;can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
 
 		switch (ecc &amp; ECC_MASK) {
@@ -1001,8 +1000,12 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 			break;
 		}
 
-		if ((ecc &amp; ECC_DIR) == 0)
+		if (!(ecc &amp; ECC_DIR)) {
 			cf-&gt;data[2] |= CAN_ERR_PROT_TX;
+			stats-&gt;tx_errors++;
+		} else {
+			stats-&gt;rx_errors++;
+		}
 
 		cf-&gt;data[6] = txerr;
 		cf-&gt;data[7] = rxerr;
@@ -1028,8 +1031,6 @@ static int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)
 	}
 
 	mod-&gt;can.state = state;
-	stats-&gt;rx_errors++;
-	stats-&gt;rx_bytes += cf-&gt;can_dlc;
 	netif_rx(skb);
 	return 0;
 }</pre><hr><pre>commit 007890d726602c925077381500f0b633cfacd711
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Wed Jul 18 15:33:14 2012 -0700

    can: janz-ican3: drop invalid skbs
    
    The commit which added the janz-ican3 driver and commit
    3ccd4c61 "can: Unify droping of invalid tx skbs and netdev stats" were
    committed into mainline Linux during the same merge window.
    
    Therefore, the addition of this code to the janz-ican3 driver was
    forgotten. This patch adds the expected code.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index f41623d003e1..754b803fa926 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -1420,6 +1420,9 @@ static int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)
 	void __iomem *desc_addr;
 	unsigned long flags;
 
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
 	spin_lock_irqsave(&amp;mod-&gt;lock, flags);
 
 	/* check that we can actually transmit */</pre>
    <div class="pagination">
        <span>[1]</span><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_2.html'>Next&gt;&gt;</a>
    <div>
</body>

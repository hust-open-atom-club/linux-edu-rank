<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_77.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><span>[78]</span><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_79.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 673c610033a8202c037ecd068c7a235495acda17
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 15 20:28:48 2010 -0500

    ext4: Move struct ext4_mount_options from ext4.h to super.c
    
    Move the ext4_mount_options structure definition from ext4.h, since it
    is only used in super.c.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 2d93620d092e..ddae3c435138 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -561,22 +561,6 @@ struct ext4_new_group_data {
 #define EXT4_IOC32_SETVERSION_OLD	FS_IOC32_SETVERSION
 #endif
 
-
-/*
- *  Mount options
- */
-struct ext4_mount_options {
-	unsigned long s_mount_opt;
-	uid_t s_resuid;
-	gid_t s_resgid;
-	unsigned long s_commit_interval;
-	u32 s_min_batch_time, s_max_batch_time;
-#ifdef CONFIG_QUOTA
-	int s_jquota_fmt;
-	char *s_qf_names[MAXQUOTAS];
-#endif
-};
-
 /* Max physical block we can addres w/o extents */
 #define EXT4_MAX_BLOCK_FILE_PHYS	0xFFFFFFFF
 
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index cf7d9131d785..7aa3a790363a 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4166,6 +4166,21 @@ static int ext4_unfreeze(struct super_block *sb)
 	return 0;
 }
 
+/*
+ * Structure to save mount options for ext4_remount's benefit
+ */
+struct ext4_mount_options {
+	unsigned long s_mount_opt;
+	uid_t s_resuid;
+	gid_t s_resgid;
+	unsigned long s_commit_interval;
+	u32 s_min_batch_time, s_max_batch_time;
+#ifdef CONFIG_QUOTA
+	int s_jquota_fmt;
+	char *s_qf_names[MAXQUOTAS];
+#endif
+};
+
 static int ext4_remount(struct super_block *sb, int *flags, char *data)
 {
 	struct ext4_super_block *es;</pre><hr><pre>commit fd8c37eccdda21153298997417144b38b1623196
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 15 20:26:48 2010 -0500

    ext4: Simplify the usage of clear_opt() and set_opt() macros
    
    Change clear_opt() and set_opt() to take a superblock pointer instead
    of a pointer to EXT4_SB(sb)-&gt;s_mount_opt.  This makes it easier for us
    to support a second mount option field.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 94ce3d7a1c4b..2d93620d092e 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -917,8 +917,10 @@ struct ext4_inode_info {
 #define EXT4_MOUNT_DISCARD		0x40000000 /* Issue DISCARD requests */
 #define EXT4_MOUNT_INIT_INODE_TABLE	0x80000000 /* Initialize uninitialized itables */
 
-#define clear_opt(o, opt)		o &amp;= ~EXT4_MOUNT_##opt
-#define set_opt(o, opt)			o |= EXT4_MOUNT_##opt
+#define clear_opt(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt &amp;= \
+						~EXT4_MOUNT_##opt
+#define set_opt(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt |= \
+						EXT4_MOUNT_##opt
 #define test_opt(sb, opt)		(EXT4_SB(sb)-&gt;s_mount_opt &amp; \
 					 EXT4_MOUNT_##opt)
 
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 5b4d4e3a4d58..731b6f738a03 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2617,7 +2617,7 @@ static inline int ext4_issue_discard(struct super_block *sb,
 	ret = sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);
 	if (ret == -EOPNOTSUPP) {
 		ext4_warning(sb, "discard not supported, disabling");
-		clear_opt(EXT4_SB(sb)-&gt;s_mount_opt, DISCARD);
+		clear_opt(sb, DISCARD);
 	}
 	return ret;
 }
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index fb15c9c0be74..cf7d9131d785 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1386,7 +1386,7 @@ static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)
 		sbi-&gt;s_qf_names[qtype] = NULL;
 		return 0;
 	}
-	set_opt(sbi-&gt;s_mount_opt, QUOTA);
+	set_opt(sb, QUOTA);
 	return 1;
 }
 
@@ -1441,21 +1441,21 @@ static int parse_options(char *options, struct super_block *sb,
 		switch (token) {
 		case Opt_bsd_df:
 			ext4_msg(sb, KERN_WARNING, deprecated_msg, p, "2.6.38");
-			clear_opt(sbi-&gt;s_mount_opt, MINIX_DF);
+			clear_opt(sb, MINIX_DF);
 			break;
 		case Opt_minix_df:
 			ext4_msg(sb, KERN_WARNING, deprecated_msg, p, "2.6.38");
-			set_opt(sbi-&gt;s_mount_opt, MINIX_DF);
+			set_opt(sb, MINIX_DF);
 
 			break;
 		case Opt_grpid:
 			ext4_msg(sb, KERN_WARNING, deprecated_msg, p, "2.6.38");
-			set_opt(sbi-&gt;s_mount_opt, GRPID);
+			set_opt(sb, GRPID);
 
 			break;
 		case Opt_nogrpid:
 			ext4_msg(sb, KERN_WARNING, deprecated_msg, p, "2.6.38");
-			clear_opt(sbi-&gt;s_mount_opt, GRPID);
+			clear_opt(sb, GRPID);
 
 			break;
 		case Opt_resuid:
@@ -1473,38 +1473,38 @@ static int parse_options(char *options, struct super_block *sb,
 			/* *sb_block = match_int(&amp;args[0]); */
 			break;
 		case Opt_err_panic:
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_CONT);
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_RO);
-			set_opt(sbi-&gt;s_mount_opt, ERRORS_PANIC);
+			clear_opt(sb, ERRORS_CONT);
+			clear_opt(sb, ERRORS_RO);
+			set_opt(sb, ERRORS_PANIC);
 			break;
 		case Opt_err_ro:
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_CONT);
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_PANIC);
-			set_opt(sbi-&gt;s_mount_opt, ERRORS_RO);
+			clear_opt(sb, ERRORS_CONT);
+			clear_opt(sb, ERRORS_PANIC);
+			set_opt(sb, ERRORS_RO);
 			break;
 		case Opt_err_cont:
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_RO);
-			clear_opt(sbi-&gt;s_mount_opt, ERRORS_PANIC);
-			set_opt(sbi-&gt;s_mount_opt, ERRORS_CONT);
+			clear_opt(sb, ERRORS_RO);
+			clear_opt(sb, ERRORS_PANIC);
+			set_opt(sb, ERRORS_CONT);
 			break;
 		case Opt_nouid32:
-			set_opt(sbi-&gt;s_mount_opt, NO_UID32);
+			set_opt(sb, NO_UID32);
 			break;
 		case Opt_debug:
-			set_opt(sbi-&gt;s_mount_opt, DEBUG);
+			set_opt(sb, DEBUG);
 			break;
 		case Opt_oldalloc:
-			set_opt(sbi-&gt;s_mount_opt, OLDALLOC);
+			set_opt(sb, OLDALLOC);
 			break;
 		case Opt_orlov:
-			clear_opt(sbi-&gt;s_mount_opt, OLDALLOC);
+			clear_opt(sb, OLDALLOC);
 			break;
 #ifdef CONFIG_EXT4_FS_XATTR
 		case Opt_user_xattr:
-			set_opt(sbi-&gt;s_mount_opt, XATTR_USER);
+			set_opt(sb, XATTR_USER);
 			break;
 		case Opt_nouser_xattr:
-			clear_opt(sbi-&gt;s_mount_opt, XATTR_USER);
+			clear_opt(sb, XATTR_USER);
 			break;
 #else
 		case Opt_user_xattr:
@@ -1514,10 +1514,10 @@ static int parse_options(char *options, struct super_block *sb,
 #endif
 #ifdef CONFIG_EXT4_FS_POSIX_ACL
 		case Opt_acl:
-			set_opt(sbi-&gt;s_mount_opt, POSIX_ACL);
+			set_opt(sb, POSIX_ACL);
 			break;
 		case Opt_noacl:
-			clear_opt(sbi-&gt;s_mount_opt, POSIX_ACL);
+			clear_opt(sb, POSIX_ACL);
 			break;
 #else
 		case Opt_acl:
@@ -1536,7 +1536,7 @@ static int parse_options(char *options, struct super_block *sb,
 					 "Cannot specify journal on remount");
 				return 0;
 			}
-			set_opt(sbi-&gt;s_mount_opt, UPDATE_JOURNAL);
+			set_opt(sb, UPDATE_JOURNAL);
 			break;
 		case Opt_journal_dev:
 			if (is_remount) {
@@ -1549,14 +1549,14 @@ static int parse_options(char *options, struct super_block *sb,
 			*journal_devnum = option;
 			break;
 		case Opt_journal_checksum:
-			set_opt(sbi-&gt;s_mount_opt, JOURNAL_CHECKSUM);
+			set_opt(sb, JOURNAL_CHECKSUM);
 			break;
 		case Opt_journal_async_commit:
-			set_opt(sbi-&gt;s_mount_opt, JOURNAL_ASYNC_COMMIT);
-			set_opt(sbi-&gt;s_mount_opt, JOURNAL_CHECKSUM);
+			set_opt(sb, JOURNAL_ASYNC_COMMIT);
+			set_opt(sb, JOURNAL_CHECKSUM);
 			break;
 		case Opt_noload:
-			set_opt(sbi-&gt;s_mount_opt, NOLOAD);
+			set_opt(sb, NOLOAD);
 			break;
 		case Opt_commit:
 			if (match_int(&amp;args[0], &amp;option))
@@ -1599,15 +1599,15 @@ static int parse_options(char *options, struct super_block *sb,
 					return 0;
 				}
 			} else {
-				clear_opt(sbi-&gt;s_mount_opt, DATA_FLAGS);
+				clear_opt(sb, DATA_FLAGS);
 				sbi-&gt;s_mount_opt |= data_opt;
 			}
 			break;
 		case Opt_data_err_abort:
-			set_opt(sbi-&gt;s_mount_opt, DATA_ERR_ABORT);
+			set_opt(sb, DATA_ERR_ABORT);
 			break;
 		case Opt_data_err_ignore:
-			clear_opt(sbi-&gt;s_mount_opt, DATA_ERR_ABORT);
+			clear_opt(sb, DATA_ERR_ABORT);
 			break;
 #ifdef CONFIG_QUOTA
 		case Opt_usrjquota:
@@ -1647,12 +1647,12 @@ static int parse_options(char *options, struct super_block *sb,
 			break;
 		case Opt_quota:
 		case Opt_usrquota:
-			set_opt(sbi-&gt;s_mount_opt, QUOTA);
-			set_opt(sbi-&gt;s_mount_opt, USRQUOTA);
+			set_opt(sb, QUOTA);
+			set_opt(sb, USRQUOTA);
 			break;
 		case Opt_grpquota:
-			set_opt(sbi-&gt;s_mount_opt, QUOTA);
-			set_opt(sbi-&gt;s_mount_opt, GRPQUOTA);
+			set_opt(sb, QUOTA);
+			set_opt(sb, GRPQUOTA);
 			break;
 		case Opt_noquota:
 			if (sb_any_quota_loaded(sb)) {
@@ -1660,9 +1660,9 @@ static int parse_options(char *options, struct super_block *sb,
 					"options when quota turned on");
 				return 0;
 			}
-			clear_opt(sbi-&gt;s_mount_opt, QUOTA);
-			clear_opt(sbi-&gt;s_mount_opt, USRQUOTA);
-			clear_opt(sbi-&gt;s_mount_opt, GRPQUOTA);
+			clear_opt(sb, QUOTA);
+			clear_opt(sb, USRQUOTA);
+			clear_opt(sb, GRPQUOTA);
 			break;
 #else
 		case Opt_quota:
@@ -1688,7 +1688,7 @@ static int parse_options(char *options, struct super_block *sb,
 			sbi-&gt;s_mount_flags |= EXT4_MF_FS_ABORTED;
 			break;
 		case Opt_nobarrier:
-			clear_opt(sbi-&gt;s_mount_opt, BARRIER);
+			clear_opt(sb, BARRIER);
 			break;
 		case Opt_barrier:
 			if (args[0].from) {
@@ -1697,9 +1697,9 @@ static int parse_options(char *options, struct super_block *sb,
 			} else
 				option = 1;	/* No argument, default to 1 */
 			if (option)
-				set_opt(sbi-&gt;s_mount_opt, BARRIER);
+				set_opt(sb, BARRIER);
 			else
-				clear_opt(sbi-&gt;s_mount_opt, BARRIER);
+				clear_opt(sb, BARRIER);
 			break;
 		case Opt_ignore:
 			break;
@@ -1723,17 +1723,17 @@ static int parse_options(char *options, struct super_block *sb,
 				 "Ignoring deprecated bh option");
 			break;
 		case Opt_i_version:
-			set_opt(sbi-&gt;s_mount_opt, I_VERSION);
+			set_opt(sb, I_VERSION);
 			sb-&gt;s_flags |= MS_I_VERSION;
 			break;
 		case Opt_nodelalloc:
-			clear_opt(sbi-&gt;s_mount_opt, DELALLOC);
+			clear_opt(sb, DELALLOC);
 			break;
 		case Opt_mblk_io_submit:
-			set_opt(sbi-&gt;s_mount_opt, MBLK_IO_SUBMIT);
+			set_opt(sb, MBLK_IO_SUBMIT);
 			break;
 		case Opt_nomblk_io_submit:
-			clear_opt(sbi-&gt;s_mount_opt, MBLK_IO_SUBMIT);
+			clear_opt(sb, MBLK_IO_SUBMIT);
 			break;
 		case Opt_stripe:
 			if (match_int(&amp;args[0], &amp;option))
@@ -1743,13 +1743,13 @@ static int parse_options(char *options, struct super_block *sb,
 			sbi-&gt;s_stripe = option;
 			break;
 		case Opt_delalloc:
-			set_opt(sbi-&gt;s_mount_opt, DELALLOC);
+			set_opt(sb, DELALLOC);
 			break;
 		case Opt_block_validity:
-			set_opt(sbi-&gt;s_mount_opt, BLOCK_VALIDITY);
+			set_opt(sb, BLOCK_VALIDITY);
 			break;
 		case Opt_noblock_validity:
-			clear_opt(sbi-&gt;s_mount_opt, BLOCK_VALIDITY);
+			clear_opt(sb, BLOCK_VALIDITY);
 			break;
 		case Opt_inode_readahead_blks:
 			if (match_int(&amp;args[0], &amp;option))
@@ -1773,7 +1773,7 @@ static int parse_options(char *options, struct super_block *sb,
 							    option);
 			break;
 		case Opt_noauto_da_alloc:
-			set_opt(sbi-&gt;s_mount_opt,NO_AUTO_DA_ALLOC);
+			set_opt(sb, NO_AUTO_DA_ALLOC);
 			break;
 		case Opt_auto_da_alloc:
 			if (args[0].from) {
@@ -1782,24 +1782,24 @@ static int parse_options(char *options, struct super_block *sb,
 			} else
 				option = 1;	/* No argument, default to 1 */
 			if (option)
-				clear_opt(sbi-&gt;s_mount_opt, NO_AUTO_DA_ALLOC);
+				clear_opt(sb, NO_AUTO_DA_ALLOC);
 			else
-				set_opt(sbi-&gt;s_mount_opt,NO_AUTO_DA_ALLOC);
+				set_opt(sb,NO_AUTO_DA_ALLOC);
 			break;
 		case Opt_discard:
-			set_opt(sbi-&gt;s_mount_opt, DISCARD);
+			set_opt(sb, DISCARD);
 			break;
 		case Opt_nodiscard:
-			clear_opt(sbi-&gt;s_mount_opt, DISCARD);
+			clear_opt(sb, DISCARD);
 			break;
 		case Opt_dioread_nolock:
-			set_opt(sbi-&gt;s_mount_opt, DIOREAD_NOLOCK);
+			set_opt(sb, DIOREAD_NOLOCK);
 			break;
 		case Opt_dioread_lock:
-			clear_opt(sbi-&gt;s_mount_opt, DIOREAD_NOLOCK);
+			clear_opt(sb, DIOREAD_NOLOCK);
 			break;
 		case Opt_init_inode_table:
-			set_opt(sbi-&gt;s_mount_opt, INIT_INODE_TABLE);
+			set_opt(sb, INIT_INODE_TABLE);
 			if (args[0].from) {
 				if (match_int(&amp;args[0], &amp;option))
 					return 0;
@@ -1810,7 +1810,7 @@ static int parse_options(char *options, struct super_block *sb,
 			sbi-&gt;s_li_wait_mult = option;
 			break;
 		case Opt_noinit_inode_table:
-			clear_opt(sbi-&gt;s_mount_opt, INIT_INODE_TABLE);
+			clear_opt(sb, INIT_INODE_TABLE);
 			break;
 		default:
 			ext4_msg(sb, KERN_ERR,
@@ -1822,10 +1822,10 @@ static int parse_options(char *options, struct super_block *sb,
 #ifdef CONFIG_QUOTA
 	if (sbi-&gt;s_qf_names[USRQUOTA] || sbi-&gt;s_qf_names[GRPQUOTA]) {
 		if (test_opt(sb, USRQUOTA) &amp;&amp; sbi-&gt;s_qf_names[USRQUOTA])
-			clear_opt(sbi-&gt;s_mount_opt, USRQUOTA);
+			clear_opt(sb, USRQUOTA);
 
 		if (test_opt(sb, GRPQUOTA) &amp;&amp; sbi-&gt;s_qf_names[GRPQUOTA])
-			clear_opt(sbi-&gt;s_mount_opt, GRPQUOTA);
+			clear_opt(sb, GRPQUOTA);
 
 		if (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {
 			ext4_msg(sb, KERN_ERR, "old and new quota "
@@ -3071,41 +3071,41 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 
 	/* Set defaults before we parse the mount options */
 	def_mount_opts = le32_to_cpu(es-&gt;s_default_mount_opts);
-	set_opt(sbi-&gt;s_mount_opt, INIT_INODE_TABLE);
+	set_opt(sb, INIT_INODE_TABLE);
 	if (def_mount_opts &amp; EXT4_DEFM_DEBUG)
-		set_opt(sbi-&gt;s_mount_opt, DEBUG);
+		set_opt(sb, DEBUG);
 	if (def_mount_opts &amp; EXT4_DEFM_BSDGROUPS) {
 		ext4_msg(sb, KERN_WARNING, deprecated_msg, "bsdgroups",
 			"2.6.38");
-		set_opt(sbi-&gt;s_mount_opt, GRPID);
+		set_opt(sb, GRPID);
 	}
 	if (def_mount_opts &amp; EXT4_DEFM_UID16)
-		set_opt(sbi-&gt;s_mount_opt, NO_UID32);
+		set_opt(sb, NO_UID32);
 #ifdef CONFIG_EXT4_FS_XATTR
 	if (def_mount_opts &amp; EXT4_DEFM_XATTR_USER)
-		set_opt(sbi-&gt;s_mount_opt, XATTR_USER);
+		set_opt(sb, XATTR_USER);
 #endif
 #ifdef CONFIG_EXT4_FS_POSIX_ACL
 	if (def_mount_opts &amp; EXT4_DEFM_ACL)
-		set_opt(sbi-&gt;s_mount_opt, POSIX_ACL);
+		set_opt(sb, POSIX_ACL);
 #endif
 	if ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)
-		set_opt(sbi-&gt;s_mount_opt, JOURNAL_DATA);
+		set_opt(sb, JOURNAL_DATA);
 	else if ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)
-		set_opt(sbi-&gt;s_mount_opt, ORDERED_DATA);
+		set_opt(sb, ORDERED_DATA);
 	else if ((def_mount_opts &amp; EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)
-		set_opt(sbi-&gt;s_mount_opt, WRITEBACK_DATA);
+		set_opt(sb, WRITEBACK_DATA);
 
 	if (le16_to_cpu(sbi-&gt;s_es-&gt;s_errors) == EXT4_ERRORS_PANIC)
-		set_opt(sbi-&gt;s_mount_opt, ERRORS_PANIC);
+		set_opt(sb, ERRORS_PANIC);
 	else if (le16_to_cpu(sbi-&gt;s_es-&gt;s_errors) == EXT4_ERRORS_CONTINUE)
-		set_opt(sbi-&gt;s_mount_opt, ERRORS_CONT);
+		set_opt(sb, ERRORS_CONT);
 	else
-		set_opt(sbi-&gt;s_mount_opt, ERRORS_RO);
+		set_opt(sb, ERRORS_RO);
 	if (def_mount_opts &amp; EXT4_DEFM_BLOCK_VALIDITY)
-		set_opt(sbi-&gt;s_mount_opt, BLOCK_VALIDITY);
+		set_opt(sb, BLOCK_VALIDITY);
 	if (def_mount_opts &amp; EXT4_DEFM_DISCARD)
-		set_opt(sbi-&gt;s_mount_opt, DISCARD);
+		set_opt(sb, DISCARD);
 
 	sbi-&gt;s_resuid = le16_to_cpu(es-&gt;s_def_resuid);
 	sbi-&gt;s_resgid = le16_to_cpu(es-&gt;s_def_resgid);
@@ -3114,7 +3114,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	sbi-&gt;s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;
 
 	if ((def_mount_opts &amp; EXT4_DEFM_NOBARRIER) == 0)
-		set_opt(sbi-&gt;s_mount_opt, BARRIER);
+		set_opt(sb, BARRIER);
 
 	/*
 	 * enable delayed allocation by default
@@ -3122,7 +3122,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	 */
 	if (!IS_EXT3_SB(sb) &amp;&amp;
 	    ((def_mount_opts &amp; EXT4_DEFM_NODELALLOC) == 0))
-		set_opt(sbi-&gt;s_mount_opt, DELALLOC);
+		set_opt(sb, DELALLOC);
 
 	if (!parse_options((char *) sbi-&gt;s_es-&gt;s_mount_opts, sb,
 			   &amp;journal_devnum, &amp;journal_ioprio, NULL, 0)) {
@@ -3425,8 +3425,8 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		       "suppressed and not mounted read-only");
 		goto failed_mount_wq;
 	} else {
-		clear_opt(sbi-&gt;s_mount_opt, DATA_FLAGS);
-		set_opt(sbi-&gt;s_mount_opt, WRITEBACK_DATA);
+		clear_opt(sb, DATA_FLAGS);
+		set_opt(sb, WRITEBACK_DATA);
 		sbi-&gt;s_journal = NULL;
 		needs_recovery = 0;
 		goto no_journal;
@@ -3464,9 +3464,9 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		 */
 		if (jbd2_journal_check_available_features
 		    (sbi-&gt;s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))
-			set_opt(sbi-&gt;s_mount_opt, ORDERED_DATA);
+			set_opt(sb, ORDERED_DATA);
 		else
-			set_opt(sbi-&gt;s_mount_opt, JOURNAL_DATA);
+			set_opt(sb, JOURNAL_DATA);
 		break;
 
 	case EXT4_MOUNT_ORDERED_DATA:
@@ -3556,18 +3556,18 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {
 		ext4_msg(sb, KERN_WARNING, "Ignoring delalloc option - "
 			 "requested data journaling mode");
-		clear_opt(sbi-&gt;s_mount_opt, DELALLOC);
+		clear_opt(sb, DELALLOC);
 	}
 	if (test_opt(sb, DIOREAD_NOLOCK)) {
 		if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {
 			ext4_msg(sb, KERN_WARNING, "Ignoring dioread_nolock "
 				"option - requested data journaling mode");
-			clear_opt(sbi-&gt;s_mount_opt, DIOREAD_NOLOCK);
+			clear_opt(sb, DIOREAD_NOLOCK);
 		}
 		if (sb-&gt;s_blocksize &lt; PAGE_SIZE) {
 			ext4_msg(sb, KERN_WARNING, "Ignoring dioread_nolock "
 				"option - block size is too small");
-			clear_opt(sbi-&gt;s_mount_opt, DIOREAD_NOLOCK);
+			clear_opt(sb, DIOREAD_NOLOCK);
 		}
 	}
 </pre><hr><pre>commit 1449032be17abb69116dbc393f67ceb8bd034f92
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Dec 14 15:27:50 2010 -0500

    ext4: Turn off multiple page-io submission by default
    
    Jon Nelson has found a test case which causes postgresql to fail with
    the error:
    
    psql:t.sql:4: ERROR: invalid page header in block 38269 of relation base/16384/16581
    
    Under memory pressure, it looks like part of a file can end up getting
    replaced by zero's.  Until we can figure out the cause, we'll roll
    back the change and use block_write_full_page() instead of
    ext4_bio_write_page().  The new, more efficient writing function can
    be used via the mount option mblk_io_submit, so we can test and fix
    the new page I/O code.
    
    To reproduce the problem, install postgres 8.4 or 9.0, and pin enough
    memory such that the system just at the end of triggering writeback
    before running the following sql script:
    
    begin;
    create temporary table foo as select x as a, ARRAY[x] as b FROM
    generate_series(1, 10000000 ) AS x;
    create index foo_a_idx on foo (a);
    create index foo_b_idx on foo USING GIN (b);
    rollback;
    
    If the temporary table is created on a hard drive partition which is
    encrypted using dm_crypt, then under memory pressure, approximately
    30-40% of the time, pgsql will issue the above failure.
    
    This patch should fix this problem, and the problem will come back if
    the file system is mounted with the mblk_io_submit mount option.
    
    Reported-by: Jon Nelson &lt;jnelson@jamponi.net&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 6a5edea2d70b..94ce3d7a1c4b 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -910,6 +910,7 @@ struct ext4_inode_info {
 #define EXT4_MOUNT_JOURNAL_CHECKSUM	0x800000 /* Journal checksums */
 #define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT	0x1000000 /* Journal Async Commit */
 #define EXT4_MOUNT_I_VERSION            0x2000000 /* i_version support */
+#define EXT4_MOUNT_MBLK_IO_SUBMIT	0x4000000 /* multi-block io submits */
 #define EXT4_MOUNT_DELALLOC		0x8000000 /* Delalloc support */
 #define EXT4_MOUNT_DATA_ERR_ABORT	0x10000000 /* Abort on file data write */
 #define EXT4_MOUNT_BLOCK_VALIDITY	0x20000000 /* Block validity checking */
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index bdbe69902207..e659597b690b 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2125,9 +2125,12 @@ static int mpage_da_submit_io(struct mpage_da_data *mpd,
 			 */
 			if (unlikely(journal_data &amp;&amp; PageChecked(page)))
 				err = __ext4_journalled_writepage(page, len);
-			else
+			else if (test_opt(inode-&gt;i_sb, MBLK_IO_SUBMIT))
 				err = ext4_bio_write_page(&amp;io_submit, page,
 							  len, mpd-&gt;wbc);
+			else
+				err = block_write_full_page(page,
+					noalloc_get_block_write, mpd-&gt;wbc);
 
 			if (!err)
 				mpd-&gt;pages_written++;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index e32195d6aac3..fb15c9c0be74 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1026,6 +1026,8 @@ static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)
 	    !(def_mount_opts &amp; EXT4_DEFM_NODELALLOC))
 		seq_puts(seq, ",nodelalloc");
 
+	if (test_opt(sb, MBLK_IO_SUBMIT))
+		seq_puts(seq, ",mblk_io_submit");
 	if (sbi-&gt;s_stripe)
 		seq_printf(seq, ",stripe=%lu", sbi-&gt;s_stripe);
 	/*
@@ -1239,8 +1241,8 @@ enum {
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
 	Opt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,
 	Opt_resize, Opt_usrquota, Opt_grpquota, Opt_i_version,
-	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
-	Opt_block_validity, Opt_noblock_validity,
+	Opt_stripe, Opt_delalloc, Opt_nodelalloc, Opt_mblk_io_submit,
+	Opt_nomblk_io_submit, Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio,
 	Opt_dioread_nolock, Opt_dioread_lock,
 	Opt_discard, Opt_nodiscard,
@@ -1304,6 +1306,8 @@ static const match_table_t tokens = {
 	{Opt_resize, "resize"},
 	{Opt_delalloc, "delalloc"},
 	{Opt_nodelalloc, "nodelalloc"},
+	{Opt_mblk_io_submit, "mblk_io_submit"},
+	{Opt_nomblk_io_submit, "nomblk_io_submit"},
 	{Opt_block_validity, "block_validity"},
 	{Opt_noblock_validity, "noblock_validity"},
 	{Opt_inode_readahead_blks, "inode_readahead_blks=%u"},
@@ -1725,6 +1729,12 @@ static int parse_options(char *options, struct super_block *sb,
 		case Opt_nodelalloc:
 			clear_opt(sbi-&gt;s_mount_opt, DELALLOC);
 			break;
+		case Opt_mblk_io_submit:
+			set_opt(sbi-&gt;s_mount_opt, MBLK_IO_SUBMIT);
+			break;
+		case Opt_nomblk_io_submit:
+			clear_opt(sbi-&gt;s_mount_opt, MBLK_IO_SUBMIT);
+			break;
 		case Opt_stripe:
 			if (match_int(&amp;args[0], &amp;option))
 				return 0;</pre><hr><pre>commit ab838338a2a9e0cb8346eb0cab9977be13e8dce5
Author: Andy Lutomirski &lt;luto@mit.edu&gt;
Date:   Tue Nov 16 18:40:52 2010 -0500

    nouveau: Acknowledge HPD irq in handler, not bottom half
    
    The old code generated an interrupt storm bad enough to completely
    take down my system.
    
    Signed-off-by: Andy Lutomirski &lt;luto@mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index 10a8d4e78e58..1c7db64c03bf 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -584,6 +584,12 @@ struct drm_nouveau_private {
 	struct work_struct irq_work;
 	struct work_struct hpd_work;
 
+	struct {
+		spinlock_t lock;
+		uint32_t hpd0_bits;
+		uint32_t hpd1_bits;
+	} hpd_state;
+
 	struct list_head vbl_waiting;
 
 	struct {
diff --git a/drivers/gpu/drm/nouveau/nouveau_irq.c b/drivers/gpu/drm/nouveau/nouveau_irq.c
index e2f2d59be3ea..7bfd9e6c9d67 100644
--- a/drivers/gpu/drm/nouveau/nouveau_irq.c
+++ b/drivers/gpu/drm/nouveau/nouveau_irq.c
@@ -60,6 +60,7 @@ nouveau_irq_preinstall(struct drm_device *dev)
 	if (dev_priv-&gt;card_type &gt;= NV_50) {
 		INIT_WORK(&amp;dev_priv-&gt;irq_work, nv50_display_irq_handler_bh);
 		INIT_WORK(&amp;dev_priv-&gt;hpd_work, nv50_display_irq_hotplug_bh);
+		spin_lock_init(&amp;dev_priv-&gt;hpd_state.lock);
 		INIT_LIST_HEAD(&amp;dev_priv-&gt;vbl_waiting);
 	}
 }
diff --git a/drivers/gpu/drm/nouveau/nv50_display.c b/drivers/gpu/drm/nouveau/nv50_display.c
index 55c9663ef2bf..f624c611ddea 100644
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -1032,11 +1032,18 @@ nv50_display_irq_hotplug_bh(struct work_struct *work)
 	struct drm_connector *connector;
 	const uint32_t gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
 	uint32_t unplug_mask, plug_mask, change_mask;
-	uint32_t hpd0, hpd1 = 0;
+	uint32_t hpd0, hpd1;
 
-	hpd0 = nv_rd32(dev, 0xe054) &amp; nv_rd32(dev, 0xe050);
+	spin_lock_irq(&amp;dev_priv-&gt;hpd_state.lock);
+	hpd0 = dev_priv-&gt;hpd_state.hpd0_bits;
+	dev_priv-&gt;hpd_state.hpd0_bits = 0;
+	hpd1 = dev_priv-&gt;hpd_state.hpd1_bits;
+	dev_priv-&gt;hpd_state.hpd1_bits = 0;
+	spin_unlock_irq(&amp;dev_priv-&gt;hpd_state.lock);
+
+	hpd0 &amp;= nv_rd32(dev, 0xe050);
 	if (dev_priv-&gt;chipset &gt;= 0x90)
-		hpd1 = nv_rd32(dev, 0xe074) &amp; nv_rd32(dev, 0xe070);
+		hpd1 &amp;= nv_rd32(dev, 0xe070);
 
 	plug_mask   = (hpd0 &amp; 0x0000ffff) | (hpd1 &lt;&lt; 16);
 	unplug_mask = (hpd0 &gt;&gt; 16) | (hpd1 &amp; 0xffff0000);
@@ -1078,10 +1085,6 @@ nv50_display_irq_hotplug_bh(struct work_struct *work)
 			helper-&gt;dpms(connector-&gt;encoder, DRM_MODE_DPMS_OFF);
 	}
 
-	nv_wr32(dev, 0xe054, nv_rd32(dev, 0xe054));
-	if (dev_priv-&gt;chipset &gt;= 0x90)
-		nv_wr32(dev, 0xe074, nv_rd32(dev, 0xe074));
-
 	drm_helper_hpd_irq_event(dev);
 }
 
@@ -1092,8 +1095,22 @@ nv50_display_irq_handler(struct drm_device *dev)
 	uint32_t delayed = 0;
 
 	if (nv_rd32(dev, NV50_PMC_INTR_0) &amp; NV50_PMC_INTR_0_HOTPLUG) {
-		if (!work_pending(&amp;dev_priv-&gt;hpd_work))
-			queue_work(dev_priv-&gt;wq, &amp;dev_priv-&gt;hpd_work);
+		uint32_t hpd0_bits, hpd1_bits = 0;
+
+		hpd0_bits = nv_rd32(dev, 0xe054);
+		nv_wr32(dev, 0xe054, hpd0_bits);
+
+		if (dev_priv-&gt;chipset &gt;= 0x90) {
+			hpd1_bits = nv_rd32(dev, 0xe074);
+			nv_wr32(dev, 0xe074, hpd1_bits);
+		}
+
+		spin_lock(&amp;dev_priv-&gt;hpd_state.lock);
+		dev_priv-&gt;hpd_state.hpd0_bits |= hpd0_bits;
+		dev_priv-&gt;hpd_state.hpd1_bits |= hpd1_bits;
+		spin_unlock(&amp;dev_priv-&gt;hpd_state.lock);
+
+		queue_work(dev_priv-&gt;wq, &amp;dev_priv-&gt;hpd_work);
 	}
 
 	while (nv_rd32(dev, NV50_PMC_INTR_0) &amp; NV50_PMC_INTR_0_DISPLAY) {</pre><hr><pre>commit 7ff9c073dd4d7200399076554f7ab9b876f196f6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 8 13:51:33 2010 -0500

    ext4: Add new ext4 inode tracepoints
    
    Add ext4_evict_inode, ext4_drop_inode, ext4_mark_inode_dirty, and
    ext4_begin_ordered_truncate()
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 191616470466..846e1e9db434 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -53,6 +53,7 @@
 static inline int ext4_begin_ordered_truncate(struct inode *inode,
 					      loff_t new_size)
 {
+	trace_ext4_begin_ordered_truncate(inode, new_size);
 	return jbd2_journal_begin_ordered_truncate(
 					EXT4_SB(inode-&gt;i_sb)-&gt;s_journal,
 					&amp;EXT4_I(inode)-&gt;jinode,
@@ -178,6 +179,7 @@ void ext4_evict_inode(struct inode *inode)
 	handle_t *handle;
 	int err;
 
+	trace_ext4_evict_inode(inode);
 	if (inode-&gt;i_nlink) {
 		truncate_inode_pages(&amp;inode-&gt;i_data, 0);
 		goto no_delete;
@@ -5649,6 +5651,7 @@ int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)
 	int err, ret;
 
 	might_sleep();
+	trace_ext4_mark_inode_dirty(inode, _RET_IP_);
 	err = ext4_reserve_inode_write(handle, inode, &amp;iloc);
 	if (ext4_handle_valid(handle) &amp;&amp;
 	    EXT4_I(inode)-&gt;i_extra_isize &lt; sbi-&gt;s_want_extra_isize &amp;&amp;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index ee91e29ddf95..61182fe6254e 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -833,6 +833,14 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	return &amp;ei-&gt;vfs_inode;
 }
 
+static int ext4_drop_inode(struct inode *inode)
+{
+	int drop = generic_drop_inode(inode);
+
+	trace_ext4_drop_inode(inode, drop);
+	return drop;
+}
+
 static void ext4_destroy_inode(struct inode *inode)
 {
 	ext4_ioend_wait(inode);
@@ -1175,6 +1183,7 @@ static const struct super_operations ext4_sops = {
 	.destroy_inode	= ext4_destroy_inode,
 	.write_inode	= ext4_write_inode,
 	.dirty_inode	= ext4_dirty_inode,
+	.drop_inode	= ext4_drop_inode,
 	.evict_inode	= ext4_evict_inode,
 	.put_super	= ext4_put_super,
 	.sync_fs	= ext4_sync_fs,
@@ -1196,6 +1205,7 @@ static const struct super_operations ext4_nojournal_sops = {
 	.destroy_inode	= ext4_destroy_inode,
 	.write_inode	= ext4_write_inode,
 	.dirty_inode	= ext4_dirty_inode,
+	.drop_inode	= ext4_drop_inode,
 	.evict_inode	= ext4_evict_inode,
 	.write_super	= ext4_write_super,
 	.put_super	= ext4_put_super,
diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index 289010d3270b..e5e345fb2a5c 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -98,6 +98,103 @@ TRACE_EVENT(ext4_allocate_inode,
 		  (unsigned long) __entry-&gt;dir, __entry-&gt;mode)
 );
 
+TRACE_EVENT(ext4_evict_inode,
+	TP_PROTO(struct inode *inode),
+
+	TP_ARGS(inode),
+
+	TP_STRUCT__entry(
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
+		__field(	ino_t,	ino			)
+		__field(	int,	nlink			)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;nlink	= inode-&gt;i_nlink;
+	),
+
+	TP_printk("dev %d,%d ino %lu nlink %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;nlink)
+);
+
+TRACE_EVENT(ext4_drop_inode,
+	TP_PROTO(struct inode *inode, int drop),
+
+	TP_ARGS(inode, drop),
+
+	TP_STRUCT__entry(
+		__field(	int,	dev_major		)
+		__field(	int,	dev_minor		)
+		__field(	ino_t,	ino			)
+		__field(	int,	drop			)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;drop	= drop;
+	),
+
+	TP_printk("dev %d,%d ino %lu drop %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;drop)
+);
+
+TRACE_EVENT(ext4_mark_inode_dirty,
+	TP_PROTO(struct inode *inode, unsigned long IP),
+
+	TP_ARGS(inode, IP),
+
+	TP_STRUCT__entry(
+		__field(	int,	dev_major		)
+		__field(	int,	dev_minor		)
+		__field(	ino_t,	ino			)
+		__field(unsigned long,	ip			)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;ip	= IP;
+	),
+
+	TP_printk("dev %d,%d ino %lu caller %pF",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, (void *)__entry-&gt;ip)
+);
+
+TRACE_EVENT(ext4_begin_ordered_truncate,
+	TP_PROTO(struct inode *inode, loff_t new_size),
+
+	TP_ARGS(inode, new_size),
+
+	TP_STRUCT__entry(
+		__field(	int,	dev_major		)
+		__field(	int,	dev_minor		)
+		__field(	ino_t,	ino			)
+		__field(	loff_t,	new_size		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev_major	= MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;ino		= inode-&gt;i_ino;
+		__entry-&gt;new_size	= new_size;
+	),
+
+	TP_printk("dev %d,%d ino %lu new_size %lld",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
+		  (long long) __entry-&gt;new_size)
+);
+
 DECLARE_EVENT_CLASS(ext4__write_begin,
 
 	TP_PROTO(struct inode *inode, loff_t pos, unsigned int len,</pre><hr><pre>commit b56ff9d397cecdaad6c98c9d57cc6fea475e1f50
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 8 13:49:33 2010 -0500

    ext4: Don't call sb_issue_discard() in ext4_free_blocks()
    
    Commit 5c521830cf (ext4: Support discard requests when running in
    no-journal mode) attempts to add sb_issue_discard() for data blocks
    (in data=writeback mode) and in no-journal mode.  Unfortunately, this
    no longer works, because in commit dd3932eddf (block: remove
    BLKDEV_IFL_WAIT), sb_issue_discard() only presents a synchronous
    interface, and there are times when we call ext4_free_blocks() when we
    are are holding a spinlock, or are otherwise in an atomic context.
    
    For now, I've removed the call to sb_issue_discard() to prevent a
    deadlock or (if spinlock debugging is enabled) failures like this:
    
    BUG: scheduling while atomic: rc.sysinit/1376/0x00000002
    Pid: 1376, comm: rc.sysinit Not tainted 2.6.36-ARCH #1
    Call Trace:
    [&lt;ffffffff810397ce&gt;] __schedule_bug+0x5e/0x70
    [&lt;ffffffff81403110&gt;] schedule+0x950/0xa70
    [&lt;ffffffff81060bad&gt;] ? insert_work+0x7d/0x90
    [&lt;ffffffff81060fbd&gt;] ? queue_work_on+0x1d/0x30
    [&lt;ffffffff81061127&gt;] ? queue_work+0x37/0x60
    [&lt;ffffffff8140377d&gt;] schedule_timeout+0x21d/0x360
    [&lt;ffffffff812031c3&gt;] ? generic_make_request+0x2c3/0x540
    [&lt;ffffffff81402680&gt;] wait_for_common+0xc0/0x150
    [&lt;ffffffff81041490&gt;] ? default_wake_function+0x0/0x10
    [&lt;ffffffff812034bc&gt;] ? submit_bio+0x7c/0x100
    [&lt;ffffffff810680a0&gt;] ? wake_bit_function+0x0/0x40
    [&lt;ffffffff814027b8&gt;] wait_for_completion+0x18/0x20
    [&lt;ffffffff8120a969&gt;] blkdev_issue_discard+0x1b9/0x210
    [&lt;ffffffff811ba03e&gt;] ext4_free_blocks+0x68e/0xb60
    [&lt;ffffffff811b1650&gt;] ? __ext4_handle_dirty_metadata+0x110/0x120
    [&lt;ffffffff811b098c&gt;] ext4_ext_truncate+0x8cc/0xa70
    [&lt;ffffffff810d713e&gt;] ? pagevec_lookup+0x1e/0x30
    [&lt;ffffffff81191618&gt;] ext4_truncate+0x178/0x5d0
    [&lt;ffffffff810eacbb&gt;] ? unmap_mapping_range+0xab/0x280
    [&lt;ffffffff810d8976&gt;] vmtruncate+0x56/0x70
    [&lt;ffffffff811925cb&gt;] ext4_setattr+0x14b/0x460
    [&lt;ffffffff811319e4&gt;] notify_change+0x194/0x380
    [&lt;ffffffff81117f80&gt;] do_truncate+0x60/0x90
    [&lt;ffffffff811e08fa&gt;] ? security_inode_permission+0x1a/0x20
    [&lt;ffffffff811eaec1&gt;] ? tomoyo_path_truncate+0x11/0x20
    [&lt;ffffffff81127539&gt;] do_last+0x5d9/0x770
    [&lt;ffffffff811278bd&gt;] do_filp_open+0x1ed/0x680
    [&lt;ffffffff8140644f&gt;] ? page_fault+0x1f/0x30
    [&lt;ffffffff81132bfc&gt;] ? alloc_fd+0xec/0x140
    [&lt;ffffffff81118db1&gt;] do_sys_open+0x61/0x120
    [&lt;ffffffff81118e8b&gt;] sys_open+0x1b/0x20
    [&lt;ffffffff81002e6b&gt;] system_call_fastpath+0x16/0x1b
    
    https://bugzilla.kernel.org/show_bug.cgi?id=22302
    
    Reported-by: Mathias Bur√©n &lt;mathias.buren@gmail.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: jiayingz@google.com

diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index c58eba34724a..5b4d4e3a4d58 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -4640,8 +4640,6 @@ void ext4_free_blocks(handle_t *handle, struct inode *inode,
 		 * with group lock held. generate_buddy look at
 		 * them with group lock_held
 		 */
-		if (test_opt(sb, DISCARD))
-			ext4_issue_discard(sb, block_group, bit, count);
 		ext4_lock_group(sb, block_group);
 		mb_clear_bits(bitmap_bh-&gt;b_data, bit, count);
 		mb_free_blocks(inode, &amp;e4b, bit, count);</pre><hr><pre>commit 83668e7141c7a0aa4035bde94344b81f9cf966ab
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 8 13:45:33 2010 -0500

    ext4: fix potential race when freeing ext4_io_page structures
    
    Use an atomic_t and make sure we don't free the structure while we
    might still be submitting I/O for that page.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 670d1343f914..6a5edea2d70b 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -177,7 +177,7 @@ struct mpage_da_data {
 
 struct ext4_io_page {
 	struct page	*p_page;
-	int		p_count;
+	atomic_t	p_count;
 };
 
 #define MAX_IO_PAGES 128
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index a24c8cca7370..7f5451cd1d38 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -67,6 +67,15 @@ void ext4_ioend_wait(struct inode *inode)
 	wait_event(*wq, (atomic_read(&amp;EXT4_I(inode)-&gt;i_ioend_count) == 0));
 }
 
+static void put_io_page(struct ext4_io_page *io_page)
+{
+	if (atomic_dec_and_test(&amp;io_page-&gt;p_count)) {
+		end_page_writeback(io_page-&gt;p_page);
+		put_page(io_page-&gt;p_page);
+		kmem_cache_free(io_page_cachep, io_page);
+	}
+}
+
 void ext4_free_io_end(ext4_io_end_t *io)
 {
 	int i;
@@ -75,15 +84,8 @@ void ext4_free_io_end(ext4_io_end_t *io)
 	BUG_ON(!io);
 	if (io-&gt;page)
 		put_page(io-&gt;page);
-	for (i = 0; i &lt; io-&gt;num_io_pages; i++) {
-		if (--io-&gt;pages[i]-&gt;p_count == 0) {
-			struct page *page = io-&gt;pages[i]-&gt;p_page;
-
-			end_page_writeback(page);
-			put_page(page);
-			kmem_cache_free(io_page_cachep, io-&gt;pages[i]);
-		}
-	}
+	for (i = 0; i &lt; io-&gt;num_io_pages; i++)
+		put_io_page(io-&gt;pages[i]);
 	io-&gt;num_io_pages = 0;
 	wq = to_ioend_wq(io-&gt;inode);
 	if (atomic_dec_and_test(&amp;EXT4_I(io-&gt;inode)-&gt;i_ioend_count) &amp;&amp;
@@ -235,13 +237,7 @@ static void ext4_end_bio(struct bio *bio, int error)
 			} while (bh != head);
 		}
 
-		if (--io_end-&gt;pages[i]-&gt;p_count == 0) {
-			struct page *page = io_end-&gt;pages[i]-&gt;p_page;
-
-			end_page_writeback(page);
-			put_page(page);
-			kmem_cache_free(io_page_cachep, io_end-&gt;pages[i]);
-		}
+		put_io_page(io_end-&gt;pages[i]);
 
 		/*
 		 * If this is a partial write which happened to make
@@ -369,7 +365,7 @@ static int io_submit_add_bh(struct ext4_io_submit *io,
 	if ((io_end-&gt;num_io_pages == 0) ||
 	    (io_end-&gt;pages[io_end-&gt;num_io_pages-1] != io_page)) {
 		io_end-&gt;pages[io_end-&gt;num_io_pages++] = io_page;
-		io_page-&gt;p_count++;
+		atomic_inc(&amp;io_page-&gt;p_count);
 	}
 	return 0;
 }
@@ -398,7 +394,7 @@ int ext4_bio_write_page(struct ext4_io_submit *io,
 		return -ENOMEM;
 	}
 	io_page-&gt;p_page = page;
-	io_page-&gt;p_count = 0;
+	atomic_set(&amp;io_page-&gt;p_count, 1);
 	get_page(page);
 
 	for (bh = head = page_buffers(page), block_start = 0;
@@ -430,10 +426,6 @@ int ext4_bio_write_page(struct ext4_io_submit *io,
 	 * PageWriteback bit from the page to prevent the system from
 	 * wedging later on.
 	 */
-	if (io_page-&gt;p_count == 0) {
-		put_page(page);
-		end_page_writeback(page);
-		kmem_cache_free(io_page_cachep, io_page);
-	}
+	put_io_page(io_page);
 	return ret;
 }</pre><hr><pre>commit f7ad6d2e9201a6e1c9ee6530a291452eb695feb8
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 8 13:43:33 2010 -0500

    ext4: handle writeback of inodes which are being freed
    
    The following BUG can occur when an inode which is getting freed when
    it still has dirty pages outstanding, and it gets deleted (in this
    because it was the target of a rename).  In ordered mode, we need to
    make sure the data pages are written just in case we crash before the
    rename (or unlink) is committed.  If the inode is being freed then
    when we try to igrab the inode, we end up tripping the BUG_ON at
    fs/ext4/page-io.c:146.
    
    To solve this problem, we need to keep track of the number of io
    callbacks which are pending, and avoid destroying the inode until they
    have all been completed.  That way we don't have to bump the inode
    count to keep the inode from being destroyed; an approach which
    doesn't work because the count could have already been dropped down to
    zero before the inode writeback has started (at which point we're not
    allowed to bump the count back up to 1, since it's already started
    getting freed).
    
    Thanks to Dave Chinner for suggesting this approach, which is also
    used by XFS.
    
      kernel BUG at /scratch_space/linux-2.6/fs/ext4/page-io.c:146!
      Call Trace:
       [&lt;ffffffff811075b1&gt;] ext4_bio_write_page+0x172/0x307
       [&lt;ffffffff811033a7&gt;] mpage_da_submit_io+0x2f9/0x37b
       [&lt;ffffffff811068d7&gt;] mpage_da_map_and_submit+0x2cc/0x2e2
       [&lt;ffffffff811069b3&gt;] mpage_add_bh_to_extent+0xc6/0xd5
       [&lt;ffffffff81106c66&gt;] write_cache_pages_da+0x2a4/0x3ac
       [&lt;ffffffff81107044&gt;] ext4_da_writepages+0x2d6/0x44d
       [&lt;ffffffff81087910&gt;] do_writepages+0x1c/0x25
       [&lt;ffffffff810810a4&gt;] __filemap_fdatawrite_range+0x4b/0x4d
       [&lt;ffffffff810815f5&gt;] filemap_fdatawrite_range+0xe/0x10
       [&lt;ffffffff81122a2e&gt;] jbd2_journal_begin_ordered_truncate+0x7b/0xa2
       [&lt;ffffffff8110615d&gt;] ext4_evict_inode+0x57/0x24c
       [&lt;ffffffff810c14a3&gt;] evict+0x22/0x92
       [&lt;ffffffff810c1a3d&gt;] iput+0x212/0x249
       [&lt;ffffffff810bdf16&gt;] dentry_iput+0xa1/0xb9
       [&lt;ffffffff810bdf6b&gt;] d_kill+0x3d/0x5d
       [&lt;ffffffff810be613&gt;] dput+0x13a/0x147
       [&lt;ffffffff810b990d&gt;] sys_renameat+0x1b5/0x258
       [&lt;ffffffff81145f71&gt;] ? _atomic_dec_and_lock+0x2d/0x4c
       [&lt;ffffffff810b2950&gt;] ? cp_new_stat+0xde/0xea
       [&lt;ffffffff810b29c1&gt;] ? sys_newlstat+0x2d/0x38
       [&lt;ffffffff810b99c6&gt;] sys_rename+0x16/0x18
       [&lt;ffffffff81002a2b&gt;] system_call_fastpath+0x16/0x1b
    
    Reported-by: Nick Bowler &lt;nbowler@elliptictech.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Tested-by: Nick Bowler &lt;nbowler@elliptictech.com&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 8b5dd6369f82..670d1343f914 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -858,6 +858,7 @@ struct ext4_inode_info {
 	spinlock_t i_completed_io_lock;
 	/* current io_end structure for async DIO write*/
 	ext4_io_end_t *cur_aio_dio;
+	atomic_t i_ioend_count;	/* Number of outstanding io_end structs */
 
 	/*
 	 * Transactions that contain inode's metadata needed to complete
@@ -2060,6 +2061,7 @@ extern int ext4_move_extents(struct file *o_filp, struct file *d_filp,
 /* page-io.c */
 extern int __init ext4_init_pageio(void);
 extern void ext4_exit_pageio(void);
+extern void ext4_ioend_wait(struct inode *);
 extern void ext4_free_io_end(ext4_io_end_t *io);
 extern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);
 extern int ext4_end_io_nolock(ext4_io_end_t *io);
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index 46a7d6a9d976..a24c8cca7370 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -32,8 +32,14 @@
 
 static struct kmem_cache *io_page_cachep, *io_end_cachep;
 
+#define WQ_HASH_SZ		37
+#define to_ioend_wq(v)	(&amp;ioend_wq[((unsigned long)v) % WQ_HASH_SZ])
+static wait_queue_head_t ioend_wq[WQ_HASH_SZ];
+
 int __init ext4_init_pageio(void)
 {
+	int i;
+
 	io_page_cachep = KMEM_CACHE(ext4_io_page, SLAB_RECLAIM_ACCOUNT);
 	if (io_page_cachep == NULL)
 		return -ENOMEM;
@@ -42,6 +48,8 @@ int __init ext4_init_pageio(void)
 		kmem_cache_destroy(io_page_cachep);
 		return -ENOMEM;
 	}
+	for (i = 0; i &lt; WQ_HASH_SZ; i++)
+		init_waitqueue_head(&amp;ioend_wq[i]);
 
 	return 0;
 }
@@ -52,9 +60,17 @@ void ext4_exit_pageio(void)
 	kmem_cache_destroy(io_page_cachep);
 }
 
+void ext4_ioend_wait(struct inode *inode)
+{
+	wait_queue_head_t *wq = to_ioend_wq(inode);
+
+	wait_event(*wq, (atomic_read(&amp;EXT4_I(inode)-&gt;i_ioend_count) == 0));
+}
+
 void ext4_free_io_end(ext4_io_end_t *io)
 {
 	int i;
+	wait_queue_head_t *wq;
 
 	BUG_ON(!io);
 	if (io-&gt;page)
@@ -69,7 +85,10 @@ void ext4_free_io_end(ext4_io_end_t *io)
 		}
 	}
 	io-&gt;num_io_pages = 0;
-	iput(io-&gt;inode);
+	wq = to_ioend_wq(io-&gt;inode);
+	if (atomic_dec_and_test(&amp;EXT4_I(io-&gt;inode)-&gt;i_ioend_count) &amp;&amp;
+	    waitqueue_active(wq))
+		wake_up_all(wq);
 	kmem_cache_free(io_end_cachep, io);
 }
 
@@ -142,8 +161,8 @@ ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)
 	io = kmem_cache_alloc(io_end_cachep, flags);
 	if (io) {
 		memset(io, 0, sizeof(*io));
-		io-&gt;inode = igrab(inode);
-		BUG_ON(!io-&gt;inode);
+		atomic_inc(&amp;EXT4_I(inode)-&gt;i_ioend_count);
+		io-&gt;inode = inode;
 		INIT_WORK(&amp;io-&gt;work, ext4_end_io_work);
 		INIT_LIST_HEAD(&amp;io-&gt;list);
 	}
@@ -171,35 +190,15 @@ static void ext4_end_bio(struct bio *bio, int error)
 	struct workqueue_struct *wq;
 	struct inode *inode;
 	unsigned long flags;
-	ext4_fsblk_t err_block;
 	int i;
 
 	BUG_ON(!io_end);
-	inode = io_end-&gt;inode;
 	bio-&gt;bi_private = NULL;
 	bio-&gt;bi_end_io = NULL;
 	if (test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags))
 		error = 0;
-	err_block = bio-&gt;bi_sector &gt;&gt; (inode-&gt;i_blkbits - 9);
 	bio_put(bio);
 
-	if (!(inode-&gt;i_sb-&gt;s_flags &amp; MS_ACTIVE)) {
-		pr_err("sb umounted, discard end_io request for inode %lu\n",
-			io_end-&gt;inode-&gt;i_ino);
-		ext4_free_io_end(io_end);
-		return;
-	}
-
-	if (error) {
-		io_end-&gt;flag |= EXT4_IO_END_ERROR;
-		ext4_warning(inode-&gt;i_sb, "I/O error writing to inode %lu "
-			     "(offset %llu size %ld starting block %llu)",
-			     inode-&gt;i_ino,
-			     (unsigned long long) io_end-&gt;offset,
-			     (long) io_end-&gt;size,
-			     (unsigned long long) err_block);
-	}
-
 	for (i = 0; i &lt; io_end-&gt;num_io_pages; i++) {
 		struct page *page = io_end-&gt;pages[i]-&gt;p_page;
 		struct buffer_head *bh, *head;
@@ -254,8 +253,19 @@ static void ext4_end_bio(struct bio *bio, int error)
 		if (!partial_write)
 			SetPageUptodate(page);
 	}
-
 	io_end-&gt;num_io_pages = 0;
+	inode = io_end-&gt;inode;
+
+	if (error) {
+		io_end-&gt;flag |= EXT4_IO_END_ERROR;
+		ext4_warning(inode-&gt;i_sb, "I/O error writing to inode %lu "
+			     "(offset %llu size %ld starting block %llu)",
+			     inode-&gt;i_ino,
+			     (unsigned long long) io_end-&gt;offset,
+			     (long) io_end-&gt;size,
+			     (unsigned long long)
+			     bio-&gt;bi_sector &gt;&gt; (inode-&gt;i_blkbits - 9));
+	}
 
 	/* Add the io_end to per-inode completed io list*/
 	spin_lock_irqsave(&amp;EXT4_I(inode)-&gt;i_completed_io_lock, flags);
@@ -305,7 +315,6 @@ static int io_submit_init(struct ext4_io_submit *io,
 	bio-&gt;bi_private = io-&gt;io_end = io_end;
 	bio-&gt;bi_end_io = ext4_end_bio;
 
-	io_end-&gt;inode = inode;
 	io_end-&gt;offset = (page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) + bh_offset(bh);
 
 	io-&gt;io_bio = bio;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 04352e9729d0..45653af88953 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -828,12 +828,14 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	ei-&gt;cur_aio_dio = NULL;
 	ei-&gt;i_sync_tid = 0;
 	ei-&gt;i_datasync_tid = 0;
+	atomic_set(&amp;ei-&gt;i_ioend_count, 0);
 
 	return &amp;ei-&gt;vfs_inode;
 }
 
 static void ext4_destroy_inode(struct inode *inode)
 {
+	ext4_ioend_wait(inode);
 	if (!list_empty(&amp;(EXT4_I(inode)-&gt;i_orphan))) {
 		ext4_msg(inode-&gt;i_sb, KERN_ERR,
 			 "Inode %lu (%p): orphan list check failed!",</pre><hr><pre>commit ce7e010aef63dc6b37a2354f7c9f5f4aedb37978
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Nov 3 12:03:21 2010 -0400

    ext4: initialize the percpu counters before replaying the journal
    
    We now initialize the percpu counters before replaying the journal,
    but after the journal, we recalculate the global counters, to deal
    with the possibility of the per-blockgroup counts getting updated by
    the journal replay.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 4d7ef31eacb1..04352e9729d0 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3347,6 +3347,24 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	get_random_bytes(&amp;sbi-&gt;s_next_generation, sizeof(u32));
 	spin_lock_init(&amp;sbi-&gt;s_next_gen_lock);
 
+	err = percpu_counter_init(&amp;sbi-&gt;s_freeblocks_counter,
+			ext4_count_free_blocks(sb));
+	if (!err) {
+		err = percpu_counter_init(&amp;sbi-&gt;s_freeinodes_counter,
+				ext4_count_free_inodes(sb));
+	}
+	if (!err) {
+		err = percpu_counter_init(&amp;sbi-&gt;s_dirs_counter,
+				ext4_count_dirs(sb));
+	}
+	if (!err) {
+		err = percpu_counter_init(&amp;sbi-&gt;s_dirtyblocks_counter, 0);
+	}
+	if (err) {
+		ext4_msg(sb, KERN_ERR, "insufficient memory");
+		goto failed_mount3;
+	}
+
 	sbi-&gt;s_stripe = ext4_get_stripe_size(sbi);
 	sbi-&gt;s_max_writeback_mb_bump = 128;
 
@@ -3445,22 +3463,19 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	}
 	set_task_ioprio(sbi-&gt;s_journal-&gt;j_task, journal_ioprio);
 
-no_journal:
-	err = percpu_counter_init(&amp;sbi-&gt;s_freeblocks_counter,
-				  ext4_count_free_blocks(sb));
-	if (!err)
-		err = percpu_counter_init(&amp;sbi-&gt;s_freeinodes_counter,
-					  ext4_count_free_inodes(sb));
-	if (!err)
-		err = percpu_counter_init(&amp;sbi-&gt;s_dirs_counter,
-					  ext4_count_dirs(sb));
-	if (!err)
-		err = percpu_counter_init(&amp;sbi-&gt;s_dirtyblocks_counter, 0);
-	if (err) {
-		ext4_msg(sb, KERN_ERR, "insufficient memory");
-		goto failed_mount_wq;
-	}
+	/*
+	 * The journal may have updated the bg summary counts, so we
+	 * need to update the global counters.
+	 */
+	percpu_counter_set(&amp;sbi-&gt;s_freeblocks_counter,
+			   ext4_count_free_blocks(sb));
+	percpu_counter_set(&amp;sbi-&gt;s_freeinodes_counter,
+			   ext4_count_free_inodes(sb));
+	percpu_counter_set(&amp;sbi-&gt;s_dirs_counter,
+			   ext4_count_dirs(sb));
+	percpu_counter_set(&amp;sbi-&gt;s_dirtyblocks_counter, 0);
 
+no_journal:
 	EXT4_SB(sb)-&gt;dio_unwritten_wq = create_workqueue("ext4-dio-unwritten");
 	if (!EXT4_SB(sb)-&gt;dio_unwritten_wq) {
 		printk(KERN_ERR "EXT4-fs: failed to create DIO workqueue\n");
@@ -3610,10 +3625,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		jbd2_journal_destroy(sbi-&gt;s_journal);
 		sbi-&gt;s_journal = NULL;
 	}
-	percpu_counter_destroy(&amp;sbi-&gt;s_freeblocks_counter);
-	percpu_counter_destroy(&amp;sbi-&gt;s_freeinodes_counter);
-	percpu_counter_destroy(&amp;sbi-&gt;s_dirs_counter);
-	percpu_counter_destroy(&amp;sbi-&gt;s_dirtyblocks_counter);
 failed_mount3:
 	if (sbi-&gt;s_flex_groups) {
 		if (is_vmalloc_addr(sbi-&gt;s_flex_groups))
@@ -3621,6 +3632,10 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		else
 			kfree(sbi-&gt;s_flex_groups);
 	}
+	percpu_counter_destroy(&amp;sbi-&gt;s_freeblocks_counter);
+	percpu_counter_destroy(&amp;sbi-&gt;s_freeinodes_counter);
+	percpu_counter_destroy(&amp;sbi-&gt;s_dirs_counter);
+	percpu_counter_destroy(&amp;sbi-&gt;s_dirtyblocks_counter);
 failed_mount2:
 	for (i = 0; i &lt; db_count; i++)
 		brelse(sbi-&gt;s_group_desc[i]);
@@ -3948,13 +3963,11 @@ static int ext4_commit_super(struct super_block *sb, int sync)
 	else
 		es-&gt;s_kbytes_written =
 			cpu_to_le64(EXT4_SB(sb)-&gt;s_kbytes_written);
-	if (percpu_counter_initialized(&amp;EXT4_SB(sb)-&gt;s_freeblocks_counter))
-		ext4_free_blocks_count_set(es, percpu_counter_sum_positive(
-					&amp;EXT4_SB(sb)-&gt;s_freeblocks_counter));
-	if (percpu_counter_initialized(&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter))
-		es-&gt;s_free_inodes_count =
-			cpu_to_le32(percpu_counter_sum_positive(
-					&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter));
+	ext4_free_blocks_count_set(es, percpu_counter_sum_positive(
+					   &amp;EXT4_SB(sb)-&gt;s_freeblocks_counter));
+	es-&gt;s_free_inodes_count =
+		cpu_to_le32(percpu_counter_sum_positive(
+				&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter));
 	sb-&gt;s_dirt = 0;
 	BUFFER_TRACE(sbh, "marking dirty");
 	mark_buffer_dirty(sbh);</pre><hr><pre>commit b2c78cd09b6ef78c8f20190f0b3e6df1d3651b70
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Nov 2 14:19:30 2010 -0400

    ext4: "ret" may be used uninitialized in ext4_lazyinit_thread()
    
    Newer GCC's reported the following build warning:
    
       fs/ext4/super.c: In function 'ext4_lazyinit_thread':
       fs/ext4/super.c:2702: warning: 'ret' may be used uninitialized in this function
    
    Fix it by removing the need for the ret variable in the first place.
    
    Signed-off-by: "Lukas Czerner" &lt;lczerner@redhat.com&gt;
    Reported-by: "Stefan Richter" &lt;stefanr@s5r6.in-berlin.de&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 8d1d9423ce9a..4d7ef31eacb1 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -2699,7 +2699,6 @@ static int ext4_lazyinit_thread(void *arg)
 	struct ext4_li_request *elr;
 	unsigned long next_wakeup;
 	DEFINE_WAIT(wait);
-	int ret;
 
 	BUG_ON(NULL == eli);
 
@@ -2723,13 +2722,12 @@ static int ext4_lazyinit_thread(void *arg)
 			elr = list_entry(pos, struct ext4_li_request,
 					 lr_request);
 
-			if (time_after_eq(jiffies, elr-&gt;lr_next_sched))
-				ret = ext4_run_li_request(elr);
-
-			if (ret) {
-				ret = 0;
-				ext4_remove_li_request(elr);
-				continue;
+			if (time_after_eq(jiffies, elr-&gt;lr_next_sched)) {
+				if (ext4_run_li_request(elr) != 0) {
+					/* error, remove the lazy_init job */
+					ext4_remove_li_request(elr);
+					continue;
+				}
 			}
 
 			if (time_before(elr-&gt;lr_next_sched, next_wakeup))</pre>
    <div class="pagination">
        <a href='1_77.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><span>[78]</span><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_79.html'>Next&gt;&gt;</a>
    <div>
</body>

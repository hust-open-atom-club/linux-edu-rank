<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_20.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><span>[21]</span><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_22.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ce553bd103c161df2676ff201746bff8ca512715
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:01 2017 -0400

    USB: ene_usb6250: implement REQUEST SENSE
    
    In the ene_usb6250 sub-driver for usb-storage, there is no support for
    the REQUEST SENSE command.  This command is issued whenever a failure
    occurs, and without it the driver has no way to tell the SCSI core
    what the reason for the failure was.
    
    This patch adds a do_scsi_request_sense() routine to the driver.  The
    new routine reports the error code stored by the previous command.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 107018447551..44aca29ad6cc 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -95,12 +95,12 @@ static struct us_unusual_dev ene_ub6250_unusual_dev_list[] = {
 #define REG_HW_TRAP1        0xFF89
 
 /* SRB Status */
-#define SS_SUCCESS                  0x00      /* No Sense */
-#define SS_NOT_READY                0x02
-#define SS_MEDIUM_ERR               0x03
-#define SS_HW_ERR                   0x04
-#define SS_ILLEGAL_REQUEST          0x05
-#define SS_UNIT_ATTENTION           0x06
+#define SS_SUCCESS		0x000000	/* No Sense */
+#define SS_NOT_READY		0x023A00	/* Medium not present */
+#define SS_MEDIUM_ERR		0x031100	/* Unrecovered read error */
+#define SS_HW_ERR		0x040800	/* Communication failure */
+#define SS_ILLEGAL_REQUEST	0x052000	/* Invalid command */
+#define SS_UNIT_ATTENTION	0x062900	/* Reset occurred */
 
 /* ENE Load FW Pattern */
 #define SD_INIT1_PATTERN   1
@@ -577,6 +577,22 @@ static int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
+static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
+{
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	unsigned char buf[18];
+
+	memset(buf, 0, 18);
+	buf[0] = 0x70;				/* Current error */
+	buf[2] = info-&gt;SrbStatus &gt;&gt; 16;		/* Sense key */
+	buf[7] = 10;				/* Additional length */
+	buf[12] = info-&gt;SrbStatus &gt;&gt; 8;		/* ASC */
+	buf[13] = info-&gt;SrbStatus;		/* ASCQ */
+
+	usb_stor_set_xfer_buf(buf, sizeof(buf), srb);
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
 static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -2212,11 +2228,13 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 	int    result;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)us-&gt;extra;
 
-	info-&gt;SrbStatus = SS_SUCCESS;
 	switch (srb-&gt;cmnd[0]) {
 	case TEST_UNIT_READY:
 		result = sd_scsi_test_unit_ready(us, srb);
 		break; /* 0x00 */
+	case REQUEST_SENSE:
+		result = do_scsi_request_sense(us, srb);
+		break; /* 0x03 */
 	case INQUIRY:
 		result = sd_scsi_inquiry(us, srb);
 		break; /* 0x12 */
@@ -2242,6 +2260,8 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = USB_STOR_TRANSPORT_FAILED;
 		break;
 	}
+	if (result == USB_STOR_TRANSPORT_GOOD)
+		info-&gt;SrbStatus = SS_SUCCESS;
 	return result;
 }
 
@@ -2252,11 +2272,14 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 {
 	int result;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)us-&gt;extra;
-	info-&gt;SrbStatus = SS_SUCCESS;
+
 	switch (srb-&gt;cmnd[0]) {
 	case TEST_UNIT_READY:
 		result = ms_scsi_test_unit_ready(us, srb);
 		break; /* 0x00 */
+	case REQUEST_SENSE:
+		result = do_scsi_request_sense(us, srb);
+		break; /* 0x03 */
 	case INQUIRY:
 		result = ms_scsi_inquiry(us, srb);
 		break; /* 0x12 */
@@ -2277,6 +2300,8 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = USB_STOR_TRANSPORT_FAILED;
 		break;
 	}
+	if (result == USB_STOR_TRANSPORT_GOOD)
+		info-&gt;SrbStatus = SS_SUCCESS;
 	return result;
 }
 </pre><hr><pre>commit aa18c4b6e0e39bfb00af48734ec24bc189ac9909
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:52 2017 -0400

    USB: ene_usb6250: fix SCSI residue overwriting
    
    In the ene_usb6250 sub-driver for usb-storage, the SCSI residue is not
    reported correctly.  The residue is initialized to 0, but this value
    is overwritten whenever the driver sends firmware to the card reader
    before performing the current command.  As a result, a valid READ or
    WRITE operation appears to have failed, causing the SCSI core to retry
    the command multiple times and eventually fail.
    
    This patch fixes the problem by resetting the SCSI residue to 0 after
    sending firmware to the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 80cd67841074..107018447551 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -1929,6 +1929,8 @@ static int ene_load_bincode(struct us_data *us, unsigned char flag)
 	bcb-&gt;CDB[0] = 0xEF;
 
 	result = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);
+	if (us-&gt;srb != NULL)
+		scsi_set_resid(us-&gt;srb, 0);
 	info-&gt;BIN_FLAG = flag;
 	kfree(buf);
 </pre><hr><pre>commit 4b309f1c4972c8f09e03ac64fc63510dbf5591a4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:42 2017 -0400

    USB: ene_usb6250: fix first command execution
    
    In the ene_usb6250 sub-driver for usb-storage, the ene_transport()
    routine is supposed to initialize the driver before executing the
    current command, if the initialization has not already been performed.
    However, a bug in the routine causes it to skip the command after
    doing the initialization.  Also, the routine does not return an
    appropriate error code if either the initialization or the command
    fails.
    
    As a result of the first bug, the first command (a SCSI INQUIRY) is
    not carried out.  The results can be seen in the system log, in the
    form of a warning message and empty or garbage INQUIRY data:
    
    Apr 18 22:40:08 notebook2 kernel: scsi host6: scsi scan: INQUIRY result too short (5), using 36
    Apr 18 22:40:08 notebook2 kernel: scsi 6:0:0:0: Direct-Access                                    PQ: 0 ANSI: 0
    
    This patch fixes both errors.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 369f3c24815a..80cd67841074 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -2280,21 +2280,22 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 
 static int ene_transport(struct scsi_cmnd *srb, struct us_data *us)
 {
-	int result = 0;
+	int result = USB_STOR_XFER_GOOD;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
 	/*US_DEBUG(usb_stor_show_command(us, srb)); */
 	scsi_set_resid(srb, 0);
-	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready))) {
+	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready)))
 		result = ene_init(us);
-	} else {
+	if (result == USB_STOR_XFER_GOOD) {
+		result = USB_STOR_TRANSPORT_ERROR;
 		if (info-&gt;SD_Status.Ready)
 			result = sd_scsi_irp(us, srb);
 
 		if (info-&gt;MS_Status.Ready)
 			result = ms_scsi_irp(us, srb);
 	}
-	return 0;
+	return result;
 }
 
 static struct scsi_host_template ene_ub6250_host_template;</pre><hr><pre>commit 63aea0dbab90a2461faaae357cbc8cfd6c8de9fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 17 18:32:03 2017 +0300

    USB: xhci: fix lock-inversion problem
    
    With threaded interrupts, bottom-half handlers are called with
    interrupts enabled.  Therefore they can't safely use spin_lock(); they
    have to use spin_lock_irqsave().  Lockdep warns about a violation
    occurring in xhci_irq():
    
    =========================================================
    [ INFO: possible irq lock inversion dependency detected ]
    4.11.0-rc8-dbg+ #1 Not tainted
    ---------------------------------------------------------
    swapper/7/0 just changed the state of lock:
     (&amp;(&amp;ehci-&gt;lock)-&gt;rlock){-.-...}, at: [&lt;ffffffffa0130a69&gt;]
    ehci_hrtimer_func+0x29/0xc0 [ehci_hcd]
    but this lock took another, HARDIRQ-unsafe lock in the past:
     (hcd_urb_list_lock){+.....}
    
    and interrupts could create inverse lock ordering between them.
    
    other info that might help us debug this:
     Possible interrupt unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hcd_urb_list_lock);
                                   local_irq_disable();
                                   lock(&amp;(&amp;ehci-&gt;lock)-&gt;rlock);
                                   lock(hcd_urb_list_lock);
      &lt;Interrupt&gt;
        lock(&amp;(&amp;ehci-&gt;lock)-&gt;rlock);
     *** DEADLOCK ***
    
    no locks held by swapper/7/0.
    the shortest dependencies between 2nd lock and 1st lock:
     -&gt; (hcd_urb_list_lock){+.....} ops: 252 {
        HARDIRQ-ON-W at:
                          __lock_acquire+0x602/0x1280
                          lock_acquire+0xd5/0x1c0
                          _raw_spin_lock+0x2f/0x40
                          usb_hcd_unlink_urb_from_ep+0x1b/0x60 [usbcore]
                          xhci_giveback_urb_in_irq.isra.45+0x70/0x1b0 [xhci_hcd]
                          finish_td.constprop.60+0x1d8/0x2e0 [xhci_hcd]
                          xhci_irq+0xdd6/0x1fa0 [xhci_hcd]
                          usb_hcd_irq+0x26/0x40 [usbcore]
                          irq_forced_thread_fn+0x2f/0x70
                          irq_thread+0x149/0x1d0
                          kthread+0x113/0x150
                          ret_from_fork+0x2e/0x40
    
    This patch fixes the problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Bart Van Assche &lt;bart.vanassche@sandisk.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Mathias Nyman &lt;mathias.nyman@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 0830b25f9499..6d2492c1c643 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2677,11 +2677,12 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 	union xhci_trb *event_ring_deq;
 	irqreturn_t ret = IRQ_NONE;
+	unsigned long flags;
 	dma_addr_t deq;
 	u64 temp_64;
 	u32 status;
 
-	spin_lock(&amp;xhci-&gt;lock);
+	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	/* Check if the xHC generated the interrupt, or the irq is shared */
 	status = readl(&amp;xhci-&gt;op_regs-&gt;status);
 	if (status == ~(u32)0) {
@@ -2754,7 +2755,7 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 	ret = IRQ_HANDLED;
 
 out:
-	spin_unlock(&amp;xhci-&gt;lock);
+	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 
 	return ret;
 }</pre><hr><pre>commit 628c2893d44876ddd11602400c70606ade62e129
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:29 2017 -0400

    USB: ene_usb6250: fix DMA to the stack
    
    The ene_usb6250 sub-driver in usb-storage does USB I/O to buffers on
    the stack, which doesn't work with vmapped stacks.  This patch fixes
    the problem by allocating a separate 512-byte buffer at probe time and
    using it for all of the offending I/O operations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 369f3c24815a..44af719194b2 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -446,6 +446,10 @@ struct ms_lib_ctrl {
 #define SD_BLOCK_LEN  9
 
 struct ene_ub6250_info {
+
+	/* I/O bounce buffer */
+	u8		*bbuf;
+
 	/* for 6250 code */
 	struct SD_STATUS	SD_Status;
 	struct MS_STATUS	MS_Status;
@@ -493,8 +497,11 @@ static int ene_load_bincode(struct us_data *us, unsigned char flag);
 
 static void ene_ub6250_info_destructor(void *extra)
 {
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) extra;
+
 	if (!extra)
 		return;
+	kfree(info-&gt;bbuf);
 }
 
 static int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)
@@ -860,8 +867,9 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 		u8 PageNum, u32 *PageBuf, struct ms_lib_type_extdat *ExtraDat)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 	int result;
-	u8 ExtBuf[4];
 	u32 bn = PhyBlockAddr * 0x20 + PageNum;
 
 	result = ene_load_bincode(us, MS_RW_PATTERN);
@@ -901,7 +909,7 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 	bcb-&gt;CDB[2]     = (unsigned char)(PhyBlockAddr&gt;&gt;16);
 	bcb-&gt;CDB[6]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;ExtBuf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -910,9 +918,9 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 	ExtraDat-&gt;status0  = 0x10;  /* Not yet,fireware support */
 
 	ExtraDat-&gt;status1  = 0x00;  /* Not yet,fireware support */
-	ExtraDat-&gt;ovrflg   = ExtBuf[0];
-	ExtraDat-&gt;mngflg   = ExtBuf[1];
-	ExtraDat-&gt;logadr   = memstick_logaddr(ExtBuf[2], ExtBuf[3]);
+	ExtraDat-&gt;ovrflg   = bbuf[0];
+	ExtraDat-&gt;mngflg   = bbuf[1];
+	ExtraDat-&gt;logadr   = memstick_logaddr(bbuf[2], bbuf[3]);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
@@ -1332,8 +1340,9 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 				u8 PageNum, struct ms_lib_type_extdat *ExtraDat)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 	int result;
-	u8 ExtBuf[4];
 
 	memset(bcb, 0, sizeof(struct bulk_cb_wrap));
 	bcb-&gt;Signature = cpu_to_le32(US_BULK_CB_SIGN);
@@ -1347,7 +1356,7 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 	bcb-&gt;CDB[2]     = (unsigned char)(PhyBlock&gt;&gt;16);
 	bcb-&gt;CDB[6]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;ExtBuf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -1355,9 +1364,9 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 	ExtraDat-&gt;intr     = 0x80;  /* Not yet, waiting for fireware support */
 	ExtraDat-&gt;status0  = 0x10;  /* Not yet, waiting for fireware support */
 	ExtraDat-&gt;status1  = 0x00;  /* Not yet, waiting for fireware support */
-	ExtraDat-&gt;ovrflg   = ExtBuf[0];
-	ExtraDat-&gt;mngflg   = ExtBuf[1];
-	ExtraDat-&gt;logadr   = memstick_logaddr(ExtBuf[2], ExtBuf[3]);
+	ExtraDat-&gt;ovrflg   = bbuf[0];
+	ExtraDat-&gt;mngflg   = bbuf[1];
+	ExtraDat-&gt;logadr   = memstick_logaddr(bbuf[2], bbuf[3]);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
@@ -1556,9 +1565,9 @@ static int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)
 	u16 PhyBlock, newblk, i;
 	u16 LogStart, LogEnde;
 	struct ms_lib_type_extdat extdat;
-	u8 buf[0x200];
 	u32 count = 0, index = 0;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	for (PhyBlock = 0; PhyBlock &lt; info-&gt;MS_Lib.NumberOfPhyBlock;) {
 		ms_lib_phy_to_log_range(PhyBlock, &amp;LogStart, &amp;LogEnde);
@@ -1572,14 +1581,16 @@ static int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)
 			}
 
 			if (count == PhyBlock) {
-				ms_lib_read_extrablock(us, PhyBlock, 0, 0x80, &amp;buf);
+				ms_lib_read_extrablock(us, PhyBlock, 0, 0x80,
+						bbuf);
 				count += 0x80;
 			}
 			index = (PhyBlock % 0x80) * 4;
 
-			extdat.ovrflg = buf[index];
-			extdat.mngflg = buf[index+1];
-			extdat.logadr = memstick_logaddr(buf[index+2], buf[index+3]);
+			extdat.ovrflg = bbuf[index];
+			extdat.mngflg = bbuf[index+1];
+			extdat.logadr = memstick_logaddr(bbuf[index+2],
+					bbuf[index+3]);
 
 			if ((extdat.ovrflg &amp; MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {
 				ms_lib_setacquired_errorblock(us, PhyBlock);
@@ -2062,9 +2073,9 @@ static int ene_ms_init(struct us_data *us)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
 	int result;
-	u8 buf[0x200];
 	u16 MSP_BlockSize, MSP_UserAreaBlocks;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	printk(KERN_INFO "transport --- ENE_MSInit\n");
 
@@ -2083,13 +2094,13 @@ static int ene_ms_init(struct us_data *us)
 	bcb-&gt;CDB[0]     = 0xF1;
 	bcb-&gt;CDB[1]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;buf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
 		printk(KERN_ERR "Execution MS Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	/* the same part to test ENE */
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;buf[0];
+	info-&gt;MS_Status = *(struct MS_STATUS *) bbuf;
 
 	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
 		printk(KERN_INFO "Insert     = %x\n", info-&gt;MS_Status.Insert);
@@ -2098,15 +2109,15 @@ static int ene_ms_init(struct us_data *us)
 		printk(KERN_INFO "IsMSPHG    = %x\n", info-&gt;MS_Status.IsMSPHG);
 		printk(KERN_INFO "WtP= %x\n", info-&gt;MS_Status.WtP);
 		if (info-&gt;MS_Status.IsMSPro) {
-			MSP_BlockSize      = (buf[6] &lt;&lt; 8) | buf[7];
-			MSP_UserAreaBlocks = (buf[10] &lt;&lt; 8) | buf[11];
+			MSP_BlockSize      = (bbuf[6] &lt;&lt; 8) | bbuf[7];
+			MSP_UserAreaBlocks = (bbuf[10] &lt;&lt; 8) | bbuf[11];
 			info-&gt;MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;
 		} else {
 			ms_card_init(us); /* Card is MS (to ms.c)*/
 		}
 		usb_stor_dbg(us, "MS Init Code OK !!\n");
 	} else {
-		usb_stor_dbg(us, "MS Card Not Ready --- %x\n", buf[0]);
+		usb_stor_dbg(us, "MS Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
@@ -2116,9 +2127,9 @@ static int ene_ms_init(struct us_data *us)
 static int ene_sd_init(struct us_data *us)
 {
 	int result;
-	u8  buf[0x200];
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	usb_stor_dbg(us, "transport --- ENE_SDInit\n");
 	/* SD Init Part-1 */
@@ -2152,17 +2163,17 @@ static int ene_sd_init(struct us_data *us)
 	bcb-&gt;Flags              = US_BULK_FLAG_IN;
 	bcb-&gt;CDB[0]             = 0xF1;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;buf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
 		usb_stor_dbg(us, "Execution SD Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	info-&gt;SD_Status =  *(struct SD_STATUS *)&amp;buf[0];
+	info-&gt;SD_Status =  *(struct SD_STATUS *) bbuf;
 	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready) {
 		struct SD_STATUS *s = &amp;info-&gt;SD_Status;
 
-		ene_get_card_status(us, (unsigned char *)&amp;buf);
+		ene_get_card_status(us, bbuf);
 		usb_stor_dbg(us, "Insert     = %x\n", s-&gt;Insert);
 		usb_stor_dbg(us, "Ready      = %x\n", s-&gt;Ready);
 		usb_stor_dbg(us, "IsMMC      = %x\n", s-&gt;IsMMC);
@@ -2170,7 +2181,7 @@ static int ene_sd_init(struct us_data *us)
 		usb_stor_dbg(us, "HiSpeed    = %x\n", s-&gt;HiSpeed);
 		usb_stor_dbg(us, "WtP        = %x\n", s-&gt;WtP);
 	} else {
-		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", buf[0]);
+		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	return USB_STOR_TRANSPORT_GOOD;
@@ -2180,13 +2191,15 @@ static int ene_sd_init(struct us_data *us)
 static int ene_init(struct us_data *us)
 {
 	int result;
-	u8  misc_reg03 = 0;
+	u8  misc_reg03;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
+	u8 *bbuf = info-&gt;bbuf;
 
-	result = ene_get_card_type(us, REG_CARD_STATUS, &amp;misc_reg03);
+	result = ene_get_card_type(us, REG_CARD_STATUS, bbuf);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
+	misc_reg03 = bbuf[0];
 	if (misc_reg03 &amp; 0x01) {
 		if (!info-&gt;SD_Status.Ready) {
 			result = ene_sd_init(us);
@@ -2303,8 +2316,9 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
 {
 	int result;
-	u8  misc_reg03 = 0;
+	u8  misc_reg03;
 	struct us_data *us;
+	struct ene_ub6250_info *info;
 
 	result = usb_stor_probe1(&amp;us, intf, id,
 		   (id - ene_ub6250_usb_ids) + ene_ub6250_unusual_dev_list,
@@ -2313,11 +2327,16 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 		return result;
 
 	/* FIXME: where should the code alloc extra buf ? */
-	if (!us-&gt;extra) {
-		us-&gt;extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);
-		if (!us-&gt;extra)
-			return -ENOMEM;
-		us-&gt;extra_destructor = ene_ub6250_info_destructor;
+	us-&gt;extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);
+	if (!us-&gt;extra)
+		return -ENOMEM;
+	us-&gt;extra_destructor = ene_ub6250_info_destructor;
+
+	info = (struct ene_ub6250_info *)(us-&gt;extra);
+	info-&gt;bbuf = kmalloc(512, GFP_KERNEL);
+	if (!info-&gt;bbuf) {
+		kfree(us-&gt;extra);
+		return -ENOMEM;
 	}
 
 	us-&gt;transport_name = "ene_ub6250";
@@ -2329,12 +2348,13 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 		return result;
 
 	/* probe card type */
-	result = ene_get_card_type(us, REG_CARD_STATUS, &amp;misc_reg03);
+	result = ene_get_card_type(us, REG_CARD_STATUS, info-&gt;bbuf);
 	if (result != USB_STOR_XFER_GOOD) {
 		usb_stor_disconnect(intf);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
+	misc_reg03 = info-&gt;bbuf[0];
 	if (!(misc_reg03 &amp; 0x01)) {
 		pr_info("ums_eneub6250: This driver only supports SD/MS cards. "
 			"It does not support SM cards.\n");</pre><hr><pre>commit 225785aec726f3edd5077be8f084b0b70ca197a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 13 16:37:01 2017 -0400

    USB: f_mass_storage: improve memory barriers and synchronization
    
    This patch reworks the way f_mass_storage.c handles memory barriers
    and synchronization:
    
            The driver now uses a wait_queue instead of doing its own
            task-state manipulations (even though only one task will ever
            use the wait_queue).
    
            The thread_wakeup_needed variable is removed.  It was only a
            source of trouble; although it was what the driver tested to
            see whether it should wake up, what we really wanted to see
            was whether a USB transfer had completed.
    
            All the explicit memory barriers scattered throughout the
            driver are replaced by a few calls to smp_load_acquire() and
            smp_store_release().
    
            The inreq_busy and outreq_busy fields are removed.  In their
            place, the driver keeps track of the current I/O direction by
            splitting BUF_STATE_BUSY into two states: BUF_STATE_SENDING
            and BUF_STATE_RECEIVING.
    
            The buffer states are no longer protected by a lock.  Mutual
            exclusion isn't needed; the state is changed only by the
            driver's main thread when it owns the buffer, and only by the
            request completion routine when the gadget core owns the buffer.
    
            The do_write() and throw_away_data() routines were reorganized
            to make efficient use of the new sleeping mechanism.  This
            resulted in the removal of one indentation level in those
            routines, making the patch appear to be more more complicated
            than it really is.
    
            In a few places, the driver allowed itself to be frozen although
            it really shouldn't have (in the middle of executing a SCSI
            command).  Those places have been fixed.
    
            The logic in the exception handler for aborting transfers and
            waiting for them to stop has been simplified.
    
    Tested-by: Thinh Nguyen &lt;thinhn@synopsys.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index a0890a058f09..e80b9c123a9d 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -260,12 +260,13 @@ struct fsg_common {
 	struct usb_gadget	*gadget;
 	struct usb_composite_dev *cdev;
 	struct fsg_dev		*fsg, *new_fsg;
+	wait_queue_head_t	io_wait;
 	wait_queue_head_t	fsg_wait;
 
 	/* filesem protects: backing files in use */
 	struct rw_semaphore	filesem;
 
-	/* lock protects: state, all the req_busy's */
+	/* lock protects: state and thread_task */
 	spinlock_t		lock;
 
 	struct usb_ep		*ep0;		/* Copy of gadget-&gt;ep0 */
@@ -303,7 +304,6 @@ struct fsg_common {
 	unsigned int		running:1;
 	unsigned int		sysfs:1;
 
-	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
 
@@ -393,16 +393,6 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 
 /* These routines may be called in process context or in_irq */
 
-/* Caller must hold fsg-&gt;lock */
-static void wakeup_thread(struct fsg_common *common)
-{
-	smp_wmb();	/* ensure the write of bh-&gt;state is complete */
-	/* Tell the main thread that something has happened */
-	common-&gt;thread_wakeup_needed = 1;
-	if (common-&gt;thread_task)
-		wake_up_process(common-&gt;thread_task);
-}
-
 static void raise_exception(struct fsg_common *common, enum fsg_state new_state)
 {
 	unsigned long		flags;
@@ -456,13 +446,9 @@ static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 	if (req-&gt;status == -ECONNRESET)		/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
-	/* Hold the lock while we update the request and buffer states */
-	smp_wmb();
-	spin_lock(&amp;common-&gt;lock);
-	bh-&gt;inreq_busy = 0;
-	bh-&gt;state = BUF_STATE_EMPTY;
-	wakeup_thread(common);
-	spin_unlock(&amp;common-&gt;lock);
+	/* Synchronize with the smp_load_acquire() in sleep_thread() */
+	smp_store_release(&amp;bh-&gt;state, BUF_STATE_EMPTY);
+	wake_up(&amp;common-&gt;io_wait);
 }
 
 static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
@@ -477,13 +463,9 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 	if (req-&gt;status == -ECONNRESET)		/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
-	/* Hold the lock while we update the request and buffer states */
-	smp_wmb();
-	spin_lock(&amp;common-&gt;lock);
-	bh-&gt;outreq_busy = 0;
-	bh-&gt;state = BUF_STATE_FULL;
-	wakeup_thread(common);
-	spin_unlock(&amp;common-&gt;lock);
+	/* Synchronize with the smp_load_acquire() in sleep_thread() */
+	smp_store_release(&amp;bh-&gt;state, BUF_STATE_FULL);
+	wake_up(&amp;common-&gt;io_wait);
 }
 
 static int _fsg_common_get_max_lun(struct fsg_common *common)
@@ -559,43 +541,39 @@ static int fsg_setup(struct usb_function *f,
 /* All the following routines run in process context */
 
 /* Use this for bulk or interrupt transfers, not ep0 */
-static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
-			   struct usb_request *req, int *pbusy,
-			   enum fsg_buffer_state *state)
+static int start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
+			   struct usb_request *req)
 {
 	int	rc;
 
 	if (ep == fsg-&gt;bulk_in)
 		dump_msg(fsg, "bulk-in", req-&gt;buf, req-&gt;length);
 
-	spin_lock_irq(&amp;fsg-&gt;common-&gt;lock);
-	*pbusy = 1;
-	*state = BUF_STATE_BUSY;
-	spin_unlock_irq(&amp;fsg-&gt;common-&gt;lock);
-
 	rc = usb_ep_queue(ep, req, GFP_KERNEL);
-	if (rc == 0)
-		return;  /* All good, we're done */
-
-	*pbusy = 0;
-	*state = BUF_STATE_EMPTY;
+	if (rc) {
 
-	/* We can't do much more than wait for a reset */
+		/* We can't do much more than wait for a reset */
+		req-&gt;status = rc;
 
-	/*
-	 * Note: currently the net2280 driver fails zero-length
-	 * submissions if DMA is enabled.
-	 */
-	if (rc != -ESHUTDOWN &amp;&amp; !(rc == -EOPNOTSUPP &amp;&amp; req-&gt;length == 0))
-		WARNING(fsg, "error in submission: %s --&gt; %d\n", ep-&gt;name, rc);
+		/*
+		 * Note: currently the net2280 driver fails zero-length
+		 * submissions if DMA is enabled.
+		 */
+		if (rc != -ESHUTDOWN &amp;&amp;
+				!(rc == -EOPNOTSUPP &amp;&amp; req-&gt;length == 0))
+			WARNING(fsg, "error in submission: %s --&gt; %d\n",
+					ep-&gt;name, rc);
+	}
+	return rc;
 }
 
 static bool start_in_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 {
 	if (!fsg_is_set(common))
 		return false;
-	start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_in,
-		       bh-&gt;inreq, &amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
+	bh-&gt;state = BUF_STATE_SENDING;
+	if (start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_in, bh-&gt;inreq))
+		bh-&gt;state = BUF_STATE_EMPTY;
 	return true;
 }
 
@@ -603,32 +581,31 @@ static bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 {
 	if (!fsg_is_set(common))
 		return false;
-	start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_out,
-		       bh-&gt;outreq, &amp;bh-&gt;outreq_busy, &amp;bh-&gt;state);
+	bh-&gt;state = BUF_STATE_RECEIVING;
+	if (start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_out, bh-&gt;outreq))
+		bh-&gt;state = BUF_STATE_FULL;
 	return true;
 }
 
-static int sleep_thread(struct fsg_common *common, bool can_freeze)
+static int sleep_thread(struct fsg_common *common, bool can_freeze,
+		struct fsg_buffhd *bh)
 {
-	int	rc = 0;
+	int	rc;
 
-	/* Wait until a signal arrives or we are woken up */
-	for (;;) {
-		if (can_freeze)
-			try_to_freeze();
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (signal_pending(current)) {
-			rc = -EINTR;
-			break;
-		}
-		if (common-&gt;thread_wakeup_needed)
-			break;
-		schedule();
-	}
-	__set_current_state(TASK_RUNNING);
-	common-&gt;thread_wakeup_needed = 0;
-	smp_rmb();	/* ensure the latest bh-&gt;state is visible */
-	return rc;
+	/* Wait until a signal arrives or bh is no longer busy */
+	if (can_freeze)
+		/*
+		 * synchronize with the smp_store_release(&amp;bh-&gt;state) in
+		 * bulk_in_complete() or bulk_out_complete()
+		 */
+		rc = wait_event_freezable(common-&gt;io_wait,
+				bh &amp;&amp; smp_load_acquire(&amp;bh-&gt;state) &gt;=
+					BUF_STATE_EMPTY);
+	else
+		rc = wait_event_interruptible(common-&gt;io_wait,
+				bh &amp;&amp; smp_load_acquire(&amp;bh-&gt;state) &gt;=
+					BUF_STATE_EMPTY);
+	return rc ? -EINTR : 0;
 }
 
 
@@ -688,11 +665,9 @@ static int do_read(struct fsg_common *common)
 
 		/* Wait for the next buffer to become available */
 		bh = common-&gt;next_buffhd_to_fill;
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(common, false);
-			if (rc)
-				return rc;
-		}
+		rc = sleep_thread(common, false, bh);
+		if (rc)
+			return rc;
 
 		/*
 		 * If we were asked to read past the end of file,
@@ -869,84 +844,80 @@ static int do_write(struct fsg_common *common)
 		bh = common-&gt;next_buffhd_to_drain;
 		if (bh-&gt;state == BUF_STATE_EMPTY &amp;&amp; !get_some_more)
 			break;			/* We stopped early */
-		if (bh-&gt;state == BUF_STATE_FULL) {
-			smp_rmb();
-			common-&gt;next_buffhd_to_drain = bh-&gt;next;
-			bh-&gt;state = BUF_STATE_EMPTY;
-
-			/* Did something go wrong with the transfer? */
-			if (bh-&gt;outreq-&gt;status != 0) {
-				curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
-				curlun-&gt;sense_data_info =
+
+		/* Wait for the data to be received */
+		rc = sleep_thread(common, false, bh);
+		if (rc)
+			return rc;
+
+		common-&gt;next_buffhd_to_drain = bh-&gt;next;
+		bh-&gt;state = BUF_STATE_EMPTY;
+
+		/* Did something go wrong with the transfer? */
+		if (bh-&gt;outreq-&gt;status != 0) {
+			curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
+			curlun-&gt;sense_data_info =
 					file_offset &gt;&gt; curlun-&gt;blkbits;
-				curlun-&gt;info_valid = 1;
-				break;
-			}
+			curlun-&gt;info_valid = 1;
+			break;
+		}
 
-			amount = bh-&gt;outreq-&gt;actual;
-			if (curlun-&gt;file_length - file_offset &lt; amount) {
-				LERROR(curlun,
-				       "write %u @ %llu beyond end %llu\n",
+		amount = bh-&gt;outreq-&gt;actual;
+		if (curlun-&gt;file_length - file_offset &lt; amount) {
+			LERROR(curlun, "write %u @ %llu beyond end %llu\n",
 				       amount, (unsigned long long)file_offset,
 				       (unsigned long long)curlun-&gt;file_length);
-				amount = curlun-&gt;file_length - file_offset;
-			}
+			amount = curlun-&gt;file_length - file_offset;
+		}
 
-			/* Don't accept excess data.  The spec doesn't say
-			 * what to do in this case.  We'll ignore the error.
-			 */
-			amount = min(amount, bh-&gt;bulk_out_intended_length);
-
-			/* Don't write a partial block */
-			amount = round_down(amount, curlun-&gt;blksize);
-			if (amount == 0)
-				goto empty_write;
-
-			/* Perform the write */
-			file_offset_tmp = file_offset;
-			nwritten = vfs_write(curlun-&gt;filp,
-					     (char __user *)bh-&gt;buf,
-					     amount, &amp;file_offset_tmp);
-			VLDBG(curlun, "file write %u @ %llu -&gt; %d\n", amount,
-			      (unsigned long long)file_offset, (int)nwritten);
-			if (signal_pending(current))
-				return -EINTR;		/* Interrupted! */
-
-			if (nwritten &lt; 0) {
-				LDBG(curlun, "error in file write: %d\n",
-				     (int)nwritten);
-				nwritten = 0;
-			} else if (nwritten &lt; amount) {
-				LDBG(curlun, "partial file write: %d/%u\n",
-				     (int)nwritten, amount);
-				nwritten = round_down(nwritten, curlun-&gt;blksize);
-			}
-			file_offset += nwritten;
-			amount_left_to_write -= nwritten;
-			common-&gt;residue -= nwritten;
+		/*
+		 * Don't accept excess data.  The spec doesn't say
+		 * what to do in this case.  We'll ignore the error.
+		 */
+		amount = min(amount, bh-&gt;bulk_out_intended_length);
 
-			/* If an error occurred, report it and its position */
-			if (nwritten &lt; amount) {
-				curlun-&gt;sense_data = SS_WRITE_ERROR;
-				curlun-&gt;sense_data_info =
+		/* Don't write a partial block */
+		amount = round_down(amount, curlun-&gt;blksize);
+		if (amount == 0)
+			goto empty_write;
+
+		/* Perform the write */
+		file_offset_tmp = file_offset;
+		nwritten = vfs_write(curlun-&gt;filp, (char __user *)bh-&gt;buf,
+				amount, &amp;file_offset_tmp);
+		VLDBG(curlun, "file write %u @ %llu -&gt; %d\n", amount,
+				(unsigned long long)file_offset, (int)nwritten);
+		if (signal_pending(current))
+			return -EINTR;		/* Interrupted! */
+
+		if (nwritten &lt; 0) {
+			LDBG(curlun, "error in file write: %d\n",
+					(int) nwritten);
+			nwritten = 0;
+		} else if (nwritten &lt; amount) {
+			LDBG(curlun, "partial file write: %d/%u\n",
+					(int) nwritten, amount);
+			nwritten = round_down(nwritten, curlun-&gt;blksize);
+		}
+		file_offset += nwritten;
+		amount_left_to_write -= nwritten;
+		common-&gt;residue -= nwritten;
+
+		/* If an error occurred, report it and its position */
+		if (nwritten &lt; amount) {
+			curlun-&gt;sense_data = SS_WRITE_ERROR;
+			curlun-&gt;sense_data_info =
 					file_offset &gt;&gt; curlun-&gt;blkbits;
-				curlun-&gt;info_valid = 1;
-				break;
-			}
+			curlun-&gt;info_valid = 1;
+			break;
+		}
 
  empty_write:
-			/* Did the host decide to stop early? */
-			if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length) {
-				common-&gt;short_packet_received = 1;
-				break;
-			}
-			continue;
+		/* Did the host decide to stop early? */
+		if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length) {
+			common-&gt;short_packet_received = 1;
+			break;
 		}
-
-		/* Wait for something to happen */
-		rc = sleep_thread(common, false);
-		if (rc)
-			return rc;
 	}
 
 	return -EIO;		/* No default reply */
@@ -1471,7 +1442,7 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 
 static int throw_away_data(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh;
+	struct fsg_buffhd	*bh, *bh2;
 	u32			amount;
 	int			rc;
 
@@ -1479,26 +1450,10 @@ static int throw_away_data(struct fsg_common *common)
 	     bh-&gt;state != BUF_STATE_EMPTY || common-&gt;usb_amount_left &gt; 0;
 	     bh = common-&gt;next_buffhd_to_drain) {
 
-		/* Throw away the data in a filled buffer */
-		if (bh-&gt;state == BUF_STATE_FULL) {
-			smp_rmb();
-			bh-&gt;state = BUF_STATE_EMPTY;
-			common-&gt;next_buffhd_to_drain = bh-&gt;next;
-
-			/* A short packet or an error ends everything */
-			if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length ||
-			    bh-&gt;outreq-&gt;status != 0) {
-				raise_exception(common,
-						FSG_STATE_ABORT_BULK_OUT);
-				return -EINTR;
-			}
-			continue;
-		}
-
 		/* Try to submit another request if we need one */
-		bh = common-&gt;next_buffhd_to_fill;
-		if (bh-&gt;state == BUF_STATE_EMPTY
-		 &amp;&amp; common-&gt;usb_amount_left &gt; 0) {
+		bh2 = common-&gt;next_buffhd_to_fill;
+		if (bh2-&gt;state == BUF_STATE_EMPTY &amp;&amp;
+				common-&gt;usb_amount_left &gt; 0) {
 			amount = min(common-&gt;usb_amount_left, FSG_BUFLEN);
 
 			/*
@@ -1506,19 +1461,30 @@ static int throw_away_data(struct fsg_common *common)
 			 * equal to the buffer size, which is divisible by
 			 * the bulk-out maxpacket size.
 			 */
-			set_bulk_out_req_length(common, bh, amount);
-			if (!start_out_transfer(common, bh))
+			set_bulk_out_req_length(common, bh2, amount);
+			if (!start_out_transfer(common, bh2))
 				/* Dunno what to do if common-&gt;fsg is NULL */
 				return -EIO;
-			common-&gt;next_buffhd_to_fill = bh-&gt;next;
+			common-&gt;next_buffhd_to_fill = bh2-&gt;next;
 			common-&gt;usb_amount_left -= amount;
 			continue;
 		}
 
-		/* Otherwise wait for something to happen */
-		rc = sleep_thread(common, true);
+		/* Wait for the data to be received */
+		rc = sleep_thread(common, false, bh);
 		if (rc)
 			return rc;
+
+		/* Throw away the data in a filled buffer */
+		bh-&gt;state = BUF_STATE_EMPTY;
+		common-&gt;next_buffhd_to_drain = bh-&gt;next;
+
+		/* A short packet or an error ends everything */
+		if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length ||
+				bh-&gt;outreq-&gt;status != 0) {
+			raise_exception(common, FSG_STATE_ABORT_BULK_OUT);
+			return -EINTR;
+		}
 	}
 	return 0;
 }
@@ -1636,11 +1602,9 @@ static void send_status(struct fsg_common *common)
 
 	/* Wait for the next buffer to become available */
 	bh = common-&gt;next_buffhd_to_fill;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return;
-	}
+	rc = sleep_thread(common, false, bh);
+	if (rc)
+		return;
 
 	if (curlun) {
 		sd = curlun-&gt;sense_data;
@@ -1839,11 +1803,10 @@ static int do_scsi_command(struct fsg_common *common)
 	/* Wait for the next buffer to become available for data or status */
 	bh = common-&gt;next_buffhd_to_fill;
 	common-&gt;next_buffhd_to_drain = bh;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
+	rc = sleep_thread(common, false, bh);
+	if (rc)
+		return rc;
+
 	common-&gt;phase_error = 0;
 	common-&gt;short_packet_received = 0;
 
@@ -2186,11 +2149,9 @@ static int get_next_command(struct fsg_common *common)
 
 	/* Wait for the next buffer to become available */
 	bh = common-&gt;next_buffhd_to_fill;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
+	rc = sleep_thread(common, true, bh);
+	if (rc)
+		return rc;
 
 	/* Queue a request to read a Bulk-only CBW */
 	set_bulk_out_req_length(common, bh, US_BULK_CB_WRAP_LEN);
@@ -2205,12 +2166,10 @@ static int get_next_command(struct fsg_common *common)
 	 */
 
 	/* Wait for the CBW to arrive */
-	while (bh-&gt;state != BUF_STATE_FULL) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
-	smp_rmb();
+	rc = sleep_thread(common, true, bh);
+	if (rc)
+		return rc;
+
 	rc = fsg_is_set(common) ? received_cbw(common-&gt;fsg, bh) : -EIO;
 	bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -2374,23 +2333,14 @@ static void handle_exception(struct fsg_common *common)
 	if (likely(common-&gt;fsg)) {
 		for (i = 0; i &lt; common-&gt;fsg_num_buffers; ++i) {
 			bh = &amp;common-&gt;buffhds[i];
-			if (bh-&gt;inreq_busy)
+			if (bh-&gt;state == BUF_STATE_SENDING)
 				usb_ep_dequeue(common-&gt;fsg-&gt;bulk_in, bh-&gt;inreq);
-			if (bh-&gt;outreq_busy)
+			if (bh-&gt;state == BUF_STATE_RECEIVING)
 				usb_ep_dequeue(common-&gt;fsg-&gt;bulk_out,
 					       bh-&gt;outreq);
-		}
 
-		/* Wait until everything is idle */
-		for (;;) {
-			int num_active = 0;
-			for (i = 0; i &lt; common-&gt;fsg_num_buffers; ++i) {
-				bh = &amp;common-&gt;buffhds[i];
-				num_active += bh-&gt;inreq_busy + bh-&gt;outreq_busy;
-			}
-			if (num_active == 0)
-				break;
-			if (sleep_thread(common, true))
+			/* Wait for a transfer to become idle */
+			if (sleep_thread(common, false, bh))
 				return;
 		}
 
@@ -2518,7 +2468,7 @@ static int fsg_main_thread(void *common_)
 		}
 
 		if (!common-&gt;running) {
-			sleep_thread(common, true);
+			sleep_thread(common, true, NULL);
 			continue;
 		}
 
@@ -2648,6 +2598,7 @@ static struct fsg_common *fsg_common_setup(struct fsg_common *common)
 	spin_lock_init(&amp;common-&gt;lock);
 	kref_init(&amp;common-&gt;ref);
 	init_completion(&amp;common-&gt;thread_notifier);
+	init_waitqueue_head(&amp;common-&gt;io_wait);
 	init_waitqueue_head(&amp;common-&gt;fsg_wait);
 	common-&gt;state = FSG_STATE_TERMINATED;
 	memset(common-&gt;luns, 0, sizeof(common-&gt;luns));
diff --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
index e6095dfbf1d5..e0814a960132 100644
--- a/drivers/usb/gadget/function/storage_common.h
+++ b/drivers/usb/gadget/function/storage_common.h
@@ -133,9 +133,10 @@ static inline bool fsg_lun_is_open(struct fsg_lun *curlun)
 #define FSG_MAX_LUNS	16
 
 enum fsg_buffer_state {
+	BUF_STATE_SENDING = -2,
+	BUF_STATE_RECEIVING,
 	BUF_STATE_EMPTY = 0,
-	BUF_STATE_FULL,
-	BUF_STATE_BUSY
+	BUF_STATE_FULL
 };
 
 struct fsg_buffhd {
@@ -151,9 +152,7 @@ struct fsg_buffhd {
 	unsigned int			bulk_out_intended_length;
 
 	struct usb_request		*inreq;
-	int				inreq_busy;
 	struct usb_request		*outreq;
-	int				outreq_busy;
 };
 
 enum fsg_state {</pre><hr><pre>commit 78db441d2ea0c804bc43a2bf3f894c4f7a6c7788
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 13 16:36:50 2017 -0400

    USB: f_mass_storage: improve async notification handling
    
    This patch makes several adjustments to the way f_mass_storage.c
    handles its internal state and asynchronous notifications (AKA
    exceptions):
    
            A number of states weren't being used for anything.
            They are removed.
    
            The FSG_STATE_IDLE state was renamed to FSG_STATE_NORMAL,
            because it now applies whenever the gadget is operating
            normally, not just when the gadget is idle.
    
            The FSG_STATE_RESET state was renamed to
            FSG_STATE_PROTOCOL_RESET, indicating that it represents a
            Bulk-Only Transport protocol reset and not a general USB
            reset.
    
            When a signal arrives, it's silly for the signal handler to
            send itself another signal!  Now it takes care of everything
            inline.
    
    Along with an assortment of other minor changes in the same category.
    
    Tested-by: Thinh Nguyen &lt;thinhn@synopsys.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index 4c8aacc232c0..a0890a058f09 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -355,7 +355,7 @@ typedef void (*fsg_routine_t)(struct fsg_dev *);
 
 static int exception_in_progress(struct fsg_common *common)
 {
-	return common-&gt;state &gt; FSG_STATE_IDLE;
+	return common-&gt;state &gt; FSG_STATE_NORMAL;
 }
 
 /* Make bulk-out requests be divisible by the maxpacket size */
@@ -528,7 +528,7 @@ static int fsg_setup(struct usb_function *f,
 		 * and reinitialize our state.
 		 */
 		DBG(fsg, "bulk reset request\n");
-		raise_exception(fsg-&gt;common, FSG_STATE_RESET);
+		raise_exception(fsg-&gt;common, FSG_STATE_PROTOCOL_RESET);
 		return USB_GADGET_DELAYED_STATUS;
 
 	case US_BULK_GET_MAX_LUN:
@@ -1625,7 +1625,7 @@ static int finish_reply(struct fsg_common *common)
 	return rc;
 }
 
-static int send_status(struct fsg_common *common)
+static void send_status(struct fsg_common *common)
 {
 	struct fsg_lun		*curlun = common-&gt;curlun;
 	struct fsg_buffhd	*bh;
@@ -1639,7 +1639,7 @@ static int send_status(struct fsg_common *common)
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
 		rc = sleep_thread(common, true);
 		if (rc)
-			return rc;
+			return;
 	}
 
 	if (curlun) {
@@ -1674,10 +1674,10 @@ static int send_status(struct fsg_common *common)
 	bh-&gt;inreq-&gt;zero = 0;
 	if (!start_in_transfer(common, bh))
 		/* Don't know what to do if common-&gt;fsg is NULL */
-		return -EIO;
+		return;
 
 	common-&gt;next_buffhd_to_fill = bh-&gt;next;
-	return 0;
+	return;
 }
 
 
@@ -2362,9 +2362,11 @@ static void handle_exception(struct fsg_common *common)
 		if (!sig)
 			break;
 		if (sig != SIGUSR1) {
+			spin_lock_irq(&amp;common-&gt;lock);
 			if (common-&gt;state &lt; FSG_STATE_EXIT)
 				DBG(common, "Main thread exiting on signal\n");
-			raise_exception(common, FSG_STATE_EXIT);
+			common-&gt;state = FSG_STATE_EXIT;
+			spin_unlock_irq(&amp;common-&gt;lock);
 		}
 	}
 
@@ -2413,10 +2415,9 @@ static void handle_exception(struct fsg_common *common)
 	common-&gt;next_buffhd_to_drain = &amp;common-&gt;buffhds[0];
 	exception_req_tag = common-&gt;exception_req_tag;
 	old_state = common-&gt;state;
+	common-&gt;state = FSG_STATE_NORMAL;
 
-	if (old_state == FSG_STATE_ABORT_BULK_OUT)
-		common-&gt;state = FSG_STATE_STATUS_PHASE;
-	else {
+	if (old_state != FSG_STATE_ABORT_BULK_OUT) {
 		for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); ++i) {
 			curlun = common-&gt;luns[i];
 			if (!curlun)
@@ -2427,21 +2428,19 @@ static void handle_exception(struct fsg_common *common)
 			curlun-&gt;sense_data_info = 0;
 			curlun-&gt;info_valid = 0;
 		}
-		common-&gt;state = FSG_STATE_IDLE;
 	}
 	spin_unlock_irq(&amp;common-&gt;lock);
 
 	/* Carry out any extra actions required for the exception */
 	switch (old_state) {
+	case FSG_STATE_NORMAL:
+		break;
+
 	case FSG_STATE_ABORT_BULK_OUT:
 		send_status(common);
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (common-&gt;state == FSG_STATE_STATUS_PHASE)
-			common-&gt;state = FSG_STATE_IDLE;
-		spin_unlock_irq(&amp;common-&gt;lock);
 		break;
 
-	case FSG_STATE_RESET:
+	case FSG_STATE_PROTOCOL_RESET:
 		/*
 		 * In case we were forced against our will to halt a
 		 * bulk endpoint, clear the halt now.  (The SuperH UDC
@@ -2474,19 +2473,13 @@ static void handle_exception(struct fsg_common *common)
 		break;
 
 	case FSG_STATE_EXIT:
-	case FSG_STATE_TERMINATED:
 		do_set_interface(common, NULL);		/* Free resources */
 		spin_lock_irq(&amp;common-&gt;lock);
 		common-&gt;state = FSG_STATE_TERMINATED;	/* Stop the thread */
 		spin_unlock_irq(&amp;common-&gt;lock);
 		break;
 
-	case FSG_STATE_INTERFACE_CHANGE:
-	case FSG_STATE_DISCONNECT:
-	case FSG_STATE_COMMAND_PHASE:
-	case FSG_STATE_DATA_PHASE:
-	case FSG_STATE_STATUS_PHASE:
-	case FSG_STATE_IDLE:
+	case FSG_STATE_TERMINATED:
 		break;
 	}
 }
@@ -2529,29 +2522,13 @@ static int fsg_main_thread(void *common_)
 			continue;
 		}
 
-		if (get_next_command(common))
+		if (get_next_command(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_DATA_PHASE;
-		spin_unlock_irq(&amp;common-&gt;lock);
-
-		if (do_scsi_command(common) || finish_reply(common))
+		if (do_scsi_command(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_STATUS_PHASE;
-		spin_unlock_irq(&amp;common-&gt;lock);
-
-		if (send_status(common))
+		if (finish_reply(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_IDLE;
-		spin_unlock_irq(&amp;common-&gt;lock);
+		send_status(common);
 	}
 
 	spin_lock_irq(&amp;common-&gt;lock);
@@ -2972,7 +2949,6 @@ static void fsg_common_release(struct kref *ref)
 	if (common-&gt;state != FSG_STATE_TERMINATED) {
 		raise_exception(common, FSG_STATE_EXIT);
 		wait_for_completion(&amp;common-&gt;thread_notifier);
-		common-&gt;thread_task = NULL;
 	}
 
 	for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); ++i) {
@@ -3021,11 +2997,11 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 	}
 
 	if (!common-&gt;thread_task) {
-		common-&gt;state = FSG_STATE_IDLE;
+		common-&gt;state = FSG_STATE_NORMAL;
 		common-&gt;thread_task =
 			kthread_create(fsg_main_thread, common, "file-storage");
 		if (IS_ERR(common-&gt;thread_task)) {
-			int ret = PTR_ERR(common-&gt;thread_task);
+			ret = PTR_ERR(common-&gt;thread_task);
 			common-&gt;thread_task = NULL;
 			common-&gt;state = FSG_STATE_TERMINATED;
 			return ret;
diff --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
index e69848994cb4..e6095dfbf1d5 100644
--- a/drivers/usb/gadget/function/storage_common.h
+++ b/drivers/usb/gadget/function/storage_common.h
@@ -157,17 +157,10 @@ struct fsg_buffhd {
 };
 
 enum fsg_state {
-	/* This one isn't used anywhere */
-	FSG_STATE_COMMAND_PHASE = -10,
-	FSG_STATE_DATA_PHASE,
-	FSG_STATE_STATUS_PHASE,
-
-	FSG_STATE_IDLE = 0,
+	FSG_STATE_NORMAL,
 	FSG_STATE_ABORT_BULK_OUT,
-	FSG_STATE_RESET,
-	FSG_STATE_INTERFACE_CHANGE,
+	FSG_STATE_PROTOCOL_RESET,
 	FSG_STATE_CONFIG_CHANGE,
-	FSG_STATE_DISCONNECT,
 	FSG_STATE_EXIT,
 	FSG_STATE_TERMINATED
 };</pre><hr><pre>commit 1633682053a7ee8058e10c76722b9b28e97fb73f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 24 13:38:28 2017 -0400

    USB: fix linked-list corruption in rh_call_control()
    
    Using KASAN, Dmitry found a bug in the rh_call_control() routine: If
    buffer allocation fails, the routine returns immediately without
    unlinking its URB from the control endpoint, eventually leading to
    linked-list corruption.
    
    This patch fixes the problem by jumping to the end of the routine
    (where the URB is unlinked) when an allocation failure occurs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Dmitry Vyukov &lt;dvyukov@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 612fab6e54fb..79bdca5cb9c7 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -520,8 +520,10 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	 */
 	tbuf_size =  max_t(u16, sizeof(struct usb_hub_descriptor), wLength);
 	tbuf = kzalloc(tbuf_size, GFP_KERNEL);
-	if (!tbuf)
-		return -ENOMEM;
+	if (!tbuf) {
+		status = -ENOMEM;
+		goto err_alloc;
+	}
 
 	bufp = tbuf;
 
@@ -734,6 +736,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	}
 
 	kfree(tbuf);
+ err_alloc:
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);</pre><hr><pre>commit 0a8fd1346254974c3a852338508e4a4cddbb35f1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 19 12:03:41 2016 -0500

    USB: fix problems with duplicate endpoint addresses
    
    When checking a new device's descriptors, the USB core does not check
    for duplicate endpoint addresses.  This can cause a problem when the
    sysfs files for those endpoints are created; trying to create multiple
    files with the same name will provoke a WARNING:
    
    WARNING: CPU: 2 PID: 865 at fs/sysfs/dir.c:31 sysfs_warn_dup+0x8a/0xa0
    sysfs: cannot create duplicate filename
    '/devices/platform/dummy_hcd.0/usb2/2-1/2-1:64.0/ep_05'
    Kernel panic - not syncing: panic_on_warn set ...
    
    CPU: 2 PID: 865 Comm: kworker/2:1 Not tainted 4.9.0-rc7+ #34
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
     ffff88006bee64c8 ffffffff81f96b8a ffffffff00000001 1ffff1000d7dcc2c
     ffffed000d7dcc24 0000000000000001 0000000041b58ab3 ffffffff8598b510
     ffffffff81f968f8 ffffffff850fee20 ffffffff85cff020 dffffc0000000000
    Call Trace:
     [&lt;     inline     &gt;] __dump_stack lib/dump_stack.c:15
     [&lt;ffffffff81f96b8a&gt;] dump_stack+0x292/0x398 lib/dump_stack.c:51
     [&lt;ffffffff8168c88e&gt;] panic+0x1cb/0x3a9 kernel/panic.c:179
     [&lt;ffffffff812b80b4&gt;] __warn+0x1c4/0x1e0 kernel/panic.c:542
     [&lt;ffffffff812b8195&gt;] warn_slowpath_fmt+0xc5/0x110 kernel/panic.c:565
     [&lt;ffffffff819e70ca&gt;] sysfs_warn_dup+0x8a/0xa0 fs/sysfs/dir.c:30
     [&lt;ffffffff819e7308&gt;] sysfs_create_dir_ns+0x178/0x1d0 fs/sysfs/dir.c:59
     [&lt;     inline     &gt;] create_dir lib/kobject.c:71
     [&lt;ffffffff81fa1b07&gt;] kobject_add_internal+0x227/0xa60 lib/kobject.c:229
     [&lt;     inline     &gt;] kobject_add_varg lib/kobject.c:366
     [&lt;ffffffff81fa2479&gt;] kobject_add+0x139/0x220 lib/kobject.c:411
     [&lt;ffffffff82737a63&gt;] device_add+0x353/0x1660 drivers/base/core.c:1088
     [&lt;ffffffff82738d8d&gt;] device_register+0x1d/0x20 drivers/base/core.c:1206
     [&lt;ffffffff82cb77d3&gt;] usb_create_ep_devs+0x163/0x260 drivers/usb/core/endpoint.c:195
     [&lt;ffffffff82c9f27b&gt;] create_intf_ep_devs+0x13b/0x200 drivers/usb/core/message.c:1030
     [&lt;ffffffff82ca39d3&gt;] usb_set_configuration+0x1083/0x18d0 drivers/usb/core/message.c:1937
     [&lt;ffffffff82cc9e2e&gt;] generic_probe+0x6e/0xe0 drivers/usb/core/generic.c:172
     [&lt;ffffffff82caa7fa&gt;] usb_probe_device+0xaa/0xe0 drivers/usb/core/driver.c:263
    
    This patch prevents the problem by checking for duplicate endpoint
    addresses during enumeration and skipping any duplicates.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 0aa9e7d697a5..25dbd8c7aec7 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -239,6 +239,16 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	if (ifp-&gt;desc.bNumEndpoints &gt;= num_ep)
 		goto skip_to_next_endpoint_or_interface_descriptor;
 
+	/* Check for duplicate endpoint addresses */
+	for (i = 0; i &lt; ifp-&gt;desc.bNumEndpoints; ++i) {
+		if (ifp-&gt;endpoint[i].desc.bEndpointAddress ==
+		    d-&gt;bEndpointAddress) {
+			dev_warn(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
+			    cfgno, inum, asnum, d-&gt;bEndpointAddress);
+			goto skip_to_next_endpoint_or_interface_descriptor;
+		}
+	}
+
 	endpoint = &amp;ifp-&gt;endpoint[ifp-&gt;desc.bNumEndpoints];
 	++ifp-&gt;desc.bNumEndpoints;
 </pre><hr><pre>commit 890e6c236dcda6d45c5f0bdd23665636376f6831
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 15:25:15 2016 -0500

    USB: gadgetfs: remove unnecessary assignment
    
    The dev_config() routine in gadgetfs has a check that
    dev-&gt;dev-&gt;bNumConfigurations is equal to 1, and then contains a
    redundant line of code setting the value to 1.  This patch removes the
    unnecessary assignment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 08e5ecc05079..6bde4396927c 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1818,7 +1818,6 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 			|| dev-&gt;dev-&gt;bDescriptorType != USB_DT_DEVICE
 			|| dev-&gt;dev-&gt;bNumConfigurations != 1)
 		goto fail;
-	dev-&gt;dev-&gt;bNumConfigurations = 1;
 	dev-&gt;dev-&gt;bcdUSB = cpu_to_le16 (0x0200);
 
 	/* triggers gadgetfs_bind(); then we can enumerate. */</pre>
    <div class="pagination">
        <a href='2_20.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><span>[21]</span><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_22.html'>Next&gt;&gt;</a>
    <div>
</body>

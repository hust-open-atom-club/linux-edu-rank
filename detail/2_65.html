<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_64.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><span>[65]</span><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_66.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 478a8a0543021172220feeb0b39bb1b3e43c988f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 16 14:52:17 2010 -0400

    [SCSI] sd: add support for runtime PM
    
    This patch (as1399) adds runtime-PM support to the sd driver.  The
    support is unsophisticated: If a SCSI disk device is mounted, or if
    its device file is held open, then the device will not be
    runtime-suspended; otherwise it will (provided userspace gives
    permission by writing "auto" to the sysfs power/control attribute).
    
    In order to make this work, a dev_set_drvdata() call had to be moved
    from sd_probe_async() to sd_probe().  Also, a few lines of code were
    changed to use a local variable instead of recalculating the address
    of an embedded struct device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 8802e48bc063..cc8a1d1d915a 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -759,6 +759,10 @@ static int sd_open(struct block_device *bdev, fmode_t mode)
 
 	sdev = sdkp-&gt;device;
 
+	retval = scsi_autopm_get_device(sdev);
+	if (retval)
+		goto error_autopm;
+
 	/*
 	 * If the device is in error recovery, wait until it is done.
 	 * If the device is offline, then disallow any access to it.
@@ -803,6 +807,8 @@ static int sd_open(struct block_device *bdev, fmode_t mode)
 	return 0;
 
 error_out:
+	scsi_autopm_put_device(sdev);
+error_autopm:
 	scsi_disk_put(sdkp);
 	return retval;	
 }
@@ -834,6 +840,8 @@ static int sd_release(struct gendisk *disk, fmode_t mode)
 	 * XXX and what if there are packets in flight and this close()
 	 * XXX is followed by a "rmmod sd_mod"?
 	 */
+
+	scsi_autopm_put_device(sdev);
 	scsi_disk_put(sdkp);
 	return 0;
 }
@@ -2232,7 +2240,6 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 	if (sdp-&gt;removable)
 		gd-&gt;flags |= GENHD_FL_REMOVABLE;
 
-	dev_set_drvdata(dev, sdkp);
 	add_disk(gd);
 	sd_dif_config_host(sdkp);
 
@@ -2240,6 +2247,7 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 
 	sd_printk(KERN_NOTICE, sdkp, "Attached SCSI %sdisk\n",
 		  sdp-&gt;removable ? "removable " : "");
+	scsi_autopm_put_device(sdp);
 	put_device(&amp;sdkp-&gt;dev);
 }
 
@@ -2317,14 +2325,15 @@ static int sd_probe(struct device *dev)
 	}
 
 	device_initialize(&amp;sdkp-&gt;dev);
-	sdkp-&gt;dev.parent = &amp;sdp-&gt;sdev_gendev;
+	sdkp-&gt;dev.parent = dev;
 	sdkp-&gt;dev.class = &amp;sd_disk_class;
-	dev_set_name(&amp;sdkp-&gt;dev, dev_name(&amp;sdp-&gt;sdev_gendev));
+	dev_set_name(&amp;sdkp-&gt;dev, dev_name(dev));
 
 	if (device_add(&amp;sdkp-&gt;dev))
 		goto out_free_index;
 
-	get_device(&amp;sdp-&gt;sdev_gendev);
+	get_device(dev);
+	dev_set_drvdata(dev, sdkp);
 
 	get_device(&amp;sdkp-&gt;dev);	/* prevent release before async_schedule */
 	async_schedule(sd_probe_async, sdkp);
@@ -2358,8 +2367,10 @@ static int sd_remove(struct device *dev)
 {
 	struct scsi_disk *sdkp;
 
-	async_synchronize_full();
 	sdkp = dev_get_drvdata(dev);
+	scsi_autopm_get_device(sdkp-&gt;device);
+
+	async_synchronize_full();
 	blk_queue_prep_rq(sdkp-&gt;device-&gt;request_queue, scsi_prep_fn);
 	device_del(&amp;sdkp-&gt;dev);
 	del_gendisk(sdkp-&gt;disk);</pre><hr><pre>commit bc4f24014de58f045f169742701a6598884d93db
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 17 10:41:42 2010 -0400

    [SCSI] implement runtime Power Management
    
    This patch (as1398b) adds runtime PM support to the SCSI layer.  Only
    the machanism is provided; use of it is up to the various high-level
    drivers, and the patch doesn't change any of them.  Except for sg --
    the patch expicitly prevents a device from being runtime-suspended
    while its sg device file is open.
    
    The implementation is simplistic.  In general, hosts and targets are
    automatically suspended when all their children are asleep, but for
    them the runtime-suspend code doesn't actually do anything.  (A host's
    runtime PM status is propagated up the device tree, though, so a
    runtime-PM-aware lower-level driver could power down the host adapter
    hardware at the appropriate times.)  There are comments indicating
    where a transport class might be notified or some other hooks added.
    
    LUNs are runtime-suspended by calling the drivers' existing suspend
    handlers (and likewise for runtime-resume).  Somewhat arbitrarily, the
    implementation delays for 100 ms before suspending an eligible LUN.
    This is because there typically are occasions during bootup when the
    same device file is opened and closed several times in quick
    succession.
    
    The way this all works is that the SCSI core increments a device's
    PM-usage count when it is registered.  If a high-level driver does
    nothing then the device will not be eligible for runtime-suspend
    because of the elevated usage count.  If a high-level driver wants to
    use runtime PM then it can call scsi_autopm_put_device() in its probe
    routine to decrement the usage count and scsi_autopm_get_device() in
    its remove routine to restore the original count.
    
    Hosts, targets, and LUNs are not suspended while they are being probed
    or removed, or while the error handler is running.  In fact, a fairly
    large part of the patch consists of code to make sure that things
    aren't suspended at such times.
    
    [jejb: fix up compile issues in PM config variations]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index a2b1414da288..8a8f803439e1 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -32,6 +32,7 @@
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/transport_class.h&gt;
 #include &lt;linux/platform_device.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;scsi/scsi_device.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
@@ -156,6 +157,7 @@ EXPORT_SYMBOL(scsi_host_set_state);
 void scsi_remove_host(struct Scsi_Host *shost)
 {
 	unsigned long flags;
+
 	mutex_lock(&amp;shost-&gt;scan_mutex);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	if (scsi_host_set_state(shost, SHOST_CANCEL))
@@ -165,6 +167,8 @@ void scsi_remove_host(struct Scsi_Host *shost)
 			return;
 		}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
+
+	scsi_autopm_get_host(shost);
 	scsi_forget_host(shost);
 	mutex_unlock(&amp;shost-&gt;scan_mutex);
 	scsi_proc_host_rm(shost);
@@ -216,12 +220,14 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		shost-&gt;shost_gendev.parent = dev ? dev : &amp;platform_bus;
 	shost-&gt;dma_dev = dma_dev;
 
-	device_enable_async_suspend(&amp;shost-&gt;shost_gendev);
-
 	error = device_add(&amp;shost-&gt;shost_gendev);
 	if (error)
 		goto out;
 
+	pm_runtime_set_active(&amp;shost-&gt;shost_gendev);
+	pm_runtime_enable(&amp;shost-&gt;shost_gendev);
+	device_enable_async_suspend(&amp;shost-&gt;shost_gendev);
+
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost-&gt;shost_gendev.parent);
 
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index c60cffbefa3c..2bf98469dc4c 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -1775,6 +1775,14 @@ int scsi_error_handler(void *data)
 		 * what we need to do to get it up and online again (if we can).
 		 * If we fail, we end up taking the thing offline.
 		 */
+		if (scsi_autopm_get_host(shost) != 0) {
+			SCSI_LOG_ERROR_RECOVERY(1,
+				printk(KERN_ERR "Error handler scsi_eh_%d "
+						"unable to autoresume\n",
+						shost-&gt;host_no));
+			continue;
+		}
+
 		if (shost-&gt;transportt-&gt;eh_strategy_handler)
 			shost-&gt;transportt-&gt;eh_strategy_handler(shost);
 		else
@@ -1788,6 +1796,7 @@ int scsi_error_handler(void *data)
 		 * which are still online.
 		 */
 		scsi_restart_operations(shost);
+		scsi_autopm_put_host(shost);
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	__set_current_state(TASK_RUNNING);
@@ -1885,12 +1894,16 @@ scsi_reset_provider_done_command(struct scsi_cmnd *scmd)
 int
 scsi_reset_provider(struct scsi_device *dev, int flag)
 {
-	struct scsi_cmnd *scmd = scsi_get_command(dev, GFP_KERNEL);
+	struct scsi_cmnd *scmd;
 	struct Scsi_Host *shost = dev-&gt;host;
 	struct request req;
 	unsigned long flags;
 	int rtn;
 
+	if (scsi_autopm_get_host(shost) &lt; 0)
+		return FAILED;
+
+	scmd = scsi_get_command(dev, GFP_KERNEL);
 	blk_rq_init(NULL, &amp;req);
 	scmd-&gt;request = &amp;req;
 
@@ -1947,6 +1960,7 @@ scsi_reset_provider(struct scsi_device *dev, int flag)
 	scsi_run_host_queues(shost);
 
 	scsi_next_command(scmd);
+	scsi_autopm_put_host(shost);
 	return rtn;
 }
 EXPORT_SYMBOL(scsi_reset_provider);
diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index cd83758ce0a2..d70e91ae60af 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -59,6 +59,12 @@ static int scsi_bus_resume_common(struct device *dev)
 
 	if (scsi_is_sdev_device(dev))
 		err = scsi_dev_type_resume(dev);
+
+	if (err == 0) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_active(dev);
+		pm_runtime_enable(dev);
+	}
 	return err;
 }
 
@@ -86,6 +92,107 @@ static int scsi_bus_poweroff(struct device *dev)
 
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_RUNTIME
+
+static int scsi_runtime_suspend(struct device *dev)
+{
+	int err = 0;
+
+	dev_dbg(dev, "scsi_runtime_suspend\n");
+	if (scsi_is_sdev_device(dev)) {
+		err = scsi_dev_type_suspend(dev, PMSG_AUTO_SUSPEND);
+		if (err == -EAGAIN)
+			pm_schedule_suspend(dev, jiffies_to_msecs(
+				round_jiffies_up_relative(HZ/10)));
+	}
+
+	/* Insert hooks here for targets, hosts, and transport classes */
+
+	return err;
+}
+
+static int scsi_runtime_resume(struct device *dev)
+{
+	int err = 0;
+
+	dev_dbg(dev, "scsi_runtime_resume\n");
+	if (scsi_is_sdev_device(dev))
+		err = scsi_dev_type_resume(dev);
+
+	/* Insert hooks here for targets, hosts, and transport classes */
+
+	return err;
+}
+
+static int scsi_runtime_idle(struct device *dev)
+{
+	int err;
+
+	dev_dbg(dev, "scsi_runtime_idle\n");
+
+	/* Insert hooks here for targets, hosts, and transport classes */
+
+	if (scsi_is_sdev_device(dev))
+		err = pm_schedule_suspend(dev, 100);
+	else
+		err = pm_runtime_suspend(dev);
+	return err;
+}
+
+int scsi_autopm_get_device(struct scsi_device *sdev)
+{
+	int	err;
+
+	err = pm_runtime_get_sync(&amp;sdev-&gt;sdev_gendev);
+	if (err &lt; 0)
+		pm_runtime_put_sync(&amp;sdev-&gt;sdev_gendev);
+	else if (err &gt; 0)
+		err = 0;
+	return err;
+}
+EXPORT_SYMBOL_GPL(scsi_autopm_get_device);
+
+void scsi_autopm_put_device(struct scsi_device *sdev)
+{
+	pm_runtime_put_sync(&amp;sdev-&gt;sdev_gendev);
+}
+EXPORT_SYMBOL_GPL(scsi_autopm_put_device);
+
+void scsi_autopm_get_target(struct scsi_target *starget)
+{
+	pm_runtime_get_sync(&amp;starget-&gt;dev);
+}
+
+void scsi_autopm_put_target(struct scsi_target *starget)
+{
+	pm_runtime_put_sync(&amp;starget-&gt;dev);
+}
+
+int scsi_autopm_get_host(struct Scsi_Host *shost)
+{
+	int	err;
+
+	err = pm_runtime_get_sync(&amp;shost-&gt;shost_gendev);
+	if (err &lt; 0)
+		pm_runtime_put_sync(&amp;shost-&gt;shost_gendev);
+	else if (err &gt; 0)
+		err = 0;
+	return err;
+}
+
+void scsi_autopm_put_host(struct Scsi_Host *shost)
+{
+	pm_runtime_put_sync(&amp;shost-&gt;shost_gendev);
+}
+
+#else
+
+#define scsi_runtime_suspend	NULL
+#define scsi_runtime_resume	NULL
+#define scsi_runtime_idle	NULL
+
+#endif /* CONFIG_PM_RUNTIME */
+
 const struct dev_pm_ops scsi_bus_pm_ops = {
 	.suspend =		scsi_bus_suspend,
 	.resume =		scsi_bus_resume_common,
@@ -93,4 +200,7 @@ const struct dev_pm_ops scsi_bus_pm_ops = {
 	.thaw =			scsi_bus_resume_common,
 	.poweroff =		scsi_bus_poweroff,
 	.restore =		scsi_bus_resume_common,
+	.runtime_suspend =	scsi_runtime_suspend,
+	.runtime_resume =	scsi_runtime_resume,
+	.runtime_idle =		scsi_runtime_idle,
 };
diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index dddacc732550..026295e2c539 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -7,6 +7,7 @@ struct request_queue;
 struct request;
 struct scsi_cmnd;
 struct scsi_device;
+struct scsi_target;
 struct scsi_host_template;
 struct Scsi_Host;
 struct scsi_nl_hdr;
@@ -147,9 +148,20 @@ static inline void scsi_netlink_exit(void) {}
 /* scsi_pm.c */
 #ifdef CONFIG_PM_OPS
 extern const struct dev_pm_ops scsi_bus_pm_ops;
-#else
+#else /* CONFIG_PM_OPS */
 #define scsi_bus_pm_ops		(*NULL)
 #endif
+#ifdef CONFIG_PM_RUNTIME
+extern void scsi_autopm_get_target(struct scsi_target *);
+extern void scsi_autopm_put_target(struct scsi_target *);
+extern int scsi_autopm_get_host(struct Scsi_Host *);
+extern void scsi_autopm_put_host(struct Scsi_Host *);
+#else
+static inline void scsi_autopm_get_target(struct scsi_target *t) {}
+static inline void scsi_autopm_put_target(struct scsi_target *t) {}
+static inline int scsi_autopm_get_host(struct Scsi_Host *h) { return 0; }
+static inline void scsi_autopm_put_host(struct Scsi_Host *h) {}
+#endif /* CONFIG_PM_RUNTIME */
 
 /* 
  * internal scsi timeout functions: for use by mid-layer and transport
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 1c027a97d8b9..3d0a1e6e9c48 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1513,14 +1513,18 @@ struct scsi_device *__scsi_add_device(struct Scsi_Host *shost, uint channel,
 	starget = scsi_alloc_target(parent, channel, id);
 	if (!starget)
 		return ERR_PTR(-ENOMEM);
+	scsi_autopm_get_target(starget);
 
 	mutex_lock(&amp;shost-&gt;scan_mutex);
 	if (!shost-&gt;async_scan)
 		scsi_complete_async_scans();
 
-	if (scsi_host_scan_allowed(shost))
+	if (scsi_host_scan_allowed(shost) &amp;&amp; scsi_autopm_get_host(shost) == 0) {
 		scsi_probe_and_add_lun(starget, lun, NULL, &amp;sdev, 1, hostdata);
+		scsi_autopm_put_host(shost);
+	}
 	mutex_unlock(&amp;shost-&gt;scan_mutex);
+	scsi_autopm_put_target(starget);
 	scsi_target_reap(starget);
 	put_device(&amp;starget-&gt;dev);
 
@@ -1574,6 +1578,7 @@ static void __scsi_scan_target(struct device *parent, unsigned int channel,
 	starget = scsi_alloc_target(parent, channel, id);
 	if (!starget)
 		return;
+	scsi_autopm_get_target(starget);
 
 	if (lun != SCAN_WILD_CARD) {
 		/*
@@ -1599,6 +1604,7 @@ static void __scsi_scan_target(struct device *parent, unsigned int channel,
 	}
 
  out_reap:
+	scsi_autopm_put_target(starget);
 	/* now determine if the target has any children at all
 	 * and if not, nuke it */
 	scsi_target_reap(starget);
@@ -1633,8 +1639,10 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 	if (!shost-&gt;async_scan)
 		scsi_complete_async_scans();
 
-	if (scsi_host_scan_allowed(shost))
+	if (scsi_host_scan_allowed(shost) &amp;&amp; scsi_autopm_get_host(shost) == 0) {
 		__scsi_scan_target(parent, channel, id, lun, rescan);
+		scsi_autopm_put_host(shost);
+	}
 	mutex_unlock(&amp;shost-&gt;scan_mutex);
 }
 EXPORT_SYMBOL(scsi_scan_target);
@@ -1686,7 +1694,7 @@ int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
 	if (!shost-&gt;async_scan)
 		scsi_complete_async_scans();
 
-	if (scsi_host_scan_allowed(shost)) {
+	if (scsi_host_scan_allowed(shost) &amp;&amp; scsi_autopm_get_host(shost) == 0) {
 		if (channel == SCAN_WILD_CARD)
 			for (channel = 0; channel &lt;= shost-&gt;max_channel;
 			     channel++)
@@ -1694,6 +1702,7 @@ int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
 						  rescan);
 		else
 			scsi_scan_channel(shost, channel, id, lun, rescan);
+		scsi_autopm_put_host(shost);
 	}
 	mutex_unlock(&amp;shost-&gt;scan_mutex);
 
@@ -1831,8 +1840,11 @@ static void do_scsi_scan_host(struct Scsi_Host *shost)
 static int do_scan_async(void *_data)
 {
 	struct async_scan_data *data = _data;
-	do_scsi_scan_host(data-&gt;shost);
+	struct Scsi_Host *shost = data-&gt;shost;
+
+	do_scsi_scan_host(shost);
 	scsi_finish_async_scan(data);
+	scsi_autopm_put_host(shost);
 	return 0;
 }
 
@@ -1847,16 +1859,20 @@ void scsi_scan_host(struct Scsi_Host *shost)
 
 	if (strncmp(scsi_scan_type, "none", 4) == 0)
 		return;
+	if (scsi_autopm_get_host(shost) &lt; 0)
+		return;
 
 	data = scsi_prep_async_scan(shost);
 	if (!data) {
 		do_scsi_scan_host(shost);
+		scsi_autopm_put_host(shost);
 		return;
 	}
 
 	p = kthread_run(do_scan_async, data, "scsi_scan_%d", shost-&gt;host_no);
 	if (IS_ERR(p))
 		do_scan_async(data);
+	/* scsi_autopm_put_host(shost) is called in do_scan_async() */
 }
 EXPORT_SYMBOL(scsi_scan_host);
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 5f85f8e831f3..562fb3bce261 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -11,6 +11,7 @@
 #include &lt;linux/init.h&gt;
 #include &lt;linux/blkdev.h&gt;
 #include &lt;linux/device.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_device.h&gt;
@@ -802,8 +803,6 @@ static int scsi_target_add(struct scsi_target *starget)
 	if (starget-&gt;state != STARGET_CREATED)
 		return 0;
 
-	device_enable_async_suspend(&amp;starget-&gt;dev);
-
 	error = device_add(&amp;starget-&gt;dev);
 	if (error) {
 		dev_err(&amp;starget-&gt;dev, "target device_add failed, error %d\n", error);
@@ -812,6 +811,10 @@ static int scsi_target_add(struct scsi_target *starget)
 	transport_add_device(&amp;starget-&gt;dev);
 	starget-&gt;state = STARGET_RUNNING;
 
+	pm_runtime_set_active(&amp;starget-&gt;dev);
+	pm_runtime_enable(&amp;starget-&gt;dev);
+	device_enable_async_suspend(&amp;starget-&gt;dev);
+
 	return 0;
 }
 
@@ -841,7 +844,20 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 		return error;
 
 	transport_configure_device(&amp;starget-&gt;dev);
+
 	device_enable_async_suspend(&amp;sdev-&gt;sdev_gendev);
+	scsi_autopm_get_target(starget);
+	pm_runtime_set_active(&amp;sdev-&gt;sdev_gendev);
+	pm_runtime_forbid(&amp;sdev-&gt;sdev_gendev);
+	pm_runtime_enable(&amp;sdev-&gt;sdev_gendev);
+	scsi_autopm_put_target(starget);
+
+	/* The following call will keep sdev active indefinitely, until
+	 * its driver does a corresponding scsi_autopm_pm_device().  Only
+	 * drivers supporting autosuspend will do this.
+	 */
+	scsi_autopm_get_device(sdev);
+
 	error = device_add(&amp;sdev-&gt;sdev_gendev);
 	if (error) {
 		printk(KERN_INFO "error 1\n");
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index d4549092400c..2968c6b83ddb 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -245,6 +245,10 @@ sg_open(struct inode *inode, struct file *filp)
 	if (retval)
 		goto sg_put;
 
+	retval = scsi_autopm_get_device(sdp-&gt;device);
+	if (retval)
+		goto sdp_put;
+
 	if (!((flags &amp; O_NONBLOCK) ||
 	      scsi_block_when_processing_errors(sdp-&gt;device))) {
 		retval = -ENXIO;
@@ -302,8 +306,11 @@ sg_open(struct inode *inode, struct file *filp)
 	}
 	retval = 0;
 error_out:
-	if (retval)
+	if (retval) {
+		scsi_autopm_put_device(sdp-&gt;device);
+sdp_put:
 		scsi_device_put(sdp-&gt;device);
+	}
 sg_put:
 	if (sdp)
 		sg_put_dev(sdp);
@@ -327,6 +334,7 @@ sg_release(struct inode *inode, struct file *filp)
 	sdp-&gt;exclude = 0;
 	wake_up_interruptible(&amp;sdp-&gt;o_excl_wait);
 
+	scsi_autopm_put_device(sdp-&gt;device);
 	kref_put(&amp;sfp-&gt;f_ref, sg_remove_sfp);
 	return 0;
 }
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index d80b6dbed1ca..50cb34ffef11 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -381,6 +381,14 @@ extern int scsi_execute_req(struct scsi_device *sdev, const unsigned char *cmd,
 			    struct scsi_sense_hdr *, int timeout, int retries,
 			    int *resid);
 
+#ifdef CONFIG_PM_RUNTIME
+extern int scsi_autopm_get_device(struct scsi_device *);
+extern void scsi_autopm_put_device(struct scsi_device *);
+#else
+static inline int scsi_autopm_get_device(struct scsi_device *d) { return 0; }
+static inline void scsi_autopm_put_device(struct scsi_device *d) {}
+#endif /* CONFIG_PM_RUNTIME */
+
 static inline int __must_check scsi_device_reprobe(struct scsi_device *sdev)
 {
 	return device_reprobe(&amp;sdev-&gt;sdev_gendev);</pre><hr><pre>commit db5bd1e0b505c54ff492172ce4abc245cf6cd639
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 17 10:36:49 2010 -0400

    [SCSI] convert to the new PM framework
    
    This patch (as1397b) converts the SCSI midlayer to use the new PM
    callbacks (struct dev_pm_ops).  A new source file, scsi_pm.c, is
    created to hold the new callback routines, and the existing
    suspend/resume code is moved there.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index 1c7ac49be649..2a3fca2eca6a 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -163,6 +163,7 @@ scsi_mod-$(CONFIG_SCSI_NETLINK)	+= scsi_netlink.o
 scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
 scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
 scsi_mod-y			+= scsi_trace.o
+scsi_mod-$(CONFIG_PM_OPS)	+= scsi_pm.o
 
 scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
 
diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
new file mode 100644
index 000000000000..cd83758ce0a2
--- /dev/null
+++ b/drivers/scsi/scsi_pm.c
@@ -0,0 +1,96 @@
+/*
+ *	scsi_pm.c	Copyright (C) 2010 Alan Stern
+ *
+ *	SCSI dynamic Power Management
+ *		Initial version: Alan Stern &lt;stern@rowland.harvard.edu&gt;
+ */
+
+#include &lt;linux/pm_runtime.h&gt;
+
+#include &lt;scsi/scsi.h&gt;
+#include &lt;scsi/scsi_device.h&gt;
+#include &lt;scsi/scsi_driver.h&gt;
+#include &lt;scsi/scsi_host.h&gt;
+
+#include "scsi_priv.h"
+
+static int scsi_dev_type_suspend(struct device *dev, pm_message_t msg)
+{
+	struct device_driver *drv;
+	int err;
+
+	err = scsi_device_quiesce(to_scsi_device(dev));
+	if (err == 0) {
+		drv = dev-&gt;driver;
+		if (drv &amp;&amp; drv-&gt;suspend)
+			err = drv-&gt;suspend(dev, msg);
+	}
+	dev_dbg(dev, "scsi suspend: %d\n", err);
+	return err;
+}
+
+static int scsi_dev_type_resume(struct device *dev)
+{
+	struct device_driver *drv;
+	int err = 0;
+
+	drv = dev-&gt;driver;
+	if (drv &amp;&amp; drv-&gt;resume)
+		err = drv-&gt;resume(dev);
+	scsi_device_resume(to_scsi_device(dev));
+	dev_dbg(dev, "scsi resume: %d\n", err);
+	return err;
+}
+
+#ifdef CONFIG_PM_SLEEP
+
+static int scsi_bus_suspend_common(struct device *dev, pm_message_t msg)
+{
+	int err = 0;
+
+	if (scsi_is_sdev_device(dev))
+		err = scsi_dev_type_suspend(dev, msg);
+	return err;
+}
+
+static int scsi_bus_resume_common(struct device *dev)
+{
+	int err = 0;
+
+	if (scsi_is_sdev_device(dev))
+		err = scsi_dev_type_resume(dev);
+	return err;
+}
+
+static int scsi_bus_suspend(struct device *dev)
+{
+	return scsi_bus_suspend_common(dev, PMSG_SUSPEND);
+}
+
+static int scsi_bus_freeze(struct device *dev)
+{
+	return scsi_bus_suspend_common(dev, PMSG_FREEZE);
+}
+
+static int scsi_bus_poweroff(struct device *dev)
+{
+	return scsi_bus_suspend_common(dev, PMSG_HIBERNATE);
+}
+
+#else /* CONFIG_PM_SLEEP */
+
+#define scsi_bus_resume_common		NULL
+#define scsi_bus_suspend		NULL
+#define scsi_bus_freeze			NULL
+#define scsi_bus_poweroff		NULL
+
+#endif /* CONFIG_PM_SLEEP */
+
+const struct dev_pm_ops scsi_bus_pm_ops = {
+	.suspend =		scsi_bus_suspend,
+	.resume =		scsi_bus_resume_common,
+	.freeze =		scsi_bus_freeze,
+	.thaw =			scsi_bus_resume_common,
+	.poweroff =		scsi_bus_poweroff,
+	.restore =		scsi_bus_resume_common,
+};
diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index 1fbf7c78bba0..dddacc732550 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -144,6 +144,13 @@ static inline void scsi_netlink_init(void) {}
 static inline void scsi_netlink_exit(void) {}
 #endif
 
+/* scsi_pm.c */
+#ifdef CONFIG_PM_OPS
+extern const struct dev_pm_ops scsi_bus_pm_ops;
+#else
+#define scsi_bus_pm_ops		(*NULL)
+#endif
+
 /* 
  * internal scsi timeout functions: for use by mid-layer and transport
  * classes.
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index c23ab978c3ba..5f85f8e831f3 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -376,57 +376,11 @@ static int scsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
-static int scsi_bus_suspend(struct device * dev, pm_message_t state)
-{
-	struct device_driver *drv;
-	struct scsi_device *sdev;
-	int err;
-
-	if (dev-&gt;type != &amp;scsi_dev_type)
-		return 0;
-
-	drv = dev-&gt;driver;
-	sdev = to_scsi_device(dev);
-
-	err = scsi_device_quiesce(sdev);
-	if (err)
-		return err;
-
-	if (drv &amp;&amp; drv-&gt;suspend) {
-		err = drv-&gt;suspend(dev, state);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static int scsi_bus_resume(struct device * dev)
-{
-	struct device_driver *drv;
-	struct scsi_device *sdev;
-	int err = 0;
-
-	if (dev-&gt;type != &amp;scsi_dev_type)
-		return 0;
-
-	drv = dev-&gt;driver;
-	sdev = to_scsi_device(dev);
-
-	if (drv &amp;&amp; drv-&gt;resume)
-		err = drv-&gt;resume(dev);
-
-	scsi_device_resume(sdev);
-
-	return err;
-}
-
 struct bus_type scsi_bus_type = {
         .name		= "scsi",
         .match		= scsi_bus_match,
 	.uevent		= scsi_bus_uevent,
-	.suspend	= scsi_bus_suspend,
-	.resume		= scsi_bus_resume,
+	.pm		= &amp;scsi_bus_pm_ops,
 };
 EXPORT_SYMBOL_GPL(scsi_bus_type);
 </pre><hr><pre>commit 0fcb4eef8294492c8f1de8236b1ed81f09e42922
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 8 00:05:37 2010 +0200

    PM / Runtime: Make runtime_status attribute not debug-only (v. 2)
    
    This patch (as1404b) makes the runtime_status sysfs attribute available
    even in the absence of CONFIG_PM_ADVANCED_DEBUG, and it changes the
    routine to display "unsupported" when runtime PM is disabled for a
    device.  Although not strictly 100% accurate, this will almost always
    be correct.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index 81d344e0e95d..1eca50c8e7ca 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -110,6 +110,38 @@ static ssize_t control_store(struct device * dev, struct device_attribute *attr,
 }
 
 static DEVICE_ATTR(control, 0644, control_show, control_store);
+
+static ssize_t rtpm_status_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	const char *p;
+
+	if (dev-&gt;power.runtime_error) {
+		p = "error\n";
+	} else if (dev-&gt;power.disable_depth) {
+		p = "unsupported\n";
+	} else {
+		switch (dev-&gt;power.runtime_status) {
+		case RPM_SUSPENDED:
+			p = "suspended\n";
+			break;
+		case RPM_SUSPENDING:
+			p = "suspending\n";
+			break;
+		case RPM_RESUMING:
+			p = "resuming\n";
+			break;
+		case RPM_ACTIVE:
+			p = "active\n";
+			break;
+		default:
+			return -EIO;
+		}
+	}
+	return sprintf(buf, p);
+}
+
+static DEVICE_ATTR(runtime_status, 0444, rtpm_status_show, NULL);
 #endif
 
 static ssize_t
@@ -184,27 +216,8 @@ static ssize_t rtpm_enabled_show(struct device *dev,
 	return sprintf(buf, "enabled\n");
 }
 
-static ssize_t rtpm_status_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	if (dev-&gt;power.runtime_error)
-		return sprintf(buf, "error\n");
-	switch (dev-&gt;power.runtime_status) {
-	case RPM_SUSPENDED:
-		return sprintf(buf, "suspended\n");
-	case RPM_SUSPENDING:
-		return sprintf(buf, "suspending\n");
-	case RPM_RESUMING:
-		return sprintf(buf, "resuming\n");
-	case RPM_ACTIVE:
-		return sprintf(buf, "active\n");
-	}
-	return -EIO;
-}
-
 static DEVICE_ATTR(runtime_usage, 0444, rtpm_usagecount_show, NULL);
 static DEVICE_ATTR(runtime_active_kids, 0444, rtpm_children_show, NULL);
-static DEVICE_ATTR(runtime_status, 0444, rtpm_status_show, NULL);
 static DEVICE_ATTR(runtime_enabled, 0444, rtpm_enabled_show, NULL);
 
 #endif
@@ -240,6 +253,7 @@ static DEVICE_ATTR(async, 0644, async_show, async_store);
 static struct attribute * power_attrs[] = {
 #ifdef CONFIG_PM_RUNTIME
 	&amp;dev_attr_control.attr,
+	&amp;dev_attr_runtime_status.attr,
 #endif
 	&amp;dev_attr_wakeup.attr,
 #ifdef CONFIG_PM_SLEEP
@@ -250,7 +264,6 @@ static struct attribute * power_attrs[] = {
 #ifdef CONFIG_PM_RUNTIME
 	&amp;dev_attr_runtime_usage.attr,
 	&amp;dev_attr_runtime_active_kids.attr,
-	&amp;dev_attr_runtime_status.attr,
 	&amp;dev_attr_runtime_enabled.attr,
 #endif
 #endif</pre><hr><pre>commit b14e033e17d0ea0ba12668d0d2f371cd31586994
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 29 22:49:24 2010 +0200

    PNPACPI: Add support for remote wakeup
    
    This patch (as1354) adds remote-wakeup support to the pnpacpi driver.
    The new can_wakeup method also allows other PNP protocol drivers
    (pnpbios or iaspnp) to add wakeup support, but I don't know enough
    about how they work to actually do it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Bjorn Helgaas &lt;bjorn.helgaas@hp.com&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/pnp/core.c b/drivers/pnp/core.c
index 5dba90995d9e..88b3cde52596 100644
--- a/drivers/pnp/core.c
+++ b/drivers/pnp/core.c
@@ -164,6 +164,9 @@ int __pnp_add_device(struct pnp_dev *dev)
 	list_add_tail(&amp;dev-&gt;global_list, &amp;pnp_global);
 	list_add_tail(&amp;dev-&gt;protocol_list, &amp;dev-&gt;protocol-&gt;devices);
 	spin_unlock(&amp;pnp_lock);
+	if (dev-&gt;protocol-&gt;can_wakeup)
+		device_set_wakeup_capable(&amp;dev-&gt;dev,
+				dev-&gt;protocol-&gt;can_wakeup(dev));
 	return device_register(&amp;dev-&gt;dev);
 }
 
diff --git a/drivers/pnp/pnpacpi/core.c b/drivers/pnp/pnpacpi/core.c
index f7ff628b7d94..dc4e32e031e9 100644
--- a/drivers/pnp/pnpacpi/core.c
+++ b/drivers/pnp/pnpacpi/core.c
@@ -122,17 +122,37 @@ static int pnpacpi_disable_resources(struct pnp_dev *dev)
 }
 
 #ifdef CONFIG_ACPI_SLEEP
+static bool pnpacpi_can_wakeup(struct pnp_dev *dev)
+{
+	struct acpi_device *acpi_dev = dev-&gt;data;
+	acpi_handle handle = acpi_dev-&gt;handle;
+
+	return acpi_bus_can_wakeup(handle);
+}
+
 static int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)
 {
 	struct acpi_device *acpi_dev = dev-&gt;data;
 	acpi_handle handle = acpi_dev-&gt;handle;
 	int power_state;
 
+	if (device_can_wakeup(&amp;dev-&gt;dev)) {
+		int rc = acpi_pm_device_sleep_wake(&amp;dev-&gt;dev,
+				device_may_wakeup(&amp;dev-&gt;dev));
+
+		if (rc)
+			return rc;
+	}
 	power_state = acpi_pm_device_sleep_state(&amp;dev-&gt;dev, NULL);
 	if (power_state &lt; 0)
 		power_state = (state.event == PM_EVENT_ON) ?
 				ACPI_STATE_D0 : ACPI_STATE_D3;
 
+	/* acpi_bus_set_power() often fails (keyboard port can't be
+	 * powered-down?), and in any case, our return value is ignored
+	 * by pnp_bus_suspend().  Hence we don't revert the wakeup
+	 * setting if the set_power fails.
+	 */
 	return acpi_bus_set_power(handle, power_state);
 }
 
@@ -141,6 +161,8 @@ static int pnpacpi_resume(struct pnp_dev *dev)
 	struct acpi_device *acpi_dev = dev-&gt;data;
 	acpi_handle handle = acpi_dev-&gt;handle;
 
+	if (device_may_wakeup(&amp;dev-&gt;dev))
+		acpi_pm_device_sleep_wake(&amp;dev-&gt;dev, false);
 	return acpi_bus_set_power(handle, ACPI_STATE_D0);
 }
 #endif
@@ -151,6 +173,7 @@ struct pnp_protocol pnpacpi_protocol = {
 	.set	 = pnpacpi_set_resources,
 	.disable = pnpacpi_disable_resources,
 #ifdef CONFIG_ACPI_SLEEP
+	.can_wakeup = pnpacpi_can_wakeup,
 	.suspend = pnpacpi_suspend,
 	.resume = pnpacpi_resume,
 #endif
diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 7c4193eb0072..1bc1338b817b 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -414,6 +414,7 @@ struct pnp_protocol {
 	int (*disable) (struct pnp_dev *dev);
 
 	/* protocol specific suspend/resume */
+	bool (*can_wakeup) (struct pnp_dev *dev);
 	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
 	int (*resume) (struct pnp_dev * dev);
 </pre><hr><pre>commit 2430d12c94ff2bafcfe4f65edf7ee5f300d2d9c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Jun 13 00:36:52 2010 +0200

    PM: describe kernel policy regarding wakeup defaults (v. 2)
    
    This patch (as1381b) updates a comment describing the kernel's policy
    toward enabling wakeup by default.
    
    It also makes device_set_wakeup_capable() actually do something when
    CONFIG_PM isn't enabled.  It's not clear this is necessary; however if
    it isn't then device_init_wakeup() and device_can_wakeup() should also
    be do-nothing routines.  Furthermore, I don't expect this change to
    have any noticeable effect -- but if it does then clearly the old
    behavior was wrong.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 22d64c18056c..76aca48722ae 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -29,8 +29,11 @@
 
 #ifdef CONFIG_PM
 
-/* changes to device_may_wakeup take effect on the next pm state change.
- * by default, devices should wakeup if they can.
+/* Changes to device_may_wakeup take effect on the next pm state change.
+ *
+ * By default, most devices should leave wakeup disabled.  The exceptions
+ * are devices that everyone expects to be wakeup sources: keyboards,
+ * power buttons, possibly network interfaces, etc.
  */
 static inline void device_init_wakeup(struct device *dev, bool val)
 {
@@ -59,7 +62,7 @@ static inline bool device_may_wakeup(struct device *dev)
 
 #else /* !CONFIG_PM */
 
-/* For some reason the next two routines work even without CONFIG_PM */
+/* For some reason the following routines work even without CONFIG_PM */
 static inline void device_init_wakeup(struct device *dev, bool val)
 {
 	dev-&gt;power.can_wakeup = val;
@@ -67,6 +70,7 @@ static inline void device_init_wakeup(struct device *dev, bool val)
 
 static inline void device_set_wakeup_capable(struct device *dev, bool capable)
 {
+	dev-&gt;power.can_wakeup = capable;
 }
 
 static inline bool device_can_wakeup(struct device *dev)</pre><hr><pre>commit 48826626263d4a61d06fd8c5805da31f925aefa0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 22 16:14:48 2010 -0400

    USB: obey the sysfs power/wakeup setting
    
    This patch (as1403) is a partial reversion of an earlier change
    (commit 5f677f1d45b2bf08085bbba7394392dfa586fa8e "USB: fix remote
    wakeup settings during system sleep").  After hearing from a user, I
    realized that remote wakeup should be enabled during system sleep
    whenever userspace allows it, and not only if a driver requests it
    too.
    
    Indeed, there could be a device with no driver, that does nothing but
    generate a wakeup request when the user presses a button.  Such a
    device should be allowed to do its job.
    
    The problem fixed by the earlier patch -- device generating a wakeup
    request for no reason, causing system suspend to abort -- was also
    addressed by a later patch ("USB: don't enable remote wakeup by
    default", accepted but not yet merged into mainline).  The device
    won't be able to generate the bogus wakeup requests because it will be
    disabled for remote wakeup by default.  Hence this reversion will not
    re-introduce any old problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt; [.34]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index de98a94d1853..a6bd53ace035 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1272,8 +1272,7 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 
 static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
 {
-	int			w, i;
-	struct usb_interface	*intf;
+	int	w;
 
 	/* Remote wakeup is needed only when we actually go to sleep.
 	 * For things like FREEZE and QUIESCE, if the device is already
@@ -1285,16 +1284,10 @@ static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
 		return;
 	}
 
-	/* If remote wakeup is permitted, see whether any interface drivers
+	/* Enable remote wakeup if it is allowed, even if no interface drivers
 	 * actually want it.
 	 */
-	w = 0;
-	if (device_may_wakeup(&amp;udev-&gt;dev) &amp;&amp; udev-&gt;actconfig) {
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			intf = udev-&gt;actconfig-&gt;interface[i];
-			w |= intf-&gt;needs_remote_wakeup;
-		}
-	}
+	w = device_may_wakeup(&amp;udev-&gt;dev);
 
 	/* If the device is autosuspended with the wrong wakeup setting,
 	 * autoresume now so the setting can be changed.</pre><hr><pre>commit 64d65872f96e2a754caa12ef48949c314384bd9f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 18 10:16:33 2010 -0400

    USB: fix oops in usb_sg_init()
    
    This patch (as1401) fixes a bug in usb_sg_init() that can cause an
    invalid pointer dereference.  An inner loop reuses some local variables
    in an unsafe manner, so new variables are introduced.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ajay Kumar Gupta &lt;ajay.gupta@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a73e08fdab36..fd4c36ea5e46 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -416,8 +416,11 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 			/* A length of zero means transfer the whole sg list */
 			len = length;
 			if (len == 0) {
-				for_each_sg(sg, sg, nents, i)
-					len += sg-&gt;length;
+				struct scatterlist	*sg2;
+				int			j;
+
+				for_each_sg(sg, sg2, nents, j)
+					len += sg2-&gt;length;
 			}
 		} else {
 			/*</pre><hr><pre>commit c043f1245654a726925529007210e9f786426448
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 4 14:02:42 2010 -0400

    USB: unbind all interfaces before rebinding them
    
    This patch (as1387) fixes a bug introduced during the changeover to
    the runtime PM framework.  When a driver doesn't support resume or
    reset-resume, and consequently its interfaces need to be unbound and
    rebound, we have to unbind all the interfaces before trying to rebind
    any of them.  Otherwise the driver's probe method for one interface
    could try to claim a different interface and fail, because that other
    interface hasn't been unbound yet.
    
    This fixes Bugzilla #15788.  The symptom is that some USB sound cards
    don't work after hibernation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Fran√ßois Valenduc &lt;francois.valenduc@tvcablenet.be&gt;
    Cc: stable &lt;stable@kernel.org&gt; [.34]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ded550eda5d9..de98a94d1853 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1328,6 +1328,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 
 	/* For all other calls, take the device back to full power and
 	 * tell the PM core in case it was autosuspended previously.
+	 * Unbind the interfaces that will need rebinding later.
 	 */
 	} else {
 		status = usb_resume_both(udev, msg);
@@ -1336,6 +1337,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 			pm_runtime_set_active(dev);
 			pm_runtime_enable(dev);
 			udev-&gt;last_busy = jiffies;
+			do_unbind_rebind(udev, DO_REBIND);
 		}
 	}
 </pre><hr><pre>commit f9e8894ae5157796dd69249c56062042d02a431d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 18 15:39:30 2010 -0400

    [SCSI] fix race in scsi_target_reap
    
    This patch (as1357) fixes a race in SCSI target allocation and
    release.  Putting a target in the STARGET_DEL state isn't protected by
    the host lock, so an old target structure could be reused by a new
    device even though it's about to be deleted.  The cure is to change
    the state while still holding the host lock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index c992ecf4e372..a77468cd5a33 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -492,19 +492,20 @@ void scsi_target_reap(struct scsi_target *starget)
 	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);
 	unsigned long flags;
 	enum scsi_target_state state;
-	int empty;
+	int empty = 0;
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	state = starget-&gt;state;
-	empty = --starget-&gt;reap_ref == 0 &amp;&amp;
-		list_empty(&amp;starget-&gt;devices) ? 1 : 0;
+	if (--starget-&gt;reap_ref == 0 &amp;&amp; list_empty(&amp;starget-&gt;devices)) {
+		empty = 1;
+		starget-&gt;state = STARGET_DEL;
+	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 
 	if (!empty)
 		return;
 
 	BUG_ON(state == STARGET_DEL);
-	starget-&gt;state = STARGET_DEL;
 	if (state == STARGET_CREATED)
 		scsi_target_destroy(starget);
 	else</pre>
    <div class="pagination">
        <a href='2_64.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><span>[65]</span><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_66.html'>Next&gt;&gt;</a>
    <div>
</body>

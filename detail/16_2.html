<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by California Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by California Institute of Technology</h1>
    <div class="pagination">
        <a href='16.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><span>[2]</span><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8456a9196f7696421eecffdbab5d785f852d95e8
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Wed Jul 18 15:33:13 2012 -0700

    can: janz-ican3: remove dead code
    
    The code which used this variable was removed during review, before the
    driver was added to mainline Linux. It is now dead code, and can be
    removed.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index e7d1532d5f1b..f41623d003e1 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -235,7 +235,6 @@ struct ican3_dev {
 
 	/* fast host interface */
 	unsigned int fastrx_start;
-	unsigned int fastrx_int;
 	unsigned int fastrx_num;
 	unsigned int fasttx_start;
 	unsigned int fasttx_num;
@@ -454,7 +453,6 @@ static void __devinit ican3_init_fast_host_interface(struct ican3_dev *mod)
 	/* save the start recv page */
 	mod-&gt;fastrx_start = mod-&gt;free_page;
 	mod-&gt;fastrx_num = 0;
-	mod-&gt;fastrx_int = 0;
 
 	/* build a single fast tohost queue descriptor */
 	memset(&amp;desc, 0, sizeof(desc));</pre><hr><pre>commit 30ec5a2cb17d78482de0cf9e38721410d48c086d
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Jan 6 11:29:19 2012 -0800

    mtd: cfi: AMD/Fujitsu compatibles: add panic write support
    
    This allows the mtdoops driver to work on flash chips using the
    AMD/Fujitsu compatible command set.
    
    As the code comments note, the locks used throughout the normal code
    paths in the driver are ignored, so that the chance of writing out the
    kernel's last messages are maximized.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Artem Bityutskiy &lt;Artem.Bityutskiy@linux.intel.com&gt;
    Signed-off-by: David Woodhouse &lt;David.Woodhouse@intel.com&gt;

diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 8d70895a58d6..e2d94bb1d7c8 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -59,6 +59,9 @@ static void cfi_amdstd_resume (struct mtd_info *);
 static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
 static int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf);
+
 static void cfi_amdstd_destroy(struct mtd_info *);
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
@@ -443,6 +446,7 @@ struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 	pr_debug("MTD %s(): write buffer size %d\n", __func__,
 			mtd-&gt;writebufsize);
 
+	mtd-&gt;panic_write = cfi_amdstd_panic_write;
 	mtd-&gt;reboot_notifier.notifier_call = cfi_amdstd_reboot;
 
 	if (cfi-&gt;cfi_mode==CFI_MODE_CFI){
@@ -1562,6 +1566,242 @@ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 	return 0;
 }
 
+/*
+ * Wait for the flash chip to become ready to write data
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ */
+static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
+				 unsigned long adr)
+{
+	struct cfi_private *cfi = map-&gt;fldrv_priv;
+	int retries = 10;
+	int i;
+
+	/*
+	 * If the driver thinks the chip is idle, and no toggle bits
+	 * are changing, then the chip is actually idle for sure.
+	 */
+	if (chip-&gt;state == FL_READY &amp;&amp; chip_ready(map, adr))
+		return 0;
+
+	/*
+	 * Try several times to reset the chip and then wait for it
+	 * to become idle. The upper limit of a few milliseconds of
+	 * delay isn't a big problem: the kernel is dying anyway. It
+	 * is more important to save the messages.
+	 */
+	while (retries &gt; 0) {
+		const unsigned long timeo = (HZ / 1000) + 1;
+
+		/* send the reset command */
+		map_write(map, CMD(0xF0), chip-&gt;start);
+
+		/* wait for the chip to become ready */
+		for (i = 0; i &lt; jiffies_to_usecs(timeo); i++) {
+			if (chip_ready(map, adr))
+				return 0;
+
+			udelay(1);
+		}
+	}
+
+	/* the chip never became ready */
+	return -EBUSY;
+}
+
+/*
+ * Write out one word of data to a single flash chip during a kernel panic
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ *
+ * The implementation of this routine is intentionally similar to
+ * do_write_oneword(), in order to ease code maintenance.
+ */
+static int do_panic_write_oneword(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, map_word datum)
+{
+	const unsigned long uWriteTimeout = (HZ / 1000) + 1;
+	struct cfi_private *cfi = map-&gt;fldrv_priv;
+	int retry_cnt = 0;
+	map_word oldd;
+	int ret = 0;
+	int i;
+
+	adr += chip-&gt;start;
+
+	ret = cfi_amdstd_panic_wait(map, chip, adr);
+	if (ret)
+		return ret;
+
+	pr_debug("MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)\n",
+			__func__, adr, datum.x[0]);
+
+	/*
+	 * Check for a NOP for the case when the datum to write is already
+	 * present - it saves time and works around buggy chips that corrupt
+	 * data at other locations when 0xff is written to a location that
+	 * already contains 0xff.
+	 */
+	oldd = map_read(map, adr);
+	if (map_word_equal(map, oldd, datum)) {
+		pr_debug("MTD %s(): NOP\n", __func__);
+		goto op_done;
+	}
+
+	ENABLE_VPP(map);
+
+retry:
+	cfi_send_gen_cmd(0xAA, cfi-&gt;addr_unlock1, chip-&gt;start, map, cfi, cfi-&gt;device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi-&gt;addr_unlock2, chip-&gt;start, map, cfi, cfi-&gt;device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi-&gt;addr_unlock1, chip-&gt;start, map, cfi, cfi-&gt;device_type, NULL);
+	map_write(map, datum, adr);
+
+	for (i = 0; i &lt; jiffies_to_usecs(uWriteTimeout); i++) {
+		if (chip_ready(map, adr))
+			break;
+
+		udelay(1);
+	}
+
+	if (!chip_good(map, adr, datum)) {
+		/* reset on all failures. */
+		map_write(map, CMD(0xF0), chip-&gt;start);
+		/* FIXME - should have reset delay before continuing */
+
+		if (++retry_cnt &lt;= MAX_WORD_RETRIES)
+			goto retry;
+
+		ret = -EIO;
+	}
+
+op_done:
+	DISABLE_VPP(map);
+	return ret;
+}
+
+/*
+ * Write out some data during a kernel panic
+ *
+ * This is used by the mtdoops driver to save the dying messages from a
+ * kernel which has panic'd.
+ *
+ * This routine ignores all of the locking used throughout the rest of the
+ * driver, in order to ensure that the data gets written out no matter what
+ * state this driver (and the flash chip itself) was in when the kernel crashed.
+ *
+ * The implementation of this routine is intentionally similar to
+ * cfi_amdstd_write_words(), in order to ease code maintenance.
+ */
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd-&gt;priv;
+	struct cfi_private *cfi = map-&gt;fldrv_priv;
+	unsigned long ofs, chipstart;
+	int ret = 0;
+	int chipnum;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to &gt;&gt; cfi-&gt;chipshift;
+	ofs = to - (chipnum &lt;&lt; cfi-&gt;chipshift);
+	chipstart = cfi-&gt;chips[chipnum].start;
+
+	/* If it's not bus aligned, do the first byte write */
+	if (ofs &amp; (map_bankwidth(map) - 1)) {
+		unsigned long bus_ofs = ofs &amp; ~(map_bankwidth(map) - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &amp;cfi-&gt;chips[chipnum], bus_ofs);
+		if (ret)
+			return ret;
+
+		/* Load 'tmp_buf' with old contents of flash */
+		tmp_buf = map_read(map, bus_ofs + chipstart);
+
+		/* Number of bytes to copy from buffer */
+		n = min_t(int, len, map_bankwidth(map) - i);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);
+
+		ret = do_panic_write_oneword(map, &amp;cfi-&gt;chips[chipnum],
+					     bus_ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+		len -= n;
+
+		if (ofs &gt;&gt; cfi-&gt;chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi-&gt;numchips)
+				return 0;
+		}
+	}
+
+	/* We are now aligned, write as much as possible */
+	while (len &gt;= map_bankwidth(map)) {
+		map_word datum;
+
+		datum = map_word_load(map, buf);
+
+		ret = do_panic_write_oneword(map, &amp;cfi-&gt;chips[chipnum],
+					     ofs, datum);
+		if (ret)
+			return ret;
+
+		ofs += map_bankwidth(map);
+		buf += map_bankwidth(map);
+		(*retlen) += map_bankwidth(map);
+		len -= map_bankwidth(map);
+
+		if (ofs &gt;&gt; cfi-&gt;chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi-&gt;numchips)
+				return 0;
+
+			chipstart = cfi-&gt;chips[chipnum].start;
+		}
+	}
+
+	/* Write the trailing bytes if any */
+	if (len &amp; (map_bankwidth(map) - 1)) {
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &amp;cfi-&gt;chips[chipnum], ofs);
+		if (ret)
+			return ret;
+
+		tmp_buf = map_read(map, ofs + chipstart);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);
+
+		ret = do_panic_write_oneword(map, &amp;cfi-&gt;chips[chipnum],
+					     ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		(*retlen) += len;
+	}
+
+	return 0;
+}
+
 
 /*
  * Handle devices with one erase region, that only implement</pre><hr><pre>commit 6c15d7afbb2f9e2d3114b513306dae736b56f535
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Jan 26 11:00:14 2012 +0000

    carma-fpga: fix race between data dumping and DMA callback
    
    When the system is under heavy load, we occasionally saw a problem where
    the system would get a legitimate interrupt when they should be
    disabled.
    
    This was caused by the data_dma_cb() DMA callback unconditionally
    re-enabling FPGA interrupts even when data dumping is disabled. When
    data dumping was re-enabled, the irq handler would fire while a DMA was
    in progress. The "BUG_ON(priv-&gt;inflight != NULL);" during the second
    invocation of the DMA callback caused the system to crash.
    
    To fix the issue, the priv-&gt;enabled boolean is moved under the
    protection of the priv-&gt;lock spinlock. The DMA callback checks the
    boolean to know whether to re-enable FPGA interrupts before it returns.
    
    Now that it is fixed, the driver keeps FPGA interrupts disabled when it
    expects that they are disabled, fixing the bug.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;

diff --git a/drivers/misc/carma/carma-fpga.c b/drivers/misc/carma/carma-fpga.c
index 4fd896deda0d..0cfc5bf13fa5 100644
--- a/drivers/misc/carma/carma-fpga.c
+++ b/drivers/misc/carma/carma-fpga.c
@@ -560,6 +560,9 @@ static void data_enable_interrupts(struct fpga_device *priv)
 
 	/* flush the writes */
 	fpga_read_reg(priv, 0, MMAP_REG_STATUS);
+	fpga_read_reg(priv, 1, MMAP_REG_STATUS);
+	fpga_read_reg(priv, 2, MMAP_REG_STATUS);
+	fpga_read_reg(priv, 3, MMAP_REG_STATUS);
 
 	/* switch back to the external interrupt source */
 	iowrite32be(0x3F, priv-&gt;regs + SYS_IRQ_SOURCE_CTL);
@@ -591,8 +594,12 @@ static void data_dma_cb(void *data)
 	list_move_tail(&amp;priv-&gt;inflight-&gt;entry, &amp;priv-&gt;used);
 	priv-&gt;inflight = NULL;
 
-	/* clear the FPGA status and re-enable interrupts */
-	data_enable_interrupts(priv);
+	/*
+	 * If data dumping is still enabled, then clear the FPGA
+	 * status registers and re-enable FPGA interrupts
+	 */
+	if (priv-&gt;enabled)
+		data_enable_interrupts(priv);
 
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
 
@@ -708,6 +715,15 @@ static irqreturn_t data_irq(int irq, void *dev_id)
 
 	spin_lock(&amp;priv-&gt;lock);
 
+	/*
+	 * This is an error case that should never happen.
+	 *
+	 * If this driver has a bug and manages to re-enable interrupts while
+	 * a DMA is in progress, then we will hit this statement and should
+	 * start paying attention immediately.
+	 */
+	BUG_ON(priv-&gt;inflight != NULL);
+
 	/* hide the interrupt by switching the IRQ driver to GPIO */
 	data_disable_interrupts(priv);
 
@@ -762,11 +778,15 @@ static irqreturn_t data_irq(int irq, void *dev_id)
  */
 static int data_device_enable(struct fpga_device *priv)
 {
+	bool enabled;
 	u32 val;
 	int ret;
 
 	/* multiple enables are safe: they do nothing */
-	if (priv-&gt;enabled)
+	spin_lock_irq(&amp;priv-&gt;lock);
+	enabled = priv-&gt;enabled;
+	spin_unlock_irq(&amp;priv-&gt;lock);
+	if (enabled)
 		return 0;
 
 	/* check that the FPGAs are programmed */
@@ -797,6 +817,9 @@ static int data_device_enable(struct fpga_device *priv)
 		goto out_error;
 	}
 
+	/* prevent the FPGAs from generating interrupts */
+	data_disable_interrupts(priv);
+
 	/* hookup the irq handler */
 	ret = request_irq(priv-&gt;irq, data_irq, IRQF_SHARED, drv_name, priv);
 	if (ret) {
@@ -804,11 +827,13 @@ static int data_device_enable(struct fpga_device *priv)
 		goto out_error;
 	}
 
-	/* switch to the external FPGA IRQ line */
-	data_enable_interrupts(priv);
-
-	/* success, we're enabled */
+	/* allow the DMA callback to re-enable FPGA interrupts */
+	spin_lock_irq(&amp;priv-&gt;lock);
 	priv-&gt;enabled = true;
+	spin_unlock_irq(&amp;priv-&gt;lock);
+
+	/* allow the FPGAs to generate interrupts */
+	data_enable_interrupts(priv);
 	return 0;
 
 out_error:
@@ -834,41 +859,40 @@ static int data_device_enable(struct fpga_device *priv)
  */
 static int data_device_disable(struct fpga_device *priv)
 {
-	int ret;
+	spin_lock_irq(&amp;priv-&gt;lock);
 
 	/* allow multiple disable */
-	if (!priv-&gt;enabled)
+	if (!priv-&gt;enabled) {
+		spin_unlock_irq(&amp;priv-&gt;lock);
 		return 0;
+	}
+
+	/*
+	 * Mark the device disabled
+	 *
+	 * This stops DMA callbacks from re-enabling interrupts
+	 */
+	priv-&gt;enabled = false;
 
-	/* switch to the internal GPIO IRQ line */
+	/* prevent the FPGAs from generating interrupts */
 	data_disable_interrupts(priv);
 
+	/* wait until all ongoing DMA has finished */
+	while (priv-&gt;inflight != NULL) {
+		spin_unlock_irq(&amp;priv-&gt;lock);
+		wait_event(priv-&gt;wait, priv-&gt;inflight == NULL);
+		spin_lock_irq(&amp;priv-&gt;lock);
+	}
+
+	spin_unlock_irq(&amp;priv-&gt;lock);
+
 	/* unhook the irq handler */
 	free_irq(priv-&gt;irq, priv);
 
-	/*
-	 * wait for all outstanding DMA to complete
-	 *
-	 * Device interrupts are disabled, therefore another buffer cannot
-	 * be marked inflight.
-	 */
-	ret = wait_event_interruptible(priv-&gt;wait, priv-&gt;inflight == NULL);
-	if (ret)
-		return ret;
-
 	/* free the correlation table */
 	sg_free_table(&amp;priv-&gt;corl_table);
 	priv-&gt;corl_nents = 0;
 
-	/*
-	 * We are taking the spinlock not to protect priv-&gt;enabled, but instead
-	 * to make sure that there are no readers in the process of altering
-	 * the free or used lists while we are setting this flag.
-	 */
-	spin_lock_irq(&amp;priv-&gt;lock);
-	priv-&gt;enabled = false;
-	spin_unlock_irq(&amp;priv-&gt;lock);
-
 	/* free all buffers: the free and used lists are not being changed */
 	data_free_buffers(priv);
 	return 0;
@@ -896,15 +920,6 @@ static unsigned int list_num_entries(struct list_head *list)
 static int data_debug_show(struct seq_file *f, void *offset)
 {
 	struct fpga_device *priv = f-&gt;private;
-	int ret;
-
-	/*
-	 * Lock the mutex first, so that we get an accurate value for enable
-	 * Lock the spinlock next, to get accurate list counts
-	 */
-	ret = mutex_lock_interruptible(&amp;priv-&gt;mutex);
-	if (ret)
-		return ret;
 
 	spin_lock_irq(&amp;priv-&gt;lock);
 
@@ -917,7 +932,6 @@ static int data_debug_show(struct seq_file *f, void *offset)
 	seq_printf(f, "num_dropped: %d\n", priv-&gt;num_dropped);
 
 	spin_unlock_irq(&amp;priv-&gt;lock);
-	mutex_unlock(&amp;priv-&gt;mutex);
 	return 0;
 }
 
@@ -970,7 +984,13 @@ static ssize_t data_en_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
 	struct fpga_device *priv = dev_get_drvdata(dev);
-	return snprintf(buf, PAGE_SIZE, "%u\n", priv-&gt;enabled);
+	int ret;
+
+	spin_lock_irq(&amp;priv-&gt;lock);
+	ret = snprintf(buf, PAGE_SIZE, "%u\n", priv-&gt;enabled);
+	spin_unlock_irq(&amp;priv-&gt;lock);
+
+	return ret;
 }
 
 static ssize_t data_en_set(struct device *dev, struct device_attribute *attr,
@@ -986,6 +1006,7 @@ static ssize_t data_en_set(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
+	/* protect against concurrent enable/disable */
 	ret = mutex_lock_interruptible(&amp;priv-&gt;mutex);
 	if (ret)
 		return ret;</pre><hr><pre>commit 75ff85a81680e5779383aa6210a4f89ed76e40ec
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Jan 26 10:59:54 2012 +0000

    carma-fpga: fix lockdep warning
    
    Lockdep occasionally complains with the message:
    INFO: HARDIRQ-safe -&gt; HARDIRQ-unsafe lock order detected
    
    This is caused by calling videobuf_dma_unmap() under spin_lock_irq(). To
    fix the warning, we drop the lock before unmapping and freeing the
    buffer.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;

diff --git a/drivers/misc/carma/carma-fpga.c b/drivers/misc/carma/carma-fpga.c
index 14e974b2a781..4fd896deda0d 100644
--- a/drivers/misc/carma/carma-fpga.c
+++ b/drivers/misc/carma/carma-fpga.c
@@ -1079,6 +1079,7 @@ static ssize_t data_read(struct file *filp, char __user *ubuf, size_t count,
 	struct fpga_reader *reader = filp-&gt;private_data;
 	struct fpga_device *priv = reader-&gt;priv;
 	struct list_head *used = &amp;priv-&gt;used;
+	bool drop_buffer = false;
 	struct data_buf *dbuf;
 	size_t avail;
 	void *data;
@@ -1166,10 +1167,12 @@ static ssize_t data_read(struct file *filp, char __user *ubuf, size_t count,
 	 * One of two things has happened, the device is disabled, or the
 	 * device has been reconfigured underneath us. In either case, we
 	 * should just throw away the buffer.
+	 *
+	 * Lockdep complains if this is done under the spinlock, so we
+	 * handle it during the unlock path.
 	 */
 	if (!priv-&gt;enabled || dbuf-&gt;size != priv-&gt;bufsize) {
-		videobuf_dma_unmap(priv-&gt;dev, &amp;dbuf-&gt;vb);
-		data_free_buffer(dbuf);
+		drop_buffer = true;
 		goto out_unlock;
 	}
 
@@ -1178,6 +1181,12 @@ static ssize_t data_read(struct file *filp, char __user *ubuf, size_t count,
 
 out_unlock:
 	spin_unlock_irq(&amp;priv-&gt;lock);
+
+	if (drop_buffer) {
+		videobuf_dma_unmap(priv-&gt;dev, &amp;dbuf-&gt;vb);
+		data_free_buffer(dbuf);
+	}
+
 	return count;
 }
 </pre><hr><pre>commit 40c8cefaaf12734327db7199a56e60058d98e7b6
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Jan 6 12:34:07 2012 +0000

    powerpc: Fix kernel log of oops/panic instruction dump
    
    A kernel oops/panic prints an instruction dump showing several
    instructions before and after the instruction which caused the
    oops/panic.
    
    The code intended that the faulting instruction be enclosed in angle
    brackets, however a bug caused the faulting instruction to be
    interpreted by printk() as the message log level.
    
    To fix this, the KERN_CONT log level is added before the actual text of
    the printed message.
    
    === Before the patch ===
    
    [ 1081.587266] Instruction dump:
    [ 1081.590236] 7c000110 7c0000f8 5400077c 552907f6 7d290378 992b0003 4e800020 38000001
    [ 1081.598034] 3d20c03a 9009a114 7c0004ac 39200000
    [ 1081.602500]  4e800020 3803ffd0 2b800009
    
    &lt;4&gt;[ 1081.587266] Instruction dump:
    &lt;4&gt;[ 1081.590236] 7c000110 7c0000f8 5400077c 552907f6 7d290378 992b0003 4e800020 38000001
    &lt;4&gt;[ 1081.598034] 3d20c03a 9009a114 7c0004ac 39200000
    &lt;98090000&gt;[ 1081.602500]  4e800020 3803ffd0 2b800009
    
    === After the patch ===
    
    [   51.385216] Instruction dump:
    [   51.388186] 7c000110 7c0000f8 5400077c 552907f6 7d290378 992b0003 4e800020 38000001
    [   51.395986] 3d20c03a 9009a114 7c0004ac 39200000 &lt;98090000&gt; 4e800020 3803ffd0 2b800009
    
    &lt;4&gt;[   51.385216] Instruction dump:
    &lt;4&gt;[   51.388186] 7c000110 7c0000f8 5400077c 552907f6 7d290378 992b0003 4e800020 38000001
    &lt;4&gt;[   51.395986] 3d20c03a 9009a114 7c0004ac 39200000 &lt;98090000&gt; 4e800020 3803ffd0 2b800009
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;

diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c
index ebe5766781aa..d817ab018486 100644
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@ -566,12 +566,12 @@ static void show_instructions(struct pt_regs *regs)
 		 */
 		if (!__kernel_text_address(pc) ||
 		     __get_user(instr, (unsigned int __user *)pc)) {
-			printk("XXXXXXXX ");
+			printk(KERN_CONT "XXXXXXXX ");
 		} else {
 			if (regs-&gt;nip == pc)
-				printk("&lt;%08x&gt; ", instr);
+				printk(KERN_CONT "&lt;%08x&gt; ", instr);
 			else
-				printk("%08x ", instr);
+				printk(KERN_CONT "%08x ", instr);
 		}
 
 		pc += sizeof(int);</pre><hr><pre>commit 0e1d715b5b982ee0099f3fbf6ad47dc8bda518a6
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Feb 11 13:34:30 2011 +0000

    misc: Add CARMA DATA-FPGA Programmer support
    
    This adds support for programming the data processing FPGAs on the OVRO
    CARMA board. These FPGAs have a special programming sequence that
    requires that we program the Freescale DMA engine, which is only
    available inside the kernel.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;

diff --git a/drivers/misc/carma/Kconfig b/drivers/misc/carma/Kconfig
index 4be183f7e6f1..c90370ed712b 100644
--- a/drivers/misc/carma/Kconfig
+++ b/drivers/misc/carma/Kconfig
@@ -7,3 +7,11 @@ config CARMA_FPGA
 	  Say Y here to include support for communicating with the data
 	  processing FPGAs on the OVRO CARMA board.
 
+config CARMA_FPGA_PROGRAM
+	tristate "CARMA DATA-FPGA Programmer"
+	depends on FSL_SOC &amp;&amp; PPC_83xx &amp;&amp; MEDIA_SUPPORT &amp;&amp; HAS_DMA &amp;&amp; FSL_DMA
+	select VIDEOBUF_DMA_SG
+	default n
+	help
+	  Say Y here to include support for programming the data processing
+	  FPGAs on the OVRO CARMA board.
diff --git a/drivers/misc/carma/Makefile b/drivers/misc/carma/Makefile
index 0b69fa787953..ff36ac2ce534 100644
--- a/drivers/misc/carma/Makefile
+++ b/drivers/misc/carma/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_CARMA_FPGA)		+= carma-fpga.o
+obj-$(CONFIG_CARMA_FPGA_PROGRAM)	+= carma-fpga-program.o
diff --git a/drivers/misc/carma/carma-fpga-program.c b/drivers/misc/carma/carma-fpga-program.c
new file mode 100644
index 000000000000..7ce6065dc20e
--- /dev/null
+++ b/drivers/misc/carma/carma-fpga-program.c
@@ -0,0 +1,1141 @@
+/*
+ * CARMA Board DATA-FPGA Programmer
+ *
+ * Copyright (c) 2009-2011 Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include &lt;linux/dma-mapping.h&gt;
+#include &lt;linux/of_platform.h&gt;
+#include &lt;linux/completion.h&gt;
+#include &lt;linux/miscdevice.h&gt;
+#include &lt;linux/dmaengine.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/highmem.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/leds.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/kref.h&gt;
+#include &lt;linux/fs.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &lt;media/videobuf-dma-sg.h&gt;
+
+/* MPC8349EMDS specific get_immrbase() */
+#include &lt;sysdev/fsl_soc.h&gt;
+
+static const char drv_name[] = "carma-fpga-program";
+
+/*
+ * Firmware images are always this exact size
+ *
+ * 12849552 bytes for a CARMA Digitizer Board (EP2S90 FPGAs)
+ * 18662880 bytes for a CARMA Correlator Board (EP2S130 FPGAs)
+ */
+#define FW_SIZE_EP2S90		12849552
+#define FW_SIZE_EP2S130		18662880
+
+struct fpga_dev {
+	struct miscdevice miscdev;
+
+	/* Reference count */
+	struct kref ref;
+
+	/* Device Registers */
+	struct device *dev;
+	void __iomem *regs;
+	void __iomem *immr;
+
+	/* Freescale DMA Device */
+	struct dma_chan *chan;
+
+	/* Interrupts */
+	int irq, status;
+	struct completion completion;
+
+	/* FPGA Bitfile */
+	struct mutex lock;
+
+	struct videobuf_dmabuf vb;
+	bool vb_allocated;
+
+	/* max size and written bytes */
+	size_t fw_size;
+	size_t bytes;
+};
+
+/*
+ * FPGA Bitfile Helpers
+ */
+
+/**
+ * fpga_drop_firmware_data() - drop the bitfile image from memory
+ * @priv: the driver's private data structure
+ *
+ * LOCKING: must hold priv-&gt;lock
+ */
+static void fpga_drop_firmware_data(struct fpga_dev *priv)
+{
+	videobuf_dma_free(&amp;priv-&gt;vb);
+	priv-&gt;vb_allocated = false;
+	priv-&gt;bytes = 0;
+}
+
+/*
+ * Private Data Reference Count
+ */
+
+static void fpga_dev_remove(struct kref *ref)
+{
+	struct fpga_dev *priv = container_of(ref, struct fpga_dev, ref);
+
+	/* free any firmware image that was not programmed */
+	fpga_drop_firmware_data(priv);
+
+	mutex_destroy(&amp;priv-&gt;lock);
+	kfree(priv);
+}
+
+/*
+ * LED Trigger (could be a seperate module)
+ */
+
+/*
+ * NOTE: this whole thing does have the problem that whenever the led's are
+ * NOTE: first set to use the fpga trigger, they could be in the wrong state
+ */
+
+DEFINE_LED_TRIGGER(ledtrig_fpga);
+
+static void ledtrig_fpga_programmed(bool enabled)
+{
+	if (enabled)
+		led_trigger_event(ledtrig_fpga, LED_FULL);
+	else
+		led_trigger_event(ledtrig_fpga, LED_OFF);
+}
+
+/*
+ * FPGA Register Helpers
+ */
+
+/* Register Definitions */
+#define FPGA_CONFIG_CONTROL		0x40
+#define FPGA_CONFIG_STATUS		0x44
+#define FPGA_CONFIG_FIFO_SIZE		0x48
+#define FPGA_CONFIG_FIFO_USED		0x4C
+#define FPGA_CONFIG_TOTAL_BYTE_COUNT	0x50
+#define FPGA_CONFIG_CUR_BYTE_COUNT	0x54
+
+#define FPGA_FIFO_ADDRESS		0x3000
+
+static int fpga_fifo_size(void __iomem *regs)
+{
+	return ioread32be(regs + FPGA_CONFIG_FIFO_SIZE);
+}
+
+#define CFG_STATUS_ERR_MASK	0xfffe
+
+static int fpga_config_error(void __iomem *regs)
+{
+	return ioread32be(regs + FPGA_CONFIG_STATUS) &amp; CFG_STATUS_ERR_MASK;
+}
+
+static int fpga_fifo_empty(void __iomem *regs)
+{
+	return ioread32be(regs + FPGA_CONFIG_FIFO_USED) == 0;
+}
+
+static void fpga_fifo_write(void __iomem *regs, u32 val)
+{
+	iowrite32be(val, regs + FPGA_FIFO_ADDRESS);
+}
+
+static void fpga_set_byte_count(void __iomem *regs, u32 count)
+{
+	iowrite32be(count, regs + FPGA_CONFIG_TOTAL_BYTE_COUNT);
+}
+
+#define CFG_CTL_ENABLE	(1 &lt;&lt; 0)
+#define CFG_CTL_RESET	(1 &lt;&lt; 1)
+#define CFG_CTL_DMA	(1 &lt;&lt; 2)
+
+static void fpga_programmer_enable(struct fpga_dev *priv, bool dma)
+{
+	u32 val;
+
+	val = (dma) ? (CFG_CTL_ENABLE | CFG_CTL_DMA) : CFG_CTL_ENABLE;
+	iowrite32be(val, priv-&gt;regs + FPGA_CONFIG_CONTROL);
+}
+
+static void fpga_programmer_disable(struct fpga_dev *priv)
+{
+	iowrite32be(0x0, priv-&gt;regs + FPGA_CONFIG_CONTROL);
+}
+
+static void fpga_dump_registers(struct fpga_dev *priv)
+{
+	u32 control, status, size, used, total, curr;
+
+	/* good status: do nothing */
+	if (priv-&gt;status == 0)
+		return;
+
+	/* Dump all status registers */
+	control = ioread32be(priv-&gt;regs + FPGA_CONFIG_CONTROL);
+	status = ioread32be(priv-&gt;regs + FPGA_CONFIG_STATUS);
+	size = ioread32be(priv-&gt;regs + FPGA_CONFIG_FIFO_SIZE);
+	used = ioread32be(priv-&gt;regs + FPGA_CONFIG_FIFO_USED);
+	total = ioread32be(priv-&gt;regs + FPGA_CONFIG_TOTAL_BYTE_COUNT);
+	curr = ioread32be(priv-&gt;regs + FPGA_CONFIG_CUR_BYTE_COUNT);
+
+	dev_err(priv-&gt;dev, "Configuration failed, dumping status registers\n");
+	dev_err(priv-&gt;dev, "Control:    0x%.8x\n", control);
+	dev_err(priv-&gt;dev, "Status:     0x%.8x\n", status);
+	dev_err(priv-&gt;dev, "FIFO Size:  0x%.8x\n", size);
+	dev_err(priv-&gt;dev, "FIFO Used:  0x%.8x\n", used);
+	dev_err(priv-&gt;dev, "FIFO Total: 0x%.8x\n", total);
+	dev_err(priv-&gt;dev, "FIFO Curr:  0x%.8x\n", curr);
+}
+
+/*
+ * FPGA Power Supply Code
+ */
+
+#define CTL_PWR_CONTROL		0x2006
+#define CTL_PWR_STATUS		0x200A
+#define CTL_PWR_FAIL		0x200B
+
+#define PWR_CONTROL_ENABLE	0x01
+
+#define PWR_STATUS_ERROR_MASK	0x10
+#define PWR_STATUS_GOOD		0x0f
+
+/*
+ * Determine if the FPGA power is good for all supplies
+ */
+static bool fpga_power_good(struct fpga_dev *priv)
+{
+	u8 val;
+
+	val = ioread8(priv-&gt;regs + CTL_PWR_STATUS);
+	if (val &amp; PWR_STATUS_ERROR_MASK)
+		return false;
+
+	return val == PWR_STATUS_GOOD;
+}
+
+/*
+ * Disable the FPGA power supplies
+ */
+static void fpga_disable_power_supplies(struct fpga_dev *priv)
+{
+	unsigned long start;
+	u8 val;
+
+	iowrite8(0x0, priv-&gt;regs + CTL_PWR_CONTROL);
+
+	/*
+	 * Wait 500ms for the power rails to discharge
+	 *
+	 * Without this delay, the CTL-CPLD state machine can get into a
+	 * state where it is waiting for the power-goods to assert, but they
+	 * never do. This only happens when enabling and disabling the
+	 * power sequencer very rapidly.
+	 *
+	 * The loop below will also wait for the power goods to de-assert,
+	 * but testing has shown that they are always disabled by the time
+	 * the sleep completes. However, omitting the sleep and only waiting
+	 * for the power-goods to de-assert was not sufficient to ensure
+	 * that the power sequencer would not wedge itself.
+	 */
+	msleep(500);
+
+	start = jiffies;
+	while (time_before(jiffies, start + HZ)) {
+		val = ioread8(priv-&gt;regs + CTL_PWR_STATUS);
+		if (!(val &amp; PWR_STATUS_GOOD))
+			break;
+
+		usleep_range(5000, 10000);
+	}
+
+	val = ioread8(priv-&gt;regs + CTL_PWR_STATUS);
+	if (val &amp; PWR_STATUS_GOOD) {
+		dev_err(priv-&gt;dev, "power disable failed: "
+				   "power goods: status 0x%.2x\n", val);
+	}
+
+	if (val &amp; PWR_STATUS_ERROR_MASK) {
+		dev_err(priv-&gt;dev, "power disable failed: "
+				   "alarm bit set: status 0x%.2x\n", val);
+	}
+}
+
+/**
+ * fpga_enable_power_supplies() - enable the DATA-FPGA power supplies
+ * @priv: the driver's private data structure
+ *
+ * Enable the DATA-FPGA power supplies, waiting up to 1 second for
+ * them to enable successfully.
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int fpga_enable_power_supplies(struct fpga_dev *priv)
+{
+	unsigned long start = jiffies;
+
+	if (fpga_power_good(priv)) {
+		dev_dbg(priv-&gt;dev, "power was already good\n");
+		return 0;
+	}
+
+	iowrite8(PWR_CONTROL_ENABLE, priv-&gt;regs + CTL_PWR_CONTROL);
+	while (time_before(jiffies, start + HZ)) {
+		if (fpga_power_good(priv))
+			return 0;
+
+		usleep_range(5000, 10000);
+	}
+
+	return fpga_power_good(priv) ? 0 : -ETIMEDOUT;
+}
+
+/*
+ * Determine if the FPGA power supplies are all enabled
+ */
+static bool fpga_power_enabled(struct fpga_dev *priv)
+{
+	u8 val;
+
+	val = ioread8(priv-&gt;regs + CTL_PWR_CONTROL);
+	if (val &amp; PWR_CONTROL_ENABLE)
+		return true;
+
+	return false;
+}
+
+/*
+ * Determine if the FPGA's are programmed and running correctly
+ */
+static bool fpga_running(struct fpga_dev *priv)
+{
+	if (!fpga_power_good(priv))
+		return false;
+
+	/* Check the config done bit */
+	return ioread32be(priv-&gt;regs + FPGA_CONFIG_STATUS) &amp; (1 &lt;&lt; 18);
+}
+
+/*
+ * FPGA Programming Code
+ */
+
+/**
+ * fpga_program_block() - put a block of data into the programmer's FIFO
+ * @priv: the driver's private data structure
+ * @buf: the data to program
+ * @count: the length of data to program (must be a multiple of 4 bytes)
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int fpga_program_block(struct fpga_dev *priv, void *buf, size_t count)
+{
+	u32 *data = buf;
+	int size = fpga_fifo_size(priv-&gt;regs);
+	int i, len;
+	unsigned long timeout;
+
+	/* enforce correct data length for the FIFO */
+	BUG_ON(count % 4 != 0);
+
+	while (count &gt; 0) {
+
+		/* Get the size of the block to write (maximum is FIFO_SIZE) */
+		len = min_t(size_t, count, size);
+		timeout = jiffies + HZ / 4;
+
+		/* Write the block */
+		for (i = 0; i &lt; len / 4; i++)
+			fpga_fifo_write(priv-&gt;regs, data[i]);
+
+		/* Update the amounts left */
+		count -= len;
+		data += len / 4;
+
+		/* Wait for the fifo to empty */
+		while (true) {
+
+			if (fpga_fifo_empty(priv-&gt;regs)) {
+				break;
+			} else {
+				dev_dbg(priv-&gt;dev, "Fifo not empty\n");
+				cpu_relax();
+			}
+
+			if (fpga_config_error(priv-&gt;regs)) {
+				dev_err(priv-&gt;dev, "Error detected\n");
+				return -EIO;
+			}
+
+			if (time_after(jiffies, timeout)) {
+				dev_err(priv-&gt;dev, "Fifo drain timeout\n");
+				return -ETIMEDOUT;
+			}
+
+			usleep_range(5000, 10000);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * fpga_program_cpu() - program the DATA-FPGA's using the CPU
+ * @priv: the driver's private data structure
+ *
+ * This is useful when the DMA programming method fails. It is possible to
+ * wedge the Freescale DMA controller such that the DMA programming method
+ * always fails. This method has always succeeded.
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static noinline int fpga_program_cpu(struct fpga_dev *priv)
+{
+	int ret;
+
+	/* Disable the programmer */
+	fpga_programmer_disable(priv);
+
+	/* Set the total byte count */
+	fpga_set_byte_count(priv-&gt;regs, priv-&gt;bytes);
+	dev_dbg(priv-&gt;dev, "total byte count %u bytes\n", priv-&gt;bytes);
+
+	/* Enable the controller for programming */
+	fpga_programmer_enable(priv, false);
+	dev_dbg(priv-&gt;dev, "enabled the controller\n");
+
+	/* Write each chunk of the FPGA bitfile to FPGA programmer */
+	ret = fpga_program_block(priv, priv-&gt;vb.vaddr, priv-&gt;bytes);
+	if (ret)
+		goto out_disable_controller;
+
+	/* Wait for the interrupt handler to signal that programming finished */
+	ret = wait_for_completion_timeout(&amp;priv-&gt;completion, 2 * HZ);
+	if (!ret) {
+		dev_err(priv-&gt;dev, "Timed out waiting for completion\n");
+		ret = -ETIMEDOUT;
+		goto out_disable_controller;
+	}
+
+	/* Retrieve the status from the interrupt handler */
+	ret = priv-&gt;status;
+
+out_disable_controller:
+	fpga_programmer_disable(priv);
+	return ret;
+}
+
+#define FIFO_DMA_ADDRESS	0xf0003000
+#define FIFO_MAX_LEN		4096
+
+/**
+ * fpga_program_dma() - program the DATA-FPGA's using the DMA engine
+ * @priv: the driver's private data structure
+ *
+ * Program the DATA-FPGA's using the Freescale DMA engine. This requires that
+ * the engine is programmed such that the hardware DMA request lines can
+ * control the entire DMA transaction. The system controller FPGA then
+ * completely offloads the programming from the CPU.
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static noinline int fpga_program_dma(struct fpga_dev *priv)
+{
+	struct videobuf_dmabuf *vb = &amp;priv-&gt;vb;
+	struct dma_chan *chan = priv-&gt;chan;
+	struct dma_async_tx_descriptor *tx;
+	size_t num_pages, len, avail = 0;
+	struct dma_slave_config config;
+	struct scatterlist *sg;
+	struct sg_table table;
+	dma_cookie_t cookie;
+	int ret, i;
+
+	/* Disable the programmer */
+	fpga_programmer_disable(priv);
+
+	/* Allocate a scatterlist for the DMA destination */
+	num_pages = DIV_ROUND_UP(priv-&gt;bytes, FIFO_MAX_LEN);
+	ret = sg_alloc_table(&amp;table, num_pages, GFP_KERNEL);
+	if (ret) {
+		dev_err(priv-&gt;dev, "Unable to allocate dst scatterlist\n");
+		ret = -ENOMEM;
+		goto out_return;
+	}
+
+	/*
+	 * This is an ugly hack
+	 *
+	 * We fill in a scatterlist as if it were mapped for DMA. This is
+	 * necessary because there exists no better structure for this
+	 * inside the kernel code.
+	 *
+	 * As an added bonus, we can use the DMAEngine API for all of this,
+	 * rather than inventing another extremely similar API.
+	 */
+	avail = priv-&gt;bytes;
+	for_each_sg(table.sgl, sg, num_pages, i) {
+		len = min_t(size_t, avail, FIFO_MAX_LEN);
+		sg_dma_address(sg) = FIFO_DMA_ADDRESS;
+		sg_dma_len(sg) = len;
+
+		avail -= len;
+	}
+
+	/* Map the buffer for DMA */
+	ret = videobuf_dma_map(priv-&gt;dev, &amp;priv-&gt;vb);
+	if (ret) {
+		dev_err(priv-&gt;dev, "Unable to map buffer for DMA\n");
+		goto out_free_table;
+	}
+
+	/*
+	 * Configure the DMA channel to transfer FIFO_SIZE / 2 bytes per
+	 * transaction, and then put it under external control
+	 */
+	memset(&amp;config, 0, sizeof(config));
+	config.direction = DMA_TO_DEVICE;
+	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	config.dst_maxburst = fpga_fifo_size(priv-&gt;regs) / 2 / 4;
+	ret = chan-&gt;device-&gt;device_control(chan, DMA_SLAVE_CONFIG,
+					   (unsigned long)&amp;config);
+	if (ret) {
+		dev_err(priv-&gt;dev, "DMA slave configuration failed\n");
+		goto out_dma_unmap;
+	}
+
+	ret = chan-&gt;device-&gt;device_control(chan, FSLDMA_EXTERNAL_START, 1);
+	if (ret) {
+		dev_err(priv-&gt;dev, "DMA external control setup failed\n");
+		goto out_dma_unmap;
+	}
+
+	/* setup and submit the DMA transaction */
+	tx = chan-&gt;device-&gt;device_prep_dma_sg(chan,
+					      table.sgl, num_pages,
+					      vb-&gt;sglist, vb-&gt;sglen, 0);
+	if (!tx) {
+		dev_err(priv-&gt;dev, "Unable to prep DMA transaction\n");
+		ret = -ENOMEM;
+		goto out_dma_unmap;
+	}
+
+	cookie = tx-&gt;tx_submit(tx);
+	if (dma_submit_error(cookie)) {
+		dev_err(priv-&gt;dev, "Unable to submit DMA transaction\n");
+		ret = -ENOMEM;
+		goto out_dma_unmap;
+	}
+
+	dma_async_memcpy_issue_pending(chan);
+
+	/* Set the total byte count */
+	fpga_set_byte_count(priv-&gt;regs, priv-&gt;bytes);
+	dev_dbg(priv-&gt;dev, "total byte count %u bytes\n", priv-&gt;bytes);
+
+	/* Enable the controller for DMA programming */
+	fpga_programmer_enable(priv, true);
+	dev_dbg(priv-&gt;dev, "enabled the controller\n");
+
+	/* Wait for the interrupt handler to signal that programming finished */
+	ret = wait_for_completion_timeout(&amp;priv-&gt;completion, 2 * HZ);
+	if (!ret) {
+		dev_err(priv-&gt;dev, "Timed out waiting for completion\n");
+		ret = -ETIMEDOUT;
+		goto out_disable_controller;
+	}
+
+	/* Retrieve the status from the interrupt handler */
+	ret = priv-&gt;status;
+
+out_disable_controller:
+	fpga_programmer_disable(priv);
+out_dma_unmap:
+	videobuf_dma_unmap(priv-&gt;dev, vb);
+out_free_table:
+	sg_free_table(&amp;table);
+out_return:
+	return ret;
+}
+
+/*
+ * Interrupt Handling
+ */
+
+static irqreturn_t fpga_irq(int irq, void *dev_id)
+{
+	struct fpga_dev *priv = dev_id;
+
+	/* Save the status */
+	priv-&gt;status = fpga_config_error(priv-&gt;regs) ? -EIO : 0;
+	dev_dbg(priv-&gt;dev, "INTERRUPT status %d\n", priv-&gt;status);
+	fpga_dump_registers(priv);
+
+	/* Disabling the programmer clears the interrupt */
+	fpga_programmer_disable(priv);
+
+	/* Notify any waiters */
+	complete(&amp;priv-&gt;completion);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * SYSFS Helpers
+ */
+
+/**
+ * fpga_do_stop() - deconfigure (reset) the DATA-FPGA's
+ * @priv: the driver's private data structure
+ *
+ * LOCKING: must hold priv-&gt;lock
+ */
+static int fpga_do_stop(struct fpga_dev *priv)
+{
+	u32 val;
+
+	/* Set the led to unprogrammed */
+	ledtrig_fpga_programmed(false);
+
+	/* Pulse the config line to reset the FPGA's */
+	val = CFG_CTL_ENABLE | CFG_CTL_RESET;
+	iowrite32be(val, priv-&gt;regs + FPGA_CONFIG_CONTROL);
+	iowrite32be(0x0, priv-&gt;regs + FPGA_CONFIG_CONTROL);
+
+	return 0;
+}
+
+static noinline int fpga_do_program(struct fpga_dev *priv)
+{
+	int ret;
+
+	if (priv-&gt;bytes != priv-&gt;fw_size) {
+		dev_err(priv-&gt;dev, "Incorrect bitfile size: got %zu bytes, "
+				   "should be %zu bytes\n",
+				   priv-&gt;bytes, priv-&gt;fw_size);
+		return -EINVAL;
+	}
+
+	if (!fpga_power_enabled(priv)) {
+		dev_err(priv-&gt;dev, "Power not enabled\n");
+		return -EINVAL;
+	}
+
+	if (!fpga_power_good(priv)) {
+		dev_err(priv-&gt;dev, "Power not good\n");
+		return -EINVAL;
+	}
+
+	/* Set the LED to unprogrammed */
+	ledtrig_fpga_programmed(false);
+
+	/* Try to program the FPGA's using DMA */
+	ret = fpga_program_dma(priv);
+
+	/* If DMA failed or doesn't exist, try with CPU */
+	if (ret) {
+		dev_warn(priv-&gt;dev, "Falling back to CPU programming\n");
+		ret = fpga_program_cpu(priv);
+	}
+
+	if (ret) {
+		dev_err(priv-&gt;dev, "Unable to program FPGA's\n");
+		return ret;
+	}
+
+	/* Drop the firmware bitfile from memory */
+	fpga_drop_firmware_data(priv);
+
+	dev_dbg(priv-&gt;dev, "FPGA programming successful\n");
+	ledtrig_fpga_programmed(true);
+
+	return 0;
+}
+
+/*
+ * File Operations
+ */
+
+static int fpga_open(struct inode *inode, struct file *filp)
+{
+	/*
+	 * The miscdevice layer puts our struct miscdevice into the
+	 * filp-&gt;private_data field. We use this to find our private
+	 * data and then overwrite it with our own private structure.
+	 */
+	struct fpga_dev *priv = container_of(filp-&gt;private_data,
+					     struct fpga_dev, miscdev);
+	unsigned int nr_pages;
+	int ret;
+
+	/* We only allow one process at a time */
+	ret = mutex_lock_interruptible(&amp;priv-&gt;lock);
+	if (ret)
+		return ret;
+
+	filp-&gt;private_data = priv;
+	kref_get(&amp;priv-&gt;ref);
+
+	/* Truncation: drop any existing data */
+	if (filp-&gt;f_flags &amp; O_TRUNC)
+		priv-&gt;bytes = 0;
+
+	/* Check if we have already allocated a buffer */
+	if (priv-&gt;vb_allocated)
+		return 0;
+
+	/* Allocate a buffer to hold enough data for the bitfile */
+	nr_pages = DIV_ROUND_UP(priv-&gt;fw_size, PAGE_SIZE);
+	ret = videobuf_dma_init_kernel(&amp;priv-&gt;vb, DMA_TO_DEVICE, nr_pages);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to allocate data buffer\n");
+		mutex_unlock(&amp;priv-&gt;lock);
+		kref_put(&amp;priv-&gt;ref, fpga_dev_remove);
+		return ret;
+	}
+
+	priv-&gt;vb_allocated = true;
+	return 0;
+}
+
+static int fpga_release(struct inode *inode, struct file *filp)
+{
+	struct fpga_dev *priv = filp-&gt;private_data;
+
+	mutex_unlock(&amp;priv-&gt;lock);
+	kref_put(&amp;priv-&gt;ref, fpga_dev_remove);
+	return 0;
+}
+
+static ssize_t fpga_write(struct file *filp, const char __user *buf,
+			  size_t count, loff_t *f_pos)
+{
+	struct fpga_dev *priv = filp-&gt;private_data;
+
+	/* FPGA bitfiles have an exact size: disallow anything else */
+	if (priv-&gt;bytes &gt;= priv-&gt;fw_size)
+		return -ENOSPC;
+
+	count = min_t(size_t, priv-&gt;fw_size - priv-&gt;bytes, count);
+	if (copy_from_user(priv-&gt;vb.vaddr + priv-&gt;bytes, buf, count))
+		return -EFAULT;
+
+	priv-&gt;bytes += count;
+	return count;
+}
+
+static ssize_t fpga_read(struct file *filp, char __user *buf, size_t count,
+			 loff_t *f_pos)
+{
+	struct fpga_dev *priv = filp-&gt;private_data;
+
+	count = min_t(size_t, priv-&gt;bytes - *f_pos, count);
+	if (copy_to_user(buf, priv-&gt;vb.vaddr + *f_pos, count))
+		return -EFAULT;
+
+	*f_pos += count;
+	return count;
+}
+
+static loff_t fpga_llseek(struct file *filp, loff_t offset, int origin)
+{
+	struct fpga_dev *priv = filp-&gt;private_data;
+	loff_t newpos;
+
+	/* only read-only opens are allowed to seek */
+	if ((filp-&gt;f_flags &amp; O_ACCMODE) != O_RDONLY)
+		return -EINVAL;
+
+	switch (origin) {
+	case SEEK_SET: /* seek relative to the beginning of the file */
+		newpos = offset;
+		break;
+	case SEEK_CUR: /* seek relative to current position in the file */
+		newpos = filp-&gt;f_pos + offset;
+		break;
+	case SEEK_END: /* seek relative to the end of the file */
+		newpos = priv-&gt;fw_size - offset;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* check for sanity */
+	if (newpos &gt; priv-&gt;fw_size)
+		return -EINVAL;
+
+	filp-&gt;f_pos = newpos;
+	return newpos;
+}
+
+static const struct file_operations fpga_fops = {
+	.open		= fpga_open,
+	.release	= fpga_release,
+	.write		= fpga_write,
+	.read		= fpga_read,
+	.llseek		= fpga_llseek,
+};
+
+/*
+ * Device Attributes
+ */
+
+static ssize_t pfail_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	u8 val;
+
+	val = ioread8(priv-&gt;regs + CTL_PWR_FAIL);
+	return snprintf(buf, PAGE_SIZE, "0x%.2x\n", val);
+}
+
+static ssize_t pgood_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", fpga_power_good(priv));
+}
+
+static ssize_t penable_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", fpga_power_enabled(priv));
+}
+
+static ssize_t penable_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	unsigned long val;
+	int ret;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val) {
+		ret = fpga_enable_power_supplies(priv);
+		if (ret)
+			return ret;
+	} else {
+		fpga_do_stop(priv);
+		fpga_disable_power_supplies(priv);
+	}
+
+	return count;
+}
+
+static ssize_t program_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", fpga_running(priv));
+}
+
+static ssize_t program_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct fpga_dev *priv = dev_get_drvdata(dev);
+	unsigned long val;
+	int ret;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	/* We can't have an image writer and be programming simultaneously */
+	if (mutex_lock_interruptible(&amp;priv-&gt;lock))
+		return -ERESTARTSYS;
+
+	/* Program or Reset the FPGA's */
+	ret = val ? fpga_do_program(priv) : fpga_do_stop(priv);
+	if (ret)
+		goto out_unlock;
+
+	/* Success */
+	ret = count;
+
+out_unlock:
+	mutex_unlock(&amp;priv-&gt;lock);
+	return ret;
+}
+
+static DEVICE_ATTR(power_fail, S_IRUGO, pfail_show, NULL);
+static DEVICE_ATTR(power_good, S_IRUGO, pgood_show, NULL);
+static DEVICE_ATTR(power_enable, S_IRUGO | S_IWUSR,
+		   penable_show, penable_store);
+
+static DEVICE_ATTR(program, S_IRUGO | S_IWUSR,
+		   program_show, program_store);
+
+static struct attribute *fpga_attributes[] = {
+	&amp;dev_attr_power_fail.attr,
+	&amp;dev_attr_power_good.attr,
+	&amp;dev_attr_power_enable.attr,
+	&amp;dev_attr_program.attr,
+	NULL,
+};
+
+static const struct attribute_group fpga_attr_group = {
+	.attrs = fpga_attributes,
+};
+
+/*
+ * OpenFirmware Device Subsystem
+ */
+
+#define SYS_REG_VERSION		0x00
+#define SYS_REG_GEOGRAPHIC	0x10
+
+static bool dma_filter(struct dma_chan *chan, void *data)
+{
+	/*
+	 * DMA Channel #0 is the only acceptable device
+	 *
+	 * This probably won't survive an unload/load cycle of the Freescale
+	 * DMAEngine driver, but that won't be a problem
+	 */
+	return chan-&gt;chan_id == 0 &amp;&amp; chan-&gt;device-&gt;dev_id == 0;
+}
+
+static int fpga_of_remove(struct platform_device *op)
+{
+	struct fpga_dev *priv = dev_get_drvdata(&amp;op-&gt;dev);
+	struct device *this_device = priv-&gt;miscdev.this_device;
+
+	sysfs_remove_group(&amp;this_device-&gt;kobj, &amp;fpga_attr_group);
+	misc_deregister(&amp;priv-&gt;miscdev);
+
+	free_irq(priv-&gt;irq, priv);
+	irq_dispose_mapping(priv-&gt;irq);
+
+	/* make sure the power supplies are off */
+	fpga_disable_power_supplies(priv);
+
+	/* unmap registers */
+	iounmap(priv-&gt;immr);
+	iounmap(priv-&gt;regs);
+
+	dma_release_channel(priv-&gt;chan);
+
+	/* drop our reference to the private data structure */
+	kref_put(&amp;priv-&gt;ref, fpga_dev_remove);
+	return 0;
+}
+
+/* CTL-CPLD Version Register */
+#define CTL_CPLD_VERSION	0x2000
+
+static int fpga_of_probe(struct platform_device *op,
+			 const struct of_device_id *match)
+{
+	struct device_node *of_node = op-&gt;dev.of_node;
+	struct device *this_device;
+	struct fpga_dev *priv;
+	dma_cap_mask_t mask;
+	u32 ver;
+	int ret;
+
+	/* Allocate private data */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&amp;op-&gt;dev, "Unable to allocate private data\n");
+		ret = -ENOMEM;
+		goto out_return;
+	}
+
+	/* Setup the miscdevice */
+	priv-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;
+	priv-&gt;miscdev.name = drv_name;
+	priv-&gt;miscdev.fops = &amp;fpga_fops;
+
+	kref_init(&amp;priv-&gt;ref);
+
+	dev_set_drvdata(&amp;op-&gt;dev, priv);
+	priv-&gt;dev = &amp;op-&gt;dev;
+	mutex_init(&amp;priv-&gt;lock);
+	init_completion(&amp;priv-&gt;completion);
+	videobuf_dma_init(&amp;priv-&gt;vb);
+
+	dev_set_drvdata(priv-&gt;dev, priv);
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+	dma_cap_set(DMA_INTERRUPT, mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_SG, mask);
+
+	/* Get control of DMA channel #0 */
+	priv-&gt;chan = dma_request_channel(mask, dma_filter, NULL);
+	if (!priv-&gt;chan) {
+		dev_err(&amp;op-&gt;dev, "Unable to acquire DMA channel #0\n");
+		ret = -ENODEV;
+		goto out_free_priv;
+	}
+
+	/* Remap the registers for use */
+	priv-&gt;regs = of_iomap(of_node, 0);
+	if (!priv-&gt;regs) {
+		dev_err(&amp;op-&gt;dev, "Unable to ioremap registers\n");
+		ret = -ENOMEM;
+		goto out_dma_release_channel;
+	}
+
+	/* Remap the IMMR for use */
+	priv-&gt;immr = ioremap(get_immrbase(), 0x100000);
+	if (!priv-&gt;immr) {
+		dev_err(&amp;op-&gt;dev, "Unable to ioremap IMMR\n");
+		ret = -ENOMEM;
+		goto out_unmap_regs;
+	}
+
+	/*
+	 * Check that external DMA is configured
+	 *
+	 * U-Boot does this for us, but we should check it and bail out if
+	 * there is a problem. Failing to have this register setup correctly
+	 * will cause the DMA controller to transfer a single cacheline
+	 * worth of data, then wedge itself.
+	 */
+	if ((ioread32be(priv-&gt;immr + 0x114) &amp; 0xE00) != 0xE00) {
+		dev_err(&amp;op-&gt;dev, "External DMA control not configured\n");
+		ret = -ENODEV;
+		goto out_unmap_immr;
+	}
+
+	/*
+	 * Check the CTL-CPLD version
+	 *
+	 * This driver uses the CTL-CPLD DATA-FPGA power sequencer, and we
+	 * don't want to run on any version of the CTL-CPLD that does not use
+	 * a compatible register layout.
+	 *
+	 * v2: changed register layout, added power sequencer
+	 * v3: added glitch filter on the i2c overcurrent/overtemp outputs
+	 */
+	ver = ioread8(priv-&gt;regs + CTL_CPLD_VERSION);
+	if (ver != 0x02 &amp;&amp; ver != 0x03) {
+		dev_err(&amp;op-&gt;dev, "CTL-CPLD is not version 0x02 or 0x03!\n");
+		ret = -ENODEV;
+		goto out_unmap_immr;
+	}
+
+	/* Set the exact size that the firmware image should be */
+	ver = ioread32be(priv-&gt;regs + SYS_REG_VERSION);
+	priv-&gt;fw_size = (ver &amp; (1 &lt;&lt; 18)) ? FW_SIZE_EP2S130 : FW_SIZE_EP2S90;
+
+	/* Find the correct IRQ number */
+	priv-&gt;irq = irq_of_parse_and_map(of_node, 0);
+	if (priv-&gt;irq == NO_IRQ) {
+		dev_err(&amp;op-&gt;dev, "Unable to find IRQ line\n");
+		ret = -ENODEV;
+		goto out_unmap_immr;
+	}
+
+	/* Request the IRQ */
+	ret = request_irq(priv-&gt;irq, fpga_irq, IRQF_SHARED, drv_name, priv);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to request IRQ %d\n", priv-&gt;irq);
+		ret = -ENODEV;
+		goto out_irq_dispose_mapping;
+	}
+
+	/* Reset and stop the FPGA's, just in case */
+	fpga_do_stop(priv);
+
+	/* Register the miscdevice */
+	ret = misc_register(&amp;priv-&gt;miscdev);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to register miscdevice\n");
+		goto out_free_irq;
+	}
+
+	/* Create the sysfs files */
+	this_device = priv-&gt;miscdev.this_device;
+	dev_set_drvdata(this_device, priv);
+	ret = sysfs_create_group(&amp;this_device-&gt;kobj, &amp;fpga_attr_group);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to create sysfs files\n");
+		goto out_misc_deregister;
+	}
+
+	dev_info(priv-&gt;dev, "CARMA FPGA Programmer: %s rev%s with %s FPGAs\n",
+			(ver &amp; (1 &lt;&lt; 17)) ? "Correlator" : "Digitizer",
+			(ver &amp; (1 &lt;&lt; 16)) ? "B" : "A",
+			(ver &amp; (1 &lt;&lt; 18)) ? "EP2S130" : "EP2S90");
+
+	return 0;
+
+out_misc_deregister:
+	misc_deregister(&amp;priv-&gt;miscdev);
+out_free_irq:
+	free_irq(priv-&gt;irq, priv);
+out_irq_dispose_mapping:
+	irq_dispose_mapping(priv-&gt;irq);
+out_unmap_immr:
+	iounmap(priv-&gt;immr);
+out_unmap_regs:
+	iounmap(priv-&gt;regs);
+out_dma_release_channel:
+	dma_release_channel(priv-&gt;chan);
+out_free_priv:
+	kref_put(&amp;priv-&gt;ref, fpga_dev_remove);
+out_return:
+	return ret;
+}
+
+static struct of_device_id fpga_of_match[] = {
+	{ .compatible = "carma,fpga-programmer", },
+	{},
+};
+
+static struct of_platform_driver fpga_of_driver = {
+	.probe		= fpga_of_probe,
+	.remove		= fpga_of_remove,
+	.driver		= {
+		.name		= drv_name,
+		.of_match_table	= fpga_of_match,
+		.owner		= THIS_MODULE,
+	},
+};
+
+/*
+ * Module Init / Exit
+ */
+
+static int __init fpga_init(void)
+{
+	led_trigger_register_simple("fpga", &amp;ledtrig_fpga);
+	return of_register_platform_driver(&amp;fpga_of_driver);
+}
+
+static void __exit fpga_exit(void)
+{
+	of_unregister_platform_driver(&amp;fpga_of_driver);
+	led_trigger_unregister_simple(ledtrig_fpga);
+}
+
+MODULE_AUTHOR("Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;");
+MODULE_DESCRIPTION("CARMA Board DATA-FPGA Programmer");
+MODULE_LICENSE("GPL");
+
+module_init(fpga_init);
+module_exit(fpga_exit);</pre><hr><pre>commit c186f0e177275e83728d7acfdf4a1b68793a7038
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Fri Feb 11 13:34:29 2011 +0000

    misc: Add CARMA DATA-FPGA Access Driver
    
    This driver allows userspace to access the data processing FPGAs on the
    OVRO CARMA board. It has two modes of operation:
    
    1) random access
    
    This allows users to poke any DATA-FPGA registers by using mmap to map
    the address region directly into their memory map.
    
    2) correlation dumping
    
    When correlating, the DATA-FPGA's have special requirements for getting
    the data out of their memory before the next correlation. This nominally
    happens at 64Hz (every 15.625ms). If the data is not dumped before the
    next correlation, data is lost.
    
    The data dumping driver handles buffering up to 1 second worth of
    correlation data from the FPGAs. This lowers the realtime scheduling
    requirements for the userspace process reading the device.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 4e007c6a4b44..d80dcdee88f3 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -481,5 +481,6 @@ source "drivers/misc/cb710/Kconfig"
 source "drivers/misc/iwmc3200top/Kconfig"
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
+source "drivers/misc/carma/Kconfig"
 
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f5468602961f..848e8464faab 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -44,3 +44,4 @@ obj-$(CONFIG_PCH_PHUB)		+= pch_phub.o
 obj-y				+= ti-st/
 obj-$(CONFIG_AB8500_PWM)	+= ab8500-pwm.o
 obj-y				+= lis3lv02d/
+obj-y				+= carma/
diff --git a/drivers/misc/carma/Kconfig b/drivers/misc/carma/Kconfig
new file mode 100644
index 000000000000..4be183f7e6f1
--- /dev/null
+++ b/drivers/misc/carma/Kconfig
@@ -0,0 +1,9 @@
+config CARMA_FPGA
+	tristate "CARMA DATA-FPGA Access Driver"
+	depends on FSL_SOC &amp;&amp; PPC_83xx &amp;&amp; MEDIA_SUPPORT &amp;&amp; HAS_DMA &amp;&amp; FSL_DMA
+	select VIDEOBUF_DMA_SG
+	default n
+	help
+	  Say Y here to include support for communicating with the data
+	  processing FPGAs on the OVRO CARMA board.
+
diff --git a/drivers/misc/carma/Makefile b/drivers/misc/carma/Makefile
new file mode 100644
index 000000000000..0b69fa787953
--- /dev/null
+++ b/drivers/misc/carma/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_CARMA_FPGA)		+= carma-fpga.o
diff --git a/drivers/misc/carma/carma-fpga.c b/drivers/misc/carma/carma-fpga.c
new file mode 100644
index 000000000000..3965821fef17
--- /dev/null
+++ b/drivers/misc/carma/carma-fpga.c
@@ -0,0 +1,1433 @@
+/*
+ * CARMA DATA-FPGA Access Driver
+ *
+ * Copyright (c) 2009-2011 Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+/*
+ * FPGA Memory Dump Format
+ *
+ * FPGA #0 control registers (32 x 32-bit words)
+ * FPGA #1 control registers (32 x 32-bit words)
+ * FPGA #2 control registers (32 x 32-bit words)
+ * FPGA #3 control registers (32 x 32-bit words)
+ * SYSFPGA control registers (32 x 32-bit words)
+ * FPGA #0 correlation array (NUM_CORL0 correlation blocks)
+ * FPGA #1 correlation array (NUM_CORL1 correlation blocks)
+ * FPGA #2 correlation array (NUM_CORL2 correlation blocks)
+ * FPGA #3 correlation array (NUM_CORL3 correlation blocks)
+ *
+ * Each correlation array consists of:
+ *
+ * Correlation Data      (2 x NUM_LAGSn x 32-bit words)
+ * Pipeline Metadata     (2 x NUM_METAn x 32-bit words)
+ * Quantization Counters (2 x NUM_QCNTn x 32-bit words)
+ *
+ * The NUM_CORLn, NUM_LAGSn, NUM_METAn, and NUM_QCNTn values come from
+ * the FPGA configuration registers. They do not change once the FPGA's
+ * have been programmed, they only change on re-programming.
+ */
+
+/*
+ * Basic Description:
+ *
+ * This driver is used to capture correlation spectra off of the four data
+ * processing FPGAs. The FPGAs are often reprogrammed at runtime, therefore
+ * this driver supports dynamic enable/disable of capture while the device
+ * remains open.
+ *
+ * The nominal capture rate is 64Hz (every 15.625ms). To facilitate this fast
+ * capture rate, all buffers are pre-allocated to avoid any potentially long
+ * running memory allocations while capturing.
+ *
+ * There are two lists and one pointer which are used to keep track of the
+ * different states of data buffers.
+ *
+ * 1) free list
+ * This list holds all empty data buffers which are ready to receive data.
+ *
+ * 2) inflight pointer
+ * This pointer holds the currently inflight data buffer. This buffer is having
+ * data copied into it by the DMA engine.
+ *
+ * 3) used list
+ * This list holds data buffers which have been filled, and are waiting to be
+ * read by userspace.
+ *
+ * All buffers start life on the free list, then move successively to the
+ * inflight pointer, and then to the used list. After they have been read by
+ * userspace, they are moved back to the free list. The cycle repeats as long
+ * as necessary.
+ *
+ * It should be noted that all buffers are mapped and ready for DMA when they
+ * are on any of the three lists. They are only unmapped when they are in the
+ * process of being read by userspace.
+ */
+
+/*
+ * Notes on the IRQ masking scheme:
+ *
+ * The IRQ masking scheme here is different than most other hardware. The only
+ * way for the DATA-FPGAs to detect if the kernel has taken too long to copy
+ * the data is if the status registers are not cleared before the next
+ * correlation data dump is ready.
+ *
+ * The interrupt line is connected to the status registers, such that when they
+ * are cleared, the interrupt is de-asserted. Therein lies our problem. We need
+ * to schedule a long-running DMA operation and return from the interrupt
+ * handler quickly, but we cannot clear the status registers.
+ *
+ * To handle this, the system controller FPGA has the capability to connect the
+ * interrupt line to a user-controlled GPIO pin. This pin is driven high
+ * (unasserted) and left that way. To mask the interrupt, we change the
+ * interrupt source to the GPIO pin. Tada, we hid the interrupt. :)
+ */
+
+#include &lt;linux/of_platform.h&gt;
+#include &lt;linux/dma-mapping.h&gt;
+#include &lt;linux/miscdevice.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/dmaengine.h&gt;
+#include &lt;linux/seq_file.h&gt;
+#include &lt;linux/highmem.h&gt;
+#include &lt;linux/debugfs.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/poll.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/kref.h&gt;
+#include &lt;linux/io.h&gt;
+
+#include &lt;media/videobuf-dma-sg.h&gt;
+
+/* system controller registers */
+#define SYS_IRQ_SOURCE_CTL	0x24
+#define SYS_IRQ_OUTPUT_EN	0x28
+#define SYS_IRQ_OUTPUT_DATA	0x2C
+#define SYS_IRQ_INPUT_DATA	0x30
+#define SYS_FPGA_CONFIG_STATUS	0x44
+
+/* GPIO IRQ line assignment */
+#define IRQ_CORL_DONE		0x10
+
+/* FPGA registers */
+#define MMAP_REG_VERSION	0x00
+#define MMAP_REG_CORL_CONF1	0x08
+#define MMAP_REG_CORL_CONF2	0x0C
+#define MMAP_REG_STATUS		0x48
+
+#define SYS_FPGA_BLOCK		0xF0000000
+
+#define DATA_FPGA_START		0x400000
+#define DATA_FPGA_SIZE		0x80000
+
+static const char drv_name[] = "carma-fpga";
+
+#define NUM_FPGA	4
+
+#define MIN_DATA_BUFS	8
+#define MAX_DATA_BUFS	64
+
+struct fpga_info {
+	unsigned int num_lag_ram;
+	unsigned int blk_size;
+};
+
+struct data_buf {
+	struct list_head entry;
+	struct videobuf_dmabuf vb;
+	size_t size;
+};
+
+struct fpga_device {
+	/* character device */
+	struct miscdevice miscdev;
+	struct device *dev;
+	struct mutex mutex;
+
+	/* reference count */
+	struct kref ref;
+
+	/* FPGA registers and information */
+	struct fpga_info info[NUM_FPGA];
+	void __iomem *regs;
+	int irq;
+
+	/* FPGA Physical Address/Size Information */
+	resource_size_t phys_addr;
+	size_t phys_size;
+
+	/* DMA structures */
+	struct sg_table corl_table;
+	unsigned int corl_nents;
+	struct dma_chan *chan;
+
+	/* Protection for all members below */
+	spinlock_t lock;
+
+	/* Device enable/disable flag */
+	bool enabled;
+
+	/* Correlation data buffers */
+	wait_queue_head_t wait;
+	struct list_head free;
+	struct list_head used;
+	struct data_buf *inflight;
+
+	/* Information about data buffers */
+	unsigned int num_dropped;
+	unsigned int num_buffers;
+	size_t bufsize;
+	struct dentry *dbg_entry;
+};
+
+struct fpga_reader {
+	struct fpga_device *priv;
+	struct data_buf *buf;
+	off_t buf_start;
+};
+
+static void fpga_device_release(struct kref *ref)
+{
+	struct fpga_device *priv = container_of(ref, struct fpga_device, ref);
+
+	/* the last reader has exited, cleanup the last bits */
+	mutex_destroy(&amp;priv-&gt;mutex);
+	kfree(priv);
+}
+
+/*
+ * Data Buffer Allocation Helpers
+ */
+
+/**
+ * data_free_buffer() - free a single data buffer and all allocated memory
+ * @buf: the buffer to free
+ *
+ * This will free all of the pages allocated to the given data buffer, and
+ * then free the structure itself
+ */
+static void data_free_buffer(struct data_buf *buf)
+{
+	/* It is ok to free a NULL buffer */
+	if (!buf)
+		return;
+
+	/* free all memory */
+	videobuf_dma_free(&amp;buf-&gt;vb);
+	kfree(buf);
+}
+
+/**
+ * data_alloc_buffer() - allocate and fill a data buffer with pages
+ * @bytes: the number of bytes required
+ *
+ * This allocates all space needed for a data buffer. It must be mapped before
+ * use in a DMA transaction using videobuf_dma_map().
+ *
+ * Returns NULL on failure
+ */
+static struct data_buf *data_alloc_buffer(const size_t bytes)
+{
+	unsigned int nr_pages;
+	struct data_buf *buf;
+	int ret;
+
+	/* calculate the number of pages necessary */
+	nr_pages = DIV_ROUND_UP(bytes, PAGE_SIZE);
+
+	/* allocate the buffer structure */
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		goto out_return;
+
+	/* initialize internal fields */
+	INIT_LIST_HEAD(&amp;buf-&gt;entry);
+	buf-&gt;size = bytes;
+
+	/* allocate the videobuf */
+	videobuf_dma_init(&amp;buf-&gt;vb);
+	ret = videobuf_dma_init_kernel(&amp;buf-&gt;vb, DMA_FROM_DEVICE, nr_pages);
+	if (ret)
+		goto out_free_buf;
+
+	return buf;
+
+out_free_buf:
+	kfree(buf);
+out_return:
+	return NULL;
+}
+
+/**
+ * data_free_buffers() - free all allocated buffers
+ * @priv: the driver's private data structure
+ *
+ * Free all buffers allocated by the driver (except those currently in the
+ * process of being read by userspace).
+ *
+ * LOCKING: must hold dev-&gt;mutex
+ * CONTEXT: user
+ */
+static void data_free_buffers(struct fpga_device *priv)
+{
+	struct data_buf *buf, *tmp;
+
+	/* the device should be stopped, no DMA in progress */
+	BUG_ON(priv-&gt;inflight != NULL);
+
+	list_for_each_entry_safe(buf, tmp, &amp;priv-&gt;free, entry) {
+		list_del_init(&amp;buf-&gt;entry);
+		videobuf_dma_unmap(priv-&gt;dev, &amp;buf-&gt;vb);
+		data_free_buffer(buf);
+	}
+
+	list_for_each_entry_safe(buf, tmp, &amp;priv-&gt;used, entry) {
+		list_del_init(&amp;buf-&gt;entry);
+		videobuf_dma_unmap(priv-&gt;dev, &amp;buf-&gt;vb);
+		data_free_buffer(buf);
+	}
+
+	priv-&gt;num_buffers = 0;
+	priv-&gt;bufsize = 0;
+}
+
+/**
+ * data_alloc_buffers() - allocate 1 seconds worth of data buffers
+ * @priv: the driver's private data structure
+ *
+ * Allocate enough buffers for a whole second worth of data
+ *
+ * This routine will attempt to degrade nicely by succeeding even if a full
+ * second worth of data buffers could not be allocated, as long as a minimum
+ * number were allocated. In this case, it will print a message to the kernel
+ * log.
+ *
+ * The device must not be modifying any lists when this is called.
+ *
+ * CONTEXT: user
+ * LOCKING: must hold dev-&gt;mutex
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_alloc_buffers(struct fpga_device *priv)
+{
+	struct data_buf *buf;
+	int i, ret;
+
+	for (i = 0; i &lt; MAX_DATA_BUFS; i++) {
+
+		/* allocate a buffer */
+		buf = data_alloc_buffer(priv-&gt;bufsize);
+		if (!buf)
+			break;
+
+		/* map it for DMA */
+		ret = videobuf_dma_map(priv-&gt;dev, &amp;buf-&gt;vb);
+		if (ret) {
+			data_free_buffer(buf);
+			break;
+		}
+
+		/* add it to the list of free buffers */
+		list_add_tail(&amp;buf-&gt;entry, &amp;priv-&gt;free);
+		priv-&gt;num_buffers++;
+	}
+
+	/* Make sure we allocated the minimum required number of buffers */
+	if (priv-&gt;num_buffers &lt; MIN_DATA_BUFS) {
+		dev_err(priv-&gt;dev, "Unable to allocate enough data buffers\n");
+		data_free_buffers(priv);
+		return -ENOMEM;
+	}
+
+	/* Warn if we are running in a degraded state, but do not fail */
+	if (priv-&gt;num_buffers &lt; MAX_DATA_BUFS) {
+		dev_warn(priv-&gt;dev,
+			 "Unable to allocate %d buffers, using %d buffers instead\n",
+			 MAX_DATA_BUFS, i);
+	}
+
+	return 0;
+}
+
+/*
+ * DMA Operations Helpers
+ */
+
+/**
+ * fpga_start_addr() - get the physical address a DATA-FPGA
+ * @priv: the driver's private data structure
+ * @fpga: the DATA-FPGA number (zero based)
+ */
+static dma_addr_t fpga_start_addr(struct fpga_device *priv, unsigned int fpga)
+{
+	return priv-&gt;phys_addr + 0x400000 + (0x80000 * fpga);
+}
+
+/**
+ * fpga_block_addr() - get the physical address of a correlation data block
+ * @priv: the driver's private data structure
+ * @fpga: the DATA-FPGA number (zero based)
+ * @blknum: the correlation block number (zero based)
+ */
+static dma_addr_t fpga_block_addr(struct fpga_device *priv, unsigned int fpga,
+				  unsigned int blknum)
+{
+	return fpga_start_addr(priv, fpga) + (0x10000 * (1 + blknum));
+}
+
+#define REG_BLOCK_SIZE	(32 * 4)
+
+/**
+ * data_setup_corl_table() - create the scatterlist for correlation dumps
+ * @priv: the driver's private data structure
+ *
+ * Create the scatterlist for transferring a correlation dump from the
+ * DATA FPGAs. This structure will be reused for each buffer than needs
+ * to be filled with correlation data.
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_setup_corl_table(struct fpga_device *priv)
+{
+	struct sg_table *table = &amp;priv-&gt;corl_table;
+	struct scatterlist *sg;
+	struct fpga_info *info;
+	int i, j, ret;
+
+	/* Calculate the number of entries needed */
+	priv-&gt;corl_nents = (1 + NUM_FPGA) * REG_BLOCK_SIZE;
+	for (i = 0; i &lt; NUM_FPGA; i++)
+		priv-&gt;corl_nents += priv-&gt;info[i].num_lag_ram;
+
+	/* Allocate the scatterlist table */
+	ret = sg_alloc_table(table, priv-&gt;corl_nents, GFP_KERNEL);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to allocate DMA table\n");
+		return ret;
+	}
+
+	/* Add the DATA FPGA registers to the scatterlist */
+	sg = table-&gt;sgl;
+	for (i = 0; i &lt; NUM_FPGA; i++) {
+		sg_dma_address(sg) = fpga_start_addr(priv, i);
+		sg_dma_len(sg) = REG_BLOCK_SIZE;
+		sg = sg_next(sg);
+	}
+
+	/* Add the SYS-FPGA registers to the scatterlist */
+	sg_dma_address(sg) = SYS_FPGA_BLOCK;
+	sg_dma_len(sg) = REG_BLOCK_SIZE;
+	sg = sg_next(sg);
+
+	/* Add the FPGA correlation data blocks to the scatterlist */
+	for (i = 0; i &lt; NUM_FPGA; i++) {
+		info = &amp;priv-&gt;info[i];
+		for (j = 0; j &lt; info-&gt;num_lag_ram; j++) {
+			sg_dma_address(sg) = fpga_block_addr(priv, i, j);
+			sg_dma_len(sg) = info-&gt;blk_size;
+			sg = sg_next(sg);
+		}
+	}
+
+	/*
+	 * All physical addresses and lengths are present in the structure
+	 * now. It can be reused for every FPGA DATA interrupt
+	 */
+	return 0;
+}
+
+/*
+ * FPGA Register Access Helpers
+ */
+
+static void fpga_write_reg(struct fpga_device *priv, unsigned int fpga,
+			   unsigned int reg, u32 val)
+{
+	const int fpga_start = DATA_FPGA_START + (fpga * DATA_FPGA_SIZE);
+	iowrite32be(val, priv-&gt;regs + fpga_start + reg);
+}
+
+static u32 fpga_read_reg(struct fpga_device *priv, unsigned int fpga,
+			 unsigned int reg)
+{
+	const int fpga_start = DATA_FPGA_START + (fpga * DATA_FPGA_SIZE);
+	return ioread32be(priv-&gt;regs + fpga_start + reg);
+}
+
+/**
+ * data_calculate_bufsize() - calculate the data buffer size required
+ * @priv: the driver's private data structure
+ *
+ * Calculate the total buffer size needed to hold a single block
+ * of correlation data
+ *
+ * CONTEXT: user
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_calculate_bufsize(struct fpga_device *priv)
+{
+	u32 num_corl, num_lags, num_meta, num_qcnt, num_pack;
+	u32 conf1, conf2, version;
+	u32 num_lag_ram, blk_size;
+	int i;
+
+	/* Each buffer starts with the 5 FPGA register areas */
+	priv-&gt;bufsize = (1 + NUM_FPGA) * REG_BLOCK_SIZE;
+
+	/* Read and store the configuration data for each FPGA */
+	for (i = 0; i &lt; NUM_FPGA; i++) {
+		version = fpga_read_reg(priv, i, MMAP_REG_VERSION);
+		conf1 = fpga_read_reg(priv, i, MMAP_REG_CORL_CONF1);
+		conf2 = fpga_read_reg(priv, i, MMAP_REG_CORL_CONF2);
+
+		/* minor version 2 and later */
+		if ((version &amp; 0x000000FF) &gt;= 2) {
+			num_corl = (conf1 &amp; 0x000000F0) &gt;&gt; 4;
+			num_pack = (conf1 &amp; 0x00000F00) &gt;&gt; 8;
+			num_lags = (conf1 &amp; 0x00FFF000) &gt;&gt; 12;
+			num_meta = (conf1 &amp; 0x7F000000) &gt;&gt; 24;
+			num_qcnt = (conf2 &amp; 0x00000FFF) &gt;&gt; 0;
+		} else {
+			num_corl = (conf1 &amp; 0x000000F0) &gt;&gt; 4;
+			num_pack = 1; /* implied */
+			num_lags = (conf1 &amp; 0x000FFF00) &gt;&gt; 8;
+			num_meta = (conf1 &amp; 0x7FF00000) &gt;&gt; 20;
+			num_qcnt = (conf2 &amp; 0x00000FFF) &gt;&gt; 0;
+		}
+
+		num_lag_ram = (num_corl + num_pack - 1) / num_pack;
+		blk_size = ((num_pack * num_lags) + num_meta + num_qcnt) * 8;
+
+		priv-&gt;info[i].num_lag_ram = num_lag_ram;
+		priv-&gt;info[i].blk_size = blk_size;
+		priv-&gt;bufsize += num_lag_ram * blk_size;
+
+		dev_dbg(priv-&gt;dev, "FPGA %d NUM_CORL: %d\n", i, num_corl);
+		dev_dbg(priv-&gt;dev, "FPGA %d NUM_PACK: %d\n", i, num_pack);
+		dev_dbg(priv-&gt;dev, "FPGA %d NUM_LAGS: %d\n", i, num_lags);
+		dev_dbg(priv-&gt;dev, "FPGA %d NUM_META: %d\n", i, num_meta);
+		dev_dbg(priv-&gt;dev, "FPGA %d NUM_QCNT: %d\n", i, num_qcnt);
+		dev_dbg(priv-&gt;dev, "FPGA %d BLK_SIZE: %d\n", i, blk_size);
+	}
+
+	dev_dbg(priv-&gt;dev, "TOTAL BUFFER SIZE: %zu bytes\n", priv-&gt;bufsize);
+	return 0;
+}
+
+/*
+ * Interrupt Handling
+ */
+
+/**
+ * data_disable_interrupts() - stop the device from generating interrupts
+ * @priv: the driver's private data structure
+ *
+ * Hide interrupts by switching to GPIO interrupt source
+ *
+ * LOCKING: must hold dev-&gt;lock
+ */
+static void data_disable_interrupts(struct fpga_device *priv)
+{
+	/* hide the interrupt by switching the IRQ driver to GPIO */
+	iowrite32be(0x2F, priv-&gt;regs + SYS_IRQ_SOURCE_CTL);
+}
+
+/**
+ * data_enable_interrupts() - allow the device to generate interrupts
+ * @priv: the driver's private data structure
+ *
+ * Unhide interrupts by switching to the FPGA interrupt source. At the
+ * same time, clear the DATA-FPGA status registers.
+ *
+ * LOCKING: must hold dev-&gt;lock
+ */
+static void data_enable_interrupts(struct fpga_device *priv)
+{
+	/* clear the actual FPGA corl_done interrupt */
+	fpga_write_reg(priv, 0, MMAP_REG_STATUS, 0x0);
+	fpga_write_reg(priv, 1, MMAP_REG_STATUS, 0x0);
+	fpga_write_reg(priv, 2, MMAP_REG_STATUS, 0x0);
+	fpga_write_reg(priv, 3, MMAP_REG_STATUS, 0x0);
+
+	/* flush the writes */
+	fpga_read_reg(priv, 0, MMAP_REG_STATUS);
+
+	/* switch back to the external interrupt source */
+	iowrite32be(0x3F, priv-&gt;regs + SYS_IRQ_SOURCE_CTL);
+}
+
+/**
+ * data_dma_cb() - DMAEngine callback for DMA completion
+ * @data: the driver's private data structure
+ *
+ * Complete a DMA transfer from the DATA-FPGA's
+ *
+ * This is called via the DMA callback mechanism, and will handle moving the
+ * completed DMA transaction to the used list, and then wake any processes
+ * waiting for new data
+ *
+ * CONTEXT: any, softirq expected
+ */
+static void data_dma_cb(void *data)
+{
+	struct fpga_device *priv = data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
+
+	/* If there is no inflight buffer, we've got a bug */
+	BUG_ON(priv-&gt;inflight == NULL);
+
+	/* Move the inflight buffer onto the used list */
+	list_move_tail(&amp;priv-&gt;inflight-&gt;entry, &amp;priv-&gt;used);
+	priv-&gt;inflight = NULL;
+
+	/* clear the FPGA status and re-enable interrupts */
+	data_enable_interrupts(priv);
+
+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
+
+	/*
+	 * We've changed both the inflight and used lists, so we need
+	 * to wake up any processes that are blocking for those events
+	 */
+	wake_up(&amp;priv-&gt;wait);
+}
+
+/**
+ * data_submit_dma() - prepare and submit the required DMA to fill a buffer
+ * @priv: the driver's private data structure
+ * @buf: the data buffer
+ *
+ * Prepare and submit the necessary DMA transactions to fill a correlation
+ * data buffer.
+ *
+ * LOCKING: must hold dev-&gt;lock
+ * CONTEXT: hardirq only
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_submit_dma(struct fpga_device *priv, struct data_buf *buf)
+{
+	struct scatterlist *dst_sg, *src_sg;
+	unsigned int dst_nents, src_nents;
+	struct dma_chan *chan = priv-&gt;chan;
+	struct dma_async_tx_descriptor *tx;
+	dma_cookie_t cookie;
+	dma_addr_t dst, src;
+
+	dst_sg = buf-&gt;vb.sglist;
+	dst_nents = buf-&gt;vb.sglen;
+
+	src_sg = priv-&gt;corl_table.sgl;
+	src_nents = priv-&gt;corl_nents;
+
+	/*
+	 * All buffers passed to this function should be ready and mapped
+	 * for DMA already. Therefore, we don't need to do anything except
+	 * submit it to the Freescale DMA Engine for processing
+	 */
+
+	/* setup the scatterlist to scatterlist transfer */
+	tx = chan-&gt;device-&gt;device_prep_dma_sg(chan,
+					      dst_sg, dst_nents,
+					      src_sg, src_nents,
+					      0);
+	if (!tx) {
+		dev_err(priv-&gt;dev, "unable to prep scatterlist DMA\n");
+		return -ENOMEM;
+	}
+
+	/* submit the transaction to the DMA controller */
+	cookie = tx-&gt;tx_submit(tx);
+	if (dma_submit_error(cookie)) {
+		dev_err(priv-&gt;dev, "unable to submit scatterlist DMA\n");
+		return -ENOMEM;
+	}
+
+	/* Prepare the re-read of the SYS-FPGA block */
+	dst = sg_dma_address(dst_sg) + (NUM_FPGA * REG_BLOCK_SIZE);
+	src = SYS_FPGA_BLOCK;
+	tx = chan-&gt;device-&gt;device_prep_dma_memcpy(chan, dst, src,
+						  REG_BLOCK_SIZE,
+						  DMA_PREP_INTERRUPT);
+	if (!tx) {
+		dev_err(priv-&gt;dev, "unable to prep SYS-FPGA DMA\n");
+		return -ENOMEM;
+	}
+
+	/* Setup the callback */
+	tx-&gt;callback = data_dma_cb;
+	tx-&gt;callback_param = priv;
+
+	/* submit the transaction to the DMA controller */
+	cookie = tx-&gt;tx_submit(tx);
+	if (dma_submit_error(cookie)) {
+		dev_err(priv-&gt;dev, "unable to submit SYS-FPGA DMA\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+#define CORL_DONE	0x1
+#define CORL_ERR	0x2
+
+static irqreturn_t data_irq(int irq, void *dev_id)
+{
+	struct fpga_device *priv = dev_id;
+	bool submitted = false;
+	struct data_buf *buf;
+	u32 status;
+	int i;
+
+	/* detect spurious interrupts via FPGA status */
+	for (i = 0; i &lt; 4; i++) {
+		status = fpga_read_reg(priv, i, MMAP_REG_STATUS);
+		if (!(status &amp; (CORL_DONE | CORL_ERR))) {
+			dev_err(priv-&gt;dev, "spurious irq detected (FPGA)\n");
+			return IRQ_NONE;
+		}
+	}
+
+	/* detect spurious interrupts via raw IRQ pin readback */
+	status = ioread32be(priv-&gt;regs + SYS_IRQ_INPUT_DATA);
+	if (status &amp; IRQ_CORL_DONE) {
+		dev_err(priv-&gt;dev, "spurious irq detected (IRQ)\n");
+		return IRQ_NONE;
+	}
+
+	spin_lock(&amp;priv-&gt;lock);
+
+	/* hide the interrupt by switching the IRQ driver to GPIO */
+	data_disable_interrupts(priv);
+
+	/* If there are no free buffers, drop this data */
+	if (list_empty(&amp;priv-&gt;free)) {
+		priv-&gt;num_dropped++;
+		goto out;
+	}
+
+	buf = list_first_entry(&amp;priv-&gt;free, struct data_buf, entry);
+	list_del_init(&amp;buf-&gt;entry);
+	BUG_ON(buf-&gt;size != priv-&gt;bufsize);
+
+	/* Submit a DMA transfer to get the correlation data */
+	if (data_submit_dma(priv, buf)) {
+		dev_err(priv-&gt;dev, "Unable to setup DMA transfer\n");
+		list_move_tail(&amp;buf-&gt;entry, &amp;priv-&gt;free);
+		goto out;
+	}
+
+	/* Save the buffer for the DMA callback */
+	priv-&gt;inflight = buf;
+	submitted = true;
+
+	/* Start the DMA Engine */
+	dma_async_memcpy_issue_pending(priv-&gt;chan);
+
+out:
+	/* If no DMA was submitted, re-enable interrupts */
+	if (!submitted)
+		data_enable_interrupts(priv);
+
+	spin_unlock(&amp;priv-&gt;lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Realtime Device Enable Helpers
+ */
+
+/**
+ * data_device_enable() - enable the device for buffered dumping
+ * @priv: the driver's private data structure
+ *
+ * Enable the device for buffered dumping. Allocates buffers and hooks up
+ * the interrupt handler. When this finishes, data will come pouring in.
+ *
+ * LOCKING: must hold dev-&gt;mutex
+ * CONTEXT: user context only
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_device_enable(struct fpga_device *priv)
+{
+	u32 val;
+	int ret;
+
+	/* multiple enables are safe: they do nothing */
+	if (priv-&gt;enabled)
+		return 0;
+
+	/* check that the FPGAs are programmed */
+	val = ioread32be(priv-&gt;regs + SYS_FPGA_CONFIG_STATUS);
+	if (!(val &amp; (1 &lt;&lt; 18))) {
+		dev_err(priv-&gt;dev, "DATA-FPGAs are not enabled\n");
+		return -ENODATA;
+	}
+
+	/* read the FPGAs to calculate the buffer size */
+	ret = data_calculate_bufsize(priv);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to calculate buffer size\n");
+		goto out_error;
+	}
+
+	/* allocate the correlation data buffers */
+	ret = data_alloc_buffers(priv);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to allocate buffers\n");
+		goto out_error;
+	}
+
+	/* setup the source scatterlist for dumping correlation data */
+	ret = data_setup_corl_table(priv);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to setup correlation DMA table\n");
+		goto out_error;
+	}
+
+	/* hookup the irq handler */
+	ret = request_irq(priv-&gt;irq, data_irq, IRQF_SHARED, drv_name, priv);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to request IRQ handler\n");
+		goto out_error;
+	}
+
+	/* switch to the external FPGA IRQ line */
+	data_enable_interrupts(priv);
+
+	/* success, we're enabled */
+	priv-&gt;enabled = true;
+	return 0;
+
+out_error:
+	sg_free_table(&amp;priv-&gt;corl_table);
+	priv-&gt;corl_nents = 0;
+
+	data_free_buffers(priv);
+	return ret;
+}
+
+/**
+ * data_device_disable() - disable the device for buffered dumping
+ * @priv: the driver's private data structure
+ *
+ * Disable the device for buffered dumping. Stops new DMA transactions from
+ * being generated, waits for all outstanding DMA to complete, and then frees
+ * all buffers.
+ *
+ * LOCKING: must hold dev-&gt;mutex
+ * CONTEXT: user only
+ *
+ * Returns 0 on success, -ERRNO otherwise
+ */
+static int data_device_disable(struct fpga_device *priv)
+{
+	int ret;
+
+	/* allow multiple disable */
+	if (!priv-&gt;enabled)
+		return 0;
+
+	/* switch to the internal GPIO IRQ line */
+	data_disable_interrupts(priv);
+
+	/* unhook the irq handler */
+	free_irq(priv-&gt;irq, priv);
+
+	/*
+	 * wait for all outstanding DMA to complete
+	 *
+	 * Device interrupts are disabled, therefore another buffer cannot
+	 * be marked inflight.
+	 */
+	ret = wait_event_interruptible(priv-&gt;wait, priv-&gt;inflight == NULL);
+	if (ret)
+		return ret;
+
+	/* free the correlation table */
+	sg_free_table(&amp;priv-&gt;corl_table);
+	priv-&gt;corl_nents = 0;
+
+	/*
+	 * We are taking the spinlock not to protect priv-&gt;enabled, but instead
+	 * to make sure that there are no readers in the process of altering
+	 * the free or used lists while we are setting this flag.
+	 */
+	spin_lock_irq(&amp;priv-&gt;lock);
+	priv-&gt;enabled = false;
+	spin_unlock_irq(&amp;priv-&gt;lock);
+
+	/* free all buffers: the free and used lists are not being changed */
+	data_free_buffers(priv);
+	return 0;
+}
+
+/*
+ * DEBUGFS Interface
+ */
+#ifdef CONFIG_DEBUG_FS
+
+/*
+ * Count the number of entries in the given list
+ */
+static unsigned int list_num_entries(struct list_head *list)
+{
+	struct list_head *entry;
+	unsigned int ret = 0;
+
+	list_for_each(entry, list)
+		ret++;
+
+	return ret;
+}
+
+static int data_debug_show(struct seq_file *f, void *offset)
+{
+	struct fpga_device *priv = f-&gt;private;
+	int ret;
+
+	/*
+	 * Lock the mutex first, so that we get an accurate value for enable
+	 * Lock the spinlock next, to get accurate list counts
+	 */
+	ret = mutex_lock_interruptible(&amp;priv-&gt;mutex);
+	if (ret)
+		return ret;
+
+	spin_lock_irq(&amp;priv-&gt;lock);
+
+	seq_printf(f, "enabled: %d\n", priv-&gt;enabled);
+	seq_printf(f, "bufsize: %d\n", priv-&gt;bufsize);
+	seq_printf(f, "num_buffers: %d\n", priv-&gt;num_buffers);
+	seq_printf(f, "num_free: %d\n", list_num_entries(&amp;priv-&gt;free));
+	seq_printf(f, "inflight: %d\n", priv-&gt;inflight != NULL);
+	seq_printf(f, "num_used: %d\n", list_num_entries(&amp;priv-&gt;used));
+	seq_printf(f, "num_dropped: %d\n", priv-&gt;num_dropped);
+
+	spin_unlock_irq(&amp;priv-&gt;lock);
+	mutex_unlock(&amp;priv-&gt;mutex);
+	return 0;
+}
+
+static int data_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, data_debug_show, inode-&gt;i_private);
+}
+
+static const struct file_operations data_debug_fops = {
+	.owner		= THIS_MODULE,
+	.open		= data_debug_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int data_debugfs_init(struct fpga_device *priv)
+{
+	priv-&gt;dbg_entry = debugfs_create_file(drv_name, S_IRUGO, NULL, priv,
+					      &amp;data_debug_fops);
+	if (IS_ERR(priv-&gt;dbg_entry))
+		return PTR_ERR(priv-&gt;dbg_entry);
+
+	return 0;
+}
+
+static void data_debugfs_exit(struct fpga_device *priv)
+{
+	debugfs_remove(priv-&gt;dbg_entry);
+}
+
+#else
+
+static inline int data_debugfs_init(struct fpga_device *priv)
+{
+	return 0;
+}
+
+static inline void data_debugfs_exit(struct fpga_device *priv)
+{
+}
+
+#endif	/* CONFIG_DEBUG_FS */
+
+/*
+ * SYSFS Attributes
+ */
+
+static ssize_t data_en_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct fpga_device *priv = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%u\n", priv-&gt;enabled);
+}
+
+static ssize_t data_en_set(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct fpga_device *priv = dev_get_drvdata(dev);
+	unsigned long enable;
+	int ret;
+
+	ret = strict_strtoul(buf, 0, &amp;enable);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to parse enable input\n");
+		return -EINVAL;
+	}
+
+	ret = mutex_lock_interruptible(&amp;priv-&gt;mutex);
+	if (ret)
+		return ret;
+
+	if (enable)
+		ret = data_device_enable(priv);
+	else
+		ret = data_device_disable(priv);
+
+	if (ret) {
+		dev_err(priv-&gt;dev, "device %s failed\n",
+			enable ? "enable" : "disable");
+		count = ret;
+		goto out_unlock;
+	}
+
+out_unlock:
+	mutex_unlock(&amp;priv-&gt;mutex);
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, data_en_show, data_en_set);
+
+static struct attribute *data_sysfs_attrs[] = {
+	&amp;dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group rt_sysfs_attr_group = {
+	.attrs = data_sysfs_attrs,
+};
+
+/*
+ * FPGA Realtime Data Character Device
+ */
+
+static int data_open(struct inode *inode, struct file *filp)
+{
+	/*
+	 * The miscdevice layer puts our struct miscdevice into the
+	 * filp-&gt;private_data field. We use this to find our private
+	 * data and then overwrite it with our own private structure.
+	 */
+	struct fpga_device *priv = container_of(filp-&gt;private_data,
+						struct fpga_device, miscdev);
+	struct fpga_reader *reader;
+	int ret;
+
+	/* allocate private data */
+	reader = kzalloc(sizeof(*reader), GFP_KERNEL);
+	if (!reader)
+		return -ENOMEM;
+
+	reader-&gt;priv = priv;
+	reader-&gt;buf = NULL;
+
+	filp-&gt;private_data = reader;
+	ret = nonseekable_open(inode, filp);
+	if (ret) {
+		dev_err(priv-&gt;dev, "nonseekable-open failed\n");
+		kfree(reader);
+		return ret;
+	}
+
+	/*
+	 * success, increase the reference count of the private data structure
+	 * so that it doesn't disappear if the device is unbound
+	 */
+	kref_get(&amp;priv-&gt;ref);
+	return 0;
+}
+
+static int data_release(struct inode *inode, struct file *filp)
+{
+	struct fpga_reader *reader = filp-&gt;private_data;
+	struct fpga_device *priv = reader-&gt;priv;
+
+	/* free the per-reader structure */
+	data_free_buffer(reader-&gt;buf);
+	kfree(reader);
+	filp-&gt;private_data = NULL;
+
+	/* decrement our reference count to the private data */
+	kref_put(&amp;priv-&gt;ref, fpga_device_release);
+	return 0;
+}
+
+static ssize_t data_read(struct file *filp, char __user *ubuf, size_t count,
+			 loff_t *f_pos)
+{
+	struct fpga_reader *reader = filp-&gt;private_data;
+	struct fpga_device *priv = reader-&gt;priv;
+	struct list_head *used = &amp;priv-&gt;used;
+	struct data_buf *dbuf;
+	size_t avail;
+	void *data;
+	int ret;
+
+	/* check if we already have a partial buffer */
+	if (reader-&gt;buf) {
+		dbuf = reader-&gt;buf;
+		goto have_buffer;
+	}
+
+	spin_lock_irq(&amp;priv-&gt;lock);
+
+	/* Block until there is at least one buffer on the used list */
+	while (list_empty(used)) {
+		spin_unlock_irq(&amp;priv-&gt;lock);
+
+		if (filp-&gt;f_flags &amp; O_NONBLOCK)
+			return -EAGAIN;
+
+		ret = wait_event_interruptible(priv-&gt;wait, !list_empty(used));
+		if (ret)
+			return ret;
+
+		spin_lock_irq(&amp;priv-&gt;lock);
+	}
+
+	/* Grab the first buffer off of the used list */
+	dbuf = list_first_entry(used, struct data_buf, entry);
+	list_del_init(&amp;dbuf-&gt;entry);
+
+	spin_unlock_irq(&amp;priv-&gt;lock);
+
+	/* Buffers are always mapped: unmap it */
+	videobuf_dma_unmap(priv-&gt;dev, &amp;dbuf-&gt;vb);
+
+	/* save the buffer for later */
+	reader-&gt;buf = dbuf;
+	reader-&gt;buf_start = 0;
+
+have_buffer:
+	/* Get the number of bytes available */
+	avail = dbuf-&gt;size - reader-&gt;buf_start;
+	data = dbuf-&gt;vb.vaddr + reader-&gt;buf_start;
+
+	/* Get the number of bytes we can transfer */
+	count = min(count, avail);
+
+	/* Copy the data to the userspace buffer */
+	if (copy_to_user(ubuf, data, count))
+		return -EFAULT;
+
+	/* Update the amount of available space */
+	avail -= count;
+
+	/*
+	 * If there is still some data available, save the buffer for the
+	 * next userspace call to read() and return
+	 */
+	if (avail &gt; 0) {
+		reader-&gt;buf_start += count;
+		reader-&gt;buf = dbuf;
+		return count;
+	}
+
+	/*
+	 * Get the buffer ready to be reused for DMA
+	 *
+	 * If it fails, we pretend that the read never happed and return
+	 * -EFAULT to userspace. The read will be retried.
+	 */
+	ret = videobuf_dma_map(priv-&gt;dev, &amp;dbuf-&gt;vb);
+	if (ret) {
+		dev_err(priv-&gt;dev, "unable to remap buffer for DMA\n");
+		return -EFAULT;
+	}
+
+	/* Lock against concurrent enable/disable */
+	spin_lock_irq(&amp;priv-&gt;lock);
+
+	/* the reader is finished with this buffer */
+	reader-&gt;buf = NULL;
+
+	/*
+	 * One of two things has happened, the device is disabled, or the
+	 * device has been reconfigured underneath us. In either case, we
+	 * should just throw away the buffer.
+	 */
+	if (!priv-&gt;enabled || dbuf-&gt;size != priv-&gt;bufsize) {
+		videobuf_dma_unmap(priv-&gt;dev, &amp;dbuf-&gt;vb);
+		data_free_buffer(dbuf);
+		goto out_unlock;
+	}
+
+	/* The buffer is safe to reuse, so add it back to the free list */
+	list_add_tail(&amp;dbuf-&gt;entry, &amp;priv-&gt;free);
+
+out_unlock:
+	spin_unlock_irq(&amp;priv-&gt;lock);
+	return count;
+}
+
+static unsigned int data_poll(struct file *filp, struct poll_table_struct *tbl)
+{
+	struct fpga_reader *reader = filp-&gt;private_data;
+	struct fpga_device *priv = reader-&gt;priv;
+	unsigned int mask = 0;
+
+	poll_wait(filp, &amp;priv-&gt;wait, tbl);
+
+	if (!list_empty(&amp;priv-&gt;used))
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static int data_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct fpga_reader *reader = filp-&gt;private_data;
+	struct fpga_device *priv = reader-&gt;priv;
+	unsigned long offset, vsize, psize, addr;
+
+	/* VMA properties */
+	offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
+	vsize = vma-&gt;vm_end - vma-&gt;vm_start;
+	psize = priv-&gt;phys_size - offset;
+	addr = (priv-&gt;phys_addr + offset) &gt;&gt; PAGE_SHIFT;
+
+	/* Check against the FPGA region's physical memory size */
+	if (vsize &gt; psize) {
+		dev_err(priv-&gt;dev, "requested mmap mapping too large\n");
+		return -EINVAL;
+	}
+
+	/* IO memory (stop cacheing) */
+	vma-&gt;vm_flags |= VM_IO | VM_RESERVED;
+	vma-&gt;vm_page_prot = pgprot_noncached(vma-&gt;vm_page_prot);
+
+	return io_remap_pfn_range(vma, vma-&gt;vm_start, addr, vsize,
+				  vma-&gt;vm_page_prot);
+}
+
+static const struct file_operations data_fops = {
+	.owner		= THIS_MODULE,
+	.open		= data_open,
+	.release	= data_release,
+	.read		= data_read,
+	.poll		= data_poll,
+	.mmap		= data_mmap,
+	.llseek		= no_llseek,
+};
+
+/*
+ * OpenFirmware Device Subsystem
+ */
+
+static bool dma_filter(struct dma_chan *chan, void *data)
+{
+	/*
+	 * DMA Channel #0 is used for the FPGA Programmer, so ignore it
+	 *
+	 * This probably won't survive an unload/load cycle of the Freescale
+	 * DMAEngine driver, but that won't be a problem
+	 */
+	if (chan-&gt;chan_id == 0 &amp;&amp; chan-&gt;device-&gt;dev_id == 0)
+		return false;
+
+	return true;
+}
+
+static int data_of_probe(struct platform_device *op,
+			 const struct of_device_id *match)
+{
+	struct device_node *of_node = op-&gt;dev.of_node;
+	struct device *this_device;
+	struct fpga_device *priv;
+	struct resource res;
+	dma_cap_mask_t mask;
+	int ret;
+
+	/* Allocate private data */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&amp;op-&gt;dev, "Unable to allocate device private data\n");
+		ret = -ENOMEM;
+		goto out_return;
+	}
+
+	dev_set_drvdata(&amp;op-&gt;dev, priv);
+	priv-&gt;dev = &amp;op-&gt;dev;
+	kref_init(&amp;priv-&gt;ref);
+	mutex_init(&amp;priv-&gt;mutex);
+
+	dev_set_drvdata(priv-&gt;dev, priv);
+	spin_lock_init(&amp;priv-&gt;lock);
+	INIT_LIST_HEAD(&amp;priv-&gt;free);
+	INIT_LIST_HEAD(&amp;priv-&gt;used);
+	init_waitqueue_head(&amp;priv-&gt;wait);
+
+	/* Setup the misc device */
+	priv-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;
+	priv-&gt;miscdev.name = drv_name;
+	priv-&gt;miscdev.fops = &amp;data_fops;
+
+	/* Get the physical address of the FPGA registers */
+	ret = of_address_to_resource(of_node, 0, &amp;res);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to find FPGA physical address\n");
+		ret = -ENODEV;
+		goto out_free_priv;
+	}
+
+	priv-&gt;phys_addr = res.start;
+	priv-&gt;phys_size = resource_size(&amp;res);
+
+	/* ioremap the registers for use */
+	priv-&gt;regs = of_iomap(of_node, 0);
+	if (!priv-&gt;regs) {
+		dev_err(&amp;op-&gt;dev, "Unable to ioremap registers\n");
+		ret = -ENOMEM;
+		goto out_free_priv;
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+	dma_cap_set(DMA_INTERRUPT, mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_SG, mask);
+
+	/* Request a DMA channel */
+	priv-&gt;chan = dma_request_channel(mask, dma_filter, NULL);
+	if (!priv-&gt;chan) {
+		dev_err(&amp;op-&gt;dev, "Unable to request DMA channel\n");
+		ret = -ENODEV;
+		goto out_unmap_regs;
+	}
+
+	/* Find the correct IRQ number */
+	priv-&gt;irq = irq_of_parse_and_map(of_node, 0);
+	if (priv-&gt;irq == NO_IRQ) {
+		dev_err(&amp;op-&gt;dev, "Unable to find IRQ line\n");
+		ret = -ENODEV;
+		goto out_release_dma;
+	}
+
+	/* Drive the GPIO for FPGA IRQ high (no interrupt) */
+	iowrite32be(IRQ_CORL_DONE, priv-&gt;regs + SYS_IRQ_OUTPUT_DATA);
+
+	/* Register the miscdevice */
+	ret = misc_register(&amp;priv-&gt;miscdev);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to register miscdevice\n");
+		goto out_irq_dispose_mapping;
+	}
+
+	/* Create the debugfs files */
+	ret = data_debugfs_init(priv);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to create debugfs files\n");
+		goto out_misc_deregister;
+	}
+
+	/* Create the sysfs files */
+	this_device = priv-&gt;miscdev.this_device;
+	dev_set_drvdata(this_device, priv);
+	ret = sysfs_create_group(&amp;this_device-&gt;kobj, &amp;rt_sysfs_attr_group);
+	if (ret) {
+		dev_err(&amp;op-&gt;dev, "Unable to create sysfs files\n");
+		goto out_data_debugfs_exit;
+	}
+
+	dev_info(&amp;op-&gt;dev, "CARMA FPGA Realtime Data Driver Loaded\n");
+	return 0;
+
+out_data_debugfs_exit:
+	data_debugfs_exit(priv);
+out_misc_deregister:
+	misc_deregister(&amp;priv-&gt;miscdev);
+out_irq_dispose_mapping:
+	irq_dispose_mapping(priv-&gt;irq);
+out_release_dma:
+	dma_release_channel(priv-&gt;chan);
+out_unmap_regs:
+	iounmap(priv-&gt;regs);
+out_free_priv:
+	kref_put(&amp;priv-&gt;ref, fpga_device_release);
+out_return:
+	return ret;
+}
+
+static int data_of_remove(struct platform_device *op)
+{
+	struct fpga_device *priv = dev_get_drvdata(&amp;op-&gt;dev);
+	struct device *this_device = priv-&gt;miscdev.this_device;
+
+	/* remove all sysfs files, now the device cannot be re-enabled */
+	sysfs_remove_group(&amp;this_device-&gt;kobj, &amp;rt_sysfs_attr_group);
+
+	/* remove all debugfs files */
+	data_debugfs_exit(priv);
+
+	/* disable the device from generating data */
+	data_device_disable(priv);
+
+	/* remove the character device to stop new readers from appearing */
+	misc_deregister(&amp;priv-&gt;miscdev);
+
+	/* cleanup everything not needed by readers */
+	irq_dispose_mapping(priv-&gt;irq);
+	dma_release_channel(priv-&gt;chan);
+	iounmap(priv-&gt;regs);
+
+	/* release our reference */
+	kref_put(&amp;priv-&gt;ref, fpga_device_release);
+	return 0;
+}
+
+static struct of_device_id data_of_match[] = {
+	{ .compatible = "carma,carma-fpga", },
+	{},
+};
+
+static struct of_platform_driver data_of_driver = {
+	.probe		= data_of_probe,
+	.remove		= data_of_remove,
+	.driver		= {
+		.name		= drv_name,
+		.of_match_table	= data_of_match,
+		.owner		= THIS_MODULE,
+	},
+};
+
+/*
+ * Module Init / Exit
+ */
+
+static int __init data_init(void)
+{
+	return of_register_platform_driver(&amp;data_of_driver);
+}
+
+static void __exit data_exit(void)
+{
+	of_unregister_platform_driver(&amp;data_of_driver);
+}
+
+MODULE_AUTHOR("Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;");
+MODULE_DESCRIPTION("CARMA DATA-FPGA Access Driver");
+MODULE_LICENSE("GPL");
+
+module_init(data_init);
+module_exit(data_exit);</pre><hr><pre>commit 8faa7cf828bca1745a4ed599876567f5afc47544
Author: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Apr 7 10:33:03 2011 -0700

    dt/fsldma: fix build warning caused by of_platform_device changes
    
    Commit 000061245a6797d542854106463b6b20fbdcb12e, "dt/powerpc:
    Eliminate users of of_platform_{,un}register_driver" forgot to convert
    the type of structure passed into platform_device_register() when it
    was converted from of_platform_device_register. Fix it.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Grant Likely &lt;grant.likely@secretlab.ca&gt;

diff --git a/drivers/dma/fsldma.c b/drivers/dma/fsldma.c
index 6b396759e7f5..8a781540590c 100644
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@ -1448,7 +1448,7 @@ static const struct of_device_id fsldma_of_ids[] = {
 	{}
 };
 
-static struct of_platform_driver fsldma_of_driver = {
+static struct platform_driver fsldma_of_driver = {
 	.driver = {
 		.name = "fsl-elo-dma",
 		.owner = THIS_MODULE,</pre><hr><pre>commit a00ae34ac8bc8a5897d9b6b9b685c39b955b14b9
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Mar 3 07:55:01 2011 +0000

    fsldma: make halt behave nicely on all supported controllers
    
    The original dma_halt() function set the CA (channel abort) bit on both
    the 83xx and 85xx controllers. This is incorrect on the 83xx, where this
    bit means TEM (transfer error mask) instead. The 83xx doesn't support
    channel abort, so we only do this operation on 85xx.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;

diff --git a/drivers/dma/fsldma.c b/drivers/dma/fsldma.c
index d300de456c90..8670a5012122 100644
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@ -221,13 +221,26 @@ static void dma_halt(struct fsldma_chan *chan)
 	u32 mode;
 	int i;
 
+	/* read the mode register */
 	mode = DMA_IN(chan, &amp;chan-&gt;regs-&gt;mr, 32);
-	mode |= FSL_DMA_MR_CA;
-	DMA_OUT(chan, &amp;chan-&gt;regs-&gt;mr, mode, 32);
 
-	mode &amp;= ~(FSL_DMA_MR_CS | FSL_DMA_MR_EMS_EN | FSL_DMA_MR_CA);
+	/*
+	 * The 85xx controller supports channel abort, which will stop
+	 * the current transfer. On 83xx, this bit is the transfer error
+	 * mask bit, which should not be changed.
+	 */
+	if ((chan-&gt;feature &amp; FSL_DMA_IP_MASK) == FSL_DMA_IP_85XX) {
+		mode |= FSL_DMA_MR_CA;
+		DMA_OUT(chan, &amp;chan-&gt;regs-&gt;mr, mode, 32);
+
+		mode &amp;= ~FSL_DMA_MR_CA;
+	}
+
+	/* stop the DMA controller */
+	mode &amp;= ~(FSL_DMA_MR_CS | FSL_DMA_MR_EMS_EN);
 	DMA_OUT(chan, &amp;chan-&gt;regs-&gt;mr, mode, 32);
 
+	/* wait for the DMA controller to become idle */
 	for (i = 0; i &lt; 100; i++) {
 		if (dma_is_idle(chan))
 			return;</pre><hr><pre>commit dc8d4091575ba81e886ebcdfd1e559c981f82f86
Author: Ira Snyder &lt;iws@ovro.caltech.edu&gt;
Date:   Thu Mar 3 07:55:00 2011 +0000

    fsldma: reduce locking during descriptor cleanup
    
    This merges the fsl_chan_ld_cleanup() function into the dma_do_tasklet()
    function to reduce locking overhead. In the best case, we will be able
    to keep the DMA controller busy while we are freeing used descriptors.
    In all cases, the spinlock is grabbed two times fewer than before on
    each transaction.
    
    Signed-off-by: Ira W. Snyder &lt;iws@ovro.caltech.edu&gt;
    Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;

diff --git a/drivers/dma/fsldma.c b/drivers/dma/fsldma.c
index 526579df6033..d300de456c90 100644
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@ -881,66 +881,16 @@ static void fsldma_cleanup_descriptor(struct fsldma_chan *chan,
 	dma_pool_free(chan-&gt;desc_pool, desc, txd-&gt;phys);
 }
 
-/**
- * fsl_chan_ld_cleanup - Clean up link descriptors
- * @chan : Freescale DMA channel
- *
- * This function is run after the queue of running descriptors has been
- * executed by the DMA engine. It will run any callbacks, and then free
- * the descriptors.
- *
- * HARDWARE STATE: idle
- */
-static void fsl_chan_ld_cleanup(struct fsldma_chan *chan)
-{
-	struct fsl_desc_sw *desc, *_desc;
-	LIST_HEAD(ld_cleanup);
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;chan-&gt;desc_lock, flags);
-
-	/* update the cookie if we have some descriptors to cleanup */
-	if (!list_empty(&amp;chan-&gt;ld_running)) {
-		dma_cookie_t cookie;
-
-		desc = to_fsl_desc(chan-&gt;ld_running.prev);
-		cookie = desc-&gt;async_tx.cookie;
-
-		chan-&gt;completed_cookie = cookie;
-		chan_dbg(chan, "completed cookie=%d\n", cookie);
-	}
-
-	/*
-	 * move the descriptors to a temporary list so we can drop the lock
-	 * during the entire cleanup operation
-	 */
-	list_splice_tail_init(&amp;chan-&gt;ld_running, &amp;ld_cleanup);
-
-	spin_unlock_irqrestore(&amp;chan-&gt;desc_lock, flags);
-
-	/* Run the callback for each descriptor, in order */
-	list_for_each_entry_safe(desc, _desc, &amp;ld_cleanup, node) {
-
-		/* Remove from the list of transactions */
-		list_del(&amp;desc-&gt;node);
-
-		/* Run all cleanup for this descriptor */
-		fsldma_cleanup_descriptor(chan, desc);
-	}
-}
-
 /**
  * fsl_chan_xfer_ld_queue - transfer any pending transactions
  * @chan : Freescale DMA channel
  *
  * HARDWARE STATE: idle
+ * LOCKING: must hold chan-&gt;desc_lock
  */
 static void fsl_chan_xfer_ld_queue(struct fsldma_chan *chan)
 {
 	struct fsl_desc_sw *desc;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;chan-&gt;desc_lock, flags);
 
 	/*
 	 * If the list of pending descriptors is empty, then we
@@ -948,7 +898,7 @@ static void fsl_chan_xfer_ld_queue(struct fsldma_chan *chan)
 	 */
 	if (list_empty(&amp;chan-&gt;ld_pending)) {
 		chan_dbg(chan, "no pending LDs\n");
-		goto out_unlock;
+		return;
 	}
 
 	/*
@@ -958,7 +908,7 @@ static void fsl_chan_xfer_ld_queue(struct fsldma_chan *chan)
 	 */
 	if (!chan-&gt;idle) {
 		chan_dbg(chan, "DMA controller still busy\n");
-		goto out_unlock;
+		return;
 	}
 
 	/*
@@ -996,9 +946,6 @@ static void fsl_chan_xfer_ld_queue(struct fsldma_chan *chan)
 
 	dma_start(chan);
 	chan-&gt;idle = false;
-
-out_unlock:
-	spin_unlock_irqrestore(&amp;chan-&gt;desc_lock, flags);
 }
 
 /**
@@ -1008,7 +955,11 @@ static void fsl_chan_xfer_ld_queue(struct fsldma_chan *chan)
 static void fsl_dma_memcpy_issue_pending(struct dma_chan *dchan)
 {
 	struct fsldma_chan *chan = to_fsl_chan(dchan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;chan-&gt;desc_lock, flags);
 	fsl_chan_xfer_ld_queue(chan);
+	spin_unlock_irqrestore(&amp;chan-&gt;desc_lock, flags);
 }
 
 /**
@@ -1109,20 +1060,53 @@ static irqreturn_t fsldma_chan_irq(int irq, void *data)
 static void dma_do_tasklet(unsigned long data)
 {
 	struct fsldma_chan *chan = (struct fsldma_chan *)data;
+	struct fsl_desc_sw *desc, *_desc;
+	LIST_HEAD(ld_cleanup);
 	unsigned long flags;
 
 	chan_dbg(chan, "tasklet entry\n");
 
-	/* run all callbacks, free all used descriptors */
-	fsl_chan_ld_cleanup(chan);
-
-	/* the channel is now idle */
 	spin_lock_irqsave(&amp;chan-&gt;desc_lock, flags);
+
+	/* update the cookie if we have some descriptors to cleanup */
+	if (!list_empty(&amp;chan-&gt;ld_running)) {
+		dma_cookie_t cookie;
+
+		desc = to_fsl_desc(chan-&gt;ld_running.prev);
+		cookie = desc-&gt;async_tx.cookie;
+
+		chan-&gt;completed_cookie = cookie;
+		chan_dbg(chan, "completed_cookie=%d\n", cookie);
+	}
+
+	/*
+	 * move the descriptors to a temporary list so we can drop the lock
+	 * during the entire cleanup operation
+	 */
+	list_splice_tail_init(&amp;chan-&gt;ld_running, &amp;ld_cleanup);
+
+	/* the hardware is now idle and ready for more */
 	chan-&gt;idle = true;
-	spin_unlock_irqrestore(&amp;chan-&gt;desc_lock, flags);
 
-	/* start any pending transactions automatically */
+	/*
+	 * Start any pending transactions automatically
+	 *
+	 * In the ideal case, we keep the DMA controller busy while we go
+	 * ahead and free the descriptors below.
+	 */
 	fsl_chan_xfer_ld_queue(chan);
+	spin_unlock_irqrestore(&amp;chan-&gt;desc_lock, flags);
+
+	/* Run the callback for each descriptor, in order */
+	list_for_each_entry_safe(desc, _desc, &amp;ld_cleanup, node) {
+
+		/* Remove from the list of transactions */
+		list_del(&amp;desc-&gt;node);
+
+		/* Run all cleanup for this descriptor */
+		fsldma_cleanup_descriptor(chan, desc);
+	}
+
 	chan_dbg(chan, "tasklet exit\n");
 }
 </pre>
    <div class="pagination">
        <a href='16.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><span>[2]</span><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_3.html'>Next&gt;&gt;</a>
    <div>
</body>

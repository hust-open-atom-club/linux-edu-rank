<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Indiana University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Indiana University</h1>
    <div class="pagination">
        <span>[1]</span><a href='30_2.html'>2</a><a href='30_3.html'>3</a><a href='30_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 335ea564509045796dc07faa7333162a0b03f214
Author: Joshua Walgenbach &lt;jjw@iu.edu&gt;
Date:   Wed Oct 21 21:52:46 2015 -0400

    staging: lustre: add in NID range management for libcfs
    
    This is a partial backport of the NID range management
    added in for nodemap. We only backport the libcfs related
    parts here.
    
    Signed-off-by: Joshua Walgenbach &lt;jjw@iu.edu&gt;
    Intel-bug-id: https://jira.hpdd.intel.com/browse/LU-3527
    Reviewed-on: http://review.whamcloud.com/8057
    Reviewed-by: Andreas Dilger &lt;andreas.dilger@intel.com&gt;
    Reviewed-by: Andrew Perepechko &lt;andrew_perepechko@xyratex.com&gt;
    Reviewed-by: John L. Hammond &lt;john.hammond@intel.com&gt;
    Reviewed-by: Ken Hornstein &lt;kenh@cmf.nrl.navy.mil&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/lustre/include/linux/lnet/nidstr.h b/drivers/staging/lustre/include/linux/lnet/nidstr.h
index 15363664eb86..4e7c9a5f9a9b 100644
--- a/drivers/staging/lustre/include/linux/lnet/nidstr.h
+++ b/drivers/staging/lustre/include/linux/lnet/nidstr.h
@@ -89,6 +89,9 @@ struct netstrfns {
 	int	(*nf_print_addrlist)(char *buffer, int count,
 				     struct list_head *list);
 	int	(*nf_match_addr)(__u32 addr, struct list_head *list);
+	bool	(*nf_is_contiguous)(struct list_head *nidlist);
+	void	(*nf_min_max)(struct list_head *nidlist, __u32 *min_nid,
+			      __u32 *max_nid);
 };
 
 #endif /* _LNET_NIDSTRINGS_H */
diff --git a/drivers/staging/lustre/lnet/lnet/nidstrings.c b/drivers/staging/lustre/lnet/lnet/nidstrings.c
index 1874dfebe33f..4402b80c8bf0 100644
--- a/drivers/staging/lustre/lnet/lnet/nidstrings.c
+++ b/drivers/staging/lustre/lnet/lnet/nidstrings.c
@@ -46,6 +46,8 @@
 /* max value for numeric network address */
 #define MAX_NUMERIC_VALUE 0xffffffff
 
+#define IPSTRING_LENGTH 16
+
 /* CAVEAT VENDITOR! Keep the canonical string representation of nets/nids
  * consistent in all conversion functions.  Some code fragments are copied
  * around for the sake of clarity...
@@ -456,6 +458,317 @@ int cfs_print_nidlist(char *buffer, int count, struct list_head *nidlist)
 }
 EXPORT_SYMBOL(cfs_print_nidlist);
 
+/**
+ * Determines minimum and maximum addresses for a single
+ * numeric address range
+ *
+ * \param	ar
+ * \param	min_nid
+ * \param	max_nid
+ */
+static void cfs_ip_ar_min_max(struct addrrange *ar, __u32 *min_nid,
+			      __u32 *max_nid)
+{
+	struct cfs_expr_list *el;
+	struct cfs_range_expr *re;
+	__u32 tmp_ip_addr = 0;
+	unsigned int min_ip[4] = {0};
+	unsigned int max_ip[4] = {0};
+	int re_count = 0;
+
+	list_for_each_entry(el, &amp;ar-&gt;ar_numaddr_ranges, el_link) {
+		list_for_each_entry(re, &amp;el-&gt;el_exprs, re_link) {
+			min_ip[re_count] = re-&gt;re_lo;
+			max_ip[re_count] = re-&gt;re_hi;
+			re_count++;
+		}
+	}
+
+	tmp_ip_addr = ((min_ip[0] &lt;&lt; 24) | (min_ip[1] &lt;&lt; 16) |
+		       (min_ip[2] &lt;&lt; 8) | min_ip[3]);
+
+	if (min_nid != NULL)
+		*min_nid = tmp_ip_addr;
+
+	tmp_ip_addr = ((max_ip[0] &lt;&lt; 24) | (max_ip[1] &lt;&lt; 16) |
+		       (max_ip[2] &lt;&lt; 8) | max_ip[3]);
+
+	if (max_nid != NULL)
+		*max_nid = tmp_ip_addr;
+}
+
+/**
+ * Determines minimum and maximum addresses for a single
+ * numeric address range
+ *
+ * \param	ar
+ * \param	min_nid
+ * \param	max_nid
+ */
+static void cfs_num_ar_min_max(struct addrrange *ar, __u32 *min_nid,
+			       __u32 *max_nid)
+{
+	struct cfs_expr_list *el;
+	struct cfs_range_expr *re;
+	unsigned int min_addr = 0;
+	unsigned int max_addr = 0;
+
+	list_for_each_entry(el, &amp;ar-&gt;ar_numaddr_ranges, el_link) {
+		list_for_each_entry(re, &amp;el-&gt;el_exprs, re_link) {
+			if (re-&gt;re_lo &lt; min_addr || min_addr == 0)
+				min_addr = re-&gt;re_lo;
+			if (re-&gt;re_hi &gt; max_addr)
+				max_addr = re-&gt;re_hi;
+		}
+	}
+
+	if (min_nid != NULL)
+		*min_nid = min_addr;
+	if (max_nid != NULL)
+		*max_nid = max_addr;
+}
+
+/**
+ * Determines whether an expression list in an nidrange contains exactly
+ * one contiguous address range. Calls the correct netstrfns for the LND
+ *
+ * \param	*nidlist
+ *
+ * \retval	true if contiguous
+ * \retval	false if not contiguous
+ */
+bool cfs_nidrange_is_contiguous(struct list_head *nidlist)
+{
+	struct nidrange *nr;
+	struct netstrfns *nf = NULL;
+	char *lndname = NULL;
+	int netnum = -1;
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		nf = nr-&gt;nr_netstrfns;
+		if (lndname == NULL)
+			lndname = nf-&gt;nf_name;
+		if (netnum == -1)
+			netnum = nr-&gt;nr_netnum;
+
+		if (strcmp(lndname, nf-&gt;nf_name) != 0 ||
+		    netnum != nr-&gt;nr_netnum)
+			return false;
+	}
+
+	if (nf == NULL)
+		return false;
+
+	if (!nf-&gt;nf_is_contiguous(nidlist))
+		return false;
+
+	return true;
+}
+EXPORT_SYMBOL(cfs_nidrange_is_contiguous);
+
+/**
+ * Determines whether an expression list in an num nidrange contains exactly
+ * one contiguous address range.
+ *
+ * \param	*nidlist
+ *
+ * \retval	true if contiguous
+ * \retval	false if not contiguous
+ */
+static bool cfs_num_is_contiguous(struct list_head *nidlist)
+{
+	struct nidrange *nr;
+	struct addrrange *ar;
+	struct cfs_expr_list *el;
+	struct cfs_range_expr *re;
+	int last_hi = 0;
+	__u32 last_end_nid = 0;
+	__u32 current_start_nid = 0;
+	__u32 current_end_nid = 0;
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		list_for_each_entry(ar, &amp;nr-&gt;nr_addrranges, ar_link) {
+			cfs_num_ar_min_max(ar, &amp;current_start_nid,
+					   &amp;current_end_nid);
+			if (last_end_nid != 0 &amp;&amp;
+			    (current_start_nid - last_end_nid != 1))
+				return false;
+			last_end_nid = current_end_nid;
+			list_for_each_entry(el, &amp;ar-&gt;ar_numaddr_ranges,
+					    el_link) {
+				list_for_each_entry(re, &amp;el-&gt;el_exprs,
+						    re_link) {
+					if (re-&gt;re_stride &gt; 1)
+						return false;
+					else if (last_hi != 0 &amp;&amp;
+						 re-&gt;re_hi - last_hi != 1)
+						return false;
+					last_hi = re-&gt;re_hi;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Determines whether an expression list in an ip nidrange contains exactly
+ * one contiguous address range.
+ *
+ * \param	*nidlist
+ *
+ * \retval	true if contiguous
+ * \retval	false if not contiguous
+ */
+static bool cfs_ip_is_contiguous(struct list_head *nidlist)
+{
+	struct nidrange *nr;
+	struct addrrange *ar;
+	struct cfs_expr_list *el;
+	struct cfs_range_expr *re;
+	int expr_count;
+	int last_hi = 255;
+	int last_diff = 0;
+	__u32 last_end_nid = 0;
+	__u32 current_start_nid = 0;
+	__u32 current_end_nid = 0;
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		list_for_each_entry(ar, &amp;nr-&gt;nr_addrranges, ar_link) {
+			last_hi = 255;
+			last_diff = 0;
+			cfs_ip_ar_min_max(ar, &amp;current_start_nid,
+					  &amp;current_end_nid);
+			if (last_end_nid != 0 &amp;&amp;
+			    (current_start_nid - last_end_nid != 1))
+				return false;
+			last_end_nid = current_end_nid;
+			list_for_each_entry(el, &amp;ar-&gt;ar_numaddr_ranges,
+					    el_link) {
+				expr_count = 0;
+				list_for_each_entry(re, &amp;el-&gt;el_exprs,
+						    re_link) {
+					expr_count++;
+					if (re-&gt;re_stride &gt; 1 ||
+					    (last_diff &gt; 0 &amp;&amp; last_hi != 255) ||
+					    (last_diff &gt; 0 &amp;&amp; last_hi == 255 &amp;&amp;
+					     re-&gt;re_lo &gt; 0))
+						return false;
+					last_hi = re-&gt;re_hi;
+					last_diff = re-&gt;re_hi - re-&gt;re_lo;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Takes a linked list of nidrange expressions, determines the minimum
+ * and maximum nid and creates appropriate nid structures
+ *
+ * \param	*nidlist
+ * \param	*min_nid
+ * \param	*max_nid
+ */
+void cfs_nidrange_find_min_max(struct list_head *nidlist, char *min_nid,
+			       char *max_nid, size_t nidstr_length)
+{
+	struct nidrange *nr;
+	struct netstrfns *nf = NULL;
+	int netnum = -1;
+	__u32 min_addr;
+	__u32 max_addr;
+	char *lndname = NULL;
+	char min_addr_str[IPSTRING_LENGTH];
+	char max_addr_str[IPSTRING_LENGTH];
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		nf = nr-&gt;nr_netstrfns;
+		lndname = nf-&gt;nf_name;
+		if (netnum == -1)
+			netnum = nr-&gt;nr_netnum;
+
+		nf-&gt;nf_min_max(nidlist, &amp;min_addr, &amp;max_addr);
+	}
+	nf-&gt;nf_addr2str(min_addr, min_addr_str);
+	nf-&gt;nf_addr2str(max_addr, max_addr_str);
+
+	snprintf(min_nid, nidstr_length, "%s@%s%d", min_addr_str, lndname,
+		 netnum);
+	snprintf(max_nid, nidstr_length, "%s@%s%d", max_addr_str, lndname,
+		 netnum);
+}
+EXPORT_SYMBOL(cfs_nidrange_find_min_max);
+
+/**
+ * Determines the min and max NID values for num LNDs
+ *
+ * \param	*nidlist
+ * \param	*min_nid
+ * \param	*max_nid
+ */
+static void cfs_num_min_max(struct list_head *nidlist, __u32 *min_nid,
+			    __u32 *max_nid)
+{
+	struct nidrange	*nr;
+	struct addrrange *ar;
+	unsigned int tmp_min_addr = 0;
+	unsigned int tmp_max_addr = 0;
+	unsigned int min_addr = 0;
+	unsigned int max_addr = 0;
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		list_for_each_entry(ar, &amp;nr-&gt;nr_addrranges, ar_link) {
+			cfs_num_ar_min_max(ar, &amp;tmp_min_addr,
+					   &amp;tmp_max_addr);
+			if (tmp_min_addr &lt; min_addr || min_addr == 0)
+				min_addr = tmp_min_addr;
+			if (tmp_max_addr &gt; max_addr)
+				max_addr = tmp_min_addr;
+		}
+	}
+	*max_nid = max_addr;
+	*min_nid = min_addr;
+}
+
+/**
+ * Takes an nidlist and determines the minimum and maximum
+ * ip addresses.
+ *
+ * \param	*nidlist
+ * \param	*min_nid
+ * \param	*max_nid
+ */
+static void cfs_ip_min_max(struct list_head *nidlist, __u32 *min_nid,
+			   __u32 *max_nid)
+{
+	struct nidrange *nr;
+	struct addrrange *ar;
+	__u32 tmp_min_ip_addr = 0;
+	__u32 tmp_max_ip_addr = 0;
+	__u32 min_ip_addr = 0;
+	__u32 max_ip_addr = 0;
+
+	list_for_each_entry(nr, nidlist, nr_link) {
+		list_for_each_entry(ar, &amp;nr-&gt;nr_addrranges, ar_link) {
+			cfs_ip_ar_min_max(ar, &amp;tmp_min_ip_addr,
+					  &amp;tmp_max_ip_addr);
+			if (tmp_min_ip_addr &lt; min_ip_addr || min_ip_addr == 0)
+				min_ip_addr = tmp_min_ip_addr;
+			if (tmp_max_ip_addr &gt; max_ip_addr)
+				max_ip_addr = tmp_max_ip_addr;
+		}
+	}
+
+	if (min_nid != NULL)
+		*min_nid = min_ip_addr;
+	if (max_nid != NULL)
+		*max_nid = max_ip_addr;
+}
+
 static int
 libcfs_lo_str2addr(const char *str, int nob, __u32 *addr)
 {
@@ -665,7 +978,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_lo_str2addr,
 	 /* .nf_parse_addr*/  libcfs_num_parse,
 	 /* .nf_print_addrlist*/  libcfs_num_addr_range_print,
-	 /* .nf_match_addr*/  libcfs_num_match},
+	 /* .nf_match_addr*/  libcfs_num_match,
+	 /* .nf_is_contiguous */  cfs_num_is_contiguous,
+	 /* .nf_min_max   */      cfs_num_min_max},
 	{/* .nf_type      */  SOCKLND,
 	 /* .nf_name      */  "tcp",
 	 /* .nf_modname   */  "ksocklnd",
@@ -673,7 +988,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  O2IBLND,
 	 /* .nf_name      */  "o2ib",
 	 /* .nf_modname   */  "ko2iblnd",
@@ -681,7 +998,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  CIBLND,
 	 /* .nf_name      */  "cib",
 	 /* .nf_modname   */  "kciblnd",
@@ -689,7 +1008,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  OPENIBLND,
 	 /* .nf_name      */  "openib",
 	 /* .nf_modname   */  "kopeniblnd",
@@ -697,7 +1018,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  IIBLND,
 	 /* .nf_name      */  "iib",
 	 /* .nf_modname   */  "kiiblnd",
@@ -705,7 +1028,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  VIBLND,
 	 /* .nf_name      */  "vib",
 	 /* .nf_modname   */  "kviblnd",
@@ -713,7 +1038,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  RALND,
 	 /* .nf_name      */  "ra",
 	 /* .nf_modname   */  "kralnd",
@@ -721,7 +1048,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  QSWLND,
 	 /* .nf_name      */  "elan",
 	 /* .nf_modname   */  "kqswlnd",
@@ -729,7 +1058,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_num_str2addr,
 	 /* .nf_parse_addrlist*/  libcfs_num_parse,
 	 /* .nf_print_addrlist*/  libcfs_num_addr_range_print,
-	 /* .nf_match_addr*/  libcfs_num_match},
+	 /* .nf_match_addr*/  libcfs_num_match,
+	 /* .nf_is_contiguous */  cfs_num_is_contiguous,
+	 /* .nf_min_max   */      cfs_num_min_max},
 	{/* .nf_type      */  GMLND,
 	 /* .nf_name      */  "gm",
 	 /* .nf_modname   */  "kgmlnd",
@@ -737,7 +1068,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_num_str2addr,
 	 /* .nf_parse_addrlist*/  libcfs_num_parse,
 	 /* .nf_print_addrlist*/  libcfs_num_addr_range_print,
-	 /* .nf_match_addr*/  libcfs_num_match},
+	 /* .nf_match_addr*/  libcfs_num_match,
+	 /* .nf_is_contiguous */  cfs_num_is_contiguous,
+	 /* .nf_min_max   */      cfs_num_min_max},
 	{/* .nf_type      */  MXLND,
 	 /* .nf_name      */  "mx",
 	 /* .nf_modname   */  "kmxlnd",
@@ -745,7 +1078,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_ip_str2addr,
 	 /* .nf_parse_addrlist*/  cfs_ip_addr_parse,
 	 /* .nf_print_addrlist*/  libcfs_ip_addr_range_print,
-	 /* .nf_match_addr*/  cfs_ip_addr_match},
+	 /* .nf_match_addr*/  cfs_ip_addr_match,
+	 /* .nf_is_contiguous */  cfs_ip_is_contiguous,
+         /* .nf_min_max   */      cfs_ip_min_max},
 	{/* .nf_type      */  PTLLND,
 	 /* .nf_name      */  "ptl",
 	 /* .nf_modname   */  "kptllnd",
@@ -753,7 +1088,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_num_str2addr,
 	 /* .nf_parse_addrlist*/  libcfs_num_parse,
 	 /* .nf_print_addrlist*/  libcfs_num_addr_range_print,
-	 /* .nf_match_addr*/  libcfs_num_match},
+	 /* .nf_match_addr*/  libcfs_num_match,
+	 /* .nf_is_contiguous */  cfs_num_is_contiguous,
+	 /* .nf_min_max   */      cfs_num_min_max},
 	{/* .nf_type      */  GNILND,
 	 /* .nf_name      */  "gni",
 	 /* .nf_modname   */  "kgnilnd",
@@ -761,7 +1098,9 @@ static struct netstrfns  libcfs_netstrfns[] = {
 	 /* .nf_str2addr  */  libcfs_num_str2addr,
 	 /* .nf_parse_addrlist*/  libcfs_num_parse,
 	 /* .nf_print_addrlist*/  libcfs_num_addr_range_print,
-	 /* .nf_match_addr*/  libcfs_num_match},
+	 /* .nf_match_addr*/  libcfs_num_match,
+	 /* .nf_is_contiguous */  cfs_num_is_contiguous,
+	 /* .nf_min_max   */      cfs_num_min_max},
 	/* placeholder for net0 alias.  It MUST BE THE LAST ENTRY */
 	{/* .nf_type      */  -1},
 };</pre><hr><pre>commit d0bfef31f4d40888683e801dfd3f7448078d7e2b
Author: Chris Hanna &lt;hannac@iu.edu&gt;
Date:   Wed Jun 3 10:28:26 2015 -0400

    staging: lustre: ptlrpc: clean up whitespace and align function params
    
    Minor changes to remove excessive whitespace and improve
    readability of ptlrpc functions.
    
    Signed-off-by: Chris Hanna &lt;hannac@iu.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/lustre/lustre/ptlrpc/client.c b/drivers/staging/lustre/lustre/ptlrpc/client.c
index 347110e6e822..35ebe0f35bd1 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/client.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/client.c
@@ -57,8 +57,8 @@ void ptlrpc_init_client(int req_portal, int rep_portal, char *name,
 			struct ptlrpc_client *cl)
 {
 	cl-&gt;cli_request_portal = req_portal;
-	cl-&gt;cli_reply_portal   = rep_portal;
-	cl-&gt;cli_name	   = name;
+	cl-&gt;cli_reply_portal = rep_portal;
+	cl-&gt;cli_name = name;
 }
 EXPORT_SYMBOL(ptlrpc_init_client);
 
@@ -68,9 +68,9 @@ EXPORT_SYMBOL(ptlrpc_init_client);
 struct ptlrpc_connection *ptlrpc_uuid_to_connection(struct obd_uuid *uuid)
 {
 	struct ptlrpc_connection *c;
-	lnet_nid_t		self;
-	lnet_process_id_t	 peer;
-	int		       err;
+	lnet_nid_t self;
+	lnet_process_id_t peer;
+	int err;
 
 	/* ptlrpc_uuid_to_peer() initializes its 2nd parameter
 	 * before accessing its values. */
@@ -148,7 +148,7 @@ struct ptlrpc_bulk_desc *ptlrpc_prep_bulk_imp(struct ptlrpc_request *req,
 	desc-&gt;bd_import = class_import_get(imp);
 	desc-&gt;bd_req = req;
 
-	desc-&gt;bd_cbid.cbid_fn  = client_bulk_callback;
+	desc-&gt;bd_cbid.cbid_fn = client_bulk_callback;
 	desc-&gt;bd_cbid.cbid_arg = desc;
 
 	/* This makes req own desc, and free it when she frees herself */
@@ -343,8 +343,8 @@ static int unpack_reply(struct ptlrpc_request *req)
 static int ptlrpc_at_recv_early_reply(struct ptlrpc_request *req)
 {
 	struct ptlrpc_request *early_req;
-	time_t		 olddl;
-	int		    rc;
+	time_t olddl;
+	int rc;
 
 	req-&gt;rq_early = 0;
 	spin_unlock(&amp;req-&gt;rq_lock);
@@ -580,8 +580,8 @@ static int __ptlrpc_request_bufs_pack(struct ptlrpc_request *request,
 				      int count, __u32 *lengths, char **bufs,
 				      struct ptlrpc_cli_ctx *ctx)
 {
-	struct obd_import  *imp = request-&gt;rq_import;
-	int		 rc;
+	struct obd_import *imp = request-&gt;rq_import;
+	int rc;
 
 	if (unlikely(ctx))
 		request-&gt;rq_cli_ctx = sptlrpc_cli_ctx_get(ctx);
@@ -605,10 +605,10 @@ static int __ptlrpc_request_bufs_pack(struct ptlrpc_request *request,
 	request-&gt;rq_type = PTL_RPC_MSG_REQUEST;
 	request-&gt;rq_export = NULL;
 
-	request-&gt;rq_req_cbid.cbid_fn  = request_out_callback;
+	request-&gt;rq_req_cbid.cbid_fn = request_out_callback;
 	request-&gt;rq_req_cbid.cbid_arg = request;
 
-	request-&gt;rq_reply_cbid.cbid_fn  = reply_in_callback;
+	request-&gt;rq_reply_cbid.cbid_fn = reply_in_callback;
 	request-&gt;rq_reply_cbid.cbid_arg = request;
 
 	request-&gt;rq_reply_deadline = 0;
@@ -761,8 +761,8 @@ EXPORT_SYMBOL(ptlrpc_request_alloc);
  * initialize its buffer structure according to capsule template \a format.
  */
 struct ptlrpc_request *ptlrpc_request_alloc_pool(struct obd_import *imp,
-					    struct ptlrpc_request_pool *pool,
-					    const struct req_format *format)
+						 struct ptlrpc_request_pool *pool,
+						 const struct req_format *format)
 {
 	return ptlrpc_request_alloc_internal(imp, pool, format);
 }
@@ -789,11 +789,11 @@ EXPORT_SYMBOL(ptlrpc_request_free);
  * Returns allocated request or NULL on error.
  */
 struct ptlrpc_request *ptlrpc_request_alloc_pack(struct obd_import *imp,
-						const struct req_format *format,
-						__u32 version, int opcode)
+						 const struct req_format *format,
+						 __u32 version, int opcode)
 {
 	struct ptlrpc_request *req = ptlrpc_request_alloc(imp, format);
-	int		    rc;
+	int rc;
 
 	if (req) {
 		rc = ptlrpc_request_pack(req, version, opcode);
@@ -820,7 +820,7 @@ ptlrpc_prep_req_pool(struct obd_import *imp,
 		     struct ptlrpc_request_pool *pool)
 {
 	struct ptlrpc_request *request;
-	int		    rc;
+	int rc;
 
 	request = __ptlrpc_request_alloc(imp, pool);
 	if (!request)
@@ -868,9 +868,9 @@ struct ptlrpc_request_set *ptlrpc_prep_set(void)
 	INIT_LIST_HEAD(&amp;set-&gt;set_new_requests);
 	INIT_LIST_HEAD(&amp;set-&gt;set_cblist);
 	set-&gt;set_max_inflight = UINT_MAX;
-	set-&gt;set_producer     = NULL;
+	set-&gt;set_producer = NULL;
 	set-&gt;set_producer_arg = NULL;
-	set-&gt;set_rc	   = 0;
+	set-&gt;set_rc = 0;
 
 	return set;
 }
@@ -894,9 +894,9 @@ struct ptlrpc_request_set *ptlrpc_prep_fcset(int max, set_producer_func func,
 	if (!set)
 		return NULL;
 
-	set-&gt;set_max_inflight  = max;
-	set-&gt;set_producer      = func;
-	set-&gt;set_producer_arg  = arg;
+	set-&gt;set_max_inflight = max;
+	set-&gt;set_producer = func;
+	set-&gt;set_producer_arg = arg;
 
 	return set;
 }
@@ -912,10 +912,10 @@ EXPORT_SYMBOL(ptlrpc_prep_fcset);
  */
 void ptlrpc_set_destroy(struct ptlrpc_request_set *set)
 {
-	struct list_head       *tmp;
-	struct list_head       *next;
-	int	       expected_phase;
-	int	       n = 0;
+	struct list_head *tmp;
+	struct list_head *next;
+	int expected_phase;
+	int n = 0;
 
 	/* Requests on the set should either all be completed, or all be new */
 	expected_phase = (atomic_read(&amp;set-&gt;set_remaining) == 0) ?
@@ -1013,7 +1013,7 @@ EXPORT_SYMBOL(ptlrpc_set_add_req);
  * Currently only used for ptlrpcd.
  */
 void ptlrpc_set_add_new_req(struct ptlrpcd_ctl *pc,
-			   struct ptlrpc_request *req)
+			    struct ptlrpc_request *req)
 {
 	struct ptlrpc_request_set *set = pc-&gt;pc_set;
 	int count, i;
@@ -1400,7 +1400,7 @@ static int after_reply(struct ptlrpc_request *req)
  */
 static int ptlrpc_send_new_req(struct ptlrpc_request *req)
 {
-	struct obd_import     *imp = req-&gt;rq_import;
+	struct obd_import *imp = req-&gt;rq_import;
 	int rc;
 
 	LASSERT(req-&gt;rq_phase == RQ_PHASE_NEW);
@@ -1669,7 +1669,7 @@ int ptlrpc_check_set(const struct lu_env *env, struct ptlrpc_request_set *set)
 					continue;
 				}
 
-				if (status != 0)  {
+				if (status != 0) {
 					req-&gt;rq_status = status;
 					ptlrpc_rqphase_move(req,
 						RQ_PHASE_INTERPRET);
@@ -1969,8 +1969,8 @@ int ptlrpc_expire_one_request(struct ptlrpc_request *req, int async_unlink)
 int ptlrpc_expired_set(void *data)
 {
 	struct ptlrpc_request_set *set = data;
-	struct list_head		*tmp;
-	time_t		     now = get_seconds();
+	struct list_head *tmp;
+	time_t now = get_seconds();
 
 	LASSERT(set != NULL);
 
@@ -2052,11 +2052,11 @@ EXPORT_SYMBOL(ptlrpc_interrupted_set);
  */
 int ptlrpc_set_next_timeout(struct ptlrpc_request_set *set)
 {
-	struct list_head	    *tmp;
-	time_t		 now = get_seconds();
-	int		    timeout = 0;
+	struct list_head *tmp;
+	time_t now = get_seconds();
+	int timeout = 0;
 	struct ptlrpc_request *req;
-	int		    deadline;
+	int deadline;
 
 	list_for_each(tmp, &amp;set-&gt;set_requests) {
 		req = list_entry(tmp, struct ptlrpc_request, rq_set_chain);
@@ -2105,10 +2105,10 @@ EXPORT_SYMBOL(ptlrpc_set_next_timeout);
  */
 int ptlrpc_set_wait(struct ptlrpc_request_set *set)
 {
-	struct list_head	    *tmp;
+	struct list_head *tmp;
 	struct ptlrpc_request *req;
-	struct l_wait_info     lwi;
-	int		    rc, timeout;
+	struct l_wait_info lwi;
+	int rc, timeout;
 
 	if (set-&gt;set_producer)
 		(void)ptlrpc_set_producer(set);
@@ -2353,8 +2353,8 @@ EXPORT_SYMBOL(ptlrpc_req_xid);
  */
 int ptlrpc_unregister_reply(struct ptlrpc_request *request, int async)
 {
-	int		rc;
-	wait_queue_head_t       *wq;
+	int rc;
+	wait_queue_head_t *wq;
 	struct l_wait_info lwi;
 
 	/*
@@ -2471,7 +2471,7 @@ void ptlrpc_free_committed(struct obd_import *imp)
 {
 	struct ptlrpc_request *req, *saved;
 	struct ptlrpc_request *last_req = NULL; /* temporary fire escape */
-	bool		       skip_committed_list = true;
+	bool skip_committed_list = true;
 
 	LASSERT(imp != NULL);
 	assert_spin_locked(&amp;imp-&gt;imp_lock);
@@ -3023,8 +3023,8 @@ EXPORT_SYMBOL(ptlrpc_sample_next_xid);
  *    have delay before it really runs by ptlrpcd thread.
  */
 struct ptlrpc_work_async_args {
-	int   (*cb)(const struct lu_env *, void *);
-	void   *cbdata;
+	int (*cb)(const struct lu_env *, void *);
+	void *cbdata;
 };
 
 static void ptlrpcd_add_work_req(struct ptlrpc_request *req)
@@ -3113,7 +3113,7 @@ void *ptlrpcd_alloc_work(struct obd_import *imp,
 
 	CLASSERT(sizeof(*args) &lt;= sizeof(req-&gt;rq_async_args));
 	args = ptlrpc_req_async_args(req);
-	args-&gt;cb     = cb;
+	args-&gt;cb = cb;
 	args-&gt;cbdata = cbdata;
 
 	return req;
diff --git a/drivers/staging/lustre/lustre/ptlrpc/events.c b/drivers/staging/lustre/lustre/ptlrpc/events.c
index 7f8644e01112..8cb1929fd31d 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/events.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/events.c
@@ -53,7 +53,7 @@ lnet_handle_eq_t   ptlrpc_eq_h;
  */
 void request_out_callback(lnet_event_t *ev)
 {
-	struct ptlrpc_cb_id   *cbid = ev-&gt;md.user_ptr;
+	struct ptlrpc_cb_id *cbid = ev-&gt;md.user_ptr;
 	struct ptlrpc_request *req = cbid-&gt;cbid_arg;
 
 	LASSERT(ev-&gt;type == LNET_EVENT_SEND ||
@@ -86,7 +86,7 @@ void request_out_callback(lnet_event_t *ev)
  */
 void reply_in_callback(lnet_event_t *ev)
 {
-	struct ptlrpc_cb_id   *cbid = ev-&gt;md.user_ptr;
+	struct ptlrpc_cb_id *cbid = ev-&gt;md.user_ptr;
 	struct ptlrpc_request *req = cbid-&gt;cbid_arg;
 
 	DEBUG_REQ(D_NET, req, "type %d, status %d", ev-&gt;type, ev-&gt;status);
@@ -172,9 +172,9 @@ void reply_in_callback(lnet_event_t *ev)
  */
 void client_bulk_callback(lnet_event_t *ev)
 {
-	struct ptlrpc_cb_id     *cbid = ev-&gt;md.user_ptr;
+	struct ptlrpc_cb_id *cbid = ev-&gt;md.user_ptr;
 	struct ptlrpc_bulk_desc *desc = cbid-&gt;cbid_arg;
-	struct ptlrpc_request   *req;
+	struct ptlrpc_request *req;
 
 	LASSERT((desc-&gt;bd_type == BULK_PUT_SINK &amp;&amp;
 		 ev-&gt;type == LNET_EVENT_PUT) ||
@@ -245,9 +245,9 @@ void client_bulk_callback(lnet_event_t *ev)
 static void ptlrpc_req_add_history(struct ptlrpc_service_part *svcpt,
 				   struct ptlrpc_request *req)
 {
-	__u64	sec = req-&gt;rq_arrival_time.tv_sec;
-	__u32	usec = req-&gt;rq_arrival_time.tv_usec &gt;&gt; 4; /* usec / 16 */
-	__u64	new_seq;
+	__u64 sec = req-&gt;rq_arrival_time.tv_sec;
+	__u32 usec = req-&gt;rq_arrival_time.tv_usec &gt;&gt; 4; /* usec / 16 */
+	__u64 new_seq;
 
 	/* set sequence ID for request and add it to history list,
 	 * it must be called with hold svcpt::scp_lock */
@@ -281,11 +281,11 @@ static void ptlrpc_req_add_history(struct ptlrpc_service_part *svcpt,
  */
 void request_in_callback(lnet_event_t *ev)
 {
-	struct ptlrpc_cb_id		  *cbid = ev-&gt;md.user_ptr;
+	struct ptlrpc_cb_id *cbid = ev-&gt;md.user_ptr;
 	struct ptlrpc_request_buffer_desc *rqbd = cbid-&gt;cbid_arg;
-	struct ptlrpc_service_part	  *svcpt = rqbd-&gt;rqbd_svcpt;
-	struct ptlrpc_service	     *service = svcpt-&gt;scp_service;
-	struct ptlrpc_request	     *req;
+	struct ptlrpc_service_part *svcpt = rqbd-&gt;rqbd_svcpt;
+	struct ptlrpc_service *service = svcpt-&gt;scp_service;
+	struct ptlrpc_request *req;
 
 	LASSERT(ev-&gt;type == LNET_EVENT_PUT ||
 		ev-&gt;type == LNET_EVENT_UNLINK);
@@ -380,7 +380,7 @@ void request_in_callback(lnet_event_t *ev)
  */
 void reply_out_callback(lnet_event_t *ev)
 {
-	struct ptlrpc_cb_id	  *cbid = ev-&gt;md.user_ptr;
+	struct ptlrpc_cb_id *cbid = ev-&gt;md.user_ptr;
 	struct ptlrpc_reply_state *rs = cbid-&gt;cbid_arg;
 	struct ptlrpc_service_part *svcpt = rs-&gt;rs_svcpt;
 
@@ -433,17 +433,17 @@ static void ptlrpc_master_callback(lnet_event_t *ev)
 }
 
 int ptlrpc_uuid_to_peer(struct obd_uuid *uuid,
-			 lnet_process_id_t *peer, lnet_nid_t *self)
+			lnet_process_id_t *peer, lnet_nid_t *self)
 {
-	int	       best_dist = 0;
-	__u32	     best_order = 0;
-	int	       count = 0;
-	int	       rc = -ENOENT;
-	int	       portals_compatibility;
-	int	       dist;
-	__u32	     order;
-	lnet_nid_t	dst_nid;
-	lnet_nid_t	src_nid;
+	int best_dist = 0;
+	__u32 best_order = 0;
+	int count = 0;
+	int rc = -ENOENT;
+	int portals_compatibility;
+	int dist;
+	__u32 order;
+	lnet_nid_t dst_nid;
+	lnet_nid_t src_nid;
 
 	portals_compatibility = LNetCtl(IOC_LIBCFS_PORTALS_COMPATIBILITY, NULL);
 
@@ -487,10 +487,10 @@ int ptlrpc_uuid_to_peer(struct obd_uuid *uuid,
 
 void ptlrpc_ni_fini(void)
 {
-	wait_queue_head_t	 waitq;
-	struct l_wait_info  lwi;
-	int		 rc;
-	int		 retries;
+	wait_queue_head_t waitq;
+	struct l_wait_info lwi;
+	int rc;
+	int retries;
 
 	/* Wait for the event queue to become idle since there may still be
 	 * messages in flight with pending events (i.e. the fire-and-forget
@@ -523,7 +523,7 @@ void ptlrpc_ni_fini(void)
 
 lnet_pid_t ptl_get_pid(void)
 {
-	lnet_pid_t	pid;
+	lnet_pid_t pid;
 
 	pid = LUSTRE_SRV_LNET_PID;
 	return pid;
@@ -531,8 +531,8 @@ lnet_pid_t ptl_get_pid(void)
 
 int ptlrpc_ni_init(void)
 {
-	int	      rc;
-	lnet_pid_t       pid;
+	int rc;
+	lnet_pid_t pid;
 
 	pid = ptl_get_pid();
 	CDEBUG(D_NET, "My pid is: %x\n", pid);
@@ -563,7 +563,7 @@ int ptlrpc_ni_init(void)
 
 int ptlrpc_init_portals(void)
 {
-	int   rc = ptlrpc_ni_init();
+	int rc = ptlrpc_ni_init();
 
 	if (rc != 0) {
 		CERROR("network initialisation failed\n");
diff --git a/drivers/staging/lustre/lustre/ptlrpc/import.c b/drivers/staging/lustre/lustre/ptlrpc/import.c
index d5fc689c008b..c9b8481dd384 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/import.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/import.c
@@ -119,7 +119,7 @@ int ptlrpc_init_import(struct obd_import *imp)
 	spin_lock(&amp;imp-&gt;imp_lock);
 
 	imp-&gt;imp_generation++;
-	imp-&gt;imp_state =  LUSTRE_IMP_NEW;
+	imp-&gt;imp_state = LUSTRE_IMP_NEW;
 
 	spin_unlock(&amp;imp-&gt;imp_lock);
 
@@ -369,7 +369,7 @@ void ptlrpc_invalidate_import(struct obd_import *imp)
 						   imp_unregistering));
 			}
 			spin_unlock(&amp;imp-&gt;imp_lock);
-		  }
+		}
 	} while (rc != 0);
 
 	/*
@@ -559,7 +559,7 @@ static int import_select_connection(struct obd_import *imp)
 		ptlrpc_connection_put(imp-&gt;imp_connection);
 	imp-&gt;imp_connection = ptlrpc_connection_addref(imp_conn-&gt;oic_conn);
 
-	dlmexp =  class_conn2export(&amp;imp-&gt;imp_dlm_handle);
+	dlmexp = class_conn2export(&amp;imp-&gt;imp_dlm_handle);
 	LASSERT(dlmexp != NULL);
 	if (dlmexp-&gt;exp_connection)
 		ptlrpc_connection_put(dlmexp-&gt;exp_connection);
@@ -1490,7 +1490,7 @@ int ptlrpc_disconnect_import(struct obd_import *imp, int noclose)
 					INITIAL_CONNECT_TIMEOUT);
 
 		IMPORT_SET_STATE(imp, LUSTRE_IMP_CONNECTING);
-		req-&gt;rq_send_state =  LUSTRE_IMP_CONNECTING;
+		req-&gt;rq_send_state = LUSTRE_IMP_CONNECTING;
 		ptlrpc_request_set_replen(req);
 		rc = ptlrpc_queue_wait(req);
 		ptlrpc_req_finished(req);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/layout.c b/drivers/staging/lustre/lustre/ptlrpc/layout.c
index a42335e26de9..d14c20008850 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/layout.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/layout.c
@@ -807,11 +807,11 @@ struct req_capsule;
 /*
  * Request fields.
  */
-#define DEFINE_MSGF(name, flags, size, swabber, dumper) {       \
-	.rmf_name    = (name),				  \
-	.rmf_flags   = (flags),				 \
-	.rmf_size    = (size),				  \
-	.rmf_swabber = (void (*)(void *))(swabber),	      \
+#define DEFINE_MSGF(name, flags, size, swabber, dumper) {	\
+	.rmf_name    = (name),					\
+	.rmf_flags   = (flags),					\
+	.rmf_size    = (size),					\
+	.rmf_swabber = (void (*)(void *))(swabber),		\
 	.rmf_dumper  = (void (*)(void *))(dumper)		\
 }
 
@@ -1164,25 +1164,25 @@ EXPORT_SYMBOL(RMF_SWAP_LAYOUTS);
 
 struct req_format {
 	const char *rf_name;
-	int	 rf_idx;
+	int rf_idx;
 	struct {
-		int			  nr;
+		int nr;
 		const struct req_msg_field **d;
 	} rf_fields[RCL_NR];
 };
 
-#define DEFINE_REQ_FMT(name, client, client_nr, server, server_nr) {    \
-	.rf_name   = name,					      \
-	.rf_fields = {						  \
+#define DEFINE_REQ_FMT(name, client, client_nr, server, server_nr) {	\
+	.rf_name = name,						\
+	.rf_fields = {							\
 		[RCL_CLIENT] = {					\
 			.nr = client_nr,				\
-			.d  = client				    \
-		},						      \
+			.d = client					\
+		},							\
 		[RCL_SERVER] = {					\
 			.nr = server_nr,				\
-			.d  = server				    \
-		}						       \
-	}							       \
+			.d = server					\
+		}							\
+	}								\
 }
 
 #define DEFINE_REQ_FMT0(name, client, server)				  \
@@ -1769,10 +1769,10 @@ EXPORT_SYMBOL(req_capsule_set);
  * field of a \a pill's \a rc_fmt's RMF's.
  */
 int req_capsule_filled_sizes(struct req_capsule *pill,
-			   enum req_location loc)
+			     enum req_location loc)
 {
 	const struct req_format *fmt = pill-&gt;rc_fmt;
-	int		      i;
+	int i;
 
 	LASSERT(fmt != NULL);
 
@@ -1806,8 +1806,8 @@ EXPORT_SYMBOL(req_capsule_filled_sizes);
 int req_capsule_server_pack(struct req_capsule *pill)
 {
 	const struct req_format *fmt;
-	int		      count;
-	int		      rc;
+	int count;
+	int rc;
 
 	LASSERT(pill-&gt;rc_loc == RCL_SERVER);
 	fmt = pill-&gt;rc_fmt;
@@ -1857,11 +1857,11 @@ swabber_dumper_helper(struct req_capsule *pill,
 		      int offset,
 		      void *value, int len, int dump, void (*swabber)(void *))
 {
-	void    *p;
-	int     i;
-	int     n;
-	int     do_swab;
-	int     inout = loc == RCL_CLIENT;
+	void *p;
+	int i;
+	int n;
+	int do_swab;
+	int inout = loc == RCL_CLIENT;
 
 	swabber = swabber ?: field-&gt;rmf_swabber;
 
@@ -1936,10 +1936,10 @@ static void *__req_capsule_get(struct req_capsule *pill,
 			       int dump)
 {
 	const struct req_format *fmt;
-	struct lustre_msg       *msg;
-	void		    *value;
-	int		      len;
-	int		      offset;
+	struct lustre_msg *msg;
+	void *value;
+	int len;
+	int offset;
 
 	void *(*getter)(struct lustre_msg *m, int n, int minlen);
 
@@ -2000,10 +2000,10 @@ static void *__req_capsule_get(struct req_capsule *pill,
  */
 static void __req_capsule_dump(struct req_capsule *pill, enum req_location loc)
 {
-	const struct    req_format *fmt;
-	const struct    req_msg_field *field;
-	int	     len;
-	int	     i;
+	const struct req_format *fmt;
+	const struct req_msg_field *field;
+	int len;
+	int i;
 
 	fmt = pill-&gt;rc_fmt;
 
@@ -2350,9 +2350,9 @@ void req_capsule_shrink(struct req_capsule *pill,
 			enum req_location loc)
 {
 	const struct req_format *fmt;
-	struct lustre_msg       *msg;
-	int		      len;
-	int		      offset;
+	struct lustre_msg *msg;
+	int len;
+	int offset;
 
 	fmt = pill-&gt;rc_fmt;
 	LASSERT(fmt != NULL);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/llog_client.c b/drivers/staging/lustre/lustre/ptlrpc/llog_client.c
index e9baf5bbee3a..1c701e0a0bc7 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/llog_client.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/llog_client.c
@@ -49,29 +49,29 @@
 #include "../include/lustre_net.h"
 #include &lt;linux/list.h&gt;
 
-#define LLOG_CLIENT_ENTRY(ctxt, imp) do {			     \
-	mutex_lock(&amp;ctxt-&gt;loc_mutex);			     \
-	if (ctxt-&gt;loc_imp) {					  \
-		imp = class_import_get(ctxt-&gt;loc_imp);		\
-	} else {						      \
-		CERROR("ctxt-&gt;loc_imp == NULL for context idx %d."    \
-		       "Unable to complete MDS/OSS recovery,"	 \
-		       "but I'll try again next time.  Not fatal.\n", \
-		       ctxt-&gt;loc_idx);				\
-		imp = NULL;					   \
-		mutex_unlock(&amp;ctxt-&gt;loc_mutex);		   \
-		return (-EINVAL);				     \
-	}							     \
-	mutex_unlock(&amp;ctxt-&gt;loc_mutex);			   \
+#define LLOG_CLIENT_ENTRY(ctxt, imp) do {				\
+	mutex_lock(&amp;ctxt-&gt;loc_mutex);					\
+	if (ctxt-&gt;loc_imp) {						\
+		imp = class_import_get(ctxt-&gt;loc_imp);			\
+	} else {							\
+		CERROR("ctxt-&gt;loc_imp == NULL for context idx %d."	\
+		       "Unable to complete MDS/OSS recovery,"		\
+		       "but I'll try again next time.  Not fatal.\n",	\
+		       ctxt-&gt;loc_idx);					\
+		imp = NULL;						\
+		mutex_unlock(&amp;ctxt-&gt;loc_mutex);				\
+		return (-EINVAL);					\
+	}								\
+	mutex_unlock(&amp;ctxt-&gt;loc_mutex);					\
 } while (0)
 
-#define LLOG_CLIENT_EXIT(ctxt, imp) do {			      \
-	mutex_lock(&amp;ctxt-&gt;loc_mutex);			     \
-	if (ctxt-&gt;loc_imp != imp)				     \
-		CWARN("loc_imp has changed from %p to %p\n",	  \
-		       ctxt-&gt;loc_imp, imp);			   \
-	class_import_put(imp);					\
-	mutex_unlock(&amp;ctxt-&gt;loc_mutex);			   \
+#define LLOG_CLIENT_EXIT(ctxt, imp) do {				\
+	mutex_lock(&amp;ctxt-&gt;loc_mutex);					\
+	if (ctxt-&gt;loc_imp != imp)					\
+		CWARN("loc_imp has changed from %p to %p\n",		\
+		       ctxt-&gt;loc_imp, imp);				\
+	class_import_put(imp);						\
+	mutex_unlock(&amp;ctxt-&gt;loc_mutex);					\
 } while (0)
 
 /* This is a callback from the llog_* functions.
@@ -80,11 +80,11 @@ static int llog_client_open(const struct lu_env *env,
 			    struct llog_handle *lgh, struct llog_logid *logid,
 			    char *name, enum llog_open_param open_param)
 {
-	struct obd_import     *imp;
-	struct llogd_body     *body;
-	struct llog_ctxt      *ctxt = lgh-&gt;lgh_ctxt;
+	struct obd_import *imp;
+	struct llogd_body *body;
+	struct llog_ctxt *ctxt = lgh-&gt;lgh_ctxt;
 	struct ptlrpc_request *req = NULL;
-	int		    rc;
+	int rc;
 
 	LLOG_CLIENT_ENTRY(ctxt, imp);
 
@@ -145,10 +145,10 @@ static int llog_client_open(const struct lu_env *env,
 static int llog_client_destroy(const struct lu_env *env,
 			       struct llog_handle *loghandle)
 {
-	struct obd_import     *imp;
+	struct obd_import *imp;
 	struct ptlrpc_request *req = NULL;
-	struct llogd_body     *body;
-	int		    rc;
+	struct llogd_body *body;
+	int rc;
 
 	LLOG_CLIENT_ENTRY(loghandle-&gt;lgh_ctxt, imp);
 	req = ptlrpc_request_alloc_pack(imp, &amp;RQF_LLOG_ORIGIN_HANDLE_DESTROY,
@@ -182,11 +182,11 @@ static int llog_client_next_block(const struct lu_env *env,
 				  int *cur_idx, int next_idx,
 				  __u64 *cur_offset, void *buf, int len)
 {
-	struct obd_import     *imp;
+	struct obd_import *imp;
 	struct ptlrpc_request *req = NULL;
-	struct llogd_body     *body;
-	void		  *ptr;
-	int		    rc;
+	struct llogd_body *body;
+	void *ptr;
+	int rc;
 
 	LLOG_CLIENT_ENTRY(loghandle-&gt;lgh_ctxt, imp);
 	req = ptlrpc_request_alloc_pack(imp, &amp;RQF_LLOG_ORIGIN_HANDLE_NEXT_BLOCK,
@@ -240,11 +240,11 @@ static int llog_client_prev_block(const struct lu_env *env,
 				  struct llog_handle *loghandle,
 				  int prev_idx, void *buf, int len)
 {
-	struct obd_import     *imp;
+	struct obd_import *imp;
 	struct ptlrpc_request *req = NULL;
-	struct llogd_body     *body;
-	void		  *ptr;
-	int		    rc;
+	struct llogd_body *body;
+	void *ptr;
+	int rc;
 
 	LLOG_CLIENT_ENTRY(loghandle-&gt;lgh_ctxt, imp);
 	req = ptlrpc_request_alloc_pack(imp, &amp;RQF_LLOG_ORIGIN_HANDLE_PREV_BLOCK,
@@ -292,12 +292,12 @@ static int llog_client_prev_block(const struct lu_env *env,
 static int llog_client_read_header(const struct lu_env *env,
 				   struct llog_handle *handle)
 {
-	struct obd_import     *imp;
+	struct obd_import *imp;
 	struct ptlrpc_request *req = NULL;
-	struct llogd_body     *body;
-	struct llog_log_hdr   *hdr;
-	struct llog_rec_hdr   *llh_hdr;
-	int		    rc;
+	struct llogd_body *body;
+	struct llog_log_hdr *hdr;
+	struct llog_rec_hdr *llh_hdr;
+	int rc;
 
 	LLOG_CLIENT_ENTRY(handle-&gt;lgh_ctxt, imp);
 	req = ptlrpc_request_alloc_pack(imp, &amp;RQF_LLOG_ORIGIN_HANDLE_READ_HEADER,
diff --git a/drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c b/drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c
index 1362160983a9..c04ae50c2c29 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/lproc_ptlrpc.c
@@ -261,8 +261,8 @@ ptlrpc_lprocfs_req_history_len_seq_show(struct seq_file *m, void *v)
 {
 	struct ptlrpc_service *svc = m-&gt;private;
 	struct ptlrpc_service_part *svcpt;
-	int	total = 0;
-	int	i;
+	int total = 0;
+	int i;
 
 	ptlrpc_service_for_each_part(svcpt, i, svc)
 		total += svcpt-&gt;scp_hist_nrqbds;
@@ -277,8 +277,8 @@ ptlrpc_lprocfs_req_history_max_seq_show(struct seq_file *m, void *n)
 {
 	struct ptlrpc_service *svc = m-&gt;private;
 	struct ptlrpc_service_part *svcpt;
-	int	total = 0;
-	int	i;
+	int total = 0;
+	int i;
 
 	ptlrpc_service_for_each_part(svcpt, i, svc)
 		total += svc-&gt;srv_hist_nrqbds_cpt_max;
@@ -289,13 +289,13 @@ ptlrpc_lprocfs_req_history_max_seq_show(struct seq_file *m, void *n)
 
 static ssize_t
 ptlrpc_lprocfs_req_history_max_seq_write(struct file *file,
-					const char __user *buffer,
-					size_t count, loff_t *off)
+					 const char __user *buffer,
+					 size_t count, loff_t *off)
 {
 	struct ptlrpc_service *svc = ((struct seq_file *)file-&gt;private_data)-&gt;private;
-	int			    bufpages;
-	int			    val;
-	int			    rc;
+	int bufpages;
+	int val;
+	int rc;
 
 	rc = lprocfs_write_helper(buffer, count, &amp;val);
 	if (rc &lt; 0)
@@ -478,17 +478,17 @@ void nrs_policy_get_info_locked(struct ptlrpc_nrs_policy *policy,
  */
 static int ptlrpc_lprocfs_nrs_seq_show(struct seq_file *m, void *n)
 {
-	struct ptlrpc_service	       *svc = m-&gt;private;
-	struct ptlrpc_service_part     *svcpt;
-	struct ptlrpc_nrs	       *nrs;
-	struct ptlrpc_nrs_policy       *policy;
-	struct ptlrpc_nrs_pol_info     *infos;
-	struct ptlrpc_nrs_pol_info	tmp;
-	unsigned			num_pols;
-	unsigned			pol_idx = 0;
-	bool				hp = false;
-	int				i;
-	int				rc = 0;
+	struct ptlrpc_service *svc = m-&gt;private;
+	struct ptlrpc_service_part *svcpt;
+	struct ptlrpc_nrs *nrs;
+	struct ptlrpc_nrs_policy *policy;
+	struct ptlrpc_nrs_pol_info *infos;
+	struct ptlrpc_nrs_pol_info tmp;
+	unsigned num_pols;
+	unsigned pol_idx = 0;
+	bool hp = false;
+	int i;
+	int rc = 0;
 
 	/**
 	 * Serialize NRS core lprocfs operations with policy registration/
@@ -638,15 +638,15 @@ static int ptlrpc_lprocfs_nrs_seq_show(struct seq_file *m, void *n)
  * regular and high-priority (if the service has one) NRS head.
  */
 static ssize_t ptlrpc_lprocfs_nrs_seq_write(struct file *file,
-					const char __user *buffer,
-					size_t count, loff_t *off)
+					    const char __user *buffer,
+					    size_t count, loff_t *off)
 {
 	struct ptlrpc_service *svc = ((struct seq_file *)file-&gt;private_data)-&gt;private;
-	enum ptlrpc_nrs_queue_type	queue = PTLRPC_NRS_QUEUE_BOTH;
-	char			       *cmd;
-	char			       *cmd_copy = NULL;
-	char			       *token;
-	int				rc = 0;
+	enum ptlrpc_nrs_queue_type queue = PTLRPC_NRS_QUEUE_BOTH;
+	char *cmd;
+	char *cmd_copy = NULL;
+	char *token;
+	int rc = 0;
 
 	if (count &gt;= LPROCFS_NRS_WR_MAX_CMD)
 		return -EINVAL;
@@ -729,8 +729,8 @@ ptlrpc_lprocfs_svc_req_history_seek(struct ptlrpc_service_part *svcpt,
 				    struct ptlrpc_srh_iterator *srhi,
 				    __u64 seq)
 {
-	struct list_head		*e;
-	struct ptlrpc_request	*req;
+	struct list_head *e;
+	struct ptlrpc_request *req;
 
 	if (srhi-&gt;srhi_req != NULL &amp;&amp;
 	    srhi-&gt;srhi_seq &gt; svcpt-&gt;scp_hist_seq_culled &amp;&amp;
@@ -860,12 +860,12 @@ static void *
 ptlrpc_lprocfs_svc_req_history_next(struct seq_file *s,
 				    void *iter, loff_t *pos)
 {
-	struct ptlrpc_service		*svc = s-&gt;private;
-	struct ptlrpc_srh_iterator	*srhi = iter;
-	struct ptlrpc_service_part	*svcpt;
-	__u64				seq;
-	int				rc;
-	int				i;
+	struct ptlrpc_service *svc = s-&gt;private;
+	struct ptlrpc_srh_iterator *srhi = iter;
+	struct ptlrpc_service_part *svcpt;
+	__u64 seq;
+	int rc;
+	int i;
 
 	for (i = srhi-&gt;srhi_idx; i &lt; svc-&gt;srv_ncpts; i++) {
 		svcpt = svc-&gt;srv_parts[i];
@@ -923,11 +923,11 @@ EXPORT_SYMBOL(target_print_req);
 
 static int ptlrpc_lprocfs_svc_req_history_show(struct seq_file *s, void *iter)
 {
-	struct ptlrpc_service		*svc = s-&gt;private;
-	struct ptlrpc_srh_iterator	*srhi = iter;
-	struct ptlrpc_service_part	*svcpt;
-	struct ptlrpc_request		*req;
-	int				rc;
+	struct ptlrpc_service *svc = s-&gt;private;
+	struct ptlrpc_srh_iterator *srhi = iter;
+	struct ptlrpc_service_part *svcpt;
+	struct ptlrpc_request *req;
+	int rc;
 
 	LASSERT(srhi-&gt;srhi_idx &lt; svc-&gt;srv_ncpts);
 
@@ -972,8 +972,8 @@ ptlrpc_lprocfs_svc_req_history_open(struct inode *inode, struct file *file)
 		.next  = ptlrpc_lprocfs_svc_req_history_next,
 		.show  = ptlrpc_lprocfs_svc_req_history_show,
 	};
-	struct seq_file       *seqf;
-	int		    rc;
+	struct seq_file *seqf;
+	int rc;
 
 	rc = seq_open(file, &amp;sops);
 	if (rc)
@@ -987,13 +987,13 @@ ptlrpc_lprocfs_svc_req_history_open(struct inode *inode, struct file *file)
 /* See also lprocfs_rd_timeouts */
 static int ptlrpc_lprocfs_timeouts_seq_show(struct seq_file *m, void *n)
 {
-	struct ptlrpc_service		*svc = m-&gt;private;
-	struct ptlrpc_service_part	*svcpt;
-	struct dhms			ts;
-	time_t				worstt;
-	unsigned int			cur;
-	unsigned int			worst;
-	int				i;
+	struct ptlrpc_service *svc = m-&gt;private;
+	struct ptlrpc_service_part *svcpt;
+	struct dhms ts;
+	time_t worstt;
+	unsigned int cur;
+	unsigned int worst;
+	int i;
 
 	if (AT_OFF) {
 		seq_printf(m, "adaptive timeouts off, using obd_timeout %u\n",
@@ -1215,8 +1215,8 @@ int lprocfs_wr_evict_client(struct file *file, const char __user *buffer,
 			    size_t count, loff_t *off)
 {
 	struct obd_device *obd = ((struct seq_file *)file-&gt;private_data)-&gt;private;
-	char	      *kbuf;
-	char	      *tmpbuf;
+	char *kbuf;
+	char *tmpbuf;
 
 	kbuf = kzalloc(BUFLEN, GFP_NOFS);
 	if (kbuf == NULL)
@@ -1264,7 +1264,7 @@ int lprocfs_wr_ping(struct file *file, const char __user *buffer,
 {
 	struct obd_device *obd = ((struct seq_file *)file-&gt;private_data)-&gt;private;
 	struct ptlrpc_request *req;
-	int		    rc;
+	int rc;
 
 	LPROCFS_CLIMP_CHECK(obd);
 	req = ptlrpc_prep_ping(obd-&gt;u.cli.cl_import);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/niobuf.c b/drivers/staging/lustre/lustre/ptlrpc/niobuf.c
index 2fa2585584a3..92c746b44462 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/niobuf.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/niobuf.c
@@ -52,17 +52,17 @@ static int ptl_send_buf(lnet_handle_md_t *mdh, void *base, int len,
 			struct ptlrpc_connection *conn, int portal, __u64 xid,
 			unsigned int offset)
 {
-	int	      rc;
-	lnet_md_t	 md;
+	int rc;
+	lnet_md_t md;
 
 	LASSERT(portal != 0);
 	LASSERT(conn != NULL);
 	CDEBUG(D_INFO, "conn=%p id %s\n", conn, libcfs_id2str(conn-&gt;c_peer));
-	md.start     = base;
-	md.length    = len;
+	md.start = base;
+	md.length = len;
 	md.threshold = (ack == LNET_ACK_REQ) ? 2 : 1;
-	md.options   = PTLRPC_MD_OPTIONS;
-	md.user_ptr  = cbid;
+	md.options = PTLRPC_MD_OPTIONS;
+	md.user_ptr = cbid;
 	md.eq_handle = ptlrpc_eq_h;
 
 	if (unlikely(ack == LNET_ACK_REQ &amp;&amp;
@@ -120,8 +120,8 @@ int ptlrpc_register_bulk(struct ptlrpc_request *req)
 	int posted_md;
 	int total_md;
 	__u64 xid;
-	lnet_handle_me_t  me_h;
-	lnet_md_t	 md;
+	lnet_handle_me_t me_h;
+	lnet_md_t md;
 
 	if (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_BULK_GET_NET))
 		return 0;
@@ -243,9 +243,9 @@ EXPORT_SYMBOL(ptlrpc_register_bulk);
 int ptlrpc_unregister_bulk(struct ptlrpc_request *req, int async)
 {
 	struct ptlrpc_bulk_desc *desc = req-&gt;rq_bulk;
-	wait_queue_head_t	     *wq;
-	struct l_wait_info       lwi;
-	int		      rc;
+	wait_queue_head_t *wq;
+	struct l_wait_info lwi;
+	int rc;
 
 	LASSERT(!in_interrupt());     /* might sleep */
 
@@ -301,8 +301,8 @@ EXPORT_SYMBOL(ptlrpc_unregister_bulk);
 
 static void ptlrpc_at_set_reply(struct ptlrpc_request *req, int flags)
 {
-	struct ptlrpc_service_part	*svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
-	struct ptlrpc_service		*svc = svcpt-&gt;scp_service;
+	struct ptlrpc_service_part *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
 	int service_time = max_t(int, get_seconds() -
 				 req-&gt;rq_arrival_time.tv_sec, 1);
 
@@ -353,8 +353,8 @@ static void ptlrpc_at_set_reply(struct ptlrpc_request *req, int flags)
 int ptlrpc_send_reply(struct ptlrpc_request *req, int flags)
 {
 	struct ptlrpc_reply_state *rs = req-&gt;rq_reply_state;
-	struct ptlrpc_connection  *conn;
-	int			rc;
+	struct ptlrpc_connection *conn;
+	int rc;
 
 	/* We must already have a reply buffer (only ptlrpc_error() may be
 	 * called without one). The reply generated by sptlrpc layer (e.g.
@@ -491,8 +491,8 @@ int ptl_send_rpc(struct ptlrpc_request *request, int noreply)
 	int rc2;
 	int mpflag = 0;
 	struct ptlrpc_connection *connection;
-	lnet_handle_me_t  reply_me_h;
-	lnet_md_t	 reply_md;
+	lnet_handle_me_t reply_me_h;
+	lnet_md_t reply_md;
 	struct obd_device *obd = request-&gt;rq_import-&gt;imp_obd;
 
 	if (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_DROP_RPC))
@@ -594,15 +594,15 @@ int ptl_send_rpc(struct ptlrpc_request *request, int noreply)
 	spin_unlock(&amp;request-&gt;rq_lock);
 
 	if (!noreply) {
-		reply_md.start     = request-&gt;rq_repbuf;
-		reply_md.length    = request-&gt;rq_repbuf_len;
+		reply_md.start = request-&gt;rq_repbuf;
+		reply_md.length = request-&gt;rq_repbuf_len;
 		/* Allow multiple early replies */
 		reply_md.threshold = LNET_MD_THRESH_INF;
 		/* Manage remote for early replies */
-		reply_md.options   = PTLRPC_MD_OPTIONS | LNET_MD_OP_PUT |
+		reply_md.options = PTLRPC_MD_OPTIONS | LNET_MD_OP_PUT |
 			LNET_MD_MANAGE_REMOTE |
 			LNET_MD_TRUNCATE; /* allow to make EOVERFLOW error */;
-		reply_md.user_ptr  = &amp;request-&gt;rq_reply_cbid;
+		reply_md.user_ptr = &amp;request-&gt;rq_reply_cbid;
 		reply_md.eq_handle = ptlrpc_eq_h;
 
 		/* We must see the unlink callback to unset rq_reply_unlink,
@@ -682,11 +682,11 @@ EXPORT_SYMBOL(ptl_send_rpc);
  */
 int ptlrpc_register_rqbd(struct ptlrpc_request_buffer_desc *rqbd)
 {
-	struct ptlrpc_service	  *service = rqbd-&gt;rqbd_svcpt-&gt;scp_service;
-	static lnet_process_id_t  match_id = {LNET_NID_ANY, LNET_PID_ANY};
-	int			  rc;
-	lnet_md_t		 md;
-	lnet_handle_me_t	  me_h;
+	struct ptlrpc_service *service = rqbd-&gt;rqbd_svcpt-&gt;scp_service;
+	static lnet_process_id_t match_id = {LNET_NID_ANY, LNET_PID_ANY};
+	int rc;
+	lnet_md_t md;
+	lnet_handle_me_t me_h;
 
 	CDEBUG(D_NET, "LNetMEAttach: portal %d\n",
 	       service-&gt;srv_req_portal);
@@ -709,12 +709,12 @@ int ptlrpc_register_rqbd(struct ptlrpc_request_buffer_desc *rqbd)
 	LASSERT(rqbd-&gt;rqbd_refcount == 0);
 	rqbd-&gt;rqbd_refcount = 1;
 
-	md.start     = rqbd-&gt;rqbd_buffer;
-	md.length    = service-&gt;srv_buf_size;
-	md.max_size  = service-&gt;srv_max_req_size;
+	md.start = rqbd-&gt;rqbd_buffer;
+	md.length = service-&gt;srv_buf_size;
+	md.max_size = service-&gt;srv_max_req_size;
 	md.threshold = LNET_MD_THRESH_INF;
-	md.options   = PTLRPC_MD_OPTIONS | LNET_MD_OP_PUT | LNET_MD_MAX_SIZE;
-	md.user_ptr  = &amp;rqbd-&gt;rqbd_cbid;
+	md.options = PTLRPC_MD_OPTIONS | LNET_MD_OP_PUT | LNET_MD_MAX_SIZE;
+	md.user_ptr = &amp;rqbd-&gt;rqbd_cbid;
 	md.eq_handle = ptlrpc_eq_h;
 
 	rc = LNetMDAttach(me_h, md, LNET_UNLINK, &amp;rqbd-&gt;rqbd_md_h);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/nrs.c b/drivers/staging/lustre/lustre/ptlrpc/nrs.c
index d38a1af8bfd7..9516acadb7a1 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/nrs.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/nrs.c
@@ -188,8 +188,8 @@ static void nrs_policy_stop_primary(struct ptlrpc_nrs *nrs)
  */
 static int nrs_policy_start_locked(struct ptlrpc_nrs_policy *policy)
 {
-	struct ptlrpc_nrs      *nrs = policy-&gt;pol_nrs;
-	int			rc = 0;
+	struct ptlrpc_nrs *nrs = policy-&gt;pol_nrs;
+	int rc = 0;
 
 	/**
 	 * Don't allow multiple starting which is too complex, and has no real
@@ -377,15 +377,15 @@ static void nrs_resource_put(struct ptlrpc_nrs_resource *res)
  */
 static
 struct ptlrpc_nrs_resource *nrs_resource_get(struct ptlrpc_nrs_policy *policy,
-					      struct ptlrpc_nrs_request *nrq,
-					      bool moving_req)
+					     struct ptlrpc_nrs_request *nrq,
+					     bool moving_req)
 {
 	/**
 	 * Set to NULL to traverse the resource hierarchy from the top.
 	 */
 	struct ptlrpc_nrs_resource *res = NULL;
 	struct ptlrpc_nrs_resource *tmp = NULL;
-	int			    rc;
+	int rc;
 
 	while (1) {
 		rc = policy-&gt;pol_desc-&gt;pd_ops-&gt;op_res_get(policy, nrq, res,
@@ -432,8 +432,8 @@ static void nrs_resource_get_safe(struct ptlrpc_nrs *nrs,
 				  struct ptlrpc_nrs_resource **resp,
 				  bool moving_req)
 {
-	struct ptlrpc_nrs_policy   *primary = NULL;
-	struct ptlrpc_nrs_policy   *fallback = NULL;
+	struct ptlrpc_nrs_policy *primary = NULL;
+	struct ptlrpc_nrs_policy *fallback = NULL;
 
 	memset(resp, 0, sizeof(resp[0]) * NRS_RES_MAX);
 
@@ -484,8 +484,8 @@ static void nrs_resource_get_safe(struct ptlrpc_nrs *nrs,
 static void nrs_resource_put_safe(struct ptlrpc_nrs_resource **resp)
 {
 	struct ptlrpc_nrs_policy *pols[NRS_RES_MAX];
-	struct ptlrpc_nrs	 *nrs = NULL;
-	int			  i;
+	struct ptlrpc_nrs *nrs = NULL;
+	int i;
 
 	for (i = 0; i &lt; NRS_RES_MAX; i++) {
 		if (resp[i] != NULL) {
@@ -530,7 +530,7 @@ static void nrs_resource_put_safe(struct ptlrpc_nrs_resource **resp)
  */
 static inline
 struct ptlrpc_nrs_request *nrs_request_get(struct ptlrpc_nrs_policy *policy,
-					    bool peek, bool force)
+					   bool peek, bool force)
 {
 	struct ptlrpc_nrs_request *nrq;
 
@@ -556,8 +556,8 @@ struct ptlrpc_nrs_request *nrs_request_get(struct ptlrpc_nrs_policy *policy,
 static inline void nrs_request_enqueue(struct ptlrpc_nrs_request *nrq)
 {
 	struct ptlrpc_nrs_policy *policy;
-	int			  rc;
-	int			  i;
+	int rc;
+	int i;
 
 	/**
 	 * Try in descending order, because the primary policy (if any) is
@@ -628,8 +628,8 @@ static inline void nrs_request_stop(struct ptlrpc_nrs_request *nrq)
 static int nrs_policy_ctl(struct ptlrpc_nrs *nrs, char *name,
 			  enum ptlrpc_nrs_ctl opc, void *arg)
 {
-	struct ptlrpc_nrs_policy       *policy;
-	int				rc = 0;
+	struct ptlrpc_nrs_policy *policy;
+	int rc = 0;
 
 	spin_lock(&amp;nrs-&gt;nrs_lock);
 
@@ -733,10 +733,10 @@ static int nrs_policy_unregister(struct ptlrpc_nrs *nrs, char *name)
 static int nrs_policy_register(struct ptlrpc_nrs *nrs,
 			       struct ptlrpc_nrs_pol_desc *desc)
 {
-	struct ptlrpc_nrs_policy       *policy;
-	struct ptlrpc_nrs_policy       *tmp;
-	struct ptlrpc_service_part     *svcpt = nrs-&gt;nrs_svcpt;
-	int				rc;
+	struct ptlrpc_nrs_policy *policy;
+	struct ptlrpc_nrs_policy *tmp;
+	struct ptlrpc_service_part *svcpt = nrs-&gt;nrs_svcpt;
+	int rc;
 
 	LASSERT(svcpt != NULL);
 	LASSERT(desc-&gt;pd_ops != NULL);
@@ -752,10 +752,10 @@ static int nrs_policy_register(struct ptlrpc_nrs *nrs,
 	if (policy == NULL)
 		return -ENOMEM;
 
-	policy-&gt;pol_nrs     = nrs;
-	policy-&gt;pol_desc    = desc;
-	policy-&gt;pol_state   = NRS_POL_STATE_STOPPED;
-	policy-&gt;pol_flags   = desc-&gt;pd_flags;
+	policy-&gt;pol_nrs = nrs;
+	policy-&gt;pol_desc = desc;
+	policy-&gt;pol_state = NRS_POL_STATE_STOPPED;
+	policy-&gt;pol_flags = desc-&gt;pd_flags;
 
 	INIT_LIST_HEAD(&amp;policy-&gt;pol_list);
 	INIT_LIST_HEAD(&amp;policy-&gt;pol_list_queued);
@@ -804,7 +804,7 @@ static int nrs_policy_register(struct ptlrpc_nrs *nrs,
  */
 static void ptlrpc_nrs_req_add_nolock(struct ptlrpc_request *req)
 {
-	struct ptlrpc_nrs_policy       *policy;
+	struct ptlrpc_nrs_policy *policy;
 
 	LASSERT(req-&gt;rq_nrq.nr_initialized);
 	LASSERT(!req-&gt;rq_nrq.nr_enqueued);
@@ -829,7 +829,7 @@ static void ptlrpc_nrs_req_add_nolock(struct ptlrpc_request *req)
  */
 static void ptlrpc_nrs_hpreq_add_nolock(struct ptlrpc_request *req)
 {
-	int	opc = lustre_msg_get_opc(req-&gt;rq_reqmsg);
+	int opc = lustre_msg_get_opc(req-&gt;rq_reqmsg);
 
 	spin_lock(&amp;req-&gt;rq_lock);
 	req-&gt;rq_hp = 1;
@@ -872,9 +872,9 @@ static int nrs_register_policies_locked(struct ptlrpc_nrs *nrs)
 {
 	struct ptlrpc_nrs_pol_desc *desc;
 	/* for convenience */
-	struct ptlrpc_service_part	 *svcpt = nrs-&gt;nrs_svcpt;
-	struct ptlrpc_service		 *svc = svcpt-&gt;scp_service;
-	int				  rc = -EINVAL;
+	struct ptlrpc_service_part *svcpt = nrs-&gt;nrs_svcpt;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
+	int rc = -EINVAL;
 
 	LASSERT(mutex_is_locked(&amp;nrs_core.nrs_mutex));
 
@@ -912,7 +912,7 @@ static int nrs_register_policies_locked(struct ptlrpc_nrs *nrs)
 static int nrs_svcpt_setup_locked0(struct ptlrpc_nrs *nrs,
 				   struct ptlrpc_service_part *svcpt)
 {
-	enum ptlrpc_nrs_queue_type	queue;
+	enum ptlrpc_nrs_queue_type queue;
 
 	LASSERT(mutex_is_locked(&amp;nrs_core.nrs_mutex));
 
@@ -943,8 +943,8 @@ static int nrs_svcpt_setup_locked0(struct ptlrpc_nrs *nrs,
  */
 static int nrs_svcpt_setup_locked(struct ptlrpc_service_part *svcpt)
 {
-	struct ptlrpc_nrs	       *nrs;
-	int				rc;
+	struct ptlrpc_nrs *nrs;
+	int rc;
 
 	LASSERT(mutex_is_locked(&amp;nrs_core.nrs_mutex));
 
@@ -988,11 +988,11 @@ static int nrs_svcpt_setup_locked(struct ptlrpc_service_part *svcpt)
  */
 static void nrs_svcpt_cleanup_locked(struct ptlrpc_service_part *svcpt)
 {
-	struct ptlrpc_nrs	       *nrs;
-	struct ptlrpc_nrs_policy       *policy;
-	struct ptlrpc_nrs_policy       *tmp;
-	int				rc;
-	bool				hp = false;
+	struct ptlrpc_nrs *nrs;
+	struct ptlrpc_nrs_policy *policy;
+	struct ptlrpc_nrs_policy *tmp;
+	int rc;
+	bool hp = false;
 
 	LASSERT(mutex_is_locked(&amp;nrs_core.nrs_mutex));
 
@@ -1028,7 +1028,7 @@ static void nrs_svcpt_cleanup_locked(struct ptlrpc_service_part *svcpt)
  */
 static struct ptlrpc_nrs_pol_desc *nrs_policy_find_desc_locked(const char *name)
 {
-	struct ptlrpc_nrs_pol_desc     *tmp;
+	struct ptlrpc_nrs_pol_desc *tmp;
 
 	list_for_each_entry(tmp, &amp;nrs_core.nrs_policies, pd_list) {
 		if (strncmp(tmp-&gt;pd_name, name, NRS_POL_NAME_MAX) == 0)
@@ -1051,11 +1051,11 @@ static struct ptlrpc_nrs_pol_desc *nrs_policy_find_desc_locked(const char *name)
  */
 static int nrs_policy_unregister_locked(struct ptlrpc_nrs_pol_desc *desc)
 {
-	struct ptlrpc_nrs	       *nrs;
-	struct ptlrpc_service	       *svc;
-	struct ptlrpc_service_part     *svcpt;
-	int				i;
-	int				rc = 0;
+	struct ptlrpc_nrs *nrs;
+	struct ptlrpc_service *svc;
+	struct ptlrpc_service_part *svcpt;
+	int i;
+	int rc = 0;
 
 	LASSERT(mutex_is_locked(&amp;nrs_core.nrs_mutex));
 	LASSERT(mutex_is_locked(&amp;ptlrpc_all_services_mutex));
@@ -1115,9 +1115,9 @@ static int nrs_policy_unregister_locked(struct ptlrpc_nrs_pol_desc *desc)
  */
 int ptlrpc_nrs_policy_register(struct ptlrpc_nrs_pol_conf *conf)
 {
-	struct ptlrpc_service	       *svc;
-	struct ptlrpc_nrs_pol_desc     *desc;
-	int				rc = 0;
+	struct ptlrpc_service *svc;
+	struct ptlrpc_nrs_pol_desc *desc;
+	int rc = 0;
 
 	LASSERT(conf != NULL);
 	LASSERT(conf-&gt;nc_ops != NULL);
@@ -1162,12 +1162,12 @@ int ptlrpc_nrs_policy_register(struct ptlrpc_nrs_pol_conf *conf)
 	}
 
 	strncpy(desc-&gt;pd_name, conf-&gt;nc_name, NRS_POL_NAME_MAX);
-	desc-&gt;pd_ops		 = conf-&gt;nc_ops;
-	desc-&gt;pd_compat		 = conf-&gt;nc_compat;
+	desc-&gt;pd_ops = conf-&gt;nc_ops;
+	desc-&gt;pd_compat = conf-&gt;nc_compat;
 	desc-&gt;pd_compat_svc_name = conf-&gt;nc_compat_svc_name;
 	if ((conf-&gt;nc_flags &amp; PTLRPC_NRS_FL_REG_EXTERN) != 0)
-		desc-&gt;pd_owner	 = conf-&gt;nc_owner;
-	desc-&gt;pd_flags		 = conf-&gt;nc_flags;
+		desc-&gt;pd_owner = conf-&gt;nc_owner;
+	desc-&gt;pd_flags = conf-&gt;nc_flags;
 	atomic_set(&amp;desc-&gt;pd_refs, 0);
 
 	/**
@@ -1187,17 +1187,17 @@ int ptlrpc_nrs_policy_register(struct ptlrpc_nrs_pol_conf *conf)
 	mutex_lock(&amp;ptlrpc_all_services_mutex);
 
 	list_for_each_entry(svc, &amp;ptlrpc_all_services, srv_list) {
-		struct ptlrpc_service_part     *svcpt;
-		int				i;
-		int				rc2;
+		struct ptlrpc_service_part *svcpt;
+		int i;
+		int rc2;
 
 		if (!nrs_policy_compatible(svc, desc) ||
 		    unlikely(svc-&gt;srv_is_stopping))
 			continue;
 
 		ptlrpc_service_for_each_part(svcpt, i, svc) {
-			struct ptlrpc_nrs      *nrs;
-			bool			hp = false;
+			struct ptlrpc_nrs *nrs;
+			bool hp = false;
 again:
 			nrs = nrs_svcpt2nrs(svcpt, hp);
 			rc = nrs_policy_register(nrs, desc);
@@ -1267,8 +1267,8 @@ EXPORT_SYMBOL(ptlrpc_nrs_policy_register);
  */
 int ptlrpc_nrs_policy_unregister(struct ptlrpc_nrs_pol_conf *conf)
 {
-	struct ptlrpc_nrs_pol_desc	*desc;
-	int				 rc;
+	struct ptlrpc_nrs_pol_desc *desc;
+	int rc;
 
 	LASSERT(conf != NULL);
 
@@ -1331,10 +1331,10 @@ EXPORT_SYMBOL(ptlrpc_nrs_policy_unregister);
  */
 int ptlrpc_service_nrs_setup(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	       *svcpt;
-	const struct ptlrpc_nrs_pol_desc       *desc;
-	int					i;
-	int					rc = 0;
+	struct ptlrpc_service_part *svcpt;
+	const struct ptlrpc_nrs_pol_desc *desc;
+	int i;
+	int rc = 0;
 
 	mutex_lock(&amp;nrs_core.nrs_mutex);
 
@@ -1376,9 +1376,9 @@ int ptlrpc_service_nrs_setup(struct ptlrpc_service *svc)
  */
 void ptlrpc_service_nrs_cleanup(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	     *svcpt;
-	const struct ptlrpc_nrs_pol_desc     *desc;
-	int				      i;
+	struct ptlrpc_service_part *svcpt;
+	const struct ptlrpc_nrs_pol_desc *desc;
+	int i;
 
 	mutex_lock(&amp;nrs_core.nrs_mutex);
 
@@ -1417,7 +1417,7 @@ void ptlrpc_service_nrs_cleanup(struct ptlrpc_service *svc)
 void ptlrpc_nrs_req_initialize(struct ptlrpc_service_part *svcpt,
 			       struct ptlrpc_request *req, bool hp)
 {
-	struct ptlrpc_nrs	*nrs = nrs_svcpt2nrs(svcpt, hp);
+	struct ptlrpc_nrs *nrs = nrs_svcpt2nrs(svcpt, hp);
 
 	memset(&amp;req-&gt;rq_nrq, 0, sizeof(req-&gt;rq_nrq));
 	nrs_resource_get_safe(nrs, &amp;req-&gt;rq_nrq, req-&gt;rq_nrq.nr_res_ptrs,
@@ -1525,8 +1525,8 @@ struct ptlrpc_request *
 ptlrpc_nrs_req_get_nolock0(struct ptlrpc_service_part *svcpt, bool hp,
 			   bool peek, bool force)
 {
-	struct ptlrpc_nrs	  *nrs = nrs_svcpt2nrs(svcpt, hp);
-	struct ptlrpc_nrs_policy  *policy;
+	struct ptlrpc_nrs *nrs = nrs_svcpt2nrs(svcpt, hp);
+	struct ptlrpc_nrs_policy *policy;
 	struct ptlrpc_nrs_request *nrq;
 
 	/**
@@ -1596,10 +1596,10 @@ bool ptlrpc_nrs_req_pending_nolock(struct ptlrpc_service_part *svcpt, bool hp)
  */
 void ptlrpc_nrs_req_hp_move(struct ptlrpc_request *req)
 {
-	struct ptlrpc_service_part	*svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
-	struct ptlrpc_nrs_request	*nrq = &amp;req-&gt;rq_nrq;
-	struct ptlrpc_nrs_resource	*res1[NRS_RES_MAX];
-	struct ptlrpc_nrs_resource	*res2[NRS_RES_MAX];
+	struct ptlrpc_service_part *svcpt = req-&gt;rq_rqbd-&gt;rqbd_svcpt;
+	struct ptlrpc_nrs_request *nrq = &amp;req-&gt;rq_nrq;
+	struct ptlrpc_nrs_resource *res1[NRS_RES_MAX];
+	struct ptlrpc_nrs_resource *res2[NRS_RES_MAX];
 
 	/**
 	 * Obtain the high-priority NRS head resources.
@@ -1661,9 +1661,9 @@ int ptlrpc_nrs_policy_control(const struct ptlrpc_service *svc,
 			      enum ptlrpc_nrs_queue_type queue, char *name,
 			      enum ptlrpc_nrs_ctl opc, bool single, void *arg)
 {
-	struct ptlrpc_service_part     *svcpt;
-	int				i;
-	int				rc = 0;
+	struct ptlrpc_service_part *svcpt;
+	int i;
+	int rc = 0;
 
 	LASSERT(opc != PTLRPC_NRS_CTL_INVALID);
 
@@ -1711,7 +1711,7 @@ extern struct ptlrpc_nrs_pol_conf nrs_conf_fifo;
  */
 int ptlrpc_nrs_init(void)
 {
-	int	rc;
+	int rc;
 
 	mutex_init(&amp;nrs_core.nrs_mutex);
 	INIT_LIST_HEAD(&amp;nrs_core.nrs_policies);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/nrs_fifo.c b/drivers/staging/lustre/lustre/ptlrpc/nrs_fifo.c
index 6a61c85cfb11..8e21f0cdc8f8 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/nrs_fifo.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/nrs_fifo.c
@@ -160,9 +160,9 @@ static int nrs_fifo_res_get(struct ptlrpc_nrs_policy *policy,
  */
 static
 struct ptlrpc_nrs_request *nrs_fifo_req_get(struct ptlrpc_nrs_policy *policy,
-					     bool peek, bool force)
+					    bool peek, bool force)
 {
-	struct nrs_fifo_head	  *head = policy-&gt;pol_private;
+	struct nrs_fifo_head *head = policy-&gt;pol_private;
 	struct ptlrpc_nrs_request *nrq;
 
 	nrq = unlikely(list_empty(&amp;head-&gt;fh_list)) ? NULL :
diff --git a/drivers/staging/lustre/lustre/ptlrpc/pack_generic.c b/drivers/staging/lustre/lustre/ptlrpc/pack_generic.c
index b51af9bf37b7..2787bfd67165 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/pack_generic.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/pack_generic.c
@@ -279,8 +279,8 @@ lustre_get_emerg_rs(struct ptlrpc_service_part *svcpt)
 
 	/* See if we have anything in a pool, and wait if nothing */
 	while (list_empty(&amp;svcpt-&gt;scp_rep_idle)) {
-		struct l_wait_info	lwi;
-		int			rc;
+		struct l_wait_info lwi;
+		int rc;
 
 		spin_unlock(&amp;svcpt-&gt;scp_rep_lock);
 		/* If we cannot get anything for some long time, we better
@@ -321,7 +321,7 @@ int lustre_pack_reply_v2(struct ptlrpc_request *req, int count,
 			 __u32 *lens, char **bufs, int flags)
 {
 	struct ptlrpc_reply_state *rs;
-	int			msg_len, rc;
+	int msg_len, rc;
 
 	LASSERT(req-&gt;rq_reply_state == NULL);
 
@@ -440,8 +440,8 @@ EXPORT_SYMBOL(lustre_msg_buf);
 int lustre_shrink_msg_v2(struct lustre_msg_v2 *msg, int segment,
 			 unsigned int newlen, int move_data)
 {
-	char   *tail = NULL, *newpos;
-	int     tail_len = 0, n;
+	char *tail = NULL, *newpos;
+	int tail_len = 0, n;
 
 	LASSERT(msg);
 	LASSERT(msg-&gt;lm_bufcount &gt; segment);
@@ -1577,8 +1577,8 @@ int do_set_info_async(struct obd_import *imp,
 		      struct ptlrpc_request_set *set)
 {
 	struct ptlrpc_request *req;
-	char		  *tmp;
-	int		    rc;
+	char *tmp;
+	int rc;
 
 	req = ptlrpc_request_alloc(imp, &amp;RQF_OBD_SET_INFO);
 	if (req == NULL)
@@ -1688,7 +1688,7 @@ void lustre_swab_connect(struct obd_connect_data *ocd)
 	CLASSERT(offsetof(typeof(*ocd), paddingF) != 0);
 }
 
-void lustre_swab_obdo(struct obdo  *o)
+void lustre_swab_obdo(struct obdo *o)
 {
 	__swab64s(&amp;o-&gt;o_valid);
 	lustre_swab_ost_id(&amp;o-&gt;o_oi);
@@ -2179,7 +2179,7 @@ EXPORT_SYMBOL(lustre_swab_lov_user_md_objects);
 
 void lustre_swab_ldlm_res_id(struct ldlm_res_id *id)
 {
-	int  i;
+	int i;
 
 	for (i = 0; i &lt; RES_NAME_SIZE; i++)
 		__swab64s(&amp;id-&gt;name[i]);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/pinger.c b/drivers/staging/lustre/lustre/ptlrpc/pinger.c
index 9fc815676eb8..61e33be865b2 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/pinger.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/pinger.c
@@ -546,8 +546,8 @@ void ptlrpc_pinger_wake_up(void)
 #define PET_TERMINATE 2
 
 static int pet_refcount;
-static int	       pet_state;
-static wait_queue_head_t       pet_waitq;
+static int pet_state;
+static wait_queue_head_t pet_waitq;
 static LIST_HEAD(pet_list);
 static DEFINE_SPINLOCK(pet_lock);
 
diff --git a/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c b/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
index 5ba3e6ed5289..e591cff323ec 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
@@ -68,9 +68,9 @@
 #include "ptlrpc_internal.h"
 
 struct ptlrpcd {
-	int		pd_size;
-	int		pd_index;
-	int		pd_nthreads;
+	int pd_size;
+	int pd_index;
+	int pd_nthreads;
 	struct ptlrpcd_ctl pd_thread_rcv;
 	struct ptlrpcd_ctl pd_threads[0];
 };
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec.c b/drivers/staging/lustre/lustre/ptlrpc/sec.c
index bcfd0b0b6f93..8798fab31f77 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec.c
@@ -113,10 +113,10 @@ static
 struct ptlrpc_sec_policy *sptlrpc_wireflavor2policy(__u32 flavor)
 {
 	static DEFINE_MUTEX(load_mutex);
-	static atomic_t       loaded = ATOMIC_INIT(0);
+	static atomic_t loaded = ATOMIC_INIT(0);
 	struct ptlrpc_sec_policy *policy;
-	__u16		     number = SPTLRPC_FLVR_POLICY(flavor);
-	__u16		     flag = 0;
+	__u16 number = SPTLRPC_FLVR_POLICY(flavor);
+	__u16 flag = 0;
 
 	if (number &gt;= SPTLRPC_POLICY_MAX)
 		return NULL;
@@ -339,7 +339,7 @@ int sptlrpc_cli_ctx_display(struct ptlrpc_cli_ctx *ctx, char *buf, int bufsize)
 
 static int import_sec_check_expire(struct obd_import *imp)
 {
-	int     adapt = 0;
+	int adapt = 0;
 
 	spin_lock(&amp;imp-&gt;imp_lock);
 	if (imp-&gt;imp_sec_expire &amp;&amp;
@@ -359,7 +359,7 @@ static int import_sec_check_expire(struct obd_import *imp)
 static int import_sec_validate_get(struct obd_import *imp,
 				   struct ptlrpc_sec **sec)
 {
-	int     rc;
+	int rc;
 
 	if (unlikely(imp-&gt;imp_sec_expire)) {
 		rc = import_sec_check_expire(imp);
@@ -447,10 +447,10 @@ int sptlrpc_req_ctx_switch(struct ptlrpc_request *req,
 			   struct ptlrpc_cli_ctx *oldctx,
 			   struct ptlrpc_cli_ctx *newctx)
 {
-	struct sptlrpc_flavor   old_flvr;
-	char		   *reqmsg = NULL; /* to workaround old gcc */
-	int		     reqmsg_size;
-	int		     rc = 0;
+	struct sptlrpc_flavor old_flvr;
+	char *reqmsg = NULL; /* to workaround old gcc */
+	int reqmsg_size;
+	int rc = 0;
 
 	LASSERT(req-&gt;rq_reqmsg);
 	LASSERT(req-&gt;rq_reqlen);
@@ -514,7 +514,7 @@ int sptlrpc_req_replace_dead_ctx(struct ptlrpc_request *req)
 {
 	struct ptlrpc_cli_ctx *oldctx = req-&gt;rq_cli_ctx;
 	struct ptlrpc_cli_ctx *newctx;
-	int		    rc;
+	int rc;
 
 	LASSERT(oldctx);
 
@@ -629,10 +629,10 @@ void req_off_ctx_list(struct ptlrpc_request *req, struct ptlrpc_cli_ctx *ctx)
  */
 int sptlrpc_req_refresh_ctx(struct ptlrpc_request *req, long timeout)
 {
-	struct ptlrpc_cli_ctx  *ctx = req-&gt;rq_cli_ctx;
-	struct ptlrpc_sec      *sec;
-	struct l_wait_info      lwi;
-	int		     rc;
+	struct ptlrpc_cli_ctx *ctx = req-&gt;rq_cli_ctx;
+	struct ptlrpc_sec *sec;
+	struct l_wait_info lwi;
+	int rc;
 
 	LASSERT(ctx);
 
@@ -878,7 +878,7 @@ void sptlrpc_request_out_callback(struct ptlrpc_request *req)
  */
 int sptlrpc_import_check_ctx(struct obd_import *imp)
 {
-	struct ptlrpc_sec     *sec;
+	struct ptlrpc_sec *sec;
 	struct ptlrpc_cli_ctx *ctx;
 	struct ptlrpc_request *req = NULL;
 	int rc;
@@ -974,7 +974,7 @@ int sptlrpc_cli_wrap_request(struct ptlrpc_request *req)
 static int do_cli_unwrap_reply(struct ptlrpc_request *req)
 {
 	struct ptlrpc_cli_ctx *ctx = req-&gt;rq_cli_ctx;
-	int		    rc;
+	int rc;
 
 	LASSERT(ctx);
 	LASSERT(ctx-&gt;cc_sec);
@@ -1082,10 +1082,10 @@ int sptlrpc_cli_unwrap_reply(struct ptlrpc_request *req)
 int sptlrpc_cli_unwrap_early_reply(struct ptlrpc_request *req,
 				   struct ptlrpc_request **req_ret)
 {
-	struct ptlrpc_request  *early_req;
-	char		   *early_buf;
-	int		     early_bufsz, early_size;
-	int		     rc;
+	struct ptlrpc_request *early_req;
+	char *early_buf;
+	int early_bufsz, early_size;
+	int rc;
 
 	early_req = ptlrpc_request_cache_alloc(GFP_NOFS);
 	if (early_req == NULL)
@@ -1273,13 +1273,13 @@ EXPORT_SYMBOL(sptlrpc_sec_put);
  */
 static
 struct ptlrpc_sec *sptlrpc_sec_create(struct obd_import *imp,
-				       struct ptlrpc_svc_ctx *svc_ctx,
-				       struct sptlrpc_flavor *sf,
-				       enum lustre_sec_part sp)
+				      struct ptlrpc_svc_ctx *svc_ctx,
+				      struct sptlrpc_flavor *sf,
+				      enum lustre_sec_part sp)
 {
 	struct ptlrpc_sec_policy *policy;
-	struct ptlrpc_sec	*sec;
-	char		      str[32];
+	struct ptlrpc_sec *sec;
+	char str[32];
 
 	if (svc_ctx) {
 		LASSERT(imp-&gt;imp_dlm_fake == 1);
@@ -1369,7 +1369,7 @@ static void sptlrpc_import_sec_adapt_inplace(struct obd_import *imp,
 					     struct ptlrpc_sec *sec,
 					     struct sptlrpc_flavor *sf)
 {
-	char    str1[32], str2[32];
+	char str1[32], str2[32];
 
 	if (sec-&gt;ps_flvr.sf_flags != sf-&gt;sf_flags)
 		CDEBUG(D_SEC, "changing sec flags: %s -&gt; %s\n",
@@ -1394,12 +1394,12 @@ int sptlrpc_import_sec_adapt(struct obd_import *imp,
 			     struct ptlrpc_svc_ctx *svc_ctx,
 			     struct sptlrpc_flavor *flvr)
 {
-	struct ptlrpc_connection   *conn;
-	struct sptlrpc_flavor       sf;
-	struct ptlrpc_sec	  *sec, *newsec;
-	enum lustre_sec_part	sp;
-	char			str[24];
-	int			 rc = 0;
+	struct ptlrpc_connection *conn;
+	struct sptlrpc_flavor sf;
+	struct ptlrpc_sec *sec, *newsec;
+	enum lustre_sec_part sp;
+	char str[24];
+	int rc = 0;
 
 	might_sleep();
 
@@ -1436,7 +1436,7 @@ int sptlrpc_import_sec_adapt(struct obd_import *imp,
 
 	sec = sptlrpc_import_sec_ref(imp);
 	if (sec) {
-		char    str2[24];
+		char str2[24];
 
 		if (flavor_equal(&amp;sf, &amp;sec-&gt;ps_flvr))
 			goto out;
@@ -1585,8 +1585,8 @@ void sptlrpc_cli_free_reqbuf(struct ptlrpc_request *req)
 void _sptlrpc_enlarge_msg_inplace(struct lustre_msg *msg,
 				  int segment, int newsize)
 {
-	void   *src, *dst;
-	int     oldsize, oldmsg_size, movesize;
+	void *src, *dst;
+	int oldsize, oldmsg_size, movesize;
 
 	LASSERT(segment &lt; msg-&gt;lm_bufcount);
 	LASSERT(msg-&gt;lm_buflens[segment] &lt;= newsize);
@@ -1635,9 +1635,9 @@ EXPORT_SYMBOL(_sptlrpc_enlarge_msg_inplace);
 int sptlrpc_cli_enlarge_reqbuf(struct ptlrpc_request *req,
 			       int segment, int newsize)
 {
-	struct ptlrpc_cli_ctx    *ctx = req-&gt;rq_cli_ctx;
-	struct ptlrpc_sec_cops   *cops;
-	struct lustre_msg	*msg = req-&gt;rq_reqmsg;
+	struct ptlrpc_cli_ctx *ctx = req-&gt;rq_cli_ctx;
+	struct ptlrpc_sec_cops *cops;
+	struct lustre_msg *msg = req-&gt;rq_reqmsg;
 
 	LASSERT(ctx);
 	LASSERT(msg);
@@ -1748,7 +1748,7 @@ static int flavor_allowed(struct sptlrpc_flavor *exp,
 int sptlrpc_target_export_check(struct obd_export *exp,
 				struct ptlrpc_request *req)
 {
-	struct sptlrpc_flavor   flavor;
+	struct sptlrpc_flavor flavor;
 
 	if (exp == NULL)
 		return 0;
@@ -1926,8 +1926,8 @@ EXPORT_SYMBOL(sptlrpc_target_export_check);
 void sptlrpc_target_update_exp_flavor(struct obd_device *obd,
 				      struct sptlrpc_rule_set *rset)
 {
-	struct obd_export       *exp;
-	struct sptlrpc_flavor    new_flvr;
+	struct obd_export *exp;
+	struct sptlrpc_flavor new_flvr;
 
 	LASSERT(obd);
 
@@ -2019,8 +2019,8 @@ static int sptlrpc_svc_check_from(struct ptlrpc_request *req, int svc_rc)
 int sptlrpc_svc_unwrap_request(struct ptlrpc_request *req)
 {
 	struct ptlrpc_sec_policy *policy;
-	struct lustre_msg	*msg = req-&gt;rq_reqbuf;
-	int		       rc;
+	struct lustre_msg *msg = req-&gt;rq_reqbuf;
+	int rc;
 
 	LASSERT(msg);
 	LASSERT(req-&gt;rq_reqmsg == NULL);
@@ -2231,8 +2231,8 @@ int sptlrpc_cli_unwrap_bulk_read(struct ptlrpc_request *req,
 				 struct ptlrpc_bulk_desc *desc,
 				 int nob)
 {
-	struct ptlrpc_cli_ctx  *ctx;
-	int		     rc;
+	struct ptlrpc_cli_ctx *ctx;
+	int rc;
 
 	LASSERT(req-&gt;rq_bulk_read &amp;&amp; !req-&gt;rq_bulk_write);
 
@@ -2256,8 +2256,8 @@ EXPORT_SYMBOL(sptlrpc_cli_unwrap_bulk_read);
 int sptlrpc_cli_unwrap_bulk_write(struct ptlrpc_request *req,
 				  struct ptlrpc_bulk_desc *desc)
 {
-	struct ptlrpc_cli_ctx  *ctx;
-	int		     rc;
+	struct ptlrpc_cli_ctx *ctx;
+	int rc;
 
 	LASSERT(!req-&gt;rq_bulk_read &amp;&amp; req-&gt;rq_bulk_write);
 
@@ -2329,7 +2329,7 @@ EXPORT_SYMBOL(sptlrpc_pack_user_desc);
 int sptlrpc_unpack_user_desc(struct lustre_msg *msg, int offset, int swabbed)
 {
 	struct ptlrpc_user_desc *pud;
-	int		      i;
+	int i;
 
 	pud = lustre_msg_buf(msg, offset, sizeof(*pud));
 	if (!pud)
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_bulk.c b/drivers/staging/lustre/lustre/ptlrpc/sec_bulk.c
index 97edc9174da3..ea35ca54e729 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_bulk.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_bulk.c
@@ -62,7 +62,7 @@
 #define POINTERS_PER_PAGE	(PAGE_CACHE_SIZE / sizeof(void *))
 #define PAGES_PER_POOL		(POINTERS_PER_PAGE)
 
-#define IDLE_IDX_MAX	    (100)
+#define IDLE_IDX_MAX	 (100)
 #define IDLE_IDX_WEIGHT	 (3)
 
 #define CACHE_QUIESCENT_PERIOD  (20)
@@ -173,8 +173,8 @@ int sptlrpc_proc_enc_pool_seq_show(struct seq_file *m, void *v)
 
 static void enc_pools_release_free_pages(long npages)
 {
-	int     p_idx, g_idx;
-	int     p_idx_max1, p_idx_max2;
+	int p_idx, g_idx;
+	int p_idx_max1, p_idx_max2;
 
 	LASSERT(npages &gt; 0);
 	LASSERT(npages &lt;= page_pools.epp_free_pages);
@@ -284,7 +284,7 @@ int npages_to_npools(unsigned long npages)
 static unsigned long enc_pools_cleanup(struct page ***pools, int npools)
 {
 	unsigned long cleaned = 0;
-	int	   i, j;
+	int i, j;
 
 	for (i = 0; i &lt; npools; i++) {
 		if (pools[i]) {
@@ -311,9 +311,9 @@ static unsigned long enc_pools_cleanup(struct page ***pools, int npools)
  */
 static void enc_pools_insert(struct page ***pools, int npools, int npages)
 {
-	int     freeslot;
-	int     op_idx, np_idx, og_idx, ng_idx;
-	int     cur_npools, end_npools;
+	int freeslot;
+	int op_idx, np_idx, og_idx, ng_idx;
+	int cur_npools, end_npools;
 
 	LASSERT(npages &gt; 0);
 	LASSERT(page_pools.epp_total_pages+npages &lt;= page_pools.epp_max_pages);
@@ -393,9 +393,9 @@ static void enc_pools_insert(struct page ***pools, int npools, int npages)
 static int enc_pools_add_pages(int npages)
 {
 	static DEFINE_MUTEX(add_pages_mutex);
-	struct page   ***pools;
-	int	     npools, alloced = 0;
-	int	     i, j, rc = -ENOMEM;
+	struct page ***pools;
+	int npools, alloced = 0;
+	int i, j, rc = -ENOMEM;
 
 	if (npages &lt; PTLRPC_MAX_BRW_PAGES)
 		npages = PTLRPC_MAX_BRW_PAGES;
@@ -494,12 +494,12 @@ static int enc_pools_should_grow(int page_needed, long now)
  */
 int sptlrpc_enc_pool_get_pages(struct ptlrpc_bulk_desc *desc)
 {
-	wait_queue_t  waitlink;
-	unsigned long   this_idle = -1;
-	unsigned long      tick = 0;
-	long	    now;
-	int	     p_idx, g_idx;
-	int	     i;
+	wait_queue_t waitlink;
+	unsigned long this_idle = -1;
+	unsigned long tick = 0;
+	long now;
+	int p_idx, g_idx;
+	int i;
 
 	LASSERT(desc-&gt;bd_iov_count &gt; 0);
 	LASSERT(desc-&gt;bd_iov_count &lt;= page_pools.epp_max_pages);
@@ -609,8 +609,8 @@ EXPORT_SYMBOL(sptlrpc_enc_pool_get_pages);
 
 void sptlrpc_enc_pool_put_pages(struct ptlrpc_bulk_desc *desc)
 {
-	int     p_idx, g_idx;
-	int     i;
+	int p_idx, g_idx;
+	int i;
 
 	if (desc-&gt;bd_enc_iov == NULL)
 		return;
@@ -658,7 +658,7 @@ EXPORT_SYMBOL(sptlrpc_enc_pool_put_pages);
  */
 int sptlrpc_enc_pool_add_user(void)
 {
-	int     need_grow = 0;
+	int need_grow = 0;
 
 	spin_lock(&amp;page_pools.epp_lock);
 	if (page_pools.epp_growing == 0 &amp;&amp; page_pools.epp_total_pages == 0) {
@@ -842,11 +842,11 @@ EXPORT_SYMBOL(bulk_sec_desc_unpack);
 int sptlrpc_get_bulk_checksum(struct ptlrpc_bulk_desc *desc, __u8 alg,
 			      void *buf, int buflen)
 {
-	struct cfs_crypto_hash_desc	*hdesc;
-	int				hashsize;
-	char				hashbuf[64];
-	unsigned int			bufsize;
-	int				i, err;
+	struct cfs_crypto_hash_desc *hdesc;
+	int hashsize;
+	char hashbuf[64];
+	unsigned int bufsize;
+	int i, err;
 
 	LASSERT(alg &gt; BULK_HASH_ALG_NULL &amp;&amp; alg &lt; BULK_HASH_ALG_MAX);
 	LASSERT(buflen &gt;= 4);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_config.c b/drivers/staging/lustre/lustre/ptlrpc/sec_config.c
index 16dbf3fcfc84..31da43e8b3c6 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_config.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_config.c
@@ -94,8 +94,8 @@ EXPORT_SYMBOL(sptlrpc_target_sec_part);
  */
 int sptlrpc_parse_flavor(const char *str, struct sptlrpc_flavor *flvr)
 {
-	char	    buf[32];
-	char	   *bulk, *alg;
+	char buf[32];
+	char *bulk, *alg;
 
 	memset(flvr, 0, sizeof(*flvr));
 
@@ -182,8 +182,8 @@ static void sptlrpc_rule_init(struct sptlrpc_rule *rule)
  */
 int sptlrpc_parse_rule(char *param, struct sptlrpc_rule *rule)
 {
-	char	   *flavor, *dir;
-	int	     rc;
+	char *flavor, *dir;
+	int rc;
 
 	sptlrpc_rule_init(rule);
 
@@ -309,9 +309,9 @@ static inline int rule_match_net(struct sptlrpc_rule *r1,
 int sptlrpc_rule_set_merge(struct sptlrpc_rule_set *rset,
 			   struct sptlrpc_rule *rule)
 {
-	struct sptlrpc_rule      *p = rset-&gt;srs_rules;
-	int		       spec_dir, spec_net;
-	int		       rc, n, match = 0;
+	struct sptlrpc_rule *p = rset-&gt;srs_rules;
+	int spec_dir, spec_net;
+	int rc, n, match = 0;
 
 	might_sleep();
 
@@ -403,8 +403,8 @@ int sptlrpc_rule_set_choose(struct sptlrpc_rule_set *rset,
 			    lnet_nid_t nid,
 			    struct sptlrpc_flavor *sf)
 {
-	struct sptlrpc_rule    *r;
-	int		     n;
+	struct sptlrpc_rule *r;
+	int n;
 
 	for (n = 0; n &lt; rset-&gt;srs_nrule; n++) {
 		r = &amp;rset-&gt;srs_rules[n];
@@ -433,7 +433,7 @@ EXPORT_SYMBOL(sptlrpc_rule_set_choose);
 void sptlrpc_rule_set_dump(struct sptlrpc_rule_set *rset)
 {
 	struct sptlrpc_rule *r;
-	int     n;
+	int n;
 
 	for (n = 0; n &lt; rset-&gt;srs_nrule; n++) {
 		r = &amp;rset-&gt;srs_rules[n];
@@ -474,8 +474,8 @@ static inline int is_hex(char c)
 
 static void target2fsname(const char *tgt, char *fsname, int buflen)
 {
-	const char     *ptr;
-	int	     len;
+	const char *ptr;
+	int len;
 
 	ptr = strrchr(tgt, '-');
 	if (ptr) {
@@ -583,8 +583,8 @@ static int sptlrpc_conf_merge_rule(struct sptlrpc_conf *conf,
 				   const char *target,
 				   struct sptlrpc_rule *rule)
 {
-	struct sptlrpc_conf_tgt  *conf_tgt;
-	struct sptlrpc_rule_set  *rule_set;
+	struct sptlrpc_conf_tgt *conf_tgt;
+	struct sptlrpc_rule_set *rule_set;
 
 	/* fsname == target means general rules for the whole fs */
 	if (strcmp(conf-&gt;sc_fsname, target) == 0) {
@@ -610,10 +610,10 @@ static int sptlrpc_conf_merge_rule(struct sptlrpc_conf *conf,
 static int __sptlrpc_process_config(struct lustre_cfg *lcfg,
 				    struct sptlrpc_conf *conf)
 {
-	char		   *target, *param;
-	char		    fsname[MTI_NAME_MAXLEN];
-	struct sptlrpc_rule     rule;
-	int		     rc;
+	char *target, *param;
+	char fsname[MTI_NAME_MAXLEN];
+	struct sptlrpc_rule rule;
+	int rc;
 
 	target = lustre_cfg_string(lcfg, 1);
 	if (target == NULL) {
@@ -671,8 +671,8 @@ EXPORT_SYMBOL(sptlrpc_process_config);
 
 static int logname2fsname(const char *logname, char *buf, int buflen)
 {
-	char   *ptr;
-	int     len;
+	char *ptr;
+	int len;
 
 	ptr = strrchr(logname, '-');
 	if (ptr == NULL || strcmp(ptr, "-sptlrpc")) {
@@ -690,7 +690,7 @@ static int logname2fsname(const char *logname, char *buf, int buflen)
 void sptlrpc_conf_log_update_begin(const char *logname)
 {
 	struct sptlrpc_conf *conf;
-	char		 fsname[16];
+	char fsname[16];
 
 	if (logname2fsname(logname, fsname, sizeof(fsname)))
 		return;
@@ -716,7 +716,7 @@ EXPORT_SYMBOL(sptlrpc_conf_log_update_begin);
 void sptlrpc_conf_log_update_end(const char *logname)
 {
 	struct sptlrpc_conf *conf;
-	char		 fsname[16];
+	char fsname[16];
 
 	if (logname2fsname(logname, fsname, sizeof(fsname)))
 		return;
@@ -741,7 +741,7 @@ EXPORT_SYMBOL(sptlrpc_conf_log_update_end);
 
 void sptlrpc_conf_log_start(const char *logname)
 {
-	char		 fsname[16];
+	char fsname[16];
 
 	if (logname2fsname(logname, fsname, sizeof(fsname)))
 		return;
@@ -755,7 +755,7 @@ EXPORT_SYMBOL(sptlrpc_conf_log_start);
 void sptlrpc_conf_log_stop(const char *logname)
 {
 	struct sptlrpc_conf *conf;
-	char		 fsname[16];
+	char fsname[16];
 
 	if (logname2fsname(logname, fsname, sizeof(fsname)))
 		return;
@@ -799,10 +799,10 @@ void sptlrpc_conf_choose_flavor(enum lustre_sec_part from,
 				lnet_nid_t nid,
 				struct sptlrpc_flavor *sf)
 {
-	struct sptlrpc_conf     *conf;
+	struct sptlrpc_conf *conf;
 	struct sptlrpc_conf_tgt *conf_tgt;
-	char		     name[MTI_NAME_MAXLEN];
-	int		      len, rc = 0;
+	char name[MTI_NAME_MAXLEN];
+	int len, rc = 0;
 
 	target2fsname(target-&gt;uuid, name, sizeof(name));
 
@@ -858,7 +858,7 @@ EXPORT_SYMBOL(sptlrpc_target_choose_flavor);
  */
 void sptlrpc_conf_client_adapt(struct obd_device *obd)
 {
-	struct obd_import  *imp;
+	struct obd_import *imp;
 
 	LASSERT(strcmp(obd-&gt;obd_type-&gt;typ_name, LUSTRE_MDC_NAME) == 0 ||
 		strcmp(obd-&gt;obd_type-&gt;typ_name, LUSTRE_OSC_NAME) == 0);
@@ -880,7 +880,7 @@ void sptlrpc_conf_client_adapt(struct obd_device *obd)
 }
 EXPORT_SYMBOL(sptlrpc_conf_client_adapt);
 
-int  sptlrpc_conf_init(void)
+int sptlrpc_conf_init(void)
 {
 	mutex_init(&amp;sptlrpc_conf_lock);
 	return 0;
@@ -888,7 +888,7 @@ int  sptlrpc_conf_init(void)
 
 void sptlrpc_conf_fini(void)
 {
-	struct sptlrpc_conf  *conf, *conf_next;
+	struct sptlrpc_conf *conf, *conf_next;
 
 	mutex_lock(&amp;sptlrpc_conf_lock);
 	list_for_each_entry_safe(conf, conf_next, &amp;sptlrpc_confs, sc_list) {
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c b/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
index 81de68edb04e..cdad608bdb8d 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
@@ -164,7 +164,7 @@ static void sec_do_gc(struct ptlrpc_sec *sec)
 static int sec_gc_main(void *arg)
 {
 	struct ptlrpc_thread *thread = (struct ptlrpc_thread *) arg;
-	struct l_wait_info    lwi;
+	struct l_wait_info lwi;
 
 	unshare_fs_struct();
 
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_lproc.c b/drivers/staging/lustre/lustre/ptlrpc/sec_lproc.c
index 982512febf05..68fcac14b3ee 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_lproc.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_lproc.c
@@ -74,7 +74,7 @@ static int sptlrpc_info_lprocfs_seq_show(struct seq_file *seq, void *v)
 	struct obd_device *dev = seq-&gt;private;
 	struct client_obd *cli = &amp;dev-&gt;u.cli;
 	struct ptlrpc_sec *sec = NULL;
-	char	       str[32];
+	char str[32];
 
 	LASSERT(strcmp(dev-&gt;obd_type-&gt;typ_name, LUSTRE_OSC_NAME) == 0 ||
 		strcmp(dev-&gt;obd_type-&gt;typ_name, LUSTRE_MDC_NAME) == 0 ||
@@ -134,7 +134,7 @@ LPROC_SEQ_FOPS_RO(sptlrpc_ctxs_lprocfs);
 
 int sptlrpc_lprocfs_cliobd_attach(struct obd_device *dev)
 {
-	int     rc;
+	int rc;
 
 	if (strcmp(dev-&gt;obd_type-&gt;typ_name, LUSTRE_OSC_NAME) != 0 &amp;&amp;
 	    strcmp(dev-&gt;obd_type-&gt;typ_name, LUSTRE_MDC_NAME) != 0 &amp;&amp;
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_null.c b/drivers/staging/lustre/lustre/ptlrpc/sec_null.c
index 4e132435b450..8c28b6b7ff02 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_null.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_null.c
@@ -92,7 +92,7 @@ int null_ctx_sign(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)
 static
 int null_ctx_verify(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)
 {
-	__u32   cksums, cksumc;
+	__u32 cksums, cksumc;
 
 	LASSERT(req-&gt;rq_repdata);
 
@@ -226,9 +226,9 @@ int null_enlarge_reqbuf(struct ptlrpc_sec *sec,
 			struct ptlrpc_request *req,
 			int segment, int newsize)
 {
-	struct lustre_msg      *newbuf;
-	struct lustre_msg      *oldbuf = req-&gt;rq_reqmsg;
-	int		     oldsize, newmsg_size, alloc_size;
+	struct lustre_msg *newbuf;
+	struct lustre_msg *oldbuf = req-&gt;rq_reqmsg;
+	int oldsize, newmsg_size, alloc_size;
 
 	LASSERT(req-&gt;rq_reqbuf);
 	LASSERT(req-&gt;rq_reqbuf == req-&gt;rq_reqmsg);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec_plain.c b/drivers/staging/lustre/lustre/ptlrpc/sec_plain.c
index 65f3ab42829c..ed39970417d8 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_plain.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_plain.c
@@ -136,7 +136,7 @@ static int plain_verify_bulk_csum(struct ptlrpc_bulk_desc *desc,
 				  struct plain_bulk_token *tokenr)
 {
 	struct plain_bulk_token tokenv;
-	int		     rc;
+	int rc;
 
 	if (hash_alg == BULK_HASH_ALG_NULL)
 		return 0;
@@ -154,8 +154,8 @@ static int plain_verify_bulk_csum(struct ptlrpc_bulk_desc *desc,
 
 static void corrupt_bulk_data(struct ptlrpc_bulk_desc *desc)
 {
-	char	   *ptr;
-	unsigned int    off, i;
+	char *ptr;
+	unsigned int off, i;
 
 	for (i = 0; i &lt; desc-&gt;bd_iov_count; i++) {
 		if (desc-&gt;bd_iov[i].kiov_len == 0)
@@ -190,7 +190,7 @@ int plain_ctx_validate(struct ptlrpc_cli_ctx *ctx)
 static
 int plain_ctx_sign(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)
 {
-	struct lustre_msg   *msg = req-&gt;rq_reqbuf;
+	struct lustre_msg *msg = req-&gt;rq_reqbuf;
 	struct plain_header *phdr;
 
 	msg-&gt;lm_secflvr = req-&gt;rq_flvr.sf_rpc;
@@ -214,10 +214,10 @@ int plain_ctx_sign(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)
 static
 int plain_ctx_verify(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)
 {
-	struct lustre_msg   *msg = req-&gt;rq_repdata;
+	struct lustre_msg *msg = req-&gt;rq_repdata;
 	struct plain_header *phdr;
-	__u32		cksum;
-	int		  swabbed;
+	__u32 cksum;
+	int swabbed;
 
 	if (msg-&gt;lm_bufcount != PLAIN_PACK_SEGMENTS) {
 		CERROR("unexpected reply buf count %u\n", msg-&gt;lm_bufcount);
@@ -290,8 +290,8 @@ int plain_cli_wrap_bulk(struct ptlrpc_cli_ctx *ctx,
 			struct ptlrpc_bulk_desc *desc)
 {
 	struct ptlrpc_bulk_sec_desc *bsd;
-	struct plain_bulk_token     *token;
-	int			  rc;
+	struct plain_bulk_token *token;
+	int rc;
 
 	LASSERT(req-&gt;rq_pack_bulk);
 	LASSERT(req-&gt;rq_reqbuf-&gt;lm_bufcount == PLAIN_PACK_SEGMENTS);
@@ -333,9 +333,9 @@ int plain_cli_unwrap_bulk(struct ptlrpc_cli_ctx *ctx,
 			  struct ptlrpc_bulk_desc *desc)
 {
 	struct ptlrpc_bulk_sec_desc *bsdv;
-	struct plain_bulk_token     *tokenv;
-	int			  rc;
-	int			  i, nob;
+	struct plain_bulk_token *tokenv;
+	int rc;
+	int i, nob;
 
 	LASSERT(req-&gt;rq_pack_bulk);
 	LASSERT(req-&gt;rq_reqbuf-&gt;lm_bufcount == PLAIN_PACK_SEGMENTS);
@@ -374,7 +374,7 @@ int plain_cli_unwrap_bulk(struct ptlrpc_cli_ctx *ctx,
 static
 struct ptlrpc_cli_ctx *plain_sec_install_ctx(struct plain_sec *plsec)
 {
-	struct ptlrpc_cli_ctx  *ctx, *ctx_new;
+	struct ptlrpc_cli_ctx *ctx, *ctx_new;
 
 	ctx_new = kzalloc(sizeof(*ctx_new), GFP_NOFS);
 
@@ -413,7 +413,7 @@ struct ptlrpc_cli_ctx *plain_sec_install_ctx(struct plain_sec *plsec)
 static
 void plain_destroy_sec(struct ptlrpc_sec *sec)
 {
-	struct plain_sec       *plsec = sec2plsec(sec);
+	struct plain_sec *plsec = sec2plsec(sec);
 
 	LASSERT(sec-&gt;ps_policy == &amp;plain_policy);
 	LASSERT(sec-&gt;ps_import);
@@ -437,9 +437,9 @@ struct ptlrpc_sec *plain_create_sec(struct obd_import *imp,
 				    struct ptlrpc_svc_ctx *svc_ctx,
 				    struct sptlrpc_flavor *sf)
 {
-	struct plain_sec       *plsec;
-	struct ptlrpc_sec      *sec;
-	struct ptlrpc_cli_ctx  *ctx;
+	struct plain_sec *plsec;
+	struct ptlrpc_sec *sec;
+	struct ptlrpc_cli_ctx *ctx;
 
 	LASSERT(SPTLRPC_FLVR_POLICY(sf-&gt;sf_rpc) == SPTLRPC_POLICY_PLAIN);
 
@@ -483,8 +483,8 @@ struct ptlrpc_cli_ctx *plain_lookup_ctx(struct ptlrpc_sec *sec,
 					struct vfs_cred *vcred,
 					int create, int remove_dead)
 {
-	struct plain_sec       *plsec = sec2plsec(sec);
-	struct ptlrpc_cli_ctx  *ctx;
+	struct plain_sec *plsec = sec2plsec(sec);
+	struct ptlrpc_cli_ctx *ctx;
 
 	read_lock(&amp;plsec-&gt;pls_lock);
 	ctx = plsec-&gt;pls_ctx;
@@ -517,8 +517,8 @@ static
 int plain_flush_ctx_cache(struct ptlrpc_sec *sec,
 			  uid_t uid, int grace, int force)
 {
-	struct plain_sec       *plsec = sec2plsec(sec);
-	struct ptlrpc_cli_ctx  *ctx;
+	struct plain_sec *plsec = sec2plsec(sec);
+	struct ptlrpc_cli_ctx *ctx;
 
 	/* do nothing unless caller want to flush for 'all' */
 	if (uid != -1)
@@ -540,7 +540,7 @@ int plain_alloc_reqbuf(struct ptlrpc_sec *sec,
 		       int msgsize)
 {
 	__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };
-	int   alloc_len;
+	int alloc_len;
 
 	buflens[PLAIN_PACK_HDR_OFF] = sizeof(struct plain_header);
 	buflens[PLAIN_PACK_MSG_OFF] = msgsize;
@@ -635,9 +635,9 @@ int plain_enlarge_reqbuf(struct ptlrpc_sec *sec,
 			 struct ptlrpc_request *req,
 			 int segment, int newsize)
 {
-	struct lustre_msg      *newbuf;
-	int		     oldsize;
-	int		     newmsg_size, newbuf_size;
+	struct lustre_msg *newbuf;
+	int oldsize;
+	int newmsg_size, newbuf_size;
 
 	LASSERT(req-&gt;rq_reqbuf);
 	LASSERT(req-&gt;rq_reqbuf_len &gt;= req-&gt;rq_reqlen);
@@ -709,9 +709,9 @@ static struct ptlrpc_svc_ctx plain_svc_ctx = {
 static
 int plain_accept(struct ptlrpc_request *req)
 {
-	struct lustre_msg   *msg = req-&gt;rq_reqbuf;
+	struct lustre_msg *msg = req-&gt;rq_reqbuf;
 	struct plain_header *phdr;
-	int		  swabbed;
+	int swabbed;
 
 	LASSERT(SPTLRPC_FLVR_POLICY(req-&gt;rq_flvr.sf_rpc) ==
 		SPTLRPC_POLICY_PLAIN);
@@ -780,9 +780,9 @@ int plain_accept(struct ptlrpc_request *req)
 static
 int plain_alloc_rs(struct ptlrpc_request *req, int msgsize)
 {
-	struct ptlrpc_reply_state   *rs;
-	__u32			buflens[PLAIN_PACK_SEGMENTS] = { 0, };
-	int			  rs_size = sizeof(*rs);
+	struct ptlrpc_reply_state *rs;
+	__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };
+	int rs_size = sizeof(*rs);
 
 	LASSERT(msgsize % 8 == 0);
 
@@ -833,9 +833,9 @@ static
 int plain_authorize(struct ptlrpc_request *req)
 {
 	struct ptlrpc_reply_state *rs = req-&gt;rq_reply_state;
-	struct lustre_msg_v2      *msg = rs-&gt;rs_repbuf;
-	struct plain_header       *phdr;
-	int			len;
+	struct lustre_msg_v2 *msg = rs-&gt;rs_repbuf;
+	struct plain_header *phdr;
+	int len;
 
 	LASSERT(rs);
 	LASSERT(msg);
@@ -880,10 +880,10 @@ static
 int plain_svc_unwrap_bulk(struct ptlrpc_request *req,
 			  struct ptlrpc_bulk_desc *desc)
 {
-	struct ptlrpc_reply_state   *rs = req-&gt;rq_reply_state;
+	struct ptlrpc_reply_state *rs = req-&gt;rq_reply_state;
 	struct ptlrpc_bulk_sec_desc *bsdr, *bsdv;
-	struct plain_bulk_token     *tokenr;
-	int			  rc;
+	struct plain_bulk_token *tokenr;
+	int rc;
 
 	LASSERT(req-&gt;rq_bulk_write);
 	LASSERT(req-&gt;rq_pack_bulk);
@@ -914,10 +914,10 @@ static
 int plain_svc_wrap_bulk(struct ptlrpc_request *req,
 			struct ptlrpc_bulk_desc *desc)
 {
-	struct ptlrpc_reply_state   *rs = req-&gt;rq_reply_state;
+	struct ptlrpc_reply_state *rs = req-&gt;rq_reply_state;
 	struct ptlrpc_bulk_sec_desc *bsdr, *bsdv;
-	struct plain_bulk_token     *tokenv;
-	int			  rc;
+	struct plain_bulk_token *tokenv;
+	int rc;
 
 	LASSERT(req-&gt;rq_bulk_read);
 	LASSERT(req-&gt;rq_pack_bulk);
diff --git a/drivers/staging/lustre/lustre/ptlrpc/service.c b/drivers/staging/lustre/lustre/ptlrpc/service.c
index 454d1a8640a5..25ccbcb1772f 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/service.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/service.c
@@ -72,7 +72,7 @@ struct mutex ptlrpc_all_services_mutex;
 struct ptlrpc_request_buffer_desc *
 ptlrpc_alloc_rqbd(struct ptlrpc_service_part *svcpt)
 {
-	struct ptlrpc_service		  *svc = svcpt-&gt;scp_service;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
 	struct ptlrpc_request_buffer_desc *rqbd;
 
 	rqbd = kzalloc_node(sizeof(*rqbd), GFP_NOFS,
@@ -121,10 +121,10 @@ ptlrpc_free_rqbd(struct ptlrpc_request_buffer_desc *rqbd)
 int
 ptlrpc_grow_req_bufs(struct ptlrpc_service_part *svcpt, int post)
 {
-	struct ptlrpc_service		  *svc = svcpt-&gt;scp_service;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
 	struct ptlrpc_request_buffer_desc *rqbd;
-	int				rc = 0;
-	int				i;
+	int rc = 0;
+	int i;
 
 	if (svcpt-&gt;scp_rqbd_allocating)
 		goto try_post;
@@ -186,7 +186,7 @@ ptlrpc_save_lock(struct ptlrpc_request *req,
 		 struct lustre_handle *lock, int mode, int no_ack)
 {
 	struct ptlrpc_reply_state *rs = req-&gt;rq_reply_state;
-	int			idx;
+	int idx;
 
 	LASSERT(rs != NULL);
 	LASSERT(rs-&gt;rs_nlocks &lt; RS_MAX_LOCKS);
@@ -275,8 +275,8 @@ static void rs_batch_init(struct rs_batch *b)
 static struct ptlrpc_hr_thread *
 ptlrpc_hr_select(struct ptlrpc_service_part *svcpt)
 {
-	struct ptlrpc_hr_partition	*hrp;
-	unsigned int			rotor;
+	struct ptlrpc_hr_partition *hrp;
+	unsigned int rotor;
 
 	if (svcpt-&gt;scp_cpt &gt;= 0 &amp;&amp;
 	    svcpt-&gt;scp_service-&gt;srv_cptable == ptlrpc_hr.hr_cpt_table) {
@@ -431,8 +431,8 @@ static int
 ptlrpc_server_post_idle_rqbds(struct ptlrpc_service_part *svcpt)
 {
 	struct ptlrpc_request_buffer_desc *rqbd;
-	int				  rc;
-	int				  posted = 0;
+	int rc;
+	int posted = 0;
 
 	for (;;) {
 		spin_lock(&amp;svcpt-&gt;scp_lock);
@@ -489,11 +489,11 @@ static void
 ptlrpc_server_nthreads_check(struct ptlrpc_service *svc,
 			     struct ptlrpc_service_conf *conf)
 {
-	struct ptlrpc_service_thr_conf	*tc = &amp;conf-&gt;psc_thr;
-	unsigned			init;
-	unsigned			total;
-	unsigned			nthrs;
-	int				weight;
+	struct ptlrpc_service_thr_conf *tc = &amp;conf-&gt;psc_thr;
+	unsigned init;
+	unsigned total;
+	unsigned nthrs;
+	int weight;
 
 	/*
 	 * Common code for estimating &amp; validating threads number.
@@ -517,7 +517,7 @@ ptlrpc_server_nthreads_check(struct ptlrpc_service *svc,
 		 * be up to 8 * nthrs_max */
 		total = min(tc-&gt;tc_nthrs_max * 8, tc-&gt;tc_nthrs_user);
 		nthrs = total / svc-&gt;srv_ncpts;
-		init  = max(init, nthrs);
+		init = max(init, nthrs);
 		goto out;
 	}
 
@@ -531,7 +531,7 @@ ptlrpc_server_nthreads_check(struct ptlrpc_service *svc,
 
 	nthrs = tc-&gt;tc_nthrs_base;
 	if (svc-&gt;srv_ncpts == 1) {
-		int	i;
+		int i;
 
 		/* NB: Increase the base number if it's single partition
 		 * and total number of cores/HTs is larger or equal to 4.
@@ -543,7 +543,7 @@ ptlrpc_server_nthreads_check(struct ptlrpc_service *svc,
 	}
 
 	if (tc-&gt;tc_thr_factor != 0) {
-		int	  factor = tc-&gt;tc_thr_factor;
+		int factor = tc-&gt;tc_thr_factor;
 		const int fade = 4;
 
 		/*
@@ -595,9 +595,9 @@ ptlrpc_service_part_init(struct ptlrpc_service *svc,
 			 struct ptlrpc_service_part *svcpt, int cpt)
 {
 	struct ptlrpc_at_array	*array;
-	int			size;
-	int			index;
-	int			rc;
+	int size;
+	int index;
+	int rc;
 
 	svcpt-&gt;scp_cpt = cpt;
 	INIT_LIST_HEAD(&amp;svcpt-&gt;scp_threads);
@@ -627,8 +627,8 @@ ptlrpc_service_part_init(struct ptlrpc_service *svc,
 	array = &amp;svcpt-&gt;scp_at_array;
 
 	size = at_est2timeout(at_max);
-	array-&gt;paa_size     = size;
-	array-&gt;paa_count    = 0;
+	array-&gt;paa_size = size;
+	array-&gt;paa_count = 0;
 	array-&gt;paa_deadline = -1;
 
 	/* allocate memory for scp_at_array (ptlrpc_at_array) */
@@ -683,15 +683,15 @@ ptlrpc_register_service(struct ptlrpc_service_conf *conf,
 			struct kset *parent,
 			struct dentry *debugfs_entry)
 {
-	struct ptlrpc_service_cpt_conf	*cconf = &amp;conf-&gt;psc_cpt;
-	struct ptlrpc_service		*service;
-	struct ptlrpc_service_part	*svcpt;
-	struct cfs_cpt_table		*cptable;
-	__u32				*cpts = NULL;
-	int				ncpts;
-	int				cpt;
-	int				rc;
-	int				i;
+	struct ptlrpc_service_cpt_conf *cconf = &amp;conf-&gt;psc_cpt;
+	struct ptlrpc_service *service;
+	struct ptlrpc_service_part *svcpt;
+	struct cfs_cpt_table *cptable;
+	__u32 *cpts = NULL;
+	int ncpts;
+	int cpt;
+	int rc;
+	int i;
 
 	LASSERT(conf-&gt;psc_buf.bc_nbufs &gt; 0);
 	LASSERT(conf-&gt;psc_buf.bc_buf_size &gt;=
@@ -707,7 +707,7 @@ ptlrpc_register_service(struct ptlrpc_service_conf *conf,
 	} else {
 		ncpts = cfs_cpt_number(cptable);
 		if (cconf-&gt;cc_pattern != NULL) {
-			struct cfs_expr_list	*el;
+			struct cfs_expr_list *el;
 
 			rc = cfs_expr_list_parse(cconf-&gt;cc_pattern,
 						 strlen(cconf-&gt;cc_pattern),
@@ -737,9 +737,9 @@ ptlrpc_register_service(struct ptlrpc_service_conf *conf,
 		return ERR_PTR(-ENOMEM);
 	}
 
-	service-&gt;srv_cptable		= cptable;
-	service-&gt;srv_cpts		= cpts;
-	service-&gt;srv_ncpts		= ncpts;
+	service-&gt;srv_cptable = cptable;
+	service-&gt;srv_cpts = cpts;
+	service-&gt;srv_ncpts = ncpts;
 
 	service-&gt;srv_cpt_bits = 0; /* it's zero already, easy to read... */
 	while ((1 &lt;&lt; service-&gt;srv_cpt_bits) &lt; cfs_cpt_number(cptable))
@@ -747,18 +747,18 @@ ptlrpc_register_service(struct ptlrpc_service_conf *conf,
 
 	/* public members */
 	spin_lock_init(&amp;service-&gt;srv_lock);
-	service-&gt;srv_name		= conf-&gt;psc_name;
-	service-&gt;srv_watchdog_factor	= conf-&gt;psc_watchdog_factor;
+	service-&gt;srv_name = conf-&gt;psc_name;
+	service-&gt;srv_watchdog_factor = conf-&gt;psc_watchdog_factor;
 	INIT_LIST_HEAD(&amp;service-&gt;srv_list); /* for safety of cleanup */
 
 	/* buffer configuration */
-	service-&gt;srv_nbuf_per_group	= test_req_buffer_pressure ?
+	service-&gt;srv_nbuf_per_group = test_req_buffer_pressure ?
 					  1 : conf-&gt;psc_buf.bc_nbufs;
-	service-&gt;srv_max_req_size	= conf-&gt;psc_buf.bc_req_max_size +
+	service-&gt;srv_max_req_size = conf-&gt;psc_buf.bc_req_max_size +
 					  SPTLRPC_MAX_PAYLOAD;
-	service-&gt;srv_buf_size		= conf-&gt;psc_buf.bc_buf_size;
-	service-&gt;srv_rep_portal		= conf-&gt;psc_buf.bc_rep_portal;
-	service-&gt;srv_req_portal		= conf-&gt;psc_buf.bc_req_portal;
+	service-&gt;srv_buf_size = conf-&gt;psc_buf.bc_buf_size;
+	service-&gt;srv_rep_portal	= conf-&gt;psc_buf.bc_rep_portal;
+	service-&gt;srv_req_portal	= conf-&gt;psc_buf.bc_req_portal;
 
 	/* Increase max reply size to next power of two */
 	service-&gt;srv_max_reply_size = 1;
@@ -766,10 +766,10 @@ ptlrpc_register_service(struct ptlrpc_service_conf *conf,
 	       conf-&gt;psc_buf.bc_rep_max_size + SPTLRPC_MAX_PAYLOAD)
 		service-&gt;srv_max_reply_size &lt;&lt;= 1;
 
-	service-&gt;srv_thread_name	= conf-&gt;psc_thr.tc_thr_name;
-	service-&gt;srv_ctx_tags		= conf-&gt;psc_thr.tc_ctx_tags;
-	service-&gt;srv_hpreq_ratio	= PTLRPC_SVC_HP_RATIO;
-	service-&gt;srv_ops		= conf-&gt;psc_ops;
+	service-&gt;srv_thread_name = conf-&gt;psc_thr.tc_thr_name;
+	service-&gt;srv_ctx_tags = conf-&gt;psc_thr.tc_ctx_tags;
+	service-&gt;srv_hpreq_ratio = PTLRPC_SVC_HP_RATIO;
+	service-&gt;srv_ops = conf-&gt;psc_ops;
 
 	for (i = 0; i &lt; ncpts; i++) {
 		if (!conf-&gt;psc_thr.tc_cpu_affinity)
@@ -859,11 +859,11 @@ static void ptlrpc_server_free_request(struct ptlrpc_request *req)
 void ptlrpc_server_drop_request(struct ptlrpc_request *req)
 {
 	struct ptlrpc_request_buffer_desc *rqbd = req-&gt;rq_rqbd;
-	struct ptlrpc_service_part	  *svcpt = rqbd-&gt;rqbd_svcpt;
-	struct ptlrpc_service		  *svc = svcpt-&gt;scp_service;
-	int				refcount;
-	struct list_head			*tmp;
-	struct list_head			*nxt;
+	struct ptlrpc_service_part *svcpt = rqbd-&gt;rqbd_svcpt;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
+	int refcount;
+	struct list_head *tmp;
+	struct list_head *nxt;
 
 	if (!atomic_dec_and_test(&amp;req-&gt;rq_refcount))
 		return;
@@ -1387,7 +1387,7 @@ static int ptlrpc_at_check_timed(struct ptlrpc_service_part *svcpt)
 	struct ptlrpc_at_array *array = &amp;svcpt-&gt;scp_at_array;
 	struct ptlrpc_request *rq, *n;
 	struct list_head work_list;
-	__u32  index, count;
+	__u32 index, count;
 	time_t deadline;
 	time_t now = get_seconds();
 	long delay;
@@ -1732,10 +1732,10 @@ static int
 ptlrpc_server_handle_req_in(struct ptlrpc_service_part *svcpt,
 			    struct ptlrpc_thread *thread)
 {
-	struct ptlrpc_service	*svc = svcpt-&gt;scp_service;
-	struct ptlrpc_request	*req;
-	__u32			deadline;
-	int			rc;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
+	struct ptlrpc_request *req;
+	__u32 deadline;
+	int rc;
 
 	spin_lock(&amp;svcpt-&gt;scp_lock);
 	if (list_empty(&amp;svcpt-&gt;scp_req_incoming)) {
@@ -1876,11 +1876,11 @@ ptlrpc_server_handle_request(struct ptlrpc_service_part *svcpt,
 {
 	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
 	struct ptlrpc_request *request;
-	struct timeval	 work_start;
-	struct timeval	 work_end;
-	long		   timediff;
-	int		    rc;
-	int		    fail_opc = 0;
+	struct timeval work_start;
+	struct timeval work_end;
+	long timediff;
+	int rc;
+	int fail_opc = 0;
 
 	request = ptlrpc_server_request_get(svcpt, false);
 	if (request == NULL)
@@ -2032,10 +2032,10 @@ static int
 ptlrpc_handle_rs(struct ptlrpc_reply_state *rs)
 {
 	struct ptlrpc_service_part *svcpt = rs-&gt;rs_svcpt;
-	struct ptlrpc_service     *svc = svcpt-&gt;scp_service;
-	struct obd_export	 *exp;
-	int			nlocks;
-	int			been_handled;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
+	struct obd_export *exp;
+	int nlocks;
+	int been_handled;
 
 	exp = rs-&gt;rs_export;
 
@@ -2262,10 +2262,10 @@ ptlrpc_wait_event(struct ptlrpc_service_part *svcpt,
  */
 static int ptlrpc_main(void *arg)
 {
-	struct ptlrpc_thread		*thread = (struct ptlrpc_thread *)arg;
-	struct ptlrpc_service_part	*svcpt = thread-&gt;t_svcpt;
-	struct ptlrpc_service		*svc = svcpt-&gt;scp_service;
-	struct ptlrpc_reply_state	*rs;
+	struct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;
+	struct ptlrpc_service_part *svcpt = thread-&gt;t_svcpt;
+	struct ptlrpc_service *svc = svcpt-&gt;scp_service;
+	struct ptlrpc_reply_state *rs;
 	struct group_info *ginfo = NULL;
 	struct lu_env *env;
 	int counter = 0, rc = 0;
@@ -2464,11 +2464,11 @@ static int hrt_dont_sleep(struct ptlrpc_hr_thread *hrt,
  */
 static int ptlrpc_hr_main(void *arg)
 {
-	struct ptlrpc_hr_thread		*hrt = (struct ptlrpc_hr_thread *)arg;
-	struct ptlrpc_hr_partition	*hrp = hrt-&gt;hrt_partition;
-	LIST_HEAD			(replies);
-	char				threadname[20];
-	int				rc;
+	struct ptlrpc_hr_thread	*hrt = (struct ptlrpc_hr_thread *)arg;
+	struct ptlrpc_hr_partition *hrp = hrt-&gt;hrt_partition;
+	LIST_HEAD	(replies);
+	char threadname[20];
+	int rc;
 
 	snprintf(threadname, sizeof(threadname), "ptlrpc_hr%02d_%03d",
 		 hrp-&gt;hrp_cpt, hrt-&gt;hrt_id);
@@ -2505,9 +2505,9 @@ static int ptlrpc_hr_main(void *arg)
 
 static void ptlrpc_stop_hr_threads(void)
 {
-	struct ptlrpc_hr_partition	*hrp;
-	int				i;
-	int				j;
+	struct ptlrpc_hr_partition *hrp;
+	int i;
+	int j;
 
 	ptlrpc_hr.hr_stopping = 1;
 
@@ -2529,12 +2529,12 @@ static void ptlrpc_stop_hr_threads(void)
 
 static int ptlrpc_start_hr_threads(void)
 {
-	struct ptlrpc_hr_partition	*hrp;
-	int				i;
-	int				j;
+	struct ptlrpc_hr_partition *hrp;
+	int i;
+	int j;
 
 	cfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {
-		int	rc = 0;
+		int rc = 0;
 
 		for (j = 0; j &lt; hrp-&gt;hrp_nthrs; j++) {
 			struct	ptlrpc_hr_thread *hrt = &amp;hrp-&gt;hrp_thrs[j];
@@ -2561,9 +2561,9 @@ static int ptlrpc_start_hr_threads(void)
 
 static void ptlrpc_svcpt_stop_threads(struct ptlrpc_service_part *svcpt)
 {
-	struct l_wait_info	lwi = { 0 };
-	struct ptlrpc_thread	*thread;
-	LIST_HEAD		(zombie);
+	struct l_wait_info lwi = { 0 };
+	struct ptlrpc_thread *thread;
+	LIST_HEAD	(zombie);
 
 	CDEBUG(D_INFO, "Stopping threads for service %s\n",
 	       svcpt-&gt;scp_service-&gt;srv_name);
@@ -2612,7 +2612,7 @@ static void ptlrpc_svcpt_stop_threads(struct ptlrpc_service_part *svcpt)
 void ptlrpc_stop_all_threads(struct ptlrpc_service *svc)
 {
 	struct ptlrpc_service_part *svcpt;
-	int			   i;
+	int i;
 
 	ptlrpc_service_for_each_part(svcpt, i, svc) {
 		if (svcpt-&gt;scp_service != NULL)
@@ -2623,9 +2623,9 @@ EXPORT_SYMBOL(ptlrpc_stop_all_threads);
 
 int ptlrpc_start_threads(struct ptlrpc_service *svc)
 {
-	int	rc = 0;
-	int	i;
-	int	j;
+	int rc = 0;
+	int i;
+	int j;
 
 	/* We require 2 threads min, see note in ptlrpc_server_handle_request */
 	LASSERT(svc-&gt;srv_nthrs_cpt_init &gt;= PTLRPC_NTHRS_INIT);
@@ -2654,10 +2654,10 @@ EXPORT_SYMBOL(ptlrpc_start_threads);
 
 int ptlrpc_start_thread(struct ptlrpc_service_part *svcpt, int wait)
 {
-	struct l_wait_info	lwi = { 0 };
-	struct ptlrpc_thread	*thread;
-	struct ptlrpc_service	*svc;
-	int			rc;
+	struct l_wait_info lwi = { 0 };
+	struct ptlrpc_thread *thread;
+	struct ptlrpc_service *svc;
+	int rc;
 
 	LASSERT(svcpt != NULL);
 
@@ -2759,12 +2759,12 @@ int ptlrpc_start_thread(struct ptlrpc_service_part *svcpt, int wait)
 
 int ptlrpc_hr_init(void)
 {
-	struct ptlrpc_hr_partition	*hrp;
-	struct ptlrpc_hr_thread		*hrt;
-	int				rc;
-	int				i;
-	int				j;
-	int				weight;
+	struct ptlrpc_hr_partition *hrp;
+	struct ptlrpc_hr_thread	*hrt;
+	int rc;
+	int i;
+	int j;
+	int weight;
 
 	memset(&amp;ptlrpc_hr, 0, sizeof(ptlrpc_hr));
 	ptlrpc_hr.hr_cpt_table = cfs_cpt_table;
@@ -2817,8 +2817,8 @@ int ptlrpc_hr_init(void)
 
 void ptlrpc_hr_fini(void)
 {
-	struct ptlrpc_hr_partition	*hrp;
-	int				i;
+	struct ptlrpc_hr_partition *hrp;
+	int i;
 
 	if (ptlrpc_hr.hr_partitions == NULL)
 		return;
@@ -2858,8 +2858,8 @@ static void ptlrpc_wait_replies(struct ptlrpc_service_part *svcpt)
 static void
 ptlrpc_service_del_atimer(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	*svcpt;
-	int				i;
+	struct ptlrpc_service_part *svcpt;
+	int i;
 
 	/* early disarm AT timer... */
 	ptlrpc_service_for_each_part(svcpt, i, svc) {
@@ -2871,11 +2871,11 @@ ptlrpc_service_del_atimer(struct ptlrpc_service *svc)
 static void
 ptlrpc_service_unlink_rqbd(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	  *svcpt;
+	struct ptlrpc_service_part *svcpt;
 	struct ptlrpc_request_buffer_desc *rqbd;
-	struct l_wait_info		  lwi;
-	int				  rc;
-	int				  i;
+	struct l_wait_info lwi;
+	int rc;
+	int i;
 
 	/* All history will be culled when the next request buffer is
 	 * freed in ptlrpc_service_purge_all() */
@@ -2927,11 +2927,11 @@ ptlrpc_service_unlink_rqbd(struct ptlrpc_service *svc)
 static void
 ptlrpc_service_purge_all(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part		*svcpt;
-	struct ptlrpc_request_buffer_desc	*rqbd;
-	struct ptlrpc_request			*req;
-	struct ptlrpc_reply_state		*rs;
-	int					i;
+	struct ptlrpc_service_part *svcpt;
+	struct ptlrpc_request_buffer_desc *rqbd;
+	struct ptlrpc_request *req;
+	struct ptlrpc_reply_state *rs;
+	int i;
 
 	ptlrpc_service_for_each_part(svcpt, i, svc) {
 		if (svcpt-&gt;scp_service == NULL)
@@ -2995,9 +2995,9 @@ ptlrpc_service_purge_all(struct ptlrpc_service *svc)
 static void
 ptlrpc_service_free(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	*svcpt;
-	struct ptlrpc_at_array		*array;
-	int				i;
+	struct ptlrpc_service_part *svcpt;
+	struct ptlrpc_at_array *array;
+	int i;
 
 	ptlrpc_service_for_each_part(svcpt, i, svc) {
 		if (svcpt-&gt;scp_service == NULL)
@@ -3056,9 +3056,9 @@ EXPORT_SYMBOL(ptlrpc_unregister_service);
  * to be shot, so it's intentionally non-aggressive. */
 int ptlrpc_svcpt_health_check(struct ptlrpc_service_part *svcpt)
 {
-	struct ptlrpc_request		*request = NULL;
-	struct timeval			right_now;
-	long				timediff;
+	struct ptlrpc_request *request = NULL;
+	struct timeval right_now;
+	long timediff;
 
 	do_gettimeofday(&amp;right_now);
 
@@ -3090,8 +3090,8 @@ int ptlrpc_svcpt_health_check(struct ptlrpc_service_part *svcpt)
 int
 ptlrpc_service_health_check(struct ptlrpc_service *svc)
 {
-	struct ptlrpc_service_part	*svcpt;
-	int				i;
+	struct ptlrpc_service_part *svcpt;
+	int i;
 
 	if (svc == NULL)
 		return 0;</pre><hr><pre>commit 29ac6840d7c8b4ce60c9dcd0a55fce6a84d3bae0
Author: Chris Hanna &lt;hannac@iu.edu&gt;
Date:   Wed Jun 3 10:23:42 2015 -0400

    staging: lustre: osc: clean up whitespace and align function parameters
    
    Minor changes to remove excessive whitespace and improve
    readability of osc functions.
    
    Signed-off-by: Chris Hanna &lt;hannac@iu.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/lustre/lustre/osc/lproc_osc.c b/drivers/staging/lustre/lustre/osc/lproc_osc.c
index 9dc84ba7aa55..ff6d2e2ffdab 100644
--- a/drivers/staging/lustre/lustre/osc/lproc_osc.c
+++ b/drivers/staging/lustre/lustre/osc/lproc_osc.c
@@ -417,8 +417,8 @@ static ssize_t osc_checksum_type_seq_write(struct file *file,
 LPROC_SEQ_FOPS(osc_checksum_type);
 
 static ssize_t resend_count_show(struct kobject *kobj,
-			     struct attribute *attr,
-			     char *buf)
+				 struct attribute *attr,
+				 char *buf)
 {
 	struct obd_device *obd = container_of(kobj, struct obd_device,
 					      obd_kobj);
@@ -427,9 +427,9 @@ static ssize_t resend_count_show(struct kobject *kobj,
 }
 
 static ssize_t resend_count_store(struct kobject *kobj,
-			      struct attribute *attr,
-			      const char *buffer,
-			      size_t count)
+				  struct attribute *attr,
+				  const char *buffer,
+				  size_t count)
 {
 	struct obd_device *obd = container_of(kobj, struct obd_device,
 					      obd_kobj);
@@ -682,8 +682,8 @@ static int osc_rpc_stats_seq_show(struct seq_file *seq, void *v)
 #undef pct
 
 static ssize_t osc_rpc_stats_seq_write(struct file *file,
-				const char __user *buf,
-				size_t len, loff_t *off)
+				       const char __user *buf,
+				       size_t len, loff_t *off)
 {
 	struct seq_file *seq = file-&gt;private_data;
 	struct obd_device *dev = seq-&gt;private;
@@ -721,8 +721,8 @@ static int osc_stats_seq_show(struct seq_file *seq, void *v)
 }
 
 static ssize_t osc_stats_seq_write(struct file *file,
-				const char __user *buf,
-				size_t len, loff_t *off)
+				   const char __user *buf,
+				   size_t len, loff_t *off)
 {
 	struct seq_file *seq = file-&gt;private_data;
 	struct obd_device *dev = seq-&gt;private;
diff --git a/drivers/staging/lustre/lustre/osc/osc_cache.c b/drivers/staging/lustre/lustre/osc/osc_cache.c
index d44b3d4ffe4d..5592d32a1a95 100644
--- a/drivers/staging/lustre/lustre/osc/osc_cache.c
+++ b/drivers/staging/lustre/lustre/osc/osc_cache.c
@@ -112,8 +112,8 @@ static const char *oes_strings[] = {
 		/* ----- extent part 0 ----- */				      \
 		__ext, EXTPARA(__ext),					      \
 		/* ----- part 1 ----- */				      \
-		atomic_read(&amp;__ext-&gt;oe_refc),			      \
-		atomic_read(&amp;__ext-&gt;oe_users),			      \
+		atomic_read(&amp;__ext-&gt;oe_refc),				      \
+		atomic_read(&amp;__ext-&gt;oe_users),				      \
 		list_empty_marker(&amp;__ext-&gt;oe_link),			      \
 		oes_strings[__ext-&gt;oe_state], ext_flags(__ext, __buf),	      \
 		__ext-&gt;oe_obj,						      \
@@ -297,12 +297,12 @@ static int osc_extent_sanity_check0(struct osc_extent *ext,
 #define sanity_check_nolock(ext) \
 	osc_extent_sanity_check0(ext, __func__, __LINE__)
 
-#define sanity_check(ext) ({						   \
-	int __res;							     \
+#define sanity_check(ext) ({						\
+	int __res;							\
 	osc_object_lock((ext)-&gt;oe_obj);					\
-	__res = sanity_check_nolock(ext);				      \
-	osc_object_unlock((ext)-&gt;oe_obj);				      \
-	__res;								 \
+	__res = sanity_check_nolock(ext);				\
+	osc_object_unlock((ext)-&gt;oe_obj);				\
+	__res;								\
 })
 
 
@@ -411,7 +411,7 @@ static void osc_extent_put_trust(struct osc_extent *ext)
 static struct osc_extent *osc_extent_search(struct osc_object *obj,
 					    pgoff_t index)
 {
-	struct rb_node    *n = obj-&gt;oo_root.rb_node;
+	struct rb_node *n = obj-&gt;oo_root.rb_node;
 	struct osc_extent *tmp, *p = NULL;
 
 	LASSERT(osc_object_is_locked(obj));
@@ -447,8 +447,8 @@ static struct osc_extent *osc_extent_lookup(struct osc_object *obj,
 /* caller must have held object lock. */
 static void osc_extent_insert(struct osc_object *obj, struct osc_extent *ext)
 {
-	struct rb_node   **n      = &amp;obj-&gt;oo_root.rb_node;
-	struct rb_node    *parent = NULL;
+	struct rb_node **n = &amp;obj-&gt;oo_root.rb_node;
+	struct rb_node *parent = NULL;
 	struct osc_extent *tmp;
 
 	LASSERT(ext-&gt;oe_intree == 0);
@@ -544,19 +544,19 @@ static int osc_extent_merge(const struct lu_env *env, struct osc_extent *cur,
 	LASSERT(cur-&gt;oe_osclock == victim-&gt;oe_osclock);
 	ppc_bits = osc_cli(obj)-&gt;cl_chunkbits - PAGE_CACHE_SHIFT;
 	chunk_start = cur-&gt;oe_start &gt;&gt; ppc_bits;
-	chunk_end   = cur-&gt;oe_end   &gt;&gt; ppc_bits;
-	if (chunk_start   != (victim-&gt;oe_end &gt;&gt; ppc_bits) + 1 &amp;&amp;
+	chunk_end = cur-&gt;oe_end &gt;&gt; ppc_bits;
+	if (chunk_start != (victim-&gt;oe_end &gt;&gt; ppc_bits) + 1 &amp;&amp;
 	    chunk_end + 1 != victim-&gt;oe_start &gt;&gt; ppc_bits)
 		return -ERANGE;
 
 	OSC_EXTENT_DUMP(D_CACHE, victim, "will be merged by %p.\n", cur);
 
-	cur-&gt;oe_start     = min(cur-&gt;oe_start, victim-&gt;oe_start);
-	cur-&gt;oe_end       = max(cur-&gt;oe_end,   victim-&gt;oe_end);
-	cur-&gt;oe_grants   += victim-&gt;oe_grants;
+	cur-&gt;oe_start = min(cur-&gt;oe_start, victim-&gt;oe_start);
+	cur-&gt;oe_end = max(cur-&gt;oe_end, victim-&gt;oe_end);
+	cur-&gt;oe_grants += victim-&gt;oe_grants;
 	cur-&gt;oe_nr_pages += victim-&gt;oe_nr_pages;
 	/* only the following bits are needed to merge */
-	cur-&gt;oe_urgent   |= victim-&gt;oe_urgent;
+	cur-&gt;oe_urgent |= victim-&gt;oe_urgent;
 	cur-&gt;oe_memalloc |= victim-&gt;oe_memalloc;
 	list_splice_init(&amp;victim-&gt;oe_pages, &amp;cur-&gt;oe_pages);
 	list_del_init(&amp;victim-&gt;oe_link);
@@ -624,18 +624,18 @@ struct osc_extent *osc_extent_find(const struct lu_env *env,
 
 {
 	struct client_obd *cli = osc_cli(obj);
-	struct cl_lock    *lock;
+	struct cl_lock *lock;
 	struct osc_extent *cur;
 	struct osc_extent *ext;
 	struct osc_extent *conflict = NULL;
 	struct osc_extent *found = NULL;
-	pgoff_t    chunk;
-	pgoff_t    max_end;
-	int	max_pages; /* max_pages_per_rpc */
-	int	chunksize;
-	int	ppc_bits; /* pages per chunk bits */
-	int	chunk_mask;
-	int	rc;
+	pgoff_t chunk;
+	pgoff_t max_end;
+	int max_pages; /* max_pages_per_rpc */
+	int chunksize;
+	int ppc_bits; /* pages per chunk bits */
+	int chunk_mask;
+	int rc;
 
 	cur = osc_extent_alloc(obj);
 	if (cur == NULL)
@@ -646,10 +646,10 @@ struct osc_extent *osc_extent_find(const struct lu_env *env,
 	LASSERT(lock-&gt;cll_descr.cld_mode &gt;= CLM_WRITE);
 
 	LASSERT(cli-&gt;cl_chunkbits &gt;= PAGE_CACHE_SHIFT);
-	ppc_bits   = cli-&gt;cl_chunkbits - PAGE_CACHE_SHIFT;
+	ppc_bits = cli-&gt;cl_chunkbits - PAGE_CACHE_SHIFT;
 	chunk_mask = ~((1 &lt;&lt; ppc_bits) - 1);
-	chunksize  = 1 &lt;&lt; cli-&gt;cl_chunkbits;
-	chunk      = index &gt;&gt; ppc_bits;
+	chunksize = 1 &lt;&lt; cli-&gt;cl_chunkbits;
+	chunk = index &gt;&gt; ppc_bits;
 
 	/* align end to rpc edge, rpc size may not be a power 2 integer. */
 	max_pages = cli-&gt;cl_max_pages_per_rpc;
@@ -659,15 +659,15 @@ struct osc_extent *osc_extent_find(const struct lu_env *env,
 
 	/* initialize new extent by parameters so far */
 	cur-&gt;oe_max_end = max_end;
-	cur-&gt;oe_start   = index &amp; chunk_mask;
-	cur-&gt;oe_end     = ((index + ~chunk_mask + 1) &amp; chunk_mask) - 1;
+	cur-&gt;oe_start = index &amp; chunk_mask;
+	cur-&gt;oe_end = ((index + ~chunk_mask + 1) &amp; chunk_mask) - 1;
 	if (cur-&gt;oe_start &lt; lock-&gt;cll_descr.cld_start)
 		cur-&gt;oe_start = lock-&gt;cll_descr.cld_start;
 	if (cur-&gt;oe_end &gt; max_end)
 		cur-&gt;oe_end = max_end;
 	cur-&gt;oe_osclock = lock;
-	cur-&gt;oe_grants  = 0;
-	cur-&gt;oe_mppr    = max_pages;
+	cur-&gt;oe_grants = 0;
+	cur-&gt;oe_mppr = max_pages;
 
 	/* grants has been allocated by caller */
 	LASSERTF(*grants &gt;= chunksize + cli-&gt;cl_extent_tax,
@@ -681,7 +681,7 @@ struct osc_extent *osc_extent_find(const struct lu_env *env,
 		ext = first_extent(obj);
 	while (ext != NULL) {
 		loff_t ext_chk_start = ext-&gt;oe_start &gt;&gt; ppc_bits;
-		loff_t ext_chk_end   = ext-&gt;oe_end   &gt;&gt; ppc_bits;
+		loff_t ext_chk_end = ext-&gt;oe_end &gt;&gt; ppc_bits;
 
 		LASSERT(sanity_check_nolock(ext) == 0);
 		if (chunk &gt; ext_chk_end + 1)
@@ -755,14 +755,14 @@ struct osc_extent *osc_extent_find(const struct lu_env *env,
 			EASSERT((ext-&gt;oe_start &amp; ~chunk_mask) == 0, ext);
 
 			/* pull ext's start back to cover cur */
-			ext-&gt;oe_start   = cur-&gt;oe_start;
+			ext-&gt;oe_start = cur-&gt;oe_start;
 			ext-&gt;oe_grants += chunksize;
 			*grants -= chunksize;
 
 			found = osc_extent_hold(ext);
 		} else if (chunk == ext_chk_end + 1) {
 			/* rear merge */
-			ext-&gt;oe_end     = cur-&gt;oe_end;
+			ext-&gt;oe_end = cur-&gt;oe_end;
 			ext-&gt;oe_grants += chunksize;
 			*grants -= chunksize;
 
@@ -943,21 +943,21 @@ static int osc_extent_wait(const struct lu_env *env, struct osc_extent *ext,
  * @size, then partial truncate happens.
  */
 static int osc_extent_truncate(struct osc_extent *ext, pgoff_t trunc_index,
-				bool partial)
+			       bool partial)
 {
-	struct cl_env_nest     nest;
-	struct lu_env	 *env;
-	struct cl_io	  *io;
-	struct osc_object     *obj = ext-&gt;oe_obj;
-	struct client_obd     *cli = osc_cli(obj);
+	struct cl_env_nest nest;
+	struct lu_env *env;
+	struct cl_io *io;
+	struct osc_object *obj = ext-&gt;oe_obj;
+	struct client_obd *cli = osc_cli(obj);
 	struct osc_async_page *oap;
 	struct osc_async_page *tmp;
-	int		    pages_in_chunk = 0;
-	int		    ppc_bits    = cli-&gt;cl_chunkbits - PAGE_CACHE_SHIFT;
-	__u64		  trunc_chunk = trunc_index &gt;&gt; ppc_bits;
-	int		    grants   = 0;
-	int		    nr_pages = 0;
-	int		    rc       = 0;
+	int pages_in_chunk = 0;
+	int ppc_bits = cli-&gt;cl_chunkbits - PAGE_CACHE_SHIFT;
+	__u64 trunc_chunk = trunc_index &gt;&gt; ppc_bits;
+	int grants = 0;
+	int nr_pages = 0;
+	int rc = 0;
 
 	LASSERT(sanity_check(ext) == 0);
 	EASSERT(ext-&gt;oe_state == OES_TRUNC, ext);
@@ -976,8 +976,8 @@ static int osc_extent_truncate(struct osc_extent *ext, pgoff_t trunc_index,
 	/* discard all pages with index greater then trunc_index */
 	list_for_each_entry_safe(oap, tmp, &amp;ext-&gt;oe_pages,
 				     oap_pending_item) {
-		struct cl_page  *sub  = oap2cl_page(oap);
-		struct cl_page  *page = cl_page_top(sub);
+		struct cl_page *sub = oap2cl_page(oap);
+		struct cl_page *page = cl_page_top(sub);
 
 		LASSERT(list_empty(&amp;oap-&gt;oap_rpc_item));
 
@@ -1022,7 +1022,7 @@ static int osc_extent_truncate(struct osc_extent *ext, pgoff_t trunc_index,
 		grants = ext-&gt;oe_grants;
 		ext-&gt;oe_grants = 0;
 	} else { /* calculate how many grants we can free */
-		int     chunks = (ext-&gt;oe_end &gt;&gt; ppc_bits) - trunc_chunk;
+		int chunks = (ext-&gt;oe_end &gt;&gt; ppc_bits) - trunc_chunk;
 		pgoff_t last_index;
 
 
@@ -1038,10 +1038,10 @@ static int osc_extent_truncate(struct osc_extent *ext, pgoff_t trunc_index,
 		}
 
 		/* this is what we can free from this extent */
-		grants	  = chunks &lt;&lt; cli-&gt;cl_chunkbits;
+		grants = chunks &lt;&lt; cli-&gt;cl_chunkbits;
 		ext-&gt;oe_grants -= grants;
-		last_index      = ((trunc_chunk + 1) &lt;&lt; ppc_bits) - 1;
-		ext-&gt;oe_end     = min(last_index, ext-&gt;oe_max_end);
+		last_index = ((trunc_chunk + 1) &lt;&lt; ppc_bits) - 1;
+		ext-&gt;oe_end = min(last_index, ext-&gt;oe_max_end);
 		LASSERT(ext-&gt;oe_end &gt;= ext-&gt;oe_start);
 		LASSERT(ext-&gt;oe_grants &gt; 0);
 	}
@@ -1236,8 +1236,8 @@ static inline int osc_is_ready(struct osc_object *osc)
 static int osc_make_ready(const struct lu_env *env, struct osc_async_page *oap,
 			  int cmd)
 {
-	struct osc_page *opg  = oap2osc_page(oap);
-	struct cl_page  *page = cl_page_top(oap2cl_page(oap));
+	struct osc_page *opg = oap2osc_page(oap);
+	struct cl_page *page = cl_page_top(oap2cl_page(oap));
 	int result;
 
 	LASSERT(cmd == OBD_BRW_WRITE); /* no cached reads */
@@ -1251,10 +1251,10 @@ static int osc_make_ready(const struct lu_env *env, struct osc_async_page *oap,
 static int osc_refresh_count(const struct lu_env *env,
 			     struct osc_async_page *oap, int cmd)
 {
-	struct osc_page  *opg = oap2osc_page(oap);
-	struct cl_page   *page = oap2cl_page(oap);
+	struct osc_page *opg = oap2osc_page(oap);
+	struct cl_page *page = oap2cl_page(oap);
 	struct cl_object *obj;
-	struct cl_attr   *attr = &amp;osc_env_info(env)-&gt;oti_attr;
+	struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
 
 	int result;
 	loff_t kms;
@@ -1283,10 +1283,10 @@ static int osc_refresh_count(const struct lu_env *env,
 static int osc_completion(const struct lu_env *env, struct osc_async_page *oap,
 			  int cmd, int rc)
 {
-	struct osc_page   *opg  = oap2osc_page(oap);
-	struct cl_page    *page = cl_page_top(oap2cl_page(oap));
-	struct osc_object *obj  = cl2osc(opg-&gt;ops_cl.cpl_obj);
-	enum cl_req_type   crt;
+	struct osc_page *opg = oap2osc_page(oap);
+	struct cl_page *page = cl_page_top(oap2cl_page(oap));
+	struct osc_object *obj = cl2osc(opg-&gt;ops_cl.cpl_obj);
+	enum cl_req_type crt;
 	int srvlock;
 
 	cmd &amp;= ~OBD_BRW_NOQUOTA;
@@ -1318,7 +1318,7 @@ static int osc_completion(const struct lu_env *env, struct osc_async_page *oap,
 
 	/* statistic */
 	if (rc == 0 &amp;&amp; srvlock) {
-		struct lu_device *ld    = opg-&gt;ops_cl.cpl_obj-&gt;co_lu.lo_dev;
+		struct lu_device *ld = opg-&gt;ops_cl.cpl_obj-&gt;co_lu.lo_dev;
 		struct osc_stats *stats = &amp;lu2osc_dev(ld)-&gt;od_stats;
 		int bytes = oap-&gt;oap_count;
 
@@ -1396,7 +1396,7 @@ static int osc_reserve_grant(struct client_obd *cli, unsigned int bytes)
 	int rc = -EDQUOT;
 
 	if (cli-&gt;cl_avail_grant &gt;= bytes) {
-		cli-&gt;cl_avail_grant    -= bytes;
+		cli-&gt;cl_avail_grant -= bytes;
 		cli-&gt;cl_reserved_grant += bytes;
 		rc = 0;
 	}
@@ -1527,7 +1527,7 @@ static int osc_enter_cache(const struct lu_env *env, struct client_obd *cli,
 			   struct osc_async_page *oap, int bytes)
 {
 	struct osc_object *osc = oap-&gt;oap_obj;
-	struct lov_oinfo  *loi = osc-&gt;oo_oinfo;
+	struct lov_oinfo *loi = osc-&gt;oo_oinfo;
 	struct osc_cache_waiter ocw;
 	struct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);
 	int rc = -EDQUOT;
@@ -1782,7 +1782,7 @@ static void osc_ap_completion(const struct lu_env *env, struct client_obd *cli,
 			      struct osc_async_page *oap, int sent, int rc)
 {
 	struct osc_object *osc = oap-&gt;oap_obj;
-	struct lov_oinfo  *loi = osc-&gt;oo_oinfo;
+	struct lov_oinfo *loi = osc-&gt;oo_oinfo;
 	__u64 xid = 0;
 
 	if (oap-&gt;oap_request != NULL) {
@@ -2049,7 +2049,7 @@ osc_send_read_rpc(const struct lu_env *env, struct client_obd *cli,
 
 #define list_to_obj(list, item) ({					      \
 	struct list_head *__tmp = (list)-&gt;next;				      \
-	list_del_init(__tmp);					      \
+	list_del_init(__tmp);						      \
 	list_entry(__tmp, struct osc_object, oo_##item);		      \
 })
 
@@ -2179,7 +2179,7 @@ static int osc_io_unplug0(const struct lu_env *env, struct client_obd *cli,
 }
 
 static int osc_io_unplug_async(const struct lu_env *env,
-				struct client_obd *cli, struct osc_object *osc)
+			       struct client_obd *cli, struct osc_object *osc)
 {
 	/* XXX: policy is no use actually. */
 	return osc_io_unplug0(env, cli, osc, PDL_POLICY_ROUND, 1);
@@ -2194,7 +2194,7 @@ void osc_io_unplug(const struct lu_env *env, struct client_obd *cli,
 int osc_prep_async_page(struct osc_object *osc, struct osc_page *ops,
 			struct page *page, loff_t offset)
 {
-	struct obd_export     *exp = osc_export(osc);
+	struct obd_export *exp = osc_export(osc);
 	struct osc_async_page *oap = &amp;ops-&gt;ops_oap;
 
 	if (!page)
@@ -2224,16 +2224,16 @@ int osc_queue_async_io(const struct lu_env *env, struct cl_io *io,
 		       struct osc_page *ops)
 {
 	struct osc_io *oio = osc_env_io(env);
-	struct osc_extent     *ext = NULL;
+	struct osc_extent *ext = NULL;
 	struct osc_async_page *oap = &amp;ops-&gt;ops_oap;
-	struct client_obd     *cli = oap-&gt;oap_cli;
-	struct osc_object     *osc = oap-&gt;oap_obj;
+	struct client_obd *cli = oap-&gt;oap_cli;
+	struct osc_object *osc = oap-&gt;oap_obj;
 	pgoff_t index;
-	int    grants = 0;
-	int    brw_flags = OBD_BRW_ASYNC;
-	int    cmd = OBD_BRW_WRITE;
-	int    need_release = 0;
-	int    rc = 0;
+	int grants = 0;
+	int brw_flags = OBD_BRW_ASYNC;
+	int cmd = OBD_BRW_WRITE;
+	int need_release = 0;
+	int rc = 0;
 
 	if (oap-&gt;oap_magic != OAP_MAGIC)
 		return -EINVAL;
@@ -2256,7 +2256,7 @@ int osc_queue_async_io(const struct lu_env *env, struct cl_io *io,
 	/* check if the file's owner/group is over quota */
 	if (!(cmd &amp; OBD_BRW_NOQUOTA)) {
 		struct cl_object *obj;
-		struct cl_attr   *attr;
+		struct cl_attr *attr;
 		unsigned int qid[MAXQUOTAS];
 
 		obj = cl_object_top(&amp;osc-&gt;oo_cl);
@@ -2386,7 +2386,7 @@ int osc_teardown_async_page(const struct lu_env *env,
 			    struct osc_object *obj, struct osc_page *ops)
 {
 	struct osc_async_page *oap = &amp;ops-&gt;ops_oap;
-	struct osc_extent     *ext = NULL;
+	struct osc_extent *ext = NULL;
 	int rc = 0;
 
 	LASSERT(oap-&gt;oap_magic == OAP_MAGIC);
@@ -2425,10 +2425,10 @@ int osc_teardown_async_page(const struct lu_env *env,
 int osc_flush_async_page(const struct lu_env *env, struct cl_io *io,
 			 struct osc_page *ops)
 {
-	struct osc_extent *ext   = NULL;
-	struct osc_object *obj   = cl2osc(ops-&gt;ops_cl.cpl_obj);
-	struct cl_page    *cp    = ops-&gt;ops_cl.cpl_page;
-	pgoff_t	    index = cp-&gt;cp_index;
+	struct osc_extent *ext = NULL;
+	struct osc_object *obj = cl2osc(ops-&gt;ops_cl.cpl_obj);
+	struct cl_page *cp = ops-&gt;ops_cl.cpl_page;
+	pgoff_t	index = cp-&gt;cp_index;
 	struct osc_async_page *oap = &amp;ops-&gt;ops_oap;
 	bool unplug = false;
 	int rc = 0;
@@ -2507,14 +2507,14 @@ int osc_flush_async_page(const struct lu_env *env, struct cl_io *io,
 int osc_cancel_async_page(const struct lu_env *env, struct osc_page *ops)
 {
 	struct osc_async_page *oap = &amp;ops-&gt;ops_oap;
-	struct osc_object     *obj = oap-&gt;oap_obj;
-	struct client_obd     *cli = osc_cli(obj);
-	struct osc_extent     *ext;
-	struct osc_extent     *found = NULL;
-	struct list_head	    *plist;
+	struct osc_object *obj = oap-&gt;oap_obj;
+	struct client_obd *cli = osc_cli(obj);
+	struct osc_extent *ext;
+	struct osc_extent *found = NULL;
+	struct list_head *plist;
 	pgoff_t index = oap2cl_page(oap)-&gt;cp_index;
-	int     rc = -EBUSY;
-	int     cmd;
+	int rc = -EBUSY;
+	int cmd;
 
 	LASSERT(!oap-&gt;oap_interrupted);
 	oap-&gt;oap_interrupted = 1;
@@ -2523,10 +2523,10 @@ int osc_cancel_async_page(const struct lu_env *env, struct osc_page *ops)
 	osc_object_lock(obj);
 	if (oap-&gt;oap_cmd &amp; OBD_BRW_WRITE) {
 		plist = &amp;obj-&gt;oo_urgent_exts;
-		cmd   = OBD_BRW_WRITE;
+		cmd = OBD_BRW_WRITE;
 	} else {
 		plist = &amp;obj-&gt;oo_reading_exts;
-		cmd   = OBD_BRW_READ;
+		cmd = OBD_BRW_READ;
 	}
 	list_for_each_entry(ext, plist, oe_link) {
 		if (ext-&gt;oe_start &lt;= index &amp;&amp; ext-&gt;oe_end &gt;= index) {
@@ -2564,13 +2564,13 @@ int osc_cancel_async_page(const struct lu_env *env, struct osc_page *ops)
 int osc_queue_sync_pages(const struct lu_env *env, struct osc_object *obj,
 			 struct list_head *list, int cmd, int brw_flags)
 {
-	struct client_obd     *cli = osc_cli(obj);
-	struct osc_extent     *ext;
+	struct client_obd *cli = osc_cli(obj);
+	struct osc_extent *ext;
 	struct osc_async_page *oap, *tmp;
-	int     page_count = 0;
-	int     mppr       = cli-&gt;cl_max_pages_per_rpc;
-	pgoff_t start      = CL_PAGE_EOF;
-	pgoff_t end	= 0;
+	int page_count = 0;
+	int mppr = cli-&gt;cl_max_pages_per_rpc;
+	pgoff_t start = CL_PAGE_EOF;
+	pgoff_t end = 0;
 
 	list_for_each_entry(oap, list, oap_pending_item) {
 		struct cl_page *cp = oap2cl_page(oap);
@@ -2785,7 +2785,7 @@ int osc_cache_wait_range(const struct lu_env *env, struct osc_object *obj,
 {
 	struct osc_extent *ext;
 	pgoff_t index = start;
-	int     result = 0;
+	int result = 0;
 
 again:
 	osc_object_lock(obj);
diff --git a/drivers/staging/lustre/lustre/osc/osc_dev.c b/drivers/staging/lustre/lustre/osc/osc_dev.c
index ce5c3af1237b..9222c9f4faae 100644
--- a/drivers/staging/lustre/lustre/osc/osc_dev.c
+++ b/drivers/staging/lustre/lustre/osc/osc_dev.c
@@ -118,7 +118,7 @@ static struct lu_device *osc2lu_dev(struct osc_device *osc)
  */
 
 static void *osc_key_init(const struct lu_context *ctx,
-			 struct lu_context_key *key)
+			  struct lu_context_key *key)
 {
 	struct osc_thread_info *info;
 
@@ -248,14 +248,14 @@ static const struct lu_device_type_operations osc_device_type_ops = {
 	.ldto_device_alloc = osc_device_alloc,
 	.ldto_device_free  = osc_device_free,
 
-	.ldto_device_init    = osc_device_init,
-	.ldto_device_fini    = osc_device_fini
+	.ldto_device_init = osc_device_init,
+	.ldto_device_fini = osc_device_fini
 };
 
 struct lu_device_type osc_device_type = {
-	.ldt_tags     = LU_DEVICE_CL,
-	.ldt_name     = LUSTRE_OSC_NAME,
-	.ldt_ops      = &amp;osc_device_type_ops,
+	.ldt_tags = LU_DEVICE_CL,
+	.ldt_name = LUSTRE_OSC_NAME,
+	.ldt_ops = &amp;osc_device_type_ops,
 	.ldt_ctx_tags = LCT_CL_THREAD
 };
 
diff --git a/drivers/staging/lustre/lustre/osc/osc_io.c b/drivers/staging/lustre/lustre/osc/osc_io.c
index 3c7300b0651d..fa24e9ed1831 100644
--- a/drivers/staging/lustre/lustre/osc/osc_io.c
+++ b/drivers/staging/lustre/lustre/osc/osc_io.c
@@ -100,16 +100,16 @@ static int osc_io_submit(const struct lu_env *env,
 			 const struct cl_io_slice *ios,
 			 enum cl_req_type crt, struct cl_2queue *queue)
 {
-	struct cl_page    *page;
-	struct cl_page    *tmp;
-	struct client_obd *cli  = NULL;
-	struct osc_object *osc  = NULL; /* to keep gcc happy */
-	struct osc_page   *opg;
-	struct cl_io      *io;
+	struct cl_page *page;
+	struct cl_page *tmp;
+	struct client_obd *cli = NULL;
+	struct osc_object *osc = NULL; /* to keep gcc happy */
+	struct osc_page *opg;
+	struct cl_io *io;
 	LIST_HEAD(list);
 
-	struct cl_page_list *qin      = &amp;queue-&gt;c2_qin;
-	struct cl_page_list *qout     = &amp;queue-&gt;c2_qout;
+	struct cl_page_list *qin = &amp;queue-&gt;c2_qin;
+	struct cl_page_list *qout = &amp;queue-&gt;c2_qout;
 	int queued = 0;
 	int result = 0;
 	int cmd;
@@ -189,8 +189,8 @@ static int osc_io_submit(const struct lu_env *env,
 static void osc_page_touch_at(const struct lu_env *env,
 			      struct cl_object *obj, pgoff_t idx, unsigned to)
 {
-	struct lov_oinfo  *loi  = cl2osc(obj)-&gt;oo_oinfo;
-	struct cl_attr    *attr = &amp;osc_env_info(env)-&gt;oti_attr;
+	struct lov_oinfo *loi = cl2osc(obj)-&gt;oo_oinfo;
+	struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
 	int valid;
 	__u64 kms;
 
@@ -233,8 +233,8 @@ static void osc_page_touch_at(const struct lu_env *env,
 static void osc_page_touch(const struct lu_env *env,
 			   struct osc_page *opage, unsigned to)
 {
-	struct cl_page    *page = opage-&gt;ops_cl.cpl_page;
-	struct cl_object  *obj  = opage-&gt;ops_cl.cpl_obj;
+	struct cl_page *page = opage-&gt;ops_cl.cpl_page;
+	struct cl_object *obj = opage-&gt;ops_cl.cpl_obj;
 
 	osc_page_touch_at(env, obj, page-&gt;cp_index, to);
 }
@@ -260,7 +260,7 @@ static int osc_io_prepare_write(const struct lu_env *env,
 {
 	struct osc_device *dev = lu2osc_dev(slice-&gt;cpl_obj-&gt;co_lu.lo_dev);
 	struct obd_import *imp = class_exp2cliimp(dev-&gt;od_exp);
-	struct osc_io     *oio = cl2osc_io(env, ios);
+	struct osc_io *oio = cl2osc_io(env, ios);
 	int result = 0;
 
 	/*
@@ -284,9 +284,9 @@ static int osc_io_commit_write(const struct lu_env *env,
 			       const struct cl_page_slice *slice,
 			       unsigned from, unsigned to)
 {
-	struct osc_io	 *oio = cl2osc_io(env, ios);
-	struct osc_page       *opg = cl2osc_page(slice);
-	struct osc_object     *obj = cl2osc(opg-&gt;ops_cl.cpl_obj);
+	struct osc_io *oio = cl2osc_io(env, ios);
+	struct osc_page *opg = cl2osc_page(slice);
+	struct osc_object *obj = cl2osc(opg-&gt;ops_cl.cpl_obj);
 	struct osc_async_page *oap = &amp;opg-&gt;ops_oap;
 
 	LASSERT(to &gt; 0);
@@ -311,10 +311,10 @@ static int osc_io_commit_write(const struct lu_env *env,
 static int osc_io_fault_start(const struct lu_env *env,
 			      const struct cl_io_slice *ios)
 {
-	struct cl_io       *io;
+	struct cl_io *io;
 	struct cl_fault_io *fio;
 
-	io  = ios-&gt;cis_io;
+	io = ios-&gt;cis_io;
 	fio = &amp;io-&gt;u.ci_fault;
 	CDEBUG(D_INFO, "%lu %d %d\n",
 	       fio-&gt;ft_index, fio-&gt;ft_writable, fio-&gt;ft_nob);
@@ -375,11 +375,11 @@ static void osc_trunc_check(const struct lu_env *env, struct cl_io *io,
 			    struct osc_io *oio, __u64 size)
 {
 	struct cl_object *clob;
-	int     partial;
+	int partial;
 	pgoff_t start;
 
-	clob    = oio-&gt;oi_cl.cis_obj;
-	start   = cl_index(clob, size);
+	clob = oio-&gt;oi_cl.cis_obj;
+	start = cl_index(clob, size);
 	partial = cl_offset(clob, start) &lt; size;
 
 	/*
@@ -392,17 +392,17 @@ static void osc_trunc_check(const struct lu_env *env, struct cl_io *io,
 static int osc_io_setattr_start(const struct lu_env *env,
 				const struct cl_io_slice *slice)
 {
-	struct cl_io	    *io     = slice-&gt;cis_io;
-	struct osc_io	   *oio    = cl2osc_io(env, slice);
-	struct cl_object	*obj    = slice-&gt;cis_obj;
-	struct lov_oinfo	*loi    = cl2osc(obj)-&gt;oo_oinfo;
-	struct cl_attr	  *attr   = &amp;osc_env_info(env)-&gt;oti_attr;
-	struct obdo	     *oa     = &amp;oio-&gt;oi_oa;
+	struct cl_io *io = slice-&gt;cis_io;
+	struct osc_io *oio = cl2osc_io(env, slice);
+	struct cl_object *obj = slice-&gt;cis_obj;
+	struct lov_oinfo *loi = cl2osc(obj)-&gt;oo_oinfo;
+	struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
+	struct obdo *oa = &amp;oio-&gt;oi_oa;
 	struct osc_async_cbargs *cbargs = &amp;oio-&gt;oi_cbarg;
-	__u64		    size   = io-&gt;u.ci_setattr.sa_attr.lvb_size;
-	unsigned int	     ia_valid = io-&gt;u.ci_setattr.sa_valid;
-	int		      result = 0;
-	struct obd_info	  oinfo = { { { 0 } } };
+	__u64 size = io-&gt;u.ci_setattr.sa_attr.lvb_size;
+	unsigned int ia_valid = io-&gt;u.ci_setattr.sa_valid;
+	int result = 0;
+	struct obd_info oinfo = { { { 0 } } };
 
 	/* truncate cache dirty pages first */
 	if (cl_io_is_trunc(io))
@@ -477,8 +477,8 @@ static int osc_io_setattr_start(const struct lu_env *env,
 static void osc_io_setattr_end(const struct lu_env *env,
 			       const struct cl_io_slice *slice)
 {
-	struct cl_io     *io  = slice-&gt;cis_io;
-	struct osc_io    *oio = cl2osc_io(env, slice);
+	struct cl_io *io = slice-&gt;cis_io;
+	struct osc_io *oio = cl2osc_io(env, slice);
 	struct cl_object *obj = slice-&gt;cis_obj;
 	struct osc_async_cbargs *cbargs = &amp;oio-&gt;oi_cbarg;
 	int result = 0;
@@ -512,8 +512,8 @@ static void osc_io_setattr_end(const struct lu_env *env,
 static int osc_io_read_start(const struct lu_env *env,
 			     const struct cl_io_slice *slice)
 {
-	struct cl_object *obj   = slice-&gt;cis_obj;
-	struct cl_attr   *attr  = &amp;osc_env_info(env)-&gt;oti_attr;
+	struct cl_object *obj = slice-&gt;cis_obj;
+	struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
 	int rc = 0;
 
 	if (!slice-&gt;cis_io-&gt;ci_noatime) {
@@ -528,8 +528,8 @@ static int osc_io_read_start(const struct lu_env *env,
 static int osc_io_write_start(const struct lu_env *env,
 			      const struct cl_io_slice *slice)
 {
-	struct cl_object *obj   = slice-&gt;cis_obj;
-	struct cl_attr   *attr  = &amp;osc_env_info(env)-&gt;oti_attr;
+	struct cl_object *obj = slice-&gt;cis_obj;
+	struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
 	int rc = 0;
 
 	OBD_FAIL_TIMEOUT(OBD_FAIL_OSC_DELAY_SETTIME, 1);
@@ -544,10 +544,10 @@ static int osc_io_write_start(const struct lu_env *env,
 static int osc_fsync_ost(const struct lu_env *env, struct osc_object *obj,
 			 struct cl_fsync_io *fio)
 {
-	struct osc_io    *oio   = osc_env_io(env);
-	struct obdo      *oa    = &amp;oio-&gt;oi_oa;
-	struct obd_info  *oinfo = &amp;oio-&gt;oi_info;
-	struct lov_oinfo *loi   = obj-&gt;oo_oinfo;
+	struct osc_io *oio = osc_env_io(env);
+	struct obdo *oa = &amp;oio-&gt;oi_oa;
+	struct obd_info *oinfo = &amp;oio-&gt;oi_info;
+	struct lov_oinfo *loi = obj-&gt;oo_oinfo;
 	struct osc_async_cbargs *cbargs = &amp;oio-&gt;oi_cbarg;
 	int rc = 0;
 
@@ -575,13 +575,13 @@ static int osc_fsync_ost(const struct lu_env *env, struct osc_object *obj,
 static int osc_io_fsync_start(const struct lu_env *env,
 			      const struct cl_io_slice *slice)
 {
-	struct cl_io       *io  = slice-&gt;cis_io;
+	struct cl_io *io = slice-&gt;cis_io;
 	struct cl_fsync_io *fio = &amp;io-&gt;u.ci_fsync;
-	struct cl_object   *obj = slice-&gt;cis_obj;
-	struct osc_object  *osc = cl2osc(obj);
-	pgoff_t start  = cl_index(obj, fio-&gt;fi_start);
-	pgoff_t end    = cl_index(obj, fio-&gt;fi_end);
-	int     result = 0;
+	struct cl_object *obj = slice-&gt;cis_obj;
+	struct osc_object *osc = cl2osc(obj);
+	pgoff_t start = cl_index(obj, fio-&gt;fi_start);
+	pgoff_t end = cl_index(obj, fio-&gt;fi_end);
+	int result = 0;
 
 	if (fio-&gt;fi_end == OBD_OBJECT_EOF)
 		end = CL_PAGE_EOF;
@@ -615,15 +615,15 @@ static void osc_io_fsync_end(const struct lu_env *env,
 			     const struct cl_io_slice *slice)
 {
 	struct cl_fsync_io *fio = &amp;slice-&gt;cis_io-&gt;u.ci_fsync;
-	struct cl_object   *obj = slice-&gt;cis_obj;
+	struct cl_object *obj = slice-&gt;cis_obj;
 	pgoff_t start = cl_index(obj, fio-&gt;fi_start);
-	pgoff_t end   = cl_index(obj, fio-&gt;fi_end);
+	pgoff_t end = cl_index(obj, fio-&gt;fi_end);
 	int result = 0;
 
 	if (fio-&gt;fi_mode == CL_FSYNC_LOCAL) {
 		result = osc_cache_wait_range(env, cl2osc(obj), start, end);
 	} else if (fio-&gt;fi_mode == CL_FSYNC_ALL) {
-		struct osc_io	   *oio    = cl2osc_io(env, slice);
+		struct osc_io *oio = cl2osc_io(env, slice);
 		struct osc_async_cbargs *cbargs = &amp;oio-&gt;oi_cbarg;
 
 		wait_for_completion(&amp;cbargs-&gt;opc_sync);
@@ -717,17 +717,17 @@ static void osc_req_attr_set(const struct lu_env *env,
 			     struct cl_req_attr *attr, u64 flags)
 {
 	struct lov_oinfo *oinfo;
-	struct cl_req    *clerq;
-	struct cl_page   *apage; /* _some_ page in @clerq */
-	struct cl_lock   *lock;  /* _some_ lock protecting @apage */
-	struct osc_lock  *olck;
-	struct osc_page  *opg;
-	struct obdo      *oa;
-	struct ost_lvb   *lvb;
-
-	oinfo	= cl2osc(obj)-&gt;oo_oinfo;
-	lvb	= &amp;oinfo-&gt;loi_lvb;
-	oa	= attr-&gt;cra_oa;
+	struct cl_req *clerq;
+	struct cl_page *apage; /* _some_ page in @clerq */
+	struct cl_lock *lock;  /* _some_ lock protecting @apage */
+	struct osc_lock *olck;
+	struct osc_page *opg;
+	struct obdo *oa;
+	struct ost_lvb *lvb;
+
+	oinfo = cl2osc(obj)-&gt;oo_oinfo;
+	lvb = &amp;oinfo-&gt;loi_lvb;
+	oa = attr-&gt;cra_oa;
 
 	if ((flags &amp; OBD_MD_FLMTIME) != 0) {
 		oa-&gt;o_mtime = lvb-&gt;lvb_mtime;
@@ -759,7 +759,7 @@ static void osc_req_attr_set(const struct lu_env *env,
 		lock = cl_lock_at_page(env, apage-&gt;cp_obj, apage, NULL, 1, 1);
 		if (lock == NULL) {
 			struct cl_object_header *head;
-			struct cl_lock	  *scan;
+			struct cl_lock *scan;
 
 			head = cl_object_header(apage-&gt;cp_obj);
 			list_for_each_entry(scan, &amp;head-&gt;coh_locks,
diff --git a/drivers/staging/lustre/lustre/osc/osc_lock.c b/drivers/staging/lustre/lustre/osc/osc_lock.c
index 350ad49550ab..06837f5f4e64 100644
--- a/drivers/staging/lustre/lustre/osc/osc_lock.c
+++ b/drivers/staging/lustre/lustre/osc/osc_lock.c
@@ -89,9 +89,9 @@ static struct ldlm_lock *osc_handle_ptr(struct lustre_handle *handle)
  */
 static int osc_lock_invariant(struct osc_lock *ols)
 {
-	struct ldlm_lock *lock	      = osc_handle_ptr(&amp;ols-&gt;ols_handle);
-	struct ldlm_lock *olock	      = ols-&gt;ols_lock;
-	int		  handle_used = lustre_handle_is_used(&amp;ols-&gt;ols_handle);
+	struct ldlm_lock *lock = osc_handle_ptr(&amp;ols-&gt;ols_handle);
+	struct ldlm_lock *olock = ols-&gt;ols_lock;
+	int handle_used = lustre_handle_is_used(&amp;ols-&gt;ols_handle);
 
 	if (ergo(osc_lock_is_lockless(ols),
 		 ols-&gt;ols_locklessable &amp;&amp; ols-&gt;ols_lock == NULL))
@@ -164,7 +164,7 @@ static void osc_lock_detach(const struct lu_env *env, struct osc_lock *olck)
 	lock_res_and_lock(dlmlock);
 	if (dlmlock-&gt;l_granted_mode == dlmlock-&gt;l_req_mode) {
 		struct cl_object *obj = olck-&gt;ols_cl.cls_obj;
-		struct cl_attr *attr  = &amp;osc_env_info(env)-&gt;oti_attr;
+		struct cl_attr *attr = &amp;osc_env_info(env)-&gt;oti_attr;
 		__u64 old_kms;
 
 		cl_object_attr_lock(obj);
@@ -237,7 +237,7 @@ static int osc_lock_unuse(const struct lu_env *env,
 static void osc_lock_fini(const struct lu_env *env,
 			  struct cl_lock_slice *slice)
 {
-	struct osc_lock  *ols = cl2osc_lock(slice);
+	struct osc_lock *ols = cl2osc_lock(slice);
 
 	LINVRNT(osc_lock_invariant(ols));
 	/*
@@ -337,25 +337,25 @@ static void osc_ast_data_put(const struct lu_env *env, struct osc_lock *olck)
 static void osc_lock_lvb_update(const struct lu_env *env, struct osc_lock *olck,
 				int rc)
 {
-	struct ost_lvb    *lvb;
-	struct cl_object  *obj;
-	struct lov_oinfo  *oinfo;
-	struct cl_attr    *attr;
-	unsigned	   valid;
+	struct ost_lvb *lvb;
+	struct cl_object *obj;
+	struct lov_oinfo *oinfo;
+	struct cl_attr *attr;
+	unsigned valid;
 
 	if (!(olck-&gt;ols_flags &amp; LDLM_FL_LVB_READY))
 		return;
 
-	lvb   = &amp;olck-&gt;ols_lvb;
-	obj   = olck-&gt;ols_cl.cls_obj;
+	lvb = &amp;olck-&gt;ols_lvb;
+	obj = olck-&gt;ols_cl.cls_obj;
 	oinfo = cl2osc(obj)-&gt;oo_oinfo;
-	attr  = &amp;osc_env_info(env)-&gt;oti_attr;
+	attr = &amp;osc_env_info(env)-&gt;oti_attr;
 	valid = CAT_BLOCKS | CAT_ATIME | CAT_CTIME | CAT_MTIME | CAT_SIZE;
 	cl_lvb2attr(attr, lvb);
 
 	cl_object_attr_lock(obj);
 	if (rc == 0) {
-		struct ldlm_lock  *dlmlock;
+		struct ldlm_lock *dlmlock;
 		__u64 size;
 
 		dlmlock = olck-&gt;ols_lock;
@@ -401,23 +401,23 @@ static void osc_lock_lvb_update(const struct lu_env *env, struct osc_lock *olck,
 static void osc_lock_granted(const struct lu_env *env, struct osc_lock *olck,
 			     struct ldlm_lock *dlmlock, int rc)
 {
-	struct ldlm_extent   *ext;
-	struct cl_lock       *lock;
+	struct ldlm_extent *ext;
+	struct cl_lock *lock;
 	struct cl_lock_descr *descr;
 
 	LASSERT(dlmlock-&gt;l_granted_mode == dlmlock-&gt;l_req_mode);
 
 	if (olck-&gt;ols_state &lt; OLS_GRANTED) {
-		lock  = olck-&gt;ols_cl.cls_lock;
-		ext   = &amp;dlmlock-&gt;l_policy_data.l_extent;
+		lock = olck-&gt;ols_cl.cls_lock;
+		ext = &amp;dlmlock-&gt;l_policy_data.l_extent;
 		descr = &amp;osc_env_info(env)-&gt;oti_descr;
 		descr-&gt;cld_obj = lock-&gt;cll_descr.cld_obj;
 
 		/* XXX check that -&gt;l_granted_mode is valid. */
-		descr-&gt;cld_mode  = osc_ldlm2cl_lock(dlmlock-&gt;l_granted_mode);
+		descr-&gt;cld_mode = osc_ldlm2cl_lock(dlmlock-&gt;l_granted_mode);
 		descr-&gt;cld_start = cl_index(descr-&gt;cld_obj, ext-&gt;start);
-		descr-&gt;cld_end   = cl_index(descr-&gt;cld_obj, ext-&gt;end);
-		descr-&gt;cld_gid   = ext-&gt;gid;
+		descr-&gt;cld_end = cl_index(descr-&gt;cld_obj, ext-&gt;end);
+		descr-&gt;cld_gid = ext-&gt;gid;
 		/*
 		 * tell upper layers the extent of the lock that was actually
 		 * granted
@@ -482,11 +482,11 @@ static void osc_lock_upcall0(const struct lu_env *env, struct osc_lock *olck)
  */
 static int osc_lock_upcall(void *cookie, int errcode)
 {
-	struct osc_lock	 *olck  = cookie;
-	struct cl_lock_slice    *slice = &amp;olck-&gt;ols_cl;
-	struct cl_lock	  *lock  = slice-&gt;cls_lock;
-	struct lu_env	   *env;
-	struct cl_env_nest       nest;
+	struct osc_lock	*olck = cookie;
+	struct cl_lock_slice *slice = &amp;olck-&gt;ols_cl;
+	struct cl_lock *lock = slice-&gt;cls_lock;
+	struct lu_env *env;
+	struct cl_env_nest nest;
 
 	env = cl_env_nested_get(&amp;nest);
 	if (!IS_ERR(env)) {
@@ -626,7 +626,7 @@ static int osc_dlm_blocking_ast0(const struct lu_env *env,
 				 void *data, int flag)
 {
 	struct osc_lock *olck;
-	struct cl_lock  *lock;
+	struct cl_lock *lock;
 	int result;
 	int cancel;
 
@@ -733,9 +733,9 @@ static int osc_ldlm_blocking_ast(struct ldlm_lock *dlmlock,
 				 struct ldlm_lock_desc *new, void *data,
 				 int flag)
 {
-	struct lu_env     *env;
+	struct lu_env *env;
 	struct cl_env_nest nest;
-	int		result;
+	int result;
 
 	/*
 	 * This can be called in the context of outer IO, e.g.,
@@ -774,9 +774,9 @@ static int osc_ldlm_completion_ast(struct ldlm_lock *dlmlock,
 				   __u64 flags, void *data)
 {
 	struct cl_env_nest nest;
-	struct lu_env     *env;
-	struct osc_lock   *olck;
-	struct cl_lock    *lock;
+	struct lu_env *env;
+	struct osc_lock *olck;
+	struct cl_lock *lock;
 	int result;
 	int dlmrc;
 
@@ -830,15 +830,15 @@ static int osc_ldlm_completion_ast(struct ldlm_lock *dlmlock,
 
 static int osc_ldlm_glimpse_ast(struct ldlm_lock *dlmlock, void *data)
 {
-	struct ptlrpc_request  *req  = data;
+	struct ptlrpc_request *req = data;
 	struct osc_lock	*olck;
-	struct cl_lock	 *lock;
-	struct cl_object       *obj;
-	struct cl_env_nest      nest;
-	struct lu_env	  *env;
-	struct ost_lvb	 *lvb;
-	struct req_capsule     *cap;
-	int		     result;
+	struct cl_lock *lock;
+	struct cl_object *obj;
+	struct cl_env_nest nest;
+	struct lu_env *env;
+	struct ost_lvb *lvb;
+	struct req_capsule *cap;
+	int result;
 
 	LASSERT(lustre_msg_get_opc(req-&gt;rq_reqmsg) == LDLM_GL_CALLBACK);
 
@@ -916,11 +916,11 @@ static void osc_lock_build_einfo(const struct lu_env *env,
 		 */
 		mode = CLM_READ;
 
-	einfo-&gt;ei_type   = LDLM_EXTENT;
-	einfo-&gt;ei_mode   = osc_cl_lock2ldlm(mode);
-	einfo-&gt;ei_cb_bl  = osc_ldlm_blocking_ast;
-	einfo-&gt;ei_cb_cp  = osc_ldlm_completion_ast;
-	einfo-&gt;ei_cb_gl  = osc_ldlm_glimpse_ast;
+	einfo-&gt;ei_type = LDLM_EXTENT;
+	einfo-&gt;ei_mode = osc_cl_lock2ldlm(mode);
+	einfo-&gt;ei_cb_bl = osc_ldlm_blocking_ast;
+	einfo-&gt;ei_cb_cp = osc_ldlm_completion_ast;
+	einfo-&gt;ei_cb_gl = osc_ldlm_glimpse_ast;
 	einfo-&gt;ei_cbdata = lock; /* value to be put into -&gt;l_ast_data */
 }
 
@@ -948,9 +948,9 @@ static void osc_lock_to_lockless(const struct lu_env *env,
 		ols-&gt;ols_locklessable = 1;
 		slice-&gt;cls_ops = &amp;osc_lock_lockless_ops;
 	} else {
-		struct osc_io *oio     = osc_env_io(env);
-		struct cl_io  *io      = oio-&gt;oi_cl.cis_io;
-		struct cl_object *obj  = slice-&gt;cls_obj;
+		struct osc_io *oio = osc_env_io(env);
+		struct cl_io *io = oio-&gt;oi_cl.cis_io;
+		struct cl_object *obj = slice-&gt;cls_obj;
 		struct osc_object *oob = cl2osc(obj);
 		const struct osc_device *osd = lu2osc_dev(obj-&gt;co_lu.lo_dev);
 		struct obd_connect_data *ocd;
@@ -1006,13 +1006,13 @@ static int osc_lock_compatible(const struct osc_lock *qing,
 static int osc_lock_enqueue_wait(const struct lu_env *env,
 				 const struct osc_lock *olck)
 {
-	struct cl_lock	  *lock    = olck-&gt;ols_cl.cls_lock;
-	struct cl_lock_descr    *descr   = &amp;lock-&gt;cll_descr;
-	struct cl_object_header *hdr     = cl_object_header(descr-&gt;cld_obj);
-	struct cl_lock	  *scan;
-	struct cl_lock	  *conflict = NULL;
-	int lockless		     = osc_lock_is_lockless(olck);
-	int rc			   = 0;
+	struct cl_lock *lock = olck-&gt;ols_cl.cls_lock;
+	struct cl_lock_descr *descr = &amp;lock-&gt;cll_descr;
+	struct cl_object_header *hdr = cl_object_header(descr-&gt;cld_obj);
+	struct cl_lock *scan;
+	struct cl_lock *conflict = NULL;
+	int lockless = osc_lock_is_lockless(olck);
+	int rc = 0;
 
 	LASSERT(cl_lock_is_mutexed(lock));
 
@@ -1102,8 +1102,8 @@ static int osc_lock_enqueue(const struct lu_env *env,
 			    const struct cl_lock_slice *slice,
 			    struct cl_io *unused, __u32 enqflags)
 {
-	struct osc_lock	  *ols     = cl2osc_lock(slice);
-	struct cl_lock	   *lock    = ols-&gt;ols_cl.cls_lock;
+	struct osc_lock *ols = cl2osc_lock(slice);
+	struct cl_lock *lock = ols-&gt;ols_cl.cls_lock;
 	int result;
 
 	LASSERT(cl_lock_is_mutexed(lock));
@@ -1116,10 +1116,10 @@ static int osc_lock_enqueue(const struct lu_env *env,
 	result = osc_lock_enqueue_wait(env, ols);
 	if (result == 0) {
 		if (!osc_lock_is_lockless(ols)) {
-			struct osc_object	*obj = cl2osc(slice-&gt;cls_obj);
-			struct osc_thread_info   *info = osc_env_info(env);
-			struct ldlm_res_id       *resname = &amp;info-&gt;oti_resname;
-			ldlm_policy_data_t       *policy = &amp;info-&gt;oti_policy;
+			struct osc_object *obj = cl2osc(slice-&gt;cls_obj);
+			struct osc_thread_info *info = osc_env_info(env);
+			struct ldlm_res_id *resname = &amp;info-&gt;oti_resname;
+			ldlm_policy_data_t *policy = &amp;info-&gt;oti_policy;
 			struct ldlm_enqueue_info *einfo = &amp;ols-&gt;ols_einfo;
 
 			/* lock will be passed as upcall cookie,
@@ -1164,7 +1164,7 @@ static int osc_lock_wait(const struct lu_env *env,
 			 const struct cl_lock_slice *slice)
 {
 	struct osc_lock *olck = cl2osc_lock(slice);
-	struct cl_lock  *lock = olck-&gt;ols_cl.cls_lock;
+	struct cl_lock *lock = olck-&gt;ols_cl.cls_lock;
 
 	LINVRNT(osc_lock_invariant(olck));
 
@@ -1245,14 +1245,14 @@ static int osc_lock_use(const struct lu_env *env,
 
 static int osc_lock_flush(struct osc_lock *ols, int discard)
 {
-	struct cl_lock       *lock  = ols-&gt;ols_cl.cls_lock;
-	struct cl_env_nest    nest;
-	struct lu_env	*env;
+	struct cl_lock *lock = ols-&gt;ols_cl.cls_lock;
+	struct cl_env_nest nest;
+	struct lu_env *env;
 	int result = 0;
 
 	env = cl_env_nested_get(&amp;nest);
 	if (!IS_ERR(env)) {
-		struct osc_object    *obj   = cl2osc(ols-&gt;ols_cl.cls_obj);
+		struct osc_object *obj = cl2osc(ols-&gt;ols_cl.cls_obj);
 		struct cl_lock_descr *descr = &amp;lock-&gt;cll_descr;
 		int rc = 0;
 
@@ -1298,11 +1298,11 @@ static int osc_lock_flush(struct osc_lock *ols, int discard)
 static void osc_lock_cancel(const struct lu_env *env,
 			    const struct cl_lock_slice *slice)
 {
-	struct cl_lock   *lock    = slice-&gt;cls_lock;
-	struct osc_lock  *olck    = cl2osc_lock(slice);
+	struct cl_lock *lock = slice-&gt;cls_lock;
+	struct osc_lock *olck = cl2osc_lock(slice);
 	struct ldlm_lock *dlmlock = olck-&gt;ols_lock;
-	int	       result  = 0;
-	int	       discard;
+	int result = 0;
+	int discard;
 
 	LASSERT(cl_lock_is_mutexed(lock));
 	LINVRNT(osc_lock_invariant(olck));
@@ -1482,7 +1482,7 @@ static int osc_lock_lockless_unuse(const struct lu_env *env,
 static void osc_lock_lockless_cancel(const struct lu_env *env,
 				     const struct cl_lock_slice *slice)
 {
-	struct osc_lock   *ols  = cl2osc_lock(slice);
+	struct osc_lock *ols = cl2osc_lock(slice);
 	int result;
 
 	result = osc_lock_flush(ols, 0);
@@ -1496,7 +1496,7 @@ static int osc_lock_lockless_wait(const struct lu_env *env,
 				  const struct cl_lock_slice *slice)
 {
 	struct osc_lock *olck = cl2osc_lock(slice);
-	struct cl_lock  *lock = olck-&gt;ols_cl.cls_lock;
+	struct cl_lock *lock = olck-&gt;ols_cl.cls_lock;
 
 	LINVRNT(osc_lock_invariant(olck));
 	LASSERT(olck-&gt;ols_state &gt;= OLS_UPCALL_RECEIVED);
@@ -1512,7 +1512,7 @@ static void osc_lock_lockless_state(const struct lu_env *env,
 
 	LINVRNT(osc_lock_invariant(lock));
 	if (state == CLS_HELD) {
-		struct osc_io *oio  = osc_env_io(env);
+		struct osc_io *oio = osc_env_io(env);
 
 		LASSERT(ergo(lock-&gt;ols_owner, lock-&gt;ols_owner == oio));
 		lock-&gt;ols_owner = oio;
@@ -1591,7 +1591,7 @@ int osc_lock_init(const struct lu_env *env,
 int osc_dlm_lock_pageref(struct ldlm_lock *dlm)
 {
 	struct osc_lock *olock;
-	int	      rc = 0;
+	int rc = 0;
 
 	spin_lock(&amp;osc_ast_guard);
 	olock = dlm-&gt;l_ast_data;
diff --git a/drivers/staging/lustre/lustre/osc/osc_object.c b/drivers/staging/lustre/lustre/osc/osc_object.c
index 92c202f70395..c628a250ebd6 100644
--- a/drivers/staging/lustre/lustre/osc/osc_object.c
+++ b/drivers/staging/lustre/lustre/osc/osc_object.c
@@ -72,7 +72,7 @@ static struct osc_object *lu2osc(const struct lu_object *obj)
 static int osc_object_init(const struct lu_env *env, struct lu_object *obj,
 			   const struct lu_object_conf *conf)
 {
-	struct osc_object	   *osc   = lu2osc(obj);
+	struct osc_object *osc = lu2osc(obj);
 	const struct cl_object_conf *cconf = lu2cl_conf(conf);
 	int i;
 
@@ -136,9 +136,9 @@ int osc_lvb_print(const struct lu_env *env, void *cookie,
 static int osc_object_print(const struct lu_env *env, void *cookie,
 			    lu_printer_t p, const struct lu_object *obj)
 {
-	struct osc_object   *osc   = lu2osc(obj);
-	struct lov_oinfo    *oinfo = osc-&gt;oo_oinfo;
-	struct osc_async_rc *ar    = &amp;oinfo-&gt;loi_ar;
+	struct osc_object *osc = lu2osc(obj);
+	struct lov_oinfo *oinfo = osc-&gt;oo_oinfo;
+	struct osc_async_rc *ar = &amp;oinfo-&gt;loi_ar;
 
 	(*p)(env, cookie, "id: " DOSTID " idx: %d gen: %d kms_valid: %u kms %llu rc: %d force_sync: %d min_xid: %llu ",
 	     POSTID(&amp;oinfo-&gt;loi_oi), oinfo-&gt;loi_ost_idx,
@@ -163,7 +163,7 @@ int osc_attr_set(const struct lu_env *env, struct cl_object *obj,
 		 const struct cl_attr *attr, unsigned valid)
 {
 	struct lov_oinfo *oinfo = cl2osc(obj)-&gt;oo_oinfo;
-	struct ost_lvb   *lvb   = &amp;oinfo-&gt;loi_lvb;
+	struct ost_lvb *lvb = &amp;oinfo-&gt;loi_lvb;
 
 	if (valid &amp; CAT_SIZE)
 		lvb-&gt;lvb_size = attr-&gt;cat_size;
@@ -188,7 +188,7 @@ static int osc_object_glimpse(const struct lu_env *env,
 {
 	struct lov_oinfo *oinfo = cl2osc(obj)-&gt;oo_oinfo;
 
-	lvb-&gt;lvb_size   = oinfo-&gt;loi_kms;
+	lvb-&gt;lvb_size = oinfo-&gt;loi_kms;
 	lvb-&gt;lvb_blocks = oinfo-&gt;loi_lvb.lvb_blocks;
 	return 0;
 }
@@ -208,9 +208,9 @@ void osc_object_clear_contended(struct osc_object *obj)
 
 int osc_object_is_contended(struct osc_object *obj)
 {
-	struct osc_device *dev  = lu2osc_dev(obj-&gt;oo_cl.co_lu.lo_dev);
+	struct osc_device *dev = lu2osc_dev(obj-&gt;oo_cl.co_lu.lo_dev);
 	int osc_contention_time = dev-&gt;od_contention_time;
-	unsigned long cur_time     = cfs_time_current();
+	unsigned long cur_time = cfs_time_current();
 	unsigned long retry_time;
 
 	if (OBD_FAIL_CHECK(OBD_FAIL_OSC_OBJECT_CONTENTION))
@@ -255,7 +255,7 @@ struct lu_object *osc_object_alloc(const struct lu_env *env,
 				   struct lu_device *dev)
 {
 	struct osc_object *osc;
-	struct lu_object  *obj;
+	struct lu_object *obj;
 
 	OBD_SLAB_ALLOC_PTR_GFP(osc, osc_object_kmem, GFP_NOFS);
 	if (osc != NULL) {
diff --git a/drivers/staging/lustre/lustre/osc/osc_page.c b/drivers/staging/lustre/lustre/osc/osc_page.c
index 76ba58b09c5d..43dfa73dd3a6 100644
--- a/drivers/staging/lustre/lustre/osc/osc_page.c
+++ b/drivers/staging/lustre/lustre/osc/osc_page.c
@@ -216,7 +216,7 @@ static int osc_page_cache_add(const struct lu_env *env,
 			      const struct cl_page_slice *slice,
 			      struct cl_io *io)
 {
-	struct osc_io   *oio = osc_env_io(env);
+	struct osc_io *oio = osc_env_io(env);
 	struct osc_page *opg = cl2osc_page(slice);
 	int result;
 
@@ -247,7 +247,7 @@ void osc_index2policy(ldlm_policy_data_t *policy, const struct cl_object *obj,
 {
 	memset(policy, 0, sizeof(*policy));
 	policy-&gt;l_extent.start = cl_offset(obj, start);
-	policy-&gt;l_extent.end   = cl_offset(obj, end + 1) - 1;
+	policy-&gt;l_extent.end = cl_offset(obj, end + 1) - 1;
 }
 
 static int osc_page_addref_lock(const struct lu_env *env,
@@ -255,7 +255,7 @@ static int osc_page_addref_lock(const struct lu_env *env,
 				struct cl_lock *lock)
 {
 	struct osc_lock *olock;
-	int	      rc;
+	int rc;
 
 	LASSERT(opg-&gt;ops_lock == NULL);
 
@@ -274,7 +274,7 @@ static int osc_page_addref_lock(const struct lu_env *env,
 static void osc_page_putref_lock(const struct lu_env *env,
 				 struct osc_page *opg)
 {
-	struct cl_lock  *lock = opg-&gt;ops_lock;
+	struct cl_lock *lock = opg-&gt;ops_lock;
 	struct osc_lock *olock;
 
 	LASSERT(lock != NULL);
@@ -291,7 +291,7 @@ static int osc_page_is_under_lock(const struct lu_env *env,
 				  struct cl_io *unused)
 {
 	struct cl_lock *lock;
-	int	     result = -ENODATA;
+	int result = -ENODATA;
 
 	lock = cl_lock_at_page(env, slice-&gt;cpl_obj, slice-&gt;cpl_page,
 			       NULL, 1, 0);
@@ -317,7 +317,7 @@ static void osc_page_completion_read(const struct lu_env *env,
 				     const struct cl_page_slice *slice,
 				     int ioret)
 {
-	struct osc_page   *opg = cl2osc_page(slice);
+	struct osc_page *opg = cl2osc_page(slice);
 	struct osc_object *obj = cl2osc(opg-&gt;ops_cl.cpl_obj);
 
 	if (likely(opg-&gt;ops_lock))
@@ -329,7 +329,7 @@ static void osc_page_completion_write(const struct lu_env *env,
 				      const struct cl_page_slice *slice,
 				      int ioret)
 {
-	struct osc_page   *opg = cl2osc_page(slice);
+	struct osc_page *opg = cl2osc_page(slice);
 	struct osc_object *obj = cl2osc(slice-&gt;cpl_obj);
 
 	osc_lru_add(osc_cli(obj), opg);
@@ -364,10 +364,10 @@ static int osc_page_print(const struct lu_env *env,
 			  const struct cl_page_slice *slice,
 			  void *cookie, lu_printer_t printer)
 {
-	struct osc_page       *opg = cl2osc_page(slice);
+	struct osc_page *opg = cl2osc_page(slice);
 	struct osc_async_page *oap = &amp;opg-&gt;ops_oap;
-	struct osc_object     *obj = cl2osc(slice-&gt;cpl_obj);
-	struct client_obd     *cli = &amp;osc_export(obj)-&gt;exp_obd-&gt;u.cli;
+	struct osc_object *obj = cl2osc(slice-&gt;cpl_obj);
+	struct client_obd *cli = &amp;osc_export(obj)-&gt;exp_obd-&gt;u.cli;
 
 	return (*printer)(env, cookie, LUSTRE_OSC_NAME "-page@%p: 1&lt; %#x %d %u %s %s &gt; 2&lt; %llu %u %u %#x %#x | %p %p %p &gt; 3&lt; %s %p %d %lu %d &gt; 4&lt; %d %d %d %lu %s | %s %s %s %s &gt; 5&lt; %s %s %s %s | %d %s | %d %s %s&gt;\n",
 			  opg,
@@ -408,7 +408,7 @@ static int osc_page_print(const struct lu_env *env,
 static void osc_page_delete(const struct lu_env *env,
 			    const struct cl_page_slice *slice)
 {
-	struct osc_page   *opg = cl2osc_page(slice);
+	struct osc_page *opg = cl2osc_page(slice);
 	struct osc_object *obj = cl2osc(opg-&gt;ops_cl.cpl_obj);
 	int rc;
 
@@ -437,13 +437,13 @@ static void osc_page_delete(const struct lu_env *env,
 void osc_page_clip(const struct lu_env *env, const struct cl_page_slice *slice,
 		   int from, int to)
 {
-	struct osc_page       *opg = cl2osc_page(slice);
+	struct osc_page *opg = cl2osc_page(slice);
 	struct osc_async_page *oap = &amp;opg-&gt;ops_oap;
 
 	LINVRNT(osc_page_protected(env, opg, CLM_READ, 0));
 
 	opg-&gt;ops_from = from;
-	opg-&gt;ops_to   = to;
+	opg-&gt;ops_to = to;
 	spin_lock(&amp;oap-&gt;oap_lock);
 	oap-&gt;oap_async_flags |= ASYNC_COUNT_STABLE;
 	spin_unlock(&amp;oap-&gt;oap_lock);
@@ -502,11 +502,11 @@ int osc_page_init(const struct lu_env *env, struct cl_object *obj,
 		struct cl_page *page, struct page *vmpage)
 {
 	struct osc_object *osc = cl2osc(obj);
-	struct osc_page   *opg = cl_object_page_slice(obj, page);
+	struct osc_page *opg = cl_object_page_slice(obj, page);
 	int result;
 
 	opg-&gt;ops_from = 0;
-	opg-&gt;ops_to   = PAGE_CACHE_SIZE;
+	opg-&gt;ops_to = PAGE_CACHE_SIZE;
 
 	result = osc_prep_async_page(osc, opg, vmpage,
 					cl_offset(obj, page-&gt;cp_index));
@@ -540,7 +540,7 @@ void osc_page_submit(const struct lu_env *env, struct osc_page *opg,
 		     enum cl_req_type crt, int brw_flags)
 {
 	struct osc_async_page *oap = &amp;opg-&gt;ops_oap;
-	struct osc_object     *obj = oap-&gt;oap_obj;
+	struct osc_object *obj = oap-&gt;oap_obj;
 
 	LINVRNT(osc_page_protected(env, opg,
 				   crt == CRT_WRITE ? CLM_WRITE : CLM_READ, 1));
@@ -550,9 +550,9 @@ void osc_page_submit(const struct lu_env *env, struct osc_page *opg,
 	LASSERT(oap-&gt;oap_async_flags &amp; ASYNC_READY);
 	LASSERT(oap-&gt;oap_async_flags &amp; ASYNC_COUNT_STABLE);
 
-	oap-&gt;oap_cmd       = crt == CRT_WRITE ? OBD_BRW_WRITE : OBD_BRW_READ;
-	oap-&gt;oap_page_off  = opg-&gt;ops_from;
-	oap-&gt;oap_count     = opg-&gt;ops_to - opg-&gt;ops_from;
+	oap-&gt;oap_cmd = crt == CRT_WRITE ? OBD_BRW_WRITE : OBD_BRW_READ;
+	oap-&gt;oap_page_off = opg-&gt;ops_from;
+	oap-&gt;oap_count = opg-&gt;ops_to - opg-&gt;ops_from;
 	oap-&gt;oap_brw_flags = OBD_BRW_SYNC | brw_flags;
 
 	if (!client_is_remote(osc_export(obj)) &amp;&amp;
diff --git a/drivers/staging/lustre/lustre/osc/osc_quota.c b/drivers/staging/lustre/lustre/osc/osc_quota.c
index 6690f149a04c..2ff253f458f8 100644
--- a/drivers/staging/lustre/lustre/osc/osc_quota.c
+++ b/drivers/staging/lustre/lustre/osc/osc_quota.c
@@ -232,7 +232,7 @@ int osc_quota_setup(struct obd_device *obd)
 
 int osc_quota_cleanup(struct obd_device *obd)
 {
-	struct client_obd     *cli = &amp;obd-&gt;u.cli;
+	struct client_obd *cli = &amp;obd-&gt;u.cli;
 	int type;
 
 	for (type = 0; type &lt; MAXQUOTAS; type++)
@@ -245,8 +245,8 @@ int osc_quotactl(struct obd_device *unused, struct obd_export *exp,
 		 struct obd_quotactl *oqctl)
 {
 	struct ptlrpc_request *req;
-	struct obd_quotactl   *oqc;
-	int		    rc;
+	struct obd_quotactl *oqc;
+	int rc;
 
 	req = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),
 					&amp;RQF_OST_QUOTACTL, LUSTRE_OST_VERSION,
@@ -285,10 +285,10 @@ int osc_quotactl(struct obd_device *unused, struct obd_export *exp,
 int osc_quotacheck(struct obd_device *unused, struct obd_export *exp,
 		   struct obd_quotactl *oqctl)
 {
-	struct client_obd       *cli = &amp;exp-&gt;exp_obd-&gt;u.cli;
-	struct ptlrpc_request   *req;
-	struct obd_quotactl     *body;
-	int		      rc;
+	struct client_obd *cli = &amp;exp-&gt;exp_obd-&gt;u.cli;
+	struct ptlrpc_request *req;
+	struct obd_quotactl *body;
+	int rc;
 
 	req = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),
 					&amp;RQF_OST_QUOTACHECK, LUSTRE_OST_VERSION,
diff --git a/drivers/staging/lustre/lustre/osc/osc_request.c b/drivers/staging/lustre/lustre/osc/osc_request.c
index 6b6851ad3990..c174de9fb309 100644
--- a/drivers/staging/lustre/lustre/osc/osc_request.c
+++ b/drivers/staging/lustre/lustre/osc/osc_request.c
@@ -264,7 +264,7 @@ static int osc_getattr_async(struct obd_export *exp, struct obd_info *oinfo,
 {
 	struct ptlrpc_request *req;
 	struct osc_async_args *aa;
-	int		    rc;
+	int rc;
 
 	req = ptlrpc_request_alloc(class_exp2cliimp(exp), &amp;RQF_OST_GETATTR);
 	if (req == NULL)
@@ -294,8 +294,8 @@ static int osc_getattr(const struct lu_env *env, struct obd_export *exp,
 		       struct obd_info *oinfo)
 {
 	struct ptlrpc_request *req;
-	struct ost_body       *body;
-	int		    rc;
+	struct ost_body *body;
+	int rc;
 
 	req = ptlrpc_request_alloc(class_exp2cliimp(exp), &amp;RQF_OST_GETATTR);
 	if (req == NULL)
@@ -338,8 +338,8 @@ static int osc_setattr(const struct lu_env *env, struct obd_export *exp,
 		       struct obd_info *oinfo, struct obd_trans_info *oti)
 {
 	struct ptlrpc_request *req;
-	struct ost_body       *body;
-	int		    rc;
+	struct ost_body *body;
+	int rc;
 
 	LASSERT(oinfo-&gt;oi_oa-&gt;o_valid &amp; OBD_MD_FLGROUP);
 
@@ -403,9 +403,9 @@ int osc_setattr_async_base(struct obd_export *exp, struct obd_info *oinfo,
 			   obd_enqueue_update_f upcall, void *cookie,
 			   struct ptlrpc_request_set *rqset)
 {
-	struct ptlrpc_request   *req;
+	struct ptlrpc_request *req;
 	struct osc_setattr_args *sa;
-	int		      rc;
+	int rc;
 
 	req = ptlrpc_request_alloc(class_exp2cliimp(exp), &amp;RQF_OST_SETATTR);
 	if (req == NULL)
@@ -460,9 +460,9 @@ int osc_real_create(struct obd_export *exp, struct obdo *oa,
 		    struct lov_stripe_md **ea, struct obd_trans_info *oti)
 {
 	struct ptlrpc_request *req;
-	struct ost_body       *body;
-	struct lov_stripe_md  *lsm;
-	int		    rc;
+	struct ost_body *body;
+	struct lov_stripe_md *lsm;
+	int rc;
 
 	LASSERT(oa);
 	LASSERT(ea);
@@ -548,10 +548,10 @@ int osc_punch_base(struct obd_export *exp, struct obd_info *oinfo,
 		   obd_enqueue_update_f upcall, void *cookie,
 		   struct ptlrpc_request_set *rqset)
 {
-	struct ptlrpc_request   *req;
+	struct ptlrpc_request *req;
 	struct osc_setattr_args *sa;
-	struct ost_body	 *body;
-	int		      rc;
+	struct ost_body *body;
+	int rc;
 
 	req = ptlrpc_request_alloc(class_exp2cliimp(exp), &amp;RQF_OST_PUNCH);
 	if (req == NULL)
@@ -577,7 +577,7 @@ int osc_punch_base(struct obd_export *exp, struct obd_info *oinfo,
 	req-&gt;rq_interpret_reply = (ptlrpc_interpterer_t)osc_setattr_interpret;
 	CLASSERT (sizeof(*sa) &lt;= sizeof(req-&gt;rq_async_args));
 	sa = ptlrpc_req_async_args(req);
-	sa-&gt;sa_oa     = oinfo-&gt;oi_oa;
+	sa-&gt;sa_oa = oinfo-&gt;oi_oa;
 	sa-&gt;sa_upcall = upcall;
 	sa-&gt;sa_cookie = cookie;
 	if (rqset == PTLRPCD_SET)
@@ -616,9 +616,9 @@ int osc_sync_base(struct obd_export *exp, struct obd_info *oinfo,
 		  struct ptlrpc_request_set *rqset)
 {
 	struct ptlrpc_request *req;
-	struct ost_body       *body;
+	struct ost_body *body;
 	struct osc_fsync_args *fa;
-	int		    rc;
+	int rc;
 
 	req = ptlrpc_request_alloc(class_exp2cliimp(exp), &amp;RQF_OST_SYNC);
 	if (req == NULL)
@@ -757,9 +757,9 @@ static int osc_destroy(const struct lu_env *env, struct obd_export *exp,
 		       struct obd_trans_info *oti, struct obd_export *md_export,
 		       void *capa)
 {
-	struct client_obd     *cli = &amp;exp-&gt;exp_obd-&gt;u.cli;
+	struct client_obd *cli = &amp;exp-&gt;exp_obd-&gt;u.cli;
 	struct ptlrpc_request *req;
-	struct ost_body       *body;
+	struct ost_body *body;
 	LIST_HEAD(cancels);
 	int rc, count;
 
@@ -947,7 +947,7 @@ static int osc_shrink_grant(struct client_obd *cli)
 
 int osc_shrink_grant_to_target(struct client_obd *cli, __u64 target_bytes)
 {
-	int			rc = 0;
+	int rc = 0;
 	struct ost_body	*body;
 
 	client_obd_list_lock(&amp;cli-&gt;cl_loi_list_lock);
@@ -1131,8 +1131,8 @@ static int check_write_rcs(struct ptlrpc_request *req,
 			   int requested_nob, int niocount,
 			   u32 page_count, struct brw_page **pga)
 {
-	int     i;
-	__u32   *remote_rcs;
+	int i;
+	__u32 *remote_rcs;
 
 	remote_rcs = req_capsule_server_sized_get(&amp;req-&gt;rq_pill, &amp;RMF_RCS,
 						  sizeof(*remote_rcs) *
@@ -1182,15 +1182,15 @@ static inline int can_merge_pages(struct brw_page *p1, struct brw_page *p2)
 }
 
 static u32 osc_checksum_bulk(int nob, u32 pg_count,
-				   struct brw_page **pga, int opc,
-				   cksum_type_t cksum_type)
+			     struct brw_page **pga, int opc,
+			     cksum_type_t cksum_type)
 {
-	__u32				cksum;
-	int				i = 0;
-	struct cfs_crypto_hash_desc	*hdesc;
-	unsigned int			bufsize;
-	int				err;
-	unsigned char			cfs_alg = cksum_obd2cfs(cksum_type);
+	__u32 cksum;
+	int i = 0;
+	struct cfs_crypto_hash_desc *hdesc;
+	unsigned int bufsize;
+	int err;
+	unsigned char cfs_alg = cksum_obd2cfs(cksum_type);
 
 	LASSERT(pg_count &gt; 0);
 
@@ -1250,14 +1250,14 @@ static int osc_brw_prep_request(int cmd, struct client_obd *cli,
 				struct obd_capa *ocapa, int reserve,
 				int resend)
 {
-	struct ptlrpc_request   *req;
+	struct ptlrpc_request *req;
 	struct ptlrpc_bulk_desc *desc;
-	struct ost_body	 *body;
-	struct obd_ioobj	*ioobj;
-	struct niobuf_remote    *niobuf;
+	struct ost_body	*body;
+	struct obd_ioobj *ioobj;
+	struct niobuf_remote *niobuf;
 	int niocount, i, requested_nob, opc, rc;
 	struct osc_brw_async_args *aa;
-	struct req_capsule      *pill;
+	struct req_capsule *pill;
 	struct brw_page *pg_prev;
 
 	if (OBD_FAIL_CHECK(OBD_FAIL_OSC_BRW_PREP_REQ))
@@ -1359,8 +1359,8 @@ static int osc_brw_prep_request(int cmd, struct client_obd *cli,
 			niobuf-&gt;len += pg-&gt;count;
 		} else {
 			niobuf-&gt;offset = pg-&gt;off;
-			niobuf-&gt;len    = pg-&gt;count;
-			niobuf-&gt;flags  = pg-&gt;flag;
+			niobuf-&gt;len = pg-&gt;count;
+			niobuf-&gt;flags = pg-&gt;flag;
 		}
 		pg_prev = pg;
 	}
@@ -1581,9 +1581,9 @@ static int osc_brw_fini_request(struct ptlrpc_request *req, int rc)
 
 	if (body-&gt;oa.o_valid &amp; OBD_MD_FLCKSUM) {
 		static int cksum_counter;
-		__u32      server_cksum = body-&gt;oa.o_cksum;
-		char      *via;
-		char      *router;
+		__u32 server_cksum = body-&gt;oa.o_cksum;
+		char *via;
+		char *router;
 		cksum_type_t cksum_type;
 
 		cksum_type = cksum_type_unpack(body-&gt;oa.o_valid &amp;OBD_MD_FLFLAGS?
@@ -1758,7 +1758,7 @@ static int brw_interpret(const struct lu_env *env,
 	struct osc_brw_async_args *aa = data;
 	struct osc_extent *ext;
 	struct osc_extent *tmp;
-	struct cl_object  *obj = NULL;
+	struct cl_object *obj = NULL;
 	struct client_obd *cli = aa-&gt;aa_cli;
 
 	rc = osc_brw_fini_request(req, rc);
@@ -1862,26 +1862,25 @@ static int brw_interpret(const struct lu_env *env,
 int osc_build_rpc(const struct lu_env *env, struct client_obd *cli,
 		  struct list_head *ext_list, int cmd, pdl_policy_t pol)
 {
-	struct ptlrpc_request		*req = NULL;
-	struct osc_extent		*ext;
-	struct brw_page			**pga = NULL;
-	struct osc_brw_async_args	*aa = NULL;
-	struct obdo			*oa = NULL;
-	struct osc_async_page		*oap;
-	struct osc_async_page		*tmp;
-	struct cl_req			*clerq = NULL;
-	enum cl_req_type		crt = (cmd &amp; OBD_BRW_WRITE) ? CRT_WRITE :
-								      CRT_READ;
-	struct ldlm_lock		*lock = NULL;
-	struct cl_req_attr		*crattr = NULL;
-	u64				starting_offset = OBD_OBJECT_EOF;
-	u64				ending_offset = 0;
-	int				mpflag = 0;
-	int				mem_tight = 0;
-	int				page_count = 0;
-	int				i;
-	int				rc;
-	struct ost_body			*body;
+	struct ptlrpc_request *req = NULL;
+	struct osc_extent *ext;
+	struct brw_page **pga = NULL;
+	struct osc_brw_async_args *aa = NULL;
+	struct obdo *oa = NULL;
+	struct osc_async_page *oap;
+	struct osc_async_page *tmp;
+	struct cl_req *clerq = NULL;
+	enum cl_req_type crt = (cmd &amp; OBD_BRW_WRITE) ? CRT_WRITE : CRT_READ;
+	struct ldlm_lock *lock = NULL;
+	struct cl_req_attr *crattr = NULL;
+	u64 starting_offset = OBD_OBJECT_EOF;
+	u64 ending_offset = 0;
+	int mpflag = 0;
+	int mem_tight = 0;
+	int page_count = 0;
+	int i;
+	int rc;
+	struct ost_body *body;
 	LIST_HEAD(rpc_list);
 
 	LASSERT(!list_empty(ext_list));
@@ -2480,10 +2479,10 @@ static int osc_statfs_async(struct obd_export *exp,
 			    struct obd_info *oinfo, __u64 max_age,
 			    struct ptlrpc_request_set *rqset)
 {
-	struct obd_device     *obd = class_exp2obd(exp);
+	struct obd_device *obd = class_exp2obd(exp);
 	struct ptlrpc_request *req;
 	struct osc_async_args *aa;
-	int		    rc;
+	int rc;
 
 	/* We could possibly pass max_age in the request (as an absolute
 	 * timestamp or a "seconds.usec ago") so the target can avoid doing
@@ -2522,10 +2521,10 @@ static int osc_statfs_async(struct obd_export *exp,
 static int osc_statfs(const struct lu_env *env, struct obd_export *exp,
 		      struct obd_statfs *osfs, __u64 max_age, __u32 flags)
 {
-	struct obd_device     *obd = class_exp2obd(exp);
-	struct obd_statfs     *msfs;
+	struct obd_device *obd = class_exp2obd(exp);
+	struct obd_statfs *msfs;
 	struct ptlrpc_request *req;
-	struct obd_import     *imp = NULL;
+	struct obd_import *imp = NULL;
 	int rc;
 
 	/*Since the request might also come from lprocfs, so we need
@@ -2749,9 +2748,9 @@ static int osc_get_info(const struct lu_env *env, struct obd_export *exp,
 		return 0;
 	} else if (KEY_IS(KEY_LAST_ID)) {
 		struct ptlrpc_request *req;
-		u64		*reply;
-		char		  *tmp;
-		int		    rc;
+		u64 *reply;
+		char *tmp;
+		int rc;
 
 		req = ptlrpc_request_alloc(class_exp2cliimp(exp),
 					   &amp;RQF_OST_GET_INFO_LAST_ID);
@@ -2788,14 +2787,14 @@ static int osc_get_info(const struct lu_env *env, struct obd_export *exp,
 	} else if (KEY_IS(KEY_FIEMAP)) {
 		struct ll_fiemap_info_key *fm_key =
 				(struct ll_fiemap_info_key *)key;
-		struct ldlm_res_id	 res_id;
-		ldlm_policy_data_t	 policy;
-		struct lustre_handle	 lockh;
-		ldlm_mode_t		 mode = 0;
-		struct ptlrpc_request	*req;
-		struct ll_user_fiemap	*reply;
-		char			*tmp;
-		int			 rc;
+		struct ldlm_res_id res_id;
+		ldlm_policy_data_t policy;
+		struct lustre_handle lockh;
+		ldlm_mode_t mode = 0;
+		struct ptlrpc_request *req;
+		struct ll_user_fiemap *reply;
+		char *tmp;
+		int rc;
 
 		if (!(fm_key-&gt;fiemap.fm_flags &amp; FIEMAP_FLAG_SYNC))
 			goto skip_locking;
@@ -2881,10 +2880,10 @@ static int osc_set_info_async(const struct lu_env *env, struct obd_export *exp,
 			      void *val, struct ptlrpc_request_set *set)
 {
 	struct ptlrpc_request *req;
-	struct obd_device     *obd = exp-&gt;exp_obd;
-	struct obd_import     *imp = class_exp2cliimp(exp);
-	char		  *tmp;
-	int		    rc;
+	struct obd_device *obd = exp-&gt;exp_obd;
+	struct obd_import *imp = class_exp2cliimp(exp);
+	char *tmp;
+	int rc;
 
 	OBD_FAIL_TIMEOUT(OBD_FAIL_OSC_SHUTDOWN, 10);
 
@@ -3071,8 +3070,8 @@ static int osc_import_event(struct obd_device *obd,
 	}
 	case IMP_EVENT_INVALIDATE: {
 		struct ldlm_namespace *ns = obd-&gt;obd_namespace;
-		struct lu_env	 *env;
-		int		    refcheck;
+		struct lu_env *env;
+		int refcheck;
 
 		env = cl_env_get(&amp;refcheck);
 		if (!IS_ERR(env)) {
@@ -3159,9 +3158,9 @@ static int brw_queue_work(const struct lu_env *env, void *data)
 int osc_setup(struct obd_device *obd, struct lustre_cfg *lcfg)
 {
 	struct lprocfs_static_vars lvars = { NULL };
-	struct client_obd	  *cli = &amp;obd-&gt;u.cli;
-	void		       *handler;
-	int			rc;
+	struct client_obd *cli = &amp;obd-&gt;u.cli;
+	void *handler;
+	int rc;
 
 	rc = ptlrpcd_addref();
 	if (rc)</pre><hr><pre>commit f4edeeb3937d5f9953b5722f1cca9573d5ffe8a0
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Tue Sep 22 11:34:04 2009 -0500

    9p: Update documentation to add fscache related bits
    
    Update the documentation to describe FS-Cache related
    caching parameters. This patch also updates the pointers
    to 9p-related papers and adds pointer to the Wiki.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/Documentation/filesystems/9p.txt b/Documentation/filesystems/9p.txt
index 6208f55c44c3..57e0b80a5274 100644
--- a/Documentation/filesystems/9p.txt
+++ b/Documentation/filesystems/9p.txt
@@ -18,11 +18,11 @@ the 9p client is available in the form of a USENIX paper:
 
 Other applications are described in the following papers:
 	* XCPU &amp; Clustering
-		http://www.xcpu.org/xcpu-talk.pdf
+		http://xcpu.org/papers/xcpu-talk.pdf
 	* KVMFS: control file system for KVM
-		http://www.xcpu.org/kvmfs.pdf
-	* CellFS: A New ProgrammingModel for the Cell BE
-		http://www.xcpu.org/cellfs-talk.pdf
+		http://xcpu.org/papers/kvmfs.pdf
+	* CellFS: A New Programming Model for the Cell BE
+		http://xcpu.org/papers/cellfs-talk.pdf
 	* PROSE I/O: Using 9p to enable Application Partitions
 		http://plan9.escet.urjc.es/iwp9/cready/PROSE_iwp9_2006.pdf
 
@@ -48,6 +48,7 @@ OPTIONS
                                 (see rfdno and wfdno)
 			virtio	- connect to the next virtio channel available
 				(from lguest or KVM with trans_virtio module)
+			rdma	- connect to a specified RDMA channel
 
   uname=name	user name to attempt mount as on the remote server.  The
   		server may override or ignore this value.  Certain user
@@ -59,16 +60,22 @@ OPTIONS
   cache=mode	specifies a caching policy.  By default, no caches are used.
 			loose = no attempts are made at consistency,
                                 intended for exclusive, read-only mounts
+			fscache = use FS-Cache for a persistent, read-only
+				cache backend.
 
   debug=n	specifies debug level.  The debug level is a bitmask.
-  			0x01 = display verbose error messages
-			0x02 = developer debug (DEBUG_CURRENT)
-			0x04 = display 9p trace
-			0x08 = display VFS trace
-			0x10 = display Marshalling debug
-			0x20 = display RPC debug
-			0x40 = display transport debug
-			0x80 = display allocation debug
+			0x01  = display verbose error messages
+			0x02  = developer debug (DEBUG_CURRENT)
+			0x04  = display 9p trace
+			0x08  = display VFS trace
+			0x10  = display Marshalling debug
+			0x20  = display RPC debug
+			0x40  = display transport debug
+			0x80  = display allocation debug
+			0x100 = display protocol message debug
+			0x200 = display Fid debug
+			0x400 = display packet debug
+			0x800 = display fscache tracing debug
 
   rfdno=n	the file descriptor for reading with trans=fd
 
@@ -100,6 +107,10 @@ OPTIONS
 			any   = v9fs does single attach and performs all
 				operations as one user
 
+  cachetag	cache tag to use the specified persistent cache.
+		cache tags for existing cache sessions can be listed at
+		/sys/fs/9p/caches. (applies only to cache=fscache)
+
 RESOURCES
 =========
 
@@ -118,7 +129,7 @@ and export.
 A Linux version of the 9p server is now maintained under the npfs project
 on sourceforge (http://sourceforge.net/projects/npfs).  The currently
 maintained version is the single-threaded version of the server (named spfs)
-available from the same CVS repository.
+available from the same SVN repository.
 
 There are user and developer mailing lists available through the v9fs project
 on sourceforge (http://sourceforge.net/projects/v9fs).
@@ -126,7 +137,8 @@ on sourceforge (http://sourceforge.net/projects/v9fs).
 A stand-alone version of the module (which should build for any 2.6 kernel)
 is available via (http://github.com/ericvh/9p-sac/tree/master)
 
-News and other information is maintained on SWiK (http://swik.net/v9fs).
+News and other information is maintained on SWiK (http://swik.net/v9fs)
+and the Wiki (http://sf.net/apps/mediawiki/v9fs/index.php).
 
 Bug reports may be issued through the kernel.org bugzilla 
 (http://bugzilla.kernel.org)</pre><hr><pre>commit 60e78d2c993e58d890596d951fff77d5965adcd6
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Wed Sep 23 13:00:27 2009 -0500

    9p: Add fscache support to 9p
    
    This patch adds a persistent, read-only caching facility for
    9p clients using the FS-Cache caching backend.
    
    When the fscache facility is enabled, each inode is associated
    with a corresponding vcookie which is an index into the FS-Cache
    indexing tree. The FS-Cache indexing tree is indexed at 3 levels:
    - session object associated with each mount.
    - inode/vcookie
    - actual data (pages)
    
    A cache tag is chosen randomly for each session. These tags can
    be read off /sys/fs/9p/caches and can be passed as a mount-time
    parameter to re-attach to the specified caching session.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/fs/9p/Kconfig b/fs/9p/Kconfig
index 74e0723e90bc..795233702a4e 100644
--- a/fs/9p/Kconfig
+++ b/fs/9p/Kconfig
@@ -8,3 +8,12 @@ config 9P_FS
 	  See &lt;http://v9fs.sf.net&gt; for more information.
 
 	  If unsure, say N.
+
+config 9P_FSCACHE
+	bool "Enable 9P client caching support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	depends on 9P_FS=m &amp;&amp; FSCACHE || 9P_FS=y &amp;&amp; FSCACHE=y
+	help
+	  Choose Y here to enable persistent, read-only local
+	  caching support for 9p clients using FS-Cache
+
diff --git a/fs/9p/Makefile b/fs/9p/Makefile
index bc7f0d1551e6..1a940ec7af61 100644
--- a/fs/9p/Makefile
+++ b/fs/9p/Makefile
@@ -8,5 +8,6 @@ obj-$(CONFIG_9P_FS) := 9p.o
 	vfs_dir.o \
 	vfs_dentry.o \
 	v9fs.o \
-	fid.o \
+	fid.o
 
+9p-$(CONFIG_9P_FSCACHE) += cache.o
diff --git a/fs/9p/cache.c b/fs/9p/cache.c
new file mode 100644
index 000000000000..51c94e26a346
--- /dev/null
+++ b/fs/9p/cache.c
@@ -0,0 +1,474 @@
+/*
+ * V9FS cache definitions.
+ *
+ *  Copyright (C) 2009 by Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to:
+ *  Free Software Foundation
+ *  51 Franklin Street, Fifth Floor
+ *  Boston, MA  02111-1301  USA
+ *
+ */
+
+#include &lt;linux/jiffies.h&gt;
+#include &lt;linux/file.h&gt;
+#include &lt;linux/stat.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;linux/fs.h&gt;
+#include &lt;net/9p/9p.h&gt;
+
+#include "v9fs.h"
+#include "cache.h"
+
+#define CACHETAG_LEN  11
+
+struct kmem_cache *vcookie_cache;
+
+struct fscache_netfs v9fs_cache_netfs = {
+	.name 		= "9p",
+	.version 	= 0,
+};
+
+static void init_once(void *foo)
+{
+	struct v9fs_cookie *vcookie = (struct v9fs_cookie *) foo;
+	vcookie-&gt;fscache = NULL;
+	vcookie-&gt;qid = NULL;
+	inode_init_once(&amp;vcookie-&gt;inode);
+}
+
+/**
+ * v9fs_init_vcookiecache - initialize a cache for vcookies to maintain
+ *			    vcookie to inode mapping
+ *
+ * Returns 0 on success.
+ */
+
+static int v9fs_init_vcookiecache(void)
+{
+	vcookie_cache = kmem_cache_create("vcookie_cache",
+					  sizeof(struct v9fs_cookie),
+					  0, (SLAB_RECLAIM_ACCOUNT|
+					      SLAB_MEM_SPREAD),
+					  init_once);
+	if (!vcookie_cache)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * v9fs_destroy_vcookiecache - destroy the cache of vcookies
+ *
+ */
+
+static void v9fs_destroy_vcookiecache(void)
+{
+	kmem_cache_destroy(vcookie_cache);
+}
+
+int __v9fs_cache_register(void)
+{
+	int ret;
+	ret = v9fs_init_vcookiecache();
+	if (ret &lt; 0)
+		return ret;
+
+	return fscache_register_netfs(&amp;v9fs_cache_netfs);
+}
+
+void __v9fs_cache_unregister(void)
+{
+	v9fs_destroy_vcookiecache();
+	fscache_unregister_netfs(&amp;v9fs_cache_netfs);
+}
+
+/**
+ * v9fs_random_cachetag - Generate a random tag to be associated
+ *			  with a new cache session.
+ *
+ * The value of jiffies is used for a fairly randomly cache tag.
+ */
+
+static
+int v9fs_random_cachetag(struct v9fs_session_info *v9ses)
+{
+	v9ses-&gt;cachetag = kmalloc(CACHETAG_LEN, GFP_KERNEL);
+	if (!v9ses-&gt;cachetag)
+		return -ENOMEM;
+
+	return scnprintf(v9ses-&gt;cachetag, CACHETAG_LEN, "%lu", jiffies);
+}
+
+static uint16_t v9fs_cache_session_get_key(const void *cookie_netfs_data,
+					   void *buffer, uint16_t bufmax)
+{
+	struct v9fs_session_info *v9ses;
+	uint16_t klen = 0;
+
+	v9ses = (struct v9fs_session_info *)cookie_netfs_data;
+	P9_DPRINTK(P9_DEBUG_FSC, "session %p buf %p size %u", v9ses,
+		   buffer, bufmax);
+
+	if (v9ses-&gt;cachetag)
+		klen = strlen(v9ses-&gt;cachetag);
+
+	if (klen &gt; bufmax)
+		return 0;
+
+	memcpy(buffer, v9ses-&gt;cachetag, klen);
+	P9_DPRINTK(P9_DEBUG_FSC, "cache session tag %s", v9ses-&gt;cachetag);
+	return klen;
+}
+
+const struct fscache_cookie_def v9fs_cache_session_index_def = {
+	.name 		= "9P.session",
+	.type 		= FSCACHE_COOKIE_TYPE_INDEX,
+	.get_key 	= v9fs_cache_session_get_key,
+};
+
+void v9fs_cache_session_get_cookie(struct v9fs_session_info *v9ses)
+{
+	/* If no cache session tag was specified, we generate a random one. */
+	if (!v9ses-&gt;cachetag)
+		v9fs_random_cachetag(v9ses);
+
+	v9ses-&gt;fscache = fscache_acquire_cookie(v9fs_cache_netfs.primary_index,
+						&amp;v9fs_cache_session_index_def,
+						v9ses);
+	P9_DPRINTK(P9_DEBUG_FSC, "session %p get cookie %p", v9ses,
+		   v9ses-&gt;fscache);
+}
+
+void v9fs_cache_session_put_cookie(struct v9fs_session_info *v9ses)
+{
+	P9_DPRINTK(P9_DEBUG_FSC, "session %p put cookie %p", v9ses,
+		   v9ses-&gt;fscache);
+	fscache_relinquish_cookie(v9ses-&gt;fscache, 0);
+	v9ses-&gt;fscache = NULL;
+}
+
+
+static uint16_t v9fs_cache_inode_get_key(const void *cookie_netfs_data,
+					 void *buffer, uint16_t bufmax)
+{
+	const struct v9fs_cookie *vcookie = cookie_netfs_data;
+	memcpy(buffer, &amp;vcookie-&gt;qid-&gt;path, sizeof(vcookie-&gt;qid-&gt;path));
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p get key %llu", &amp;vcookie-&gt;inode,
+		   vcookie-&gt;qid-&gt;path);
+	return sizeof(vcookie-&gt;qid-&gt;path);
+}
+
+static void v9fs_cache_inode_get_attr(const void *cookie_netfs_data,
+				      uint64_t *size)
+{
+	const struct v9fs_cookie *vcookie = cookie_netfs_data;
+	*size = i_size_read(&amp;vcookie-&gt;inode);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p get attr %llu", &amp;vcookie-&gt;inode,
+		   *size);
+}
+
+static uint16_t v9fs_cache_inode_get_aux(const void *cookie_netfs_data,
+					 void *buffer, uint16_t buflen)
+{
+	const struct v9fs_cookie *vcookie = cookie_netfs_data;
+	memcpy(buffer, &amp;vcookie-&gt;qid-&gt;version, sizeof(vcookie-&gt;qid-&gt;version));
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p get aux %u", &amp;vcookie-&gt;inode,
+		   vcookie-&gt;qid-&gt;version);
+	return sizeof(vcookie-&gt;qid-&gt;version);
+}
+
+static enum
+fscache_checkaux v9fs_cache_inode_check_aux(void *cookie_netfs_data,
+					    const void *buffer,
+					    uint16_t buflen)
+{
+	const struct v9fs_cookie *vcookie = cookie_netfs_data;
+
+	if (buflen != sizeof(vcookie-&gt;qid-&gt;version))
+		return FSCACHE_CHECKAUX_OBSOLETE;
+
+	if (memcmp(buffer, &amp;vcookie-&gt;qid-&gt;version,
+		   sizeof(vcookie-&gt;qid-&gt;version)))
+		return FSCACHE_CHECKAUX_OBSOLETE;
+
+	return FSCACHE_CHECKAUX_OKAY;
+}
+
+static void v9fs_cache_inode_now_uncached(void *cookie_netfs_data)
+{
+	struct v9fs_cookie *vcookie = cookie_netfs_data;
+	struct pagevec pvec;
+	pgoff_t first;
+	int loop, nr_pages;
+
+	pagevec_init(&amp;pvec, 0);
+	first = 0;
+
+	for (;;) {
+		nr_pages = pagevec_lookup(&amp;pvec, vcookie-&gt;inode.i_mapping,
+					  first,
+					  PAGEVEC_SIZE - pagevec_count(&amp;pvec));
+		if (!nr_pages)
+			break;
+
+		for (loop = 0; loop &lt; nr_pages; loop++)
+			ClearPageFsCache(pvec.pages[loop]);
+
+		first = pvec.pages[nr_pages - 1]-&gt;index + 1;
+
+		pvec.nr = nr_pages;
+		pagevec_release(&amp;pvec);
+		cond_resched();
+	}
+}
+
+const struct fscache_cookie_def v9fs_cache_inode_index_def = {
+	.name		= "9p.inode",
+	.type		= FSCACHE_COOKIE_TYPE_DATAFILE,
+	.get_key	= v9fs_cache_inode_get_key,
+	.get_attr	= v9fs_cache_inode_get_attr,
+	.get_aux	= v9fs_cache_inode_get_aux,
+	.check_aux	= v9fs_cache_inode_check_aux,
+	.now_uncached	= v9fs_cache_inode_now_uncached,
+};
+
+void v9fs_cache_inode_get_cookie(struct inode *inode)
+{
+	struct v9fs_cookie *vcookie;
+	struct v9fs_session_info *v9ses;
+
+	if (!S_ISREG(inode-&gt;i_mode))
+		return;
+
+	vcookie = v9fs_inode2cookie(inode);
+	if (vcookie-&gt;fscache)
+		return;
+
+	v9ses = v9fs_inode2v9ses(inode);
+	vcookie-&gt;fscache = fscache_acquire_cookie(v9ses-&gt;fscache,
+						  &amp;v9fs_cache_inode_index_def,
+						  vcookie);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p get cookie %p", inode,
+		   vcookie-&gt;fscache);
+}
+
+void v9fs_cache_inode_put_cookie(struct inode *inode)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	if (!vcookie-&gt;fscache)
+		return;
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p put cookie %p", inode,
+		   vcookie-&gt;fscache);
+
+	fscache_relinquish_cookie(vcookie-&gt;fscache, 0);
+	vcookie-&gt;fscache = NULL;
+}
+
+void v9fs_cache_inode_flush_cookie(struct inode *inode)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	if (!vcookie-&gt;fscache)
+		return;
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p flush cookie %p", inode,
+		   vcookie-&gt;fscache);
+
+	fscache_relinquish_cookie(vcookie-&gt;fscache, 1);
+	vcookie-&gt;fscache = NULL;
+}
+
+void v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+	struct p9_fid *fid;
+
+	if (!vcookie-&gt;fscache)
+		return;
+
+	spin_lock(&amp;vcookie-&gt;lock);
+	fid = filp-&gt;private_data;
+	if ((filp-&gt;f_flags &amp; O_ACCMODE) != O_RDONLY)
+		v9fs_cache_inode_flush_cookie(inode);
+	else
+		v9fs_cache_inode_get_cookie(inode);
+
+	spin_unlock(&amp;vcookie-&gt;lock);
+}
+
+void v9fs_cache_inode_reset_cookie(struct inode *inode)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+	struct v9fs_session_info *v9ses;
+	struct fscache_cookie *old;
+
+	if (!vcookie-&gt;fscache)
+		return;
+
+	old = vcookie-&gt;fscache;
+
+	spin_lock(&amp;vcookie-&gt;lock);
+	fscache_relinquish_cookie(vcookie-&gt;fscache, 1);
+
+	v9ses = v9fs_inode2v9ses(inode);
+	vcookie-&gt;fscache = fscache_acquire_cookie(v9ses-&gt;fscache,
+						  &amp;v9fs_cache_inode_index_def,
+						  vcookie);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p revalidating cookie old %p new %p",
+		   inode, old, vcookie-&gt;fscache);
+
+	spin_unlock(&amp;vcookie-&gt;lock);
+}
+
+int __v9fs_fscache_release_page(struct page *page, gfp_t gfp)
+{
+	struct inode *inode = page-&gt;mapping-&gt;host;
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	BUG_ON(!vcookie-&gt;fscache);
+
+	if (PageFsCache(page)) {
+		if (fscache_check_page_write(vcookie-&gt;fscache, page)) {
+			if (!(gfp &amp; __GFP_WAIT))
+				return 0;
+			fscache_wait_on_page_write(vcookie-&gt;fscache, page);
+		}
+
+		fscache_uncache_page(vcookie-&gt;fscache, page);
+		ClearPageFsCache(page);
+	}
+
+	return 1;
+}
+
+void __v9fs_fscache_invalidate_page(struct page *page)
+{
+	struct inode *inode = page-&gt;mapping-&gt;host;
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	BUG_ON(!vcookie-&gt;fscache);
+
+	if (PageFsCache(page)) {
+		fscache_wait_on_page_write(vcookie-&gt;fscache, page);
+		BUG_ON(!PageLocked(page));
+		fscache_uncache_page(vcookie-&gt;fscache, page);
+		ClearPageFsCache(page);
+	}
+}
+
+static void v9fs_vfs_readpage_complete(struct page *page, void *data,
+				       int error)
+{
+	if (!error)
+		SetPageUptodate(page);
+
+	unlock_page(page);
+}
+
+/**
+ * __v9fs_readpage_from_fscache - read a page from cache
+ *
+ * Returns 0 if the pages are in cache and a BIO is submitted,
+ * 1 if the pages are not in cache and -error otherwise.
+ */
+
+int __v9fs_readpage_from_fscache(struct inode *inode, struct page *page)
+{
+	int ret;
+	const struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p page %p", inode, page);
+	if (!vcookie-&gt;fscache)
+		return -ENOBUFS;
+
+	ret = fscache_read_or_alloc_page(vcookie-&gt;fscache,
+					 page,
+					 v9fs_vfs_readpage_complete,
+					 NULL,
+					 GFP_KERNEL);
+	switch (ret) {
+	case -ENOBUFS:
+	case -ENODATA:
+		P9_DPRINTK(P9_DEBUG_FSC, "page/inode not in cache %d", ret);
+		return 1;
+	case 0:
+		P9_DPRINTK(P9_DEBUG_FSC, "BIO submitted");
+		return ret;
+	default:
+		P9_DPRINTK(P9_DEBUG_FSC, "ret %d", ret);
+		return ret;
+	}
+}
+
+/**
+ * __v9fs_readpages_from_fscache - read multiple pages from cache
+ *
+ * Returns 0 if the pages are in cache and a BIO is submitted,
+ * 1 if the pages are not in cache and -error otherwise.
+ */
+
+int __v9fs_readpages_from_fscache(struct inode *inode,
+				  struct address_space *mapping,
+				  struct list_head *pages,
+				  unsigned *nr_pages)
+{
+	int ret;
+	const struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p pages %u", inode, *nr_pages);
+	if (!vcookie-&gt;fscache)
+		return -ENOBUFS;
+
+	ret = fscache_read_or_alloc_pages(vcookie-&gt;fscache,
+					  mapping, pages, nr_pages,
+					  v9fs_vfs_readpage_complete,
+					  NULL,
+					  mapping_gfp_mask(mapping));
+	switch (ret) {
+	case -ENOBUFS:
+	case -ENODATA:
+		P9_DPRINTK(P9_DEBUG_FSC, "pages/inodes not in cache %d", ret);
+		return 1;
+	case 0:
+		BUG_ON(!list_empty(pages));
+		BUG_ON(*nr_pages != 0);
+		P9_DPRINTK(P9_DEBUG_FSC, "BIO submitted");
+		return ret;
+	default:
+		P9_DPRINTK(P9_DEBUG_FSC, "ret %d", ret);
+		return ret;
+	}
+}
+
+/**
+ * __v9fs_readpage_to_fscache - write a page to the cache
+ *
+ */
+
+void __v9fs_readpage_to_fscache(struct inode *inode, struct page *page)
+{
+	int ret;
+	const struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+
+	P9_DPRINTK(P9_DEBUG_FSC, "inode %p page %p", inode, page);
+	ret = fscache_write_page(vcookie-&gt;fscache, page, GFP_KERNEL);
+	P9_DPRINTK(P9_DEBUG_FSC, "ret =  %d", ret);
+	if (ret != 0)
+		v9fs_uncache_page(inode, page);
+}
diff --git a/fs/9p/cache.h b/fs/9p/cache.h
new file mode 100644
index 000000000000..a94192bfaee8
--- /dev/null
+++ b/fs/9p/cache.h
@@ -0,0 +1,176 @@
+/*
+ * V9FS cache definitions.
+ *
+ *  Copyright (C) 2009 by Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to:
+ *  Free Software Foundation
+ *  51 Franklin Street, Fifth Floor
+ *  Boston, MA  02111-1301  USA
+ *
+ */
+
+#ifndef _9P_CACHE_H
+#ifdef CONFIG_9P_FSCACHE
+#include &lt;linux/fscache.h&gt;
+#include &lt;linux/spinlock.h&gt;
+
+extern struct kmem_cache *vcookie_cache;
+
+struct v9fs_cookie {
+	spinlock_t lock;
+	struct inode inode;
+	struct fscache_cookie *fscache;
+	struct p9_qid *qid;
+};
+
+static inline struct v9fs_cookie *v9fs_inode2cookie(const struct inode *inode)
+{
+	return container_of(inode, struct v9fs_cookie, inode);
+}
+
+extern struct fscache_netfs v9fs_cache_netfs;
+extern const struct fscache_cookie_def v9fs_cache_session_index_def;
+extern const struct fscache_cookie_def v9fs_cache_inode_index_def;
+
+extern void v9fs_cache_session_get_cookie(struct v9fs_session_info *v9ses);
+extern void v9fs_cache_session_put_cookie(struct v9fs_session_info *v9ses);
+
+extern void v9fs_cache_inode_get_cookie(struct inode *inode);
+extern void v9fs_cache_inode_put_cookie(struct inode *inode);
+extern void v9fs_cache_inode_flush_cookie(struct inode *inode);
+extern void v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp);
+extern void v9fs_cache_inode_reset_cookie(struct inode *inode);
+
+extern int __v9fs_cache_register(void);
+extern void __v9fs_cache_unregister(void);
+
+extern int __v9fs_fscache_release_page(struct page *page, gfp_t gfp);
+extern void __v9fs_fscache_invalidate_page(struct page *page);
+extern int __v9fs_readpage_from_fscache(struct inode *inode,
+					struct page *page);
+extern int __v9fs_readpages_from_fscache(struct inode *inode,
+					 struct address_space *mapping,
+					 struct list_head *pages,
+					 unsigned *nr_pages);
+extern void __v9fs_readpage_to_fscache(struct inode *inode, struct page *page);
+
+
+/**
+ * v9fs_cache_register - Register v9fs file system with the cache
+ */
+static inline int v9fs_cache_register(void)
+{
+	return __v9fs_cache_register();
+}
+
+/**
+ * v9fs_cache_unregister - Unregister v9fs from the cache
+ */
+static inline void v9fs_cache_unregister(void)
+{
+	__v9fs_cache_unregister();
+}
+
+static inline int v9fs_fscache_release_page(struct page *page,
+					    gfp_t gfp)
+{
+	return __v9fs_fscache_release_page(page, gfp);
+}
+
+static inline void v9fs_fscache_invalidate_page(struct page *page)
+{
+	__v9fs_fscache_invalidate_page(page);
+}
+
+static inline int v9fs_readpage_from_fscache(struct inode *inode,
+					     struct page *page)
+{
+	return __v9fs_readpage_from_fscache(inode, page);
+}
+
+static inline int v9fs_readpages_from_fscache(struct inode *inode,
+					      struct address_space *mapping,
+					      struct list_head *pages,
+					      unsigned *nr_pages)
+{
+	return __v9fs_readpages_from_fscache(inode, mapping, pages,
+					     nr_pages);
+}
+
+static inline void v9fs_readpage_to_fscache(struct inode *inode,
+					    struct page *page)
+{
+	if (PageFsCache(page))
+		__v9fs_readpage_to_fscache(inode, page);
+}
+
+static inline void v9fs_uncache_page(struct inode *inode, struct page *page)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+	fscache_uncache_page(vcookie-&gt;fscache, page);
+	BUG_ON(PageFsCache(page));
+}
+
+static inline void v9fs_vcookie_set_qid(struct inode *inode,
+					struct p9_qid *qid)
+{
+	struct v9fs_cookie *vcookie = v9fs_inode2cookie(inode);
+	spin_lock(&amp;vcookie-&gt;lock);
+	vcookie-&gt;qid = qid;
+	spin_unlock(&amp;vcookie-&gt;lock);
+}
+
+#else /* CONFIG_9P_FSCACHE */
+
+static inline int v9fs_cache_register(void)
+{
+	return 1;
+}
+
+static inline void v9fs_cache_unregister(void) {}
+
+static inline int v9fs_fscache_release_page(struct page *page,
+					    gfp_t gfp) {
+	return 1;
+}
+
+static inline void v9fs_fscache_invalidate_page(struct page *page) {}
+
+static inline int v9fs_readpage_from_fscache(struct inode *inode,
+					     struct page *page)
+{
+	return -ENOBUFS;
+}
+
+static inline int v9fs_readpages_from_fscache(struct inode *inode,
+					      struct address_space *mapping,
+					      struct list_head *pages,
+					      unsigned *nr_pages)
+{
+	return -ENOBUFS;
+}
+
+static inline void v9fs_readpage_to_fscache(struct inode *inode,
+					    struct page *page)
+{}
+
+static inline void v9fs_uncache_page(struct inode *inode, struct page *page)
+{}
+
+static inline void v9fs_vcookie_set_qid(struct inode *inode,
+					struct p9_qid *qid)
+{}
+
+#endif /* CONFIG_9P_FSCACHE */
+#endif /* _9P_CACHE_H */
diff --git a/fs/9p/v9fs.c b/fs/9p/v9fs.c
index f7003cfac63d..cf62b05e296a 100644
--- a/fs/9p/v9fs.c
+++ b/fs/9p/v9fs.c
@@ -34,21 +34,25 @@
 #include &lt;net/9p/transport.h&gt;
 #include "v9fs.h"
 #include "v9fs_vfs.h"
+#include "cache.h"
+
+static DEFINE_SPINLOCK(v9fs_sessionlist_lock);
+static LIST_HEAD(v9fs_sessionlist);
 
 /*
-  * Option Parsing (code inspired by NFS code)
-  *  NOTE: each transport will parse its own options
-  */
+ * Option Parsing (code inspired by NFS code)
+ *  NOTE: each transport will parse its own options
+ */
 
 enum {
 	/* Options that take integer arguments */
 	Opt_debug, Opt_dfltuid, Opt_dfltgid, Opt_afid,
 	/* String options */
-	Opt_uname, Opt_remotename, Opt_trans,
+	Opt_uname, Opt_remotename, Opt_trans, Opt_cache, Opt_cachetag,
 	/* Options that take no arguments */
 	Opt_nodevmap,
 	/* Cache options */
-	Opt_cache_loose,
+	Opt_cache_loose, Opt_fscache,
 	/* Access options */
 	Opt_access,
 	/* Error token */
@@ -63,8 +67,10 @@ static const match_table_t tokens = {
 	{Opt_uname, "uname=%s"},
 	{Opt_remotename, "aname=%s"},
 	{Opt_nodevmap, "nodevmap"},
-	{Opt_cache_loose, "cache=loose"},
+	{Opt_cache, "cache=%s"},
 	{Opt_cache_loose, "loose"},
+	{Opt_fscache, "fscache"},
+	{Opt_cachetag, "cachetag=%s"},
 	{Opt_access, "access=%s"},
 	{Opt_err, NULL}
 };
@@ -89,16 +95,16 @@ static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)
 	v9ses-&gt;afid = ~0;
 	v9ses-&gt;debug = 0;
 	v9ses-&gt;cache = 0;
+#ifdef CONFIG_9P_FSCACHE
+	v9ses-&gt;cachetag = NULL;
+#endif
 
 	if (!opts)
 		return 0;
 
 	options = kstrdup(opts, GFP_KERNEL);
-	if (!options) {
-		P9_DPRINTK(P9_DEBUG_ERROR,
-			   "failed to allocate copy of option string\n");
-		return -ENOMEM;
-	}
+	if (!options)
+		goto fail_option_alloc;
 
 	while ((p = strsep(&amp;options, ",")) != NULL) {
 		int token;
@@ -143,16 +149,33 @@ static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)
 		case Opt_cache_loose:
 			v9ses-&gt;cache = CACHE_LOOSE;
 			break;
+		case Opt_fscache:
+			v9ses-&gt;cache = CACHE_FSCACHE;
+			break;
+		case Opt_cachetag:
+#ifdef CONFIG_9P_FSCACHE
+			v9ses-&gt;cachetag = match_strdup(&amp;args[0]);
+#endif
+			break;
+		case Opt_cache:
+			s = match_strdup(&amp;args[0]);
+			if (!s)
+				goto fail_option_alloc;
+
+			if (strcmp(s, "loose") == 0)
+				v9ses-&gt;cache = CACHE_LOOSE;
+			else if (strcmp(s, "fscache") == 0)
+				v9ses-&gt;cache = CACHE_FSCACHE;
+			else
+				v9ses-&gt;cache = CACHE_NONE;
+			kfree(s);
+			break;
 
 		case Opt_access:
 			s = match_strdup(&amp;args[0]);
-			if (!s) {
-				P9_DPRINTK(P9_DEBUG_ERROR,
-					   "failed to allocate copy"
-					   " of option argument\n");
-				ret = -ENOMEM;
-				break;
-			}
+			if (!s)
+				goto fail_option_alloc;
+
 			v9ses-&gt;flags &amp;= ~V9FS_ACCESS_MASK;
 			if (strcmp(s, "user") == 0)
 				v9ses-&gt;flags |= V9FS_ACCESS_USER;
@@ -173,6 +196,11 @@ static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)
 	}
 	kfree(options);
 	return ret;
+
+fail_option_alloc:
+	P9_DPRINTK(P9_DEBUG_ERROR,
+		   "failed to allocate copy of option argument\n");
+	return -ENOMEM;
 }
 
 /**
@@ -200,6 +228,10 @@ struct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,
 		return ERR_PTR(-ENOMEM);
 	}
 
+	spin_lock(&amp;v9fs_sessionlist_lock);
+	list_add(&amp;v9ses-&gt;slist, &amp;v9fs_sessionlist);
+	spin_unlock(&amp;v9fs_sessionlist_lock);
+
 	v9ses-&gt;flags = V9FS_EXTENDED | V9FS_ACCESS_USER;
 	strcpy(v9ses-&gt;uname, V9FS_DEFUSER);
 	strcpy(v9ses-&gt;aname, V9FS_DEFANAME);
@@ -249,6 +281,11 @@ struct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,
 	else
 		fid-&gt;uid = ~0;
 
+#ifdef CONFIG_9P_FSCACHE
+	/* register the session for caching */
+	v9fs_cache_session_get_cookie(v9ses);
+#endif
+
 	return fid;
 
 error:
@@ -268,8 +305,18 @@ void v9fs_session_close(struct v9fs_session_info *v9ses)
 		v9ses-&gt;clnt = NULL;
 	}
 
+#ifdef CONFIG_9P_FSCACHE
+	if (v9ses-&gt;fscache) {
+		v9fs_cache_session_put_cookie(v9ses);
+		kfree(v9ses-&gt;cachetag);
+	}
+#endif
 	__putname(v9ses-&gt;uname);
 	__putname(v9ses-&gt;aname);
+
+	spin_lock(&amp;v9fs_sessionlist_lock);
+	list_del(&amp;v9ses-&gt;slist);
+	spin_unlock(&amp;v9fs_sessionlist_lock);
 }
 
 /**
@@ -286,25 +333,132 @@ void v9fs_session_cancel(struct v9fs_session_info *v9ses) {
 
 extern int v9fs_error_init(void);
 
+static struct kobject *v9fs_kobj;
+
+#ifdef CONFIG_9P_FSCACHE
 /**
- * v9fs_init - Initialize module
+ * caches_show - list caches associated with a session
+ *
+ * Returns the size of buffer written.
+ */
+
+static ssize_t caches_show(struct kobject *kobj,
+			   struct kobj_attribute *attr,
+			   char *buf)
+{
+	ssize_t n = 0, count = 0, limit = PAGE_SIZE;
+	struct v9fs_session_info *v9ses;
+
+	spin_lock(&amp;v9fs_sessionlist_lock);
+	list_for_each_entry(v9ses, &amp;v9fs_sessionlist, slist) {
+		if (v9ses-&gt;cachetag) {
+			n = snprintf(buf, limit, "%s\n", v9ses-&gt;cachetag);
+			if (n &lt; 0) {
+				count = n;
+				break;
+			}
+
+			count += n;
+			limit -= n;
+		}
+	}
+
+	spin_unlock(&amp;v9fs_sessionlist_lock);
+	return count;
+}
+
+static struct kobj_attribute v9fs_attr_cache = __ATTR_RO(caches);
+#endif /* CONFIG_9P_FSCACHE */
+
+static struct attribute *v9fs_attrs[] = {
+#ifdef CONFIG_9P_FSCACHE
+	&amp;v9fs_attr_cache.attr,
+#endif
+	NULL,
+};
+
+static struct attribute_group v9fs_attr_group = {
+	.attrs = v9fs_attrs,
+};
+
+/**
+ * v9fs_sysfs_init - Initialize the v9fs sysfs interface
+ *
+ */
+
+static int v9fs_sysfs_init(void)
+{
+	v9fs_kobj = kobject_create_and_add("9p", fs_kobj);
+	if (!v9fs_kobj)
+		return -ENOMEM;
+
+	if (sysfs_create_group(v9fs_kobj, &amp;v9fs_attr_group)) {
+		kobject_put(v9fs_kobj);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * v9fs_sysfs_cleanup - Unregister the v9fs sysfs interface
+ *
+ */
+
+static void v9fs_sysfs_cleanup(void)
+{
+	sysfs_remove_group(v9fs_kobj, &amp;v9fs_attr_group);
+	kobject_put(v9fs_kobj);
+}
+
+/**
+ * init_v9fs - Initialize module
  *
  */
 
 static int __init init_v9fs(void)
 {
+	int err;
 	printk(KERN_INFO "Installing v9fs 9p2000 file system support\n");
 	/* TODO: Setup list of registered trasnport modules */
-	return register_filesystem(&amp;v9fs_fs_type);
+	err = register_filesystem(&amp;v9fs_fs_type);
+	if (err &lt; 0) {
+		printk(KERN_ERR "Failed to register filesystem\n");
+		return err;
+	}
+
+	err = v9fs_cache_register();
+	if (err &lt; 0) {
+		printk(KERN_ERR "Failed to register v9fs for caching\n");
+		goto out_fs_unreg;
+	}
+
+	err = v9fs_sysfs_init();
+	if (err &lt; 0) {
+		printk(KERN_ERR "Failed to register with sysfs\n");
+		goto out_sysfs_cleanup;
+	}
+
+	return 0;
+
+out_sysfs_cleanup:
+	v9fs_sysfs_cleanup();
+
+out_fs_unreg:
+	unregister_filesystem(&amp;v9fs_fs_type);
+
+	return err;
 }
 
 /**
- * v9fs_init - shutdown module
+ * exit_v9fs - shutdown module
  *
  */
 
 static void __exit exit_v9fs(void)
 {
+	v9fs_sysfs_cleanup();
+	v9fs_cache_unregister();
 	unregister_filesystem(&amp;v9fs_fs_type);
 }
 
diff --git a/fs/9p/v9fs.h b/fs/9p/v9fs.h
index 38762bf102a9..019f4ccb70c1 100644
--- a/fs/9p/v9fs.h
+++ b/fs/9p/v9fs.h
@@ -51,6 +51,7 @@ enum p9_session_flags {
 enum p9_cache_modes {
 	CACHE_NONE,
 	CACHE_LOOSE,
+	CACHE_FSCACHE,
 };
 
 /**
@@ -60,6 +61,8 @@ enum p9_cache_modes {
  * @debug: debug level
  * @afid: authentication handle
  * @cache: cache mode of type &amp;p9_cache_modes
+ * @cachetag: the tag of the cache associated with this session
+ * @fscache: session cookie associated with FS-Cache
  * @options: copy of options string given by user
  * @uname: string user name to mount hierarchy as
  * @aname: mount specifier for remote hierarchy
@@ -68,7 +71,7 @@ enum p9_cache_modes {
  * @dfltgid: default numeric groupid to mount hierarchy as
  * @uid: if %V9FS_ACCESS_SINGLE, the numeric uid which mounted the hierarchy
  * @clnt: reference to 9P network client instantiated for this session
- * @debugfs_dir: reference to debugfs_dir which can be used for add'l debug
+ * @slist: reference to list of registered 9p sessions
  *
  * This structure holds state for each session instance established during
  * a sys_mount() .
@@ -84,6 +87,10 @@ struct v9fs_session_info {
 	unsigned short debug;
 	unsigned int afid;
 	unsigned int cache;
+#ifdef CONFIG_9P_FSCACHE
+	char *cachetag;
+	struct fscache_cookie *fscache;
+#endif
 
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
@@ -92,11 +99,9 @@ struct v9fs_session_info {
 	unsigned int dfltgid;	/* default gid for legacy support */
 	u32 uid;		/* if ACCESS_SINGLE, the uid that has access */
 	struct p9_client *clnt;	/* 9p client */
-	struct dentry *debugfs_dir;
+	struct list_head slist; /* list of sessions registered with v9fs */
 };
 
-extern struct dentry *v9fs_debugfs_root;
-
 struct p9_fid *v9fs_session_init(struct v9fs_session_info *, const char *,
 									char *);
 void v9fs_session_close(struct v9fs_session_info *v9ses);
diff --git a/fs/9p/v9fs_vfs.h b/fs/9p/v9fs_vfs.h
index f0c7de78e205..3a7560e35865 100644
--- a/fs/9p/v9fs_vfs.h
+++ b/fs/9p/v9fs_vfs.h
@@ -44,7 +44,13 @@ extern const struct file_operations v9fs_dir_operations;
 extern const struct dentry_operations v9fs_dentry_operations;
 extern const struct dentry_operations v9fs_cached_dentry_operations;
 
+#ifdef CONFIG_9P_FSCACHE
+struct inode *v9fs_alloc_inode(struct super_block *sb);
+void v9fs_destroy_inode(struct inode *inode);
+#endif
+
 struct inode *v9fs_get_inode(struct super_block *sb, int mode);
+void v9fs_clear_inode(struct inode *inode);
 ino_t v9fs_qid2ino(struct p9_qid *qid);
 void v9fs_stat2inode(struct p9_wstat *, struct inode *, struct super_block *);
 int v9fs_dir_release(struct inode *inode, struct file *filp);
diff --git a/fs/9p/vfs_addr.c b/fs/9p/vfs_addr.c
index 92828281a30b..90e38449f4b3 100644
--- a/fs/9p/vfs_addr.c
+++ b/fs/9p/vfs_addr.c
@@ -38,6 +38,7 @@
 
 #include "v9fs.h"
 #include "v9fs_vfs.h"
+#include "cache.h"
 
 /**
  * v9fs_vfs_readpage - read an entire page in from 9P
@@ -52,18 +53,31 @@ static int v9fs_vfs_readpage(struct file *filp, struct page *page)
 	int retval;
 	loff_t offset;
 	char *buffer;
+	struct inode *inode;
 
+	inode = page-&gt;mapping-&gt;host;
 	P9_DPRINTK(P9_DEBUG_VFS, "\n");
+
+	BUG_ON(!PageLocked(page));
+
+	retval = v9fs_readpage_from_fscache(inode, page);
+	if (retval == 0)
+		return retval;
+
 	buffer = kmap(page);
 	offset = page_offset(page);
 
 	retval = v9fs_file_readn(filp, buffer, NULL, PAGE_CACHE_SIZE, offset);
-	if (retval &lt; 0)
+	if (retval &lt; 0) {
+		v9fs_uncache_page(inode, page);
 		goto done;
+	}
 
 	memset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);
 	flush_dcache_page(page);
 	SetPageUptodate(page);
+
+	v9fs_readpage_to_fscache(inode, page);
 	retval = 0;
 
 done:
@@ -72,6 +86,78 @@ static int v9fs_vfs_readpage(struct file *filp, struct page *page)
 	return retval;
 }
 
+/**
+ * v9fs_vfs_readpages - read a set of pages from 9P
+ *
+ * @filp: file being read
+ * @mapping: the address space
+ * @pages: list of pages to read
+ * @nr_pages: count of pages to read
+ *
+ */
+
+static int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,
+			     struct list_head *pages, unsigned nr_pages)
+{
+	int ret = 0;
+	struct inode *inode;
+
+	inode = mapping-&gt;host;
+	P9_DPRINTK(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, filp);
+
+	ret = v9fs_readpages_from_fscache(inode, mapping, pages, &amp;nr_pages);
+	if (ret == 0)
+		return ret;
+
+	ret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);
+	P9_DPRINTK(P9_DEBUG_VFS, "  = %d\n", ret);
+	return ret;
+}
+
+/**
+ * v9fs_release_page - release the private state associated with a page
+ *
+ * Returns 1 if the page can be released, false otherwise.
+ */
+
+static int v9fs_release_page(struct page *page, gfp_t gfp)
+{
+	if (PagePrivate(page))
+		return 0;
+
+	return v9fs_fscache_release_page(page, gfp);
+}
+
+/**
+ * v9fs_invalidate_page - Invalidate a page completely or partially
+ *
+ * @page: structure to page
+ * @offset: offset in the page
+ */
+
+static void v9fs_invalidate_page(struct page *page, unsigned long offset)
+{
+	if (offset == 0)
+		v9fs_fscache_invalidate_page(page);
+}
+
+/**
+ * v9fs_launder_page - Writeback a dirty page
+ * Since the writes go directly to the server, we simply return a 0
+ * here to indicate success.
+ *
+ * Returns 0 on success.
+ */
+
+static int v9fs_launder_page(struct page *page)
+{
+	return 0;
+}
+
 const struct address_space_operations v9fs_addr_operations = {
       .readpage = v9fs_vfs_readpage,
+      .readpages = v9fs_vfs_readpages,
+      .releasepage = v9fs_release_page,
+      .invalidatepage = v9fs_invalidate_page,
+      .launder_page = v9fs_launder_page,
 };
diff --git a/fs/9p/vfs_file.c b/fs/9p/vfs_file.c
index cafaa46434ba..3902bf43a088 100644
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@ -41,6 +41,7 @@
 #include "v9fs.h"
 #include "v9fs_vfs.h"
 #include "fid.h"
+#include "cache.h"
 
 static const struct file_operations v9fs_cached_file_operations;
 
@@ -86,6 +87,10 @@ int v9fs_file_open(struct inode *inode, struct file *file)
 		/* enable cached file options */
 		if(file-&gt;f_op == &amp;v9fs_file_operations)
 			file-&gt;f_op = &amp;v9fs_cached_file_operations;
+
+#ifdef CONFIG_9P_FSCACHE
+		v9fs_cache_inode_set_cookie(inode, file);
+#endif
 	}
 
 	return 0;
@@ -238,8 +243,9 @@ v9fs_file_write(struct file *filp, const char __user * data,
 	if (total &gt; 0) {
 		pg_start = origin &gt;&gt; PAGE_CACHE_SHIFT;
 		pg_end = (origin + total - 1) &gt;&gt; PAGE_CACHE_SHIFT;
-		invalidate_inode_pages2_range(inode-&gt;i_mapping, pg_start,
-								pg_end);
+		if (inode-&gt;i_mapping &amp;&amp; inode-&gt;i_mapping-&gt;nrpages)
+			invalidate_inode_pages2_range(inode-&gt;i_mapping,
+						      pg_start, pg_end);
 		*offset += total;
 		i_size_write(inode, i_size_read(inode) + total);
 		inode-&gt;i_blocks = (i_size_read(inode) + 512 - 1) &gt;&gt; 9;
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index f3bfa87926bd..5947628aefef 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -40,6 +40,7 @@
 #include "v9fs.h"
 #include "v9fs_vfs.h"
 #include "fid.h"
+#include "cache.h"
 
 static const struct inode_operations v9fs_dir_inode_operations;
 static const struct inode_operations v9fs_dir_inode_operations_ext;
@@ -197,6 +198,39 @@ v9fs_blank_wstat(struct p9_wstat *wstat)
 	wstat-&gt;extension = NULL;
 }
 
+#ifdef CONFIG_9P_FSCACHE
+/**
+ * v9fs_alloc_inode - helper function to allocate an inode
+ * This callback is executed before setting up the inode so that we
+ * can associate a vcookie with each inode.
+ *
+ */
+
+struct inode *v9fs_alloc_inode(struct super_block *sb)
+{
+	struct v9fs_cookie *vcookie;
+	vcookie = (struct v9fs_cookie *)kmem_cache_alloc(vcookie_cache,
+							 GFP_KERNEL);
+	if (!vcookie)
+		return NULL;
+
+	vcookie-&gt;fscache = NULL;
+	vcookie-&gt;qid = NULL;
+	spin_lock_init(&amp;vcookie-&gt;lock);
+	return &amp;vcookie-&gt;inode;
+}
+
+/**
+ * v9fs_destroy_inode - destroy an inode
+ *
+ */
+
+void v9fs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(vcookie_cache, v9fs_inode2cookie(inode));
+}
+#endif
+
 /**
  * v9fs_get_inode - helper function to setup an inode
  * @sb: superblock
@@ -326,6 +360,21 @@ v9fs_clone_walk(struct v9fs_session_info *v9ses, u32 fid, struct dentry *dentry)
 }
 */
 
+
+/**
+ * v9fs_clear_inode - release an inode
+ * @inode: inode to release
+ *
+ */
+void v9fs_clear_inode(struct inode *inode)
+{
+	filemap_fdatawrite(inode-&gt;i_mapping);
+
+#ifdef CONFIG_9P_FSCACHE
+	v9fs_cache_inode_put_cookie(inode);
+#endif
+}
+
 /**
  * v9fs_inode_from_fid - populate an inode by issuing a attribute request
  * @v9ses: session information
@@ -356,8 +405,14 @@ v9fs_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,
 
 	v9fs_stat2inode(st, ret, sb);
 	ret-&gt;i_ino = v9fs_qid2ino(&amp;st-&gt;qid);
+
+#ifdef CONFIG_9P_FSCACHE
+	v9fs_vcookie_set_qid(ret, &amp;st-&gt;qid);
+	v9fs_cache_inode_get_cookie(ret);
+#endif
 	p9stat_free(st);
 	kfree(st);
+
 	return ret;
 
 error:
@@ -751,7 +806,7 @@ v9fs_vfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	P9_DPRINTK(P9_DEBUG_VFS, "dentry: %p\n", dentry);
 	err = -EPERM;
 	v9ses = v9fs_inode2v9ses(dentry-&gt;d_inode);
-	if (v9ses-&gt;cache == CACHE_LOOSE)
+	if (v9ses-&gt;cache == CACHE_LOOSE || v9ses-&gt;cache == CACHE_FSCACHE)
 		return simple_getattr(mnt, dentry, stat);
 
 	fid = v9fs_fid_lookup(dentry);
diff --git a/fs/9p/vfs_super.c b/fs/9p/vfs_super.c
index 8961f1a8f668..14a86448572c 100644
--- a/fs/9p/vfs_super.c
+++ b/fs/9p/vfs_super.c
@@ -44,20 +44,8 @@
 #include "v9fs_vfs.h"
 #include "fid.h"
 
-static void v9fs_clear_inode(struct inode *);
 static const struct super_operations v9fs_super_ops;
 
-/**
- * v9fs_clear_inode - release an inode
- * @inode: inode to release
- *
- */
-
-static void v9fs_clear_inode(struct inode *inode)
-{
-	filemap_fdatawrite(inode-&gt;i_mapping);
-}
-
 /**
  * v9fs_set_super - set the superblock
  * @s: super block
@@ -220,6 +208,10 @@ v9fs_umount_begin(struct super_block *sb)
 }
 
 static const struct super_operations v9fs_super_ops = {
+#ifdef CONFIG_9P_FSCACHE
+	.alloc_inode = v9fs_alloc_inode,
+	.destroy_inode = v9fs_destroy_inode,
+#endif
 	.statfs = simple_statfs,
 	.clear_inode = v9fs_clear_inode,
 	.show_options = generic_show_options,
diff --git a/include/net/9p/9p.h b/include/net/9p/9p.h
index b77c1478c99f..a7fb54808a23 100644
--- a/include/net/9p/9p.h
+++ b/include/net/9p/9p.h
@@ -38,6 +38,8 @@
  * @P9_DEBUG_SLABS: memory management tracing
  * @P9_DEBUG_FCALL: verbose dump of protocol messages
  * @P9_DEBUG_FID: fid allocation/deallocation tracking
+ * @P9_DEBUG_PKT: packet marshalling/unmarshalling
+ * @P9_DEBUG_FSC: FS-cache tracing
  *
  * These flags are passed at mount time to turn on various levels of
  * verbosity and tracing which will be output to the system logs.
@@ -54,6 +56,7 @@ enum p9_debug_flags {
 	P9_DEBUG_FCALL =	(1&lt;&lt;8),
 	P9_DEBUG_FID =		(1&lt;&lt;9),
 	P9_DEBUG_PKT =		(1&lt;&lt;10),
+	P9_DEBUG_FSC =		(1&lt;&lt;11),
 };
 
 #ifdef CONFIG_NET_9P_DEBUG</pre><hr><pre>commit 637d020a02cd734bf27acfc56c6d942cddd9eb80
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Tue Sep 22 11:34:05 2009 -0500

    9p: Fix the incorrect update of inode size in v9fs_file_write()
    
    When using the cache=loose flags, the inode's size was not being
    updated correctly on a remote write. Thus subsequent reads of
    the whole file resulted in a truncated read. Fix it.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/fs/9p/vfs_file.c b/fs/9p/vfs_file.c
index de7690eec4d8..cafaa46434ba 100644
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@ -32,6 +32,7 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/inet.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/pagemap.h&gt;
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/idr.h&gt;
 #include &lt;net/9p/9p.h&gt;
@@ -210,6 +211,7 @@ v9fs_file_write(struct file *filp, const char __user * data,
 	struct p9_client *clnt;
 	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int origin = *offset;
+	unsigned long pg_start, pg_end;
 
 	P9_DPRINTK(P9_DEBUG_VFS, "data %p count %d offset %x\n", data,
 		(int)count, (int)*offset);
@@ -225,7 +227,7 @@ v9fs_file_write(struct file *filp, const char __user * data,
 		if (count &lt; rsize)
 			rsize = count;
 
-		n = p9_client_write(fid, NULL, data+total, *offset+total,
+		n = p9_client_write(fid, NULL, data+total, origin+total,
 									rsize);
 		if (n &lt;= 0)
 			break;
@@ -234,13 +236,12 @@ v9fs_file_write(struct file *filp, const char __user * data,
 	} while (count &gt; 0);
 
 	if (total &gt; 0) {
-		invalidate_inode_pages2_range(inode-&gt;i_mapping, origin,
-								origin+total);
+		pg_start = origin &gt;&gt; PAGE_CACHE_SHIFT;
+		pg_end = (origin + total - 1) &gt;&gt; PAGE_CACHE_SHIFT;
+		invalidate_inode_pages2_range(inode-&gt;i_mapping, pg_start,
+								pg_end);
 		*offset += total;
-	}
-
-	if (*offset &gt; i_size_read(inode)) {
-		i_size_write(inode, *offset);
+		i_size_write(inode, i_size_read(inode) + total);
 		inode-&gt;i_blocks = (i_size_read(inode) + 512 - 1) &gt;&gt; 9;
 	}
 </pre><hr><pre>commit 7549ae3e81cc45908cbeee54a52b24f247fb0a2d
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Tue Sep 22 11:34:05 2009 -0500

    9p: Use the i_size_[read, write]() macros instead of using inode-&gt;i_size directly.
    
    Change all occurrence of inode-&gt;i_size with i_size_read() or i_size_write()
    as appropriate.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/fs/9p/vfs_file.c b/fs/9p/vfs_file.c
index 68bf2af6c389..de7690eec4d8 100644
--- a/fs/9p/vfs_file.c
+++ b/fs/9p/vfs_file.c
@@ -72,7 +72,7 @@ int v9fs_file_open(struct inode *inode, struct file *file)
 			return err;
 		}
 		if (omode &amp; P9_OTRUNC) {
-			inode-&gt;i_size = 0;
+			i_size_write(inode, 0);
 			inode-&gt;i_blocks = 0;
 		}
 		if ((file-&gt;f_flags &amp; O_APPEND) &amp;&amp; (!v9fs_extended(v9ses)))
@@ -239,9 +239,9 @@ v9fs_file_write(struct file *filp, const char __user * data,
 		*offset += total;
 	}
 
-	if (*offset &gt; inode-&gt;i_size) {
-		inode-&gt;i_size = *offset;
-		inode-&gt;i_blocks = (inode-&gt;i_size + 512 - 1) &gt;&gt; 9;
+	if (*offset &gt; i_size_read(inode)) {
+		i_size_write(inode, *offset);
+		inode-&gt;i_blocks = (i_size_read(inode) + 512 - 1) &gt;&gt; 9;
 	}
 
 	if (n &lt; 0)
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index 06a223d50a81..f3bfa87926bd 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -872,10 +872,10 @@ v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
 	} else
 		inode-&gt;i_rdev = 0;
 
-	inode-&gt;i_size = stat-&gt;length;
+	i_size_write(inode, stat-&gt;length);
 
 	/* not real number of blocks, but 512 byte ones ... */
-	inode-&gt;i_blocks = (inode-&gt;i_size + 512 - 1) &gt;&gt; 9;
+	inode-&gt;i_blocks = (i_size_read(inode) + 512 - 1) &gt;&gt; 9;
 }
 
 /**</pre><hr><pre>commit 4b53e4b500779230aedd5355940aeaaed0b5353b
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Mon Aug 17 16:42:28 2009 -0500

    9p: remove unnecessary v9fses-&gt;options which duplicates the mount string
    
    The mount options string is saved in sb-&gt;s_options. This patch removes
    the redundant duplicating of the mount options. Also, since we are not
    displaying anything special in show options, we replace v9fs_show_options
    with generic_show_options for now.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/fs/9p/v9fs.c b/fs/9p/v9fs.c
index 332b5ff02fec..f7003cfac63d 100644
--- a/fs/9p/v9fs.c
+++ b/fs/9p/v9fs.c
@@ -76,7 +76,7 @@ static const match_table_t tokens = {
  * Return 0 upon success, -ERRNO upon failure.
  */
 
-static int v9fs_parse_options(struct v9fs_session_info *v9ses)
+static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)
 {
 	char *options;
 	substring_t args[MAX_OPT_ARGS];
@@ -90,10 +90,10 @@ static int v9fs_parse_options(struct v9fs_session_info *v9ses)
 	v9ses-&gt;debug = 0;
 	v9ses-&gt;cache = 0;
 
-	if (!v9ses-&gt;options)
+	if (!opts)
 		return 0;
 
-	options = kstrdup(v9ses-&gt;options, GFP_KERNEL);
+	options = kstrdup(opts, GFP_KERNEL);
 	if (!options) {
 		P9_DPRINTK(P9_DEBUG_ERROR,
 			   "failed to allocate copy of option string\n");
@@ -206,24 +206,14 @@ struct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,
 	v9ses-&gt;uid = ~0;
 	v9ses-&gt;dfltuid = V9FS_DEFUID;
 	v9ses-&gt;dfltgid = V9FS_DEFGID;
-	if (data) {
-		v9ses-&gt;options = kstrdup(data, GFP_KERNEL);
-		if (!v9ses-&gt;options) {
-			P9_DPRINTK(P9_DEBUG_ERROR,
-			   "failed to allocate copy of option string\n");
-			retval = -ENOMEM;
-			goto error;
-		}
-	}
 
-	rc = v9fs_parse_options(v9ses);
+	rc = v9fs_parse_options(v9ses, data);
 	if (rc &lt; 0) {
 		retval = rc;
 		goto error;
 	}
 
-	v9ses-&gt;clnt = p9_client_create(dev_name, v9ses-&gt;options);
-
+	v9ses-&gt;clnt = p9_client_create(dev_name, data);
 	if (IS_ERR(v9ses-&gt;clnt)) {
 		retval = PTR_ERR(v9ses-&gt;clnt);
 		v9ses-&gt;clnt = NULL;
@@ -280,7 +270,6 @@ void v9fs_session_close(struct v9fs_session_info *v9ses)
 
 	__putname(v9ses-&gt;uname);
 	__putname(v9ses-&gt;aname);
-	kfree(v9ses-&gt;options);
 }
 
 /**
diff --git a/fs/9p/v9fs.h b/fs/9p/v9fs.h
index a7d567192998..38762bf102a9 100644
--- a/fs/9p/v9fs.h
+++ b/fs/9p/v9fs.h
@@ -85,7 +85,6 @@ struct v9fs_session_info {
 	unsigned int afid;
 	unsigned int cache;
 
-	char *options;		/* copy of mount options */
 	char *uname;		/* user name to mount as */
 	char *aname;		/* name of remote hierarchy being mounted */
 	unsigned int maxdata;	/* max data for client interface */
diff --git a/fs/9p/vfs_super.c b/fs/9p/vfs_super.c
index 072dce094477..8961f1a8f668 100644
--- a/fs/9p/vfs_super.c
+++ b/fs/9p/vfs_super.c
@@ -81,7 +81,7 @@ static int v9fs_set_super(struct super_block *s, void *data)
 
 static void
 v9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,
-		int flags)
+		int flags, void *data)
 {
 	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;
 	sb-&gt;s_blocksize_bits = fls(v9ses-&gt;maxdata - 1);
@@ -91,6 +91,8 @@ v9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,
 
 	sb-&gt;s_flags = flags | MS_ACTIVE | MS_SYNCHRONOUS | MS_DIRSYNC |
 	    MS_NOATIME;
+
+	save_mount_options(sb, data);
 }
 
 /**
@@ -139,7 +141,7 @@ static int v9fs_get_sb(struct file_system_type *fs_type, int flags,
 		retval = PTR_ERR(sb);
 		goto free_stat;
 	}
-	v9fs_fill_super(sb, v9ses, flags);
+	v9fs_fill_super(sb, v9ses, flags, data);
 
 	inode = v9fs_get_inode(sb, S_IFDIR | mode);
 	if (IS_ERR(inode)) {
@@ -208,21 +210,6 @@ static void v9fs_kill_super(struct super_block *s)
 	P9_DPRINTK(P9_DEBUG_VFS, "exiting kill_super\n");
 }
 
-/**
- * v9fs_show_options - Show mount options in /proc/mounts
- * @m: seq_file to write to
- * @mnt: mount descriptor
- *
- */
-
-static int v9fs_show_options(struct seq_file *m, struct vfsmount *mnt)
-{
-	struct v9fs_session_info *v9ses = mnt-&gt;mnt_sb-&gt;s_fs_info;
-	if (v9ses-&gt;options != NULL)
-		seq_printf(m, ",%s", v9ses-&gt;options);
-	return 0;
-}
-
 static void
 v9fs_umount_begin(struct super_block *sb)
 {
@@ -235,7 +222,7 @@ v9fs_umount_begin(struct super_block *sb)
 static const struct super_operations v9fs_super_ops = {
 	.statfs = simple_statfs,
 	.clear_inode = v9fs_clear_inode,
-	.show_options = v9fs_show_options,
+	.show_options = generic_show_options,
 	.umount_begin = v9fs_umount_begin,
 };
 </pre><hr><pre>commit 0aad37ef3deed118d3816e1d1a600eb2ec9dcb87
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Mon Aug 17 16:38:45 2009 -0500

    net/9p: insulate the client against an invalid error code sent by a 9p server
    
    A looney tunes server sending an invalid error code (which is !IS_ERR_VALUE)
    can result in a client oops. So fix it by adding a check and converting unknown
    or invalid error codes to -ESERVERFAULT.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/net/9p/client.c b/net/9p/client.c
index 7bbd2d5ae8d3..5bf5f227dbe0 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -411,14 +411,9 @@ static int p9_check_errors(struct p9_client *c, struct p9_req_t *req)
 		if (c-&gt;dotu)
 			err = -ecode;
 
-		if (!err) {
+		if (!err || !IS_ERR_VALUE(err))
 			err = p9_errstr2errno(ename, strlen(ename));
 
-			/* string match failed */
-			if (!err)
-				err = -ESERVERFAULT;
-		}
-
 		P9_DPRINTK(P9_DEBUG_9P, "&lt;&lt;&lt; RERROR (%d) %s\n", -ecode, ename);
 
 		kfree(ename);
diff --git a/net/9p/error.c b/net/9p/error.c
index fdebe4314062..52518512a93e 100644
--- a/net/9p/error.c
+++ b/net/9p/error.c
@@ -239,7 +239,7 @@ int p9_errstr2errno(char *errstr, int len)
 		errstr[len] = 0;
 		printk(KERN_ERR "%s: server reported unknown error %s\n",
 			__func__, errstr);
-		errno = 1;
+		errno = ESERVERFAULT;
 	}
 
 	return -errno;</pre><hr><pre>commit 48559b4c30708ebdc849483da9fb83ee08c6c908
Author: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
Date:   Mon Aug 17 16:32:18 2009 -0500

    9p: Add missing cast for the error return value in v9fs_get_inode
    
    Cast the error return value (ENOMEM) in v9fs_get_inode() to its
    correct type using ERR_PTR.
    
    Signed-off-by: Abhishek Kulkarni &lt;adkulkar@umail.iu.edu&gt;
    Signed-off-by: Eric Van Hensbergen &lt;ericvh@gmail.com&gt;

diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index fac30d21851f..06a223d50a81 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -215,7 +215,7 @@ struct inode *v9fs_get_inode(struct super_block *sb, int mode)
 	inode = new_inode(sb);
 	if (!inode) {
 		P9_EPRINTK(KERN_WARNING, "Problem allocating inode\n");
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 	}
 
 	inode-&gt;i_mode = mode;</pre>
    <div class="pagination">
        <span>[1]</span><a href='30_2.html'>2</a><a href='30_3.html'>3</a><a href='30_2.html'>Next&gt;&gt;</a>
    <div>
</body>

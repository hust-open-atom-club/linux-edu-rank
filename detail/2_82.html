<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_81.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><span>[82]</span><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_83.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bcca06efea883bdf3803a0bb0ffa60f26730387d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 13 11:35:54 2009 -0500

    USB: don't enable wakeup by default for PCI host controllers
    
    This patch (as1199) changes the initial wakeup settings for PCI USB
    host controllers.  The controllers are marked as capable of waking the
    system, but wakeup is not enabled by default.
    
    It turns out that enabling wakeup for USB host controllers has a lot
    of bad consequences.  As the simplest example, if a USB mouse or
    keyboard is unplugged immediately after the computer is put to sleep,
    the unplug will cause the system to wake back up again!  We are better
    off marking them as wakeup-capable and leaving wakeup disabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 507741ed4482..99432785f438 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -128,7 +128,6 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	}
 
 	pci_set_master(dev);
-	device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 
 	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bdc6e86e1f8b..9faa5c8fe025 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -230,7 +230,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		pci_read_config_word(pdev, 0x62, &amp;port_wake);
 		if (port_wake &amp; 0x0001) {
 			dev_warn(&amp;pdev-&gt;dev, "Enabling legacy PCI PM\n");
-			device_init_wakeup(&amp;pdev-&gt;dev, 1);
+			device_set_wakeup_capable(&amp;pdev-&gt;dev, 1);
 		}
 	}
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 65a9609f4ad6..5cf5f1eca4f4 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -593,12 +593,10 @@ static int ohci_run (struct ohci_hcd *ohci)
 	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
 	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
 	 * If the bus glue detected wakeup capability then it should
-	 * already be enabled.  Either way, if wakeup should be enabled
-	 * but isn't, we'll enable it now.
+	 * already be enabled; if so we'll just enable it again.
 	 */
-	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0
-			&amp;&amp; !device_can_wakeup(hcd-&gt;self.controller))
-		device_init_wakeup(hcd-&gt;self.controller, 1);
+	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0)
+		device_set_wakeup_capable(hcd-&gt;self.controller, 1);
 
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
 	case OHCI_USB_OPER:</pre><hr><pre>commit ddeac4e75f2527a340f9dc655bde49bb2429b39b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 15 17:03:33 2009 -0500

    USB: fix toggle mismatch in disable_endpoint paths
    
    This patch (as1200) finishes some fixes that were left incomplete by
    an earlier patch.
    
    Although nobody has addressed this issue in the past, it turns out
    that we need to distinguish between two different modes of disabling
    and enabling endpoints.  In one mode only the data structures in
    usbcore are affected, and in the other mode the host controller and
    device hardware states are affected as well.
    
    The earlier patch added an extra argument to the routines in the
    enable_endpoint pathways to reflect this difference.  This patch adds
    corresponding arguments to the disable_endpoint pathways.  Without
    this change, the endpoint toggle state can get out of sync between
    the host and the device.  The exact mechanism depends on the details
    of the host controller (whether or not it stores its own copy of the
    toggle values).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dan Streetman &lt;ddstreet@ieee.org&gt;
    Tested-by: Dan Streetman &lt;ddstreet@ieee.org&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 98760553bc95..d0a21a5f8201 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -284,7 +284,7 @@ static int usb_unbind_interface(struct device *dev)
 	 * supports "soft" unbinding.
 	 */
 	if (!driver-&gt;soft_unbind)
-		usb_disable_interface(udev, intf);
+		usb_disable_interface(udev, intf, false);
 
 	driver-&gt;disconnect(intf);
 	usb_cancel_queued_reset(intf);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 94d5ee263c20..cd50d86029e7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2382,8 +2382,8 @@ static int hub_port_debounce(struct usb_hub *hub, int port1)
 
 void usb_ep0_reinit(struct usb_device *udev)
 {
-	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
-	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
+	usb_disable_endpoint(udev, 0 + USB_DIR_IN, true);
+	usb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);
 	usb_enable_endpoint(udev, &amp;udev-&gt;ep0, true);
 }
 EXPORT_SYMBOL_GPL(usb_ep0_reinit);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index de51667dd64d..31fb204f44c6 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1039,14 +1039,15 @@ static void remove_intf_ep_devs(struct usb_interface *intf)
  * @dev: the device whose endpoint is being disabled
  * @epaddr: the endpoint's address.  Endpoint number for output,
  *	endpoint number + USB_DIR_IN for input
+ * @reset_hardware: flag to erase any endpoint state stored in the
+ *	controller hardware
  *
- * Deallocates hcd/hardware state for this endpoint ... and nukes all
- * pending urbs.
- *
- * If the HCD hasn't registered a disable() function, this sets the
- * endpoint's maxpacket size to 0 to prevent further submissions.
+ * Disables the endpoint for URB submission and nukes all pending URBs.
+ * If @reset_hardware is set then also deallocates hcd/hardware state
+ * for the endpoint.
  */
-void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
+void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
+		bool reset_hardware)
 {
 	unsigned int epnum = epaddr &amp; USB_ENDPOINT_NUMBER_MASK;
 	struct usb_host_endpoint *ep;
@@ -1056,15 +1057,18 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 
 	if (usb_endpoint_out(epaddr)) {
 		ep = dev-&gt;ep_out[epnum];
-		dev-&gt;ep_out[epnum] = NULL;
+		if (reset_hardware)
+			dev-&gt;ep_out[epnum] = NULL;
 	} else {
 		ep = dev-&gt;ep_in[epnum];
-		dev-&gt;ep_in[epnum] = NULL;
+		if (reset_hardware)
+			dev-&gt;ep_in[epnum] = NULL;
 	}
 	if (ep) {
 		ep-&gt;enabled = 0;
 		usb_hcd_flush_endpoint(dev, ep);
-		usb_hcd_disable_endpoint(dev, ep);
+		if (reset_hardware)
+			usb_hcd_disable_endpoint(dev, ep);
 	}
 }
 
@@ -1072,17 +1076,21 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
  * usb_disable_interface -- Disable all endpoints for an interface
  * @dev: the device whose interface is being disabled
  * @intf: pointer to the interface descriptor
+ * @reset_hardware: flag to erase any endpoint state stored in the
+ *	controller hardware
  *
  * Disables all the endpoints for the interface's current altsetting.
  */
-void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf)
+void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,
+		bool reset_hardware)
 {
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int i;
 
 	for (i = 0; i &lt; alt-&gt;desc.bNumEndpoints; ++i) {
 		usb_disable_endpoint(dev,
-				alt-&gt;endpoint[i].desc.bEndpointAddress);
+				alt-&gt;endpoint[i].desc.bEndpointAddress,
+				reset_hardware);
 	}
 }
 
@@ -1103,8 +1111,8 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 	dev_dbg(&amp;dev-&gt;dev, "%s nuking %s URBs\n", __func__,
 		skip_ep0 ? "non-ep0" : "all");
 	for (i = skip_ep0; i &lt; 16; ++i) {
-		usb_disable_endpoint(dev, i);
-		usb_disable_endpoint(dev, i + USB_DIR_IN);
+		usb_disable_endpoint(dev, i, true);
+		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
 	}
 	dev-&gt;toggle[0] = dev-&gt;toggle[1] = 0;
 
@@ -1274,7 +1282,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 		remove_intf_ep_devs(iface);
 		usb_remove_sysfs_intf_files(iface);
 	}
-	usb_disable_interface(dev, iface);
+	usb_disable_interface(dev, iface, true);
 
 	iface-&gt;cur_altsetting = alt;
 
@@ -1353,8 +1361,8 @@ int usb_reset_configuration(struct usb_device *dev)
 	 */
 
 	for (i = 1; i &lt; 16; ++i) {
-		usb_disable_endpoint(dev, i);
-		usb_disable_endpoint(dev, i + USB_DIR_IN);
+		usb_disable_endpoint(dev, i, true);
+		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
 	}
 
 	config = dev-&gt;actconfig;
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 386177867a8a..9d0f33fe8719 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -15,9 +15,10 @@ extern void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_host_endpoint *ep, bool reset_toggle);
 extern void usb_enable_interface(struct usb_device *dev,
 		struct usb_interface *intf, bool reset_toggles);
-extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
+extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
+		bool reset_hardware);
 extern void usb_disable_interface(struct usb_device *dev,
-		struct usb_interface *intf);
+		struct usb_interface *intf, bool reset_hardware);
 extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);</pre><hr><pre>commit bebd590ca27e80ffe3129ab4f0a3124f0a340f43
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 16 14:06:58 2008 -0500

    PCI: fix incorrect error return in pci_enable_wake
    
    This patch (as1186) fixes a minor mistake in pci_enable_wake().  When
    the routine is asked to disable remote wakeup, it should not return an
    error merely because the device is not allowed to do wakeups!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d4d71fae6233..1fb7cff4cdae 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1091,7 +1091,7 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	int error = 0;
 	bool pme_done = false;
 
-	if (!device_may_wakeup(&amp;dev-&gt;dev))
+	if (enable &amp;&amp; !device_may_wakeup(&amp;dev-&gt;dev))
 		return -EINVAL;
 
 	/*</pre><hr><pre>commit 2caf7fcdb8532045680f06b67b9e63f0c9613aaa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 31 11:31:33 2008 -0500

    USB: re-enable interface after driver unbinds
    
    This patch (as1197) fixes an error introduced recently.  Since a
    significant number of devices can't handle Set-Interface requests, we
    no longer call usb_set_interface() when a driver unbinds from an
    interface, provided the interface is already in altsetting 0.  However
    the interface still does get disabled, and the call to
    usb_set_interface() was the only thing re-enabling it.  Since the
    interface doesn't get re-enabled, further attempts to use it fail.
    
    So the patch adds a call to usb_enable_interface() when a driver
    unbinds and the interface is in altsetting 0.  For this to work
    right, the interface's endpoints have to be re-enabled but their
    toggles have to be left alone.  Therefore an additional argument is
    added to usb_enable_endpoint() and usb_enable_interface(), a flag
    indicating whether or not the endpoint toggles should be reset.
    
    This is a forward-ported version of a patch which fixes Bugzilla
    #12301.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Roka &lt;roka@dawid.hu&gt;
    Reported-by: Erik Ekman &lt;erik@kryo.se&gt;
    Tested-by: Erik Ekman &lt;erik@kryo.se&gt;
    Tested-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 41c06025506e..98760553bc95 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -295,9 +295,12 @@ static int usb_unbind_interface(struct device *dev)
 	 * altsetting means creating new endpoint device entries).
 	 * When either of these happens, defer the Set-Interface.
 	 */
-	if (intf-&gt;cur_altsetting-&gt;desc.bAlternateSetting == 0)
-		;	/* Already in altsetting 0 so skip Set-Interface */
-	else if (!error &amp;&amp; intf-&gt;dev.power.status == DPM_ON)
+	if (intf-&gt;cur_altsetting-&gt;desc.bAlternateSetting == 0) {
+		/* Already in altsetting 0 so skip Set-Interface.
+		 * Just re-enable it without affecting the endpoint toggles.
+		 */
+		usb_enable_interface(udev, intf, false);
+	} else if (!error &amp;&amp; intf-&gt;dev.power.status == DPM_ON)
 		usb_set_interface(udev, intf-&gt;altsetting[0].
 				desc.bInterfaceNumber, 0);
 	else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 756b8d9993fc..d5d0e40b1e2d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2384,7 +2384,7 @@ void usb_ep0_reinit(struct usb_device *udev)
 {
 	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
 	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-	usb_enable_endpoint(udev, &amp;udev-&gt;ep0);
+	usb_enable_endpoint(udev, &amp;udev-&gt;ep0, true);
 }
 EXPORT_SYMBOL_GPL(usb_ep0_reinit);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5589686981f1..de51667dd64d 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1143,22 +1143,26 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
  * usb_enable_endpoint - Enable an endpoint for USB communications
  * @dev: the device whose interface is being enabled
  * @ep: the endpoint
+ * @reset_toggle: flag to set the endpoint's toggle back to 0
  *
- * Resets the endpoint toggle, and sets dev-&gt;ep_{in,out} pointers.
+ * Resets the endpoint toggle if asked, and sets dev-&gt;ep_{in,out} pointers.
  * For control endpoints, both the input and output sides are handled.
  */
-void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
+void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,
+		bool reset_toggle)
 {
 	int epnum = usb_endpoint_num(&amp;ep-&gt;desc);
 	int is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	int is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
 
 	if (is_out || is_control) {
-		usb_settoggle(dev, epnum, 1, 0);
+		if (reset_toggle)
+			usb_settoggle(dev, epnum, 1, 0);
 		dev-&gt;ep_out[epnum] = ep;
 	}
 	if (!is_out || is_control) {
-		usb_settoggle(dev, epnum, 0, 0);
+		if (reset_toggle)
+			usb_settoggle(dev, epnum, 0, 0);
 		dev-&gt;ep_in[epnum] = ep;
 	}
 	ep-&gt;enabled = 1;
@@ -1168,17 +1172,18 @@ void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
  * usb_enable_interface - Enable all the endpoints for an interface
  * @dev: the device whose interface is being enabled
  * @intf: pointer to the interface descriptor
+ * @reset_toggles: flag to set the endpoints' toggles back to 0
  *
  * Enables all the endpoints for the interface's current altsetting.
  */
-static void usb_enable_interface(struct usb_device *dev,
-				 struct usb_interface *intf)
+void usb_enable_interface(struct usb_device *dev,
+		struct usb_interface *intf, bool reset_toggles)
 {
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int i;
 
 	for (i = 0; i &lt; alt-&gt;desc.bNumEndpoints; ++i)
-		usb_enable_endpoint(dev, &amp;alt-&gt;endpoint[i]);
+		usb_enable_endpoint(dev, &amp;alt-&gt;endpoint[i], reset_toggles);
 }
 
 /**
@@ -1303,7 +1308,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * during the SETUP stage - hence EP0 toggles are "don't care" here.
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
-	usb_enable_interface(dev, iface);
+	usb_enable_interface(dev, iface, true);
 	if (device_is_registered(&amp;iface-&gt;dev)) {
 		usb_create_sysfs_intf_files(iface);
 		create_intf_ep_devs(iface);
@@ -1382,7 +1387,7 @@ int usb_reset_configuration(struct usb_device *dev)
 			usb_remove_sysfs_intf_files(intf);
 		}
 		intf-&gt;cur_altsetting = alt;
-		usb_enable_interface(dev, intf);
+		usb_enable_interface(dev, intf, true);
 		if (device_is_registered(&amp;intf-&gt;dev)) {
 			usb_create_sysfs_intf_files(intf);
 			create_intf_ep_devs(intf);
@@ -1685,7 +1690,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 			alt = &amp;intf-&gt;altsetting[0];
 
 		intf-&gt;cur_altsetting = alt;
-		usb_enable_interface(dev, intf);
+		usb_enable_interface(dev, intf, true);
 		intf-&gt;dev.parent = &amp;dev-&gt;dev;
 		intf-&gt;dev.driver = NULL;
 		intf-&gt;dev.bus = &amp;usb_bus_type;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index c0821564a3fe..dcfc072630c1 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -362,7 +362,7 @@ struct usb_device *usb_alloc_dev(struct usb_device *parent,
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
-	usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
+	usb_enable_endpoint(dev, &amp;dev-&gt;ep0, true);
 	dev-&gt;can_submit = 1;
 
 	/* Save readable and stable topology id, distinguishing devices
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 381eae90c3b7..386177867a8a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -12,7 +12,9 @@ extern int usb_create_ep_devs(struct device *parent,
 extern void usb_remove_ep_devs(struct usb_host_endpoint *endpoint);
 
 extern void usb_enable_endpoint(struct usb_device *dev,
-		struct usb_host_endpoint *ep);
+		struct usb_host_endpoint *ep, bool reset_toggle);
+extern void usb_enable_interface(struct usb_device *dev,
+		struct usb_interface *intf, bool reset_toggles);
 extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface(struct usb_device *dev,
 		struct usb_interface *intf);</pre><hr><pre>commit df718962bf91c7bd345060aadaa24b03f6140b07
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 19 10:27:56 2008 -0500

    USB: cancel pending Set-Config requests if userspace gets there first
    
    This patch (as1195) eliminates a potential problem identified by
    Oliver Neukum.  When a driver queues an asynchronous Set-Config
    request using usb_driver_set_configuration(), the request should be
    cancelled if userspace changes the configuration first.  The patch
    introduces a linked list of pending async Set-Config requests, and
    uses it to invalidate the requests for a particular device whenever
    that device's configuration is set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 7943901c641c..5589686981f1 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -18,6 +18,8 @@
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
 
+static void cancel_async_set_config(struct usb_device *udev);
+
 struct api_context {
 	struct completion	done;
 	int			status;
@@ -1636,6 +1638,9 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device(dev, 1);	/* Skip ep0 */
 
+	/* Get rid of pending async Set-Config requests for this device */
+	cancel_async_set_config(dev);
+
 	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
 			      NULL, 0, USB_CTRL_SET_TIMEOUT);
@@ -1725,10 +1730,14 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	return 0;
 }
 
+static LIST_HEAD(set_config_list);
+static DEFINE_SPINLOCK(set_config_lock);
+
 struct set_config_request {
 	struct usb_device	*udev;
 	int			config;
 	struct work_struct	work;
+	struct list_head	node;
 };
 
 /* Worker routine for usb_driver_set_configuration() */
@@ -1736,14 +1745,35 @@ static void driver_set_config_work(struct work_struct *work)
 {
 	struct set_config_request *req =
 		container_of(work, struct set_config_request, work);
+	struct usb_device *udev = req-&gt;udev;
 
-	usb_lock_device(req-&gt;udev);
-	usb_set_configuration(req-&gt;udev, req-&gt;config);
-	usb_unlock_device(req-&gt;udev);
-	usb_put_dev(req-&gt;udev);
+	usb_lock_device(udev);
+	spin_lock(&amp;set_config_lock);
+	list_del(&amp;req-&gt;node);
+	spin_unlock(&amp;set_config_lock);
+
+	if (req-&gt;config &gt;= -1)		/* Is req still valid? */
+		usb_set_configuration(udev, req-&gt;config);
+	usb_unlock_device(udev);
+	usb_put_dev(udev);
 	kfree(req);
 }
 
+/* Cancel pending Set-Config requests for a device whose configuration
+ * was just changed
+ */
+static void cancel_async_set_config(struct usb_device *udev)
+{
+	struct set_config_request *req;
+
+	spin_lock(&amp;set_config_lock);
+	list_for_each_entry(req, &amp;set_config_list, node) {
+		if (req-&gt;udev == udev)
+			req-&gt;config = -999;	/* Mark as cancelled */
+	}
+	spin_unlock(&amp;set_config_lock);
+}
+
 /**
  * usb_driver_set_configuration - Provide a way for drivers to change device configurations
  * @udev: the device whose configuration is being updated
@@ -1775,6 +1805,10 @@ int usb_driver_set_configuration(struct usb_device *udev, int config)
 	req-&gt;config = config;
 	INIT_WORK(&amp;req-&gt;work, driver_set_config_work);
 
+	spin_lock(&amp;set_config_lock);
+	list_add(&amp;req-&gt;node, &amp;set_config_list);
+	spin_unlock(&amp;set_config_lock);
+
 	usb_get_dev(udev);
 	schedule_work(&amp;req-&gt;work);
 	return 0;</pre><hr><pre>commit 6fd9086a518d4f14213a32fe6c9ac17fabebbc1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 17 17:20:38 2008 -0500

    USB: automatically enable wakeup for PCI host controllers
    
    This patch (as1193b) enables wakeup during initialization for all PCI
    host controllers, and it removes some code (and comments!) that are no
    longer needed now that the PCI core automatically initializes wakeup
    settings for all new devices.
    
    The idea is that the bus should initialize wakeup, and the bus glue
    or controller driver should enable it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 99432785f438..507741ed4482 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -128,6 +128,7 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	}
 
 	pci_set_master(dev);
+	device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 
 	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6af47a0937b8..bdc6e86e1f8b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -219,15 +219,19 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &amp;ehci-&gt;sbrn);
 
-	/* Workaround current PCI init glitch:  wakeup bits aren't
-	 * being set from PCI PM capability.
+	/* Keep this around for a while just in case some EHCI
+	 * implementation uses legacy PCI PM support.  This test
+	 * can be removed on 17 Dec 2009 if the dev_warn() hasn't
+	 * been triggered by then.
 	 */
 	if (!device_can_wakeup(&amp;pdev-&gt;dev)) {
 		u16	port_wake;
 
 		pci_read_config_word(pdev, 0x62, &amp;port_wake);
-		if (port_wake &amp; 0x0001)
+		if (port_wake &amp; 0x0001) {
+			dev_warn(&amp;pdev-&gt;dev, "Enabling legacy PCI PM\n");
 			device_init_wakeup(&amp;pdev-&gt;dev, 1);
+		}
 	}
 
 #ifdef	CONFIG_USB_SUSPEND
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8aa3f4556a32..65a9609f4ad6 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -589,13 +589,15 @@ static int ohci_run (struct ohci_hcd *ohci)
 		/* also: power/overcurrent flags in roothub.a */
 	}
 
-	/* Reset USB nearly "by the book".  RemoteWakeupConnected was
-	 * saved if boot firmware (BIOS/SMM/...) told us it's connected,
-	 * or if bus glue did the same (e.g. for PCI add-in cards with
-	 * PCI PM support).
+	/* Reset USB nearly "by the book".  RemoteWakeupConnected has
+	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
+	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
+	 * If the bus glue detected wakeup capability then it should
+	 * already be enabled.  Either way, if wakeup should be enabled
+	 * but isn't, we'll enable it now.
 	 */
 	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0
-			&amp;&amp; !device_may_wakeup(hcd-&gt;self.controller))
+			&amp;&amp; !device_can_wakeup(hcd-&gt;self.controller))
 		device_init_wakeup(hcd-&gt;self.controller, 1);
 
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 8380cc2e961a..8b28ae7865ba 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -355,9 +355,9 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 		/* RWC may not be set for add-in PCI cards, since boot
 		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities (once the PCI layer is fixed).
+		 * PM wakeup capabilities.
 		 */
-		if (device_may_wakeup(&amp;pdev-&gt;dev))
+		if (device_can_wakeup(&amp;pdev-&gt;dev))
 			ohci-&gt;hc_control |= OHCI_CTRL_RWC;
 	}
 #endif /* CONFIG_PM */</pre><hr><pre>commit a0d4922da2e4ccb0973095d8d29f36f6b1b5f703
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 17 15:06:03 2008 -0500

    USB: fix up suspend and resume for PCI host controllers
    
    This patch (as1192) rearranges the USB PCI host controller suspend and
    resume and resume routines:
    
            Use pci_wake_from_d3() for enabling and disabling wakeup,
            instead of pci_enable_wake().
    
            Carry out the actual state change while interrupts are
            disabled.
    
            Change the order of the preparations to agree with the
            general recommendation for PCI devices, instead of
            messing around with the wakeup settings while the device
            is in D3.
    
                    In .suspend:
                            Call the underlying driver to disable IRQ
                                    generation;
                            pci_wake_from_d3(device_may_wakeup());
                            pci_disable_device();
    
                    In .suspend_late:
                            pci_save_state();
                            pci_set_power_state(D3hot);
                            (for PPC_PMAC) Disable ASIC clocks
    
                    In .resume_early:
                            (for PPC_PMAC) Enable ASIC clocks
                            pci_set_power_state(D0);
                            pci_restore_state();
    
                    In .resume:
                            pci_enable_device();
                            pci_set_master();
                            pci_wake_from_d3(0);
                            Call the underlying driver to reenable IRQ
                                    generation
    
            Add the necessary .suspend_late and .resume_early method
            pointers to the PCI host controller drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 5b87ae7f0a6a..99432785f438 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -191,17 +191,15 @@ EXPORT_SYMBOL_GPL(usb_hcd_pci_remove);
 /**
  * usb_hcd_pci_suspend - power management suspend of a PCI-based HCD
  * @dev: USB Host Controller being suspended
- * @message: semantics in flux
+ * @message: Power Management message describing this state transition
  *
- * Store this function in the HCD's struct pci_driver as suspend().
+ * Store this function in the HCD's struct pci_driver as .suspend.
  */
 int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 {
-	struct usb_hcd		*hcd;
+	struct usb_hcd		*hcd = pci_get_drvdata(dev);
 	int			retval = 0;
-	int			has_pci_pm;
-
-	hcd = pci_get_drvdata(dev);
+	int			wake, w;
 
 	/* Root hub suspend should have stopped all downstream traffic,
 	 * and all bus master traffic.  And done so for both the interface
@@ -212,8 +210,15 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 	 * otherwise the swsusp will save (and restore) garbage state.
 	 */
 	if (!(hcd-&gt;state == HC_STATE_SUSPENDED ||
-			hcd-&gt;state == HC_STATE_HALT))
-		return -EBUSY;
+			hcd-&gt;state == HC_STATE_HALT)) {
+		dev_warn(&amp;dev-&gt;dev, "Root hub is not suspended\n");
+		retval = -EBUSY;
+		goto done;
+	}
+
+	/* We might already be suspended (runtime PM -- not yet written) */
+	if (dev-&gt;current_state != PCI_D0)
+		goto done;
 
 	if (hcd-&gt;driver-&gt;pci_suspend) {
 		retval = hcd-&gt;driver-&gt;pci_suspend(hcd, message);
@@ -221,49 +226,60 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 		if (retval)
 			goto done;
 	}
-	synchronize_irq(dev-&gt;irq);
 
-	/* FIXME until the generic PM interfaces change a lot more, this
-	 * can't use PCI D1 and D2 states.  For example, the confusion
-	 * between messages and states will need to vanish, and messages
-	 * will need to provide a target system state again.
-	 *
-	 * It'll be important to learn characteristics of the target state,
-	 * especially on embedded hardware where the HCD will often be in
-	 * charge of an external VBUS power supply and one or more clocks.
-	 * Some target system states will leave them active; others won't.
-	 * (With PCI, that's often handled by platform BIOS code.)
-	 */
+	synchronize_irq(dev-&gt;irq);
 
-	/* even when the PCI layer rejects some of the PCI calls
-	 * below, HCs can try global suspend and reduce DMA traffic.
-	 * PM-sensitive HCDs may already have done this.
+	/* Don't fail on error to enable wakeup.  We rely on pci code
+	 * to reject requests the hardware can't implement, rather
+	 * than coding the same thing.
 	 */
-	has_pci_pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	wake = (hcd-&gt;state == HC_STATE_SUSPENDED &amp;&amp;
+			device_may_wakeup(&amp;dev-&gt;dev));
+	w = pci_wake_from_d3(dev, wake);
+	if (w &lt; 0)
+		wake = w;
+	dev_dbg(&amp;dev-&gt;dev, "wakeup: %d\n", wake);
 
 	/* Downstream ports from this root hub should already be quiesced, so
 	 * there will be no DMA activity.  Now we can shut down the upstream
 	 * link (except maybe for PME# resume signaling) and enter some PCI
 	 * low power state, if the hardware allows.
 	 */
-	if (hcd-&gt;state == HC_STATE_SUSPENDED) {
+	pci_disable_device(dev);
+ done:
+	return retval;
+}
+EXPORT_SYMBOL_GPL(usb_hcd_pci_suspend);
 
-		/* no DMA or IRQs except when HC is active */
-		if (dev-&gt;current_state == PCI_D0) {
-			pci_save_state(dev);
-			pci_disable_device(dev);
-		}
+/**
+ * usb_hcd_pci_suspend_late - suspend a PCI-based HCD after IRQs are disabled
+ * @dev: USB Host Controller being suspended
+ * @message: Power Management message describing this state transition
+ *
+ * Store this function in the HCD's struct pci_driver as .suspend_late.
+ */
+int usb_hcd_pci_suspend_late(struct pci_dev *dev, pm_message_t message)
+{
+	int			retval = 0;
+	int			has_pci_pm;
 
-		if (message.event == PM_EVENT_FREEZE ||
-				message.event == PM_EVENT_PRETHAW) {
-			dev_dbg(hcd-&gt;self.controller, "--&gt; no state change\n");
-			goto done;
-		}
+	/* We might already be suspended (runtime PM -- not yet written) */
+	if (dev-&gt;current_state != PCI_D0)
+		goto done;
 
-		if (!has_pci_pm) {
-			dev_dbg(hcd-&gt;self.controller, "--&gt; PCI D0/legacy\n");
-			goto done;
-		}
+	pci_save_state(dev);
+
+	/* Don't change state if we don't need to */
+	if (message.event == PM_EVENT_FREEZE ||
+			message.event == PM_EVENT_PRETHAW) {
+		dev_dbg(&amp;dev-&gt;dev, "--&gt; no state change\n");
+		goto done;
+	}
+
+	has_pci_pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	if (!has_pci_pm) {
+		dev_dbg(&amp;dev-&gt;dev, "--&gt; PCI D0 legacy\n");
+	} else {
 
 		/* NOTE:  dev-&gt;current_state becomes nonzero only here, and
 		 * only for devices that support PCI PM.  Also, exiting
@@ -273,35 +289,16 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 		retval = pci_set_power_state(dev, PCI_D3hot);
 		suspend_report_result(pci_set_power_state, retval);
 		if (retval == 0) {
-			int wake = device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev);
-
-			wake = wake &amp;&amp; device_may_wakeup(hcd-&gt;self.controller);
-
-			dev_dbg(hcd-&gt;self.controller, "--&gt; PCI D3%s\n",
-					wake ? "/wakeup" : "");
-
-			/* Ignore these return values.  We rely on pci code to
-			 * reject requests the hardware can't implement, rather
-			 * than coding the same thing.
-			 */
-			(void) pci_enable_wake(dev, PCI_D3hot, wake);
-			(void) pci_enable_wake(dev, PCI_D3cold, wake);
+			dev_dbg(&amp;dev-&gt;dev, "--&gt; PCI D3\n");
 		} else {
 			dev_dbg(&amp;dev-&gt;dev, "PCI D3 suspend fail, %d\n",
 					retval);
-			(void) usb_hcd_pci_resume(dev);
+			pci_restore_state(dev);
 		}
-
-	} else if (hcd-&gt;state != HC_STATE_HALT) {
-		dev_dbg(hcd-&gt;self.controller, "hcd state %d; not suspended\n",
-			hcd-&gt;state);
-		WARN_ON(1);
-		retval = -EINVAL;
 	}
 
-done:
-	if (retval == 0) {
 #ifdef CONFIG_PPC_PMAC
+	if (retval == 0) {
 		/* Disable ASIC clocks for USB */
 		if (machine_is(powermac)) {
 			struct device_node	*of_node;
@@ -311,30 +308,24 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 				pmac_call_feature(PMAC_FTR_USB_ENABLE,
 							of_node, 0, 0);
 		}
-#endif
 	}
+#endif
 
+ done:
 	return retval;
 }
-EXPORT_SYMBOL_GPL(usb_hcd_pci_suspend);
+EXPORT_SYMBOL_GPL(usb_hcd_pci_suspend_late);
 
 /**
- * usb_hcd_pci_resume - power management resume of a PCI-based HCD
+ * usb_hcd_pci_resume_early - resume a PCI-based HCD before IRQs are enabled
  * @dev: USB Host Controller being resumed
  *
- * Store this function in the HCD's struct pci_driver as resume().
+ * Store this function in the HCD's struct pci_driver as .resume_early.
  */
-int usb_hcd_pci_resume(struct pci_dev *dev)
+int usb_hcd_pci_resume_early(struct pci_dev *dev)
 {
-	struct usb_hcd		*hcd;
-	int			retval;
-
-	hcd = pci_get_drvdata(dev);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		dev_dbg(hcd-&gt;self.controller,
-				"can't resume, not suspended!\n");
-		return 0;
-	}
+	int		retval = 0;
+	pci_power_t	state = dev-&gt;current_state;
 
 #ifdef CONFIG_PPC_PMAC
 	/* Reenable ASIC clocks for USB */
@@ -352,7 +343,7 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 	 * calls "standby", "suspend to RAM", and so on).  There are also
 	 * dirty cases when swsusp fakes a suspend in "shutdown" mode.
 	 */
-	if (dev-&gt;current_state != PCI_D0) {
+	if (state != PCI_D0) {
 #ifdef	DEBUG
 		int	pci_pm;
 		u16	pmcr;
@@ -364,8 +355,7 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 			/* Clean case:  power to USB and to HC registers was
 			 * maintained; remote wakeup is easy.
 			 */
-			dev_dbg(hcd-&gt;self.controller, "resume from PCI D%d\n",
-					pmcr);
+			dev_dbg(&amp;dev-&gt;dev, "resume from PCI D%d\n", pmcr);
 		} else {
 			/* Clean:  HC lost Vcc power, D0 uninitialized
 			 *   + Vaux may have preserved port and transceiver
@@ -376,32 +366,55 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 			 *   + after BIOS init
 			 *   + after Linux init (HCD statically linked)
 			 */
-			dev_dbg(hcd-&gt;self.controller,
-				"PCI D0, from previous PCI D%d\n",
-				dev-&gt;current_state);
+			dev_dbg(&amp;dev-&gt;dev, "resume from previous PCI D%d\n",
+					state);
 		}
 #endif
-		/* yes, ignore these results too... */
-		(void) pci_enable_wake(dev, dev-&gt;current_state, 0);
-		(void) pci_enable_wake(dev, PCI_D3cold, 0);
+
+		retval = pci_set_power_state(dev, PCI_D0);
 	} else {
 		/* Same basic cases: clean (powered/not), dirty */
-		dev_dbg(hcd-&gt;self.controller, "PCI legacy resume\n");
+		dev_dbg(&amp;dev-&gt;dev, "PCI legacy resume\n");
+	}
+
+	if (retval &lt; 0)
+		dev_err(&amp;dev-&gt;dev, "can't resume: %d\n", retval);
+	else
+		pci_restore_state(dev);
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(usb_hcd_pci_resume_early);
+
+/**
+ * usb_hcd_pci_resume - power management resume of a PCI-based HCD
+ * @dev: USB Host Controller being resumed
+ *
+ * Store this function in the HCD's struct pci_driver as .resume.
+ */
+int usb_hcd_pci_resume(struct pci_dev *dev)
+{
+	struct usb_hcd		*hcd;
+	int			retval;
+
+	hcd = pci_get_drvdata(dev);
+	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+		dev_dbg(hcd-&gt;self.controller,
+				"can't resume, not suspended!\n");
+		return 0;
 	}
 
-	/* NOTE:  the PCI API itself is asymmetric here.  We don't need to
-	 * pci_set_power_state(PCI_D0) since that's part of re-enabling;
-	 * but that won't re-enable bus mastering.  Yet pci_disable_device()
-	 * explicitly disables bus mastering...
-	 */
 	retval = pci_enable_device(dev);
 	if (retval &lt; 0) {
-		dev_err(hcd-&gt;self.controller,
-			"can't re-enable after resume, %d!\n", retval);
+		dev_err(&amp;dev-&gt;dev, "can't re-enable after resume, %d!\n",
+				retval);
 		return retval;
 	}
+
 	pci_set_master(dev);
-	pci_restore_state(dev);
+
+	/* yes, ignore this result too... */
+	(void) pci_wake_from_d3(dev, 0);
 
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
@@ -413,7 +426,6 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 			usb_hc_died(hcd);
 		}
 	}
-
 	return retval;
 }
 EXPORT_SYMBOL_GPL(usb_hcd_pci_resume);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index aa5da82d9071..572d2cf46e8d 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -256,7 +256,9 @@ extern int usb_hcd_pci_probe(struct pci_dev *dev,
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 
 #ifdef CONFIG_PM
-extern int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t state);
+extern int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t msg);
+extern int usb_hcd_pci_suspend_late(struct pci_dev *dev, pm_message_t msg);
+extern int usb_hcd_pci_resume_early(struct pci_dev *dev);
 extern int usb_hcd_pci_resume(struct pci_dev *dev);
 #endif /* CONFIG_PM */
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 36864f958444..6af47a0937b8 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -428,6 +428,8 @@ static struct pci_driver ehci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
+	.suspend_late =	usb_hcd_pci_suspend_late,
+	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 	.shutdown = 	usb_hcd_pci_shutdown,
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index a9c2ae36c7ad..8380cc2e961a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -487,6 +487,8 @@ static struct pci_driver ohci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
+	.suspend_late =	usb_hcd_pci_suspend_late,
+	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index cf5e4cf7ea42..4e221060f58c 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -942,6 +942,8 @@ static struct pci_driver uhci_pci_driver = {
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,
+	.suspend_late =	usb_hcd_pci_suspend_late,
+	.resume_early =	usb_hcd_pci_resume_early,
 	.resume =	usb_hcd_pci_resume,
 #endif	/* PM */
 };</pre><hr><pre>commit a81a81a25d3ecdab777abca87c5ddf484056103d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Dec 18 16:41:49 2008 -0500

    USB: storage: set CAPACITY_HEURISTICS flag for bad vendors
    
    This patch (as1194) makes usb-storage set the CAPACITY_HEURISTICS flag
    for all devices made by Nokia, Nikon, or Motorola.  These companies
    seem to include the READ CAPACITY bug in all of their devices.
    
    Since cell phones and digital cameras rely on flash storage, which
    always has an even number of sectors, setting CAPACITY_HEURISTICS
    shouldn't cause any problems.  Not even if the companies wise up and
    start making devices without the bug.
    
    A large number of unusual_devs entries are now unnecessary, so the
    patch removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 8d78084abf9f..2a42b862aa9f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -59,6 +59,13 @@
 #include "transport.h"
 #include "protocol.h"
 
+/* Vendor IDs for companies that seem to include the READ CAPACITY bug
+ * in all their devices
+ */
+#define VENDOR_ID_NOKIA		0x0421
+#define VENDOR_ID_NIKON		0x04b0
+#define VENDOR_ID_MOTOROLA	0x22b8
+
 /***********************************************************************
  * Host functions 
  ***********************************************************************/
@@ -142,6 +149,22 @@ static int slave_configure(struct scsi_device *sdev)
 	 * settings can't be overridden via the scsi devinfo mechanism. */
 	if (sdev-&gt;type == TYPE_DISK) {
 
+		/* Some vendors seem to put the READ CAPACITY bug into
+		 * all their devices -- primarily makers of cell phones
+		 * and digital cameras.  Since these devices always use
+		 * flash media and can be expected to have an even number
+		 * of sectors, we will always enable the CAPACITY_HEURISTICS
+		 * flag unless told otherwise. */
+		switch (le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idVendor)) {
+		case VENDOR_ID_NOKIA:
+		case VENDOR_ID_NIKON:
+		case VENDOR_ID_MOTOROLA:
+			if (!(us-&gt;fflags &amp; (US_FL_FIX_CAPACITY |
+					US_FL_CAPACITY_OK)))
+				us-&gt;fflags |= US_FL_CAPACITY_HEURISTICS;
+			break;
+		}
+
 		/* Disk-type devices use MODE SENSE(6) if the protocol
 		 * (SubClass) is Transparent SCSI, otherwise they use
 		 * MODE SENSE(10). */
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 035bbc5d8231..a7f9513fa19d 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -174,42 +174,6 @@ UNUSUAL_DEV(  0x0421, 0x0019, 0x0592, 0x0592,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_MAX_SECTORS_64 ),
 
-/* Reported by Filip Joelsson &lt;filip@blueturtle.nu&gt; */
-UNUSUAL_DEV(  0x0421, 0x005d, 0x0001, 0x0600,
-		"Nokia",
-		"Nokia 3110c",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Reported by Ozan Sener &lt;themgzzy@gmail.com&gt; */
-UNUSUAL_DEV(  0x0421, 0x0060, 0x0551, 0x0551,
-		"Nokia",
-		"3500c",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Reported by CSECSY Laszlo &lt;boobaa@frugalware.org&gt; */
-UNUSUAL_DEV(  0x0421, 0x0063, 0x0001, 0x0601,
-		"Nokia",
-		"Nokia 3109c",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Patch for Nokia 5310 capacity */
-UNUSUAL_DEV(  0x0421, 0x006a, 0x0000, 0x0701,
-		"Nokia",
-		"5310",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Submitted by Ricky Wong Yung Fei &lt;evilbladewarrior@gmail.com&gt; */
-/* Nokia 7610 Supernova - Too many sectors reported in usb storage mode */
-UNUSUAL_DEV(  0x0421, 0x00f5, 0x0000, 0x0470,
-		"Nokia",
-		"7610 Supernova",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
 /* Reported by Mario Rettig &lt;mariorettig@web.de&gt; */
 UNUSUAL_DEV(  0x0421, 0x042e, 0x0100, 0x0100,
 		"Nokia",
@@ -275,27 +239,6 @@ UNUSUAL_DEV(  0x0421, 0x0495, 0x0370, 0x0370,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_MAX_SECTORS_64 ),
 
-/* Reported by Cedric Godin &lt;cedric@belbone.be&gt; */
-UNUSUAL_DEV(  0x0421, 0x04b9, 0x0500, 0x0551,
-		"Nokia",
-		"5300",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Reported by Paulo Fessel &lt;pfessel@gmail.com&gt; */
-UNUSUAL_DEV(  0x0421, 0x04bd, 0x0000, 0x9999,
-		"Nokia",
-		"5200",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
-/* Reported by Richard Nauber &lt;RichardNauber@web.de&gt; */
-UNUSUAL_DEV(  0x0421, 0x04fa, 0x0550, 0x0660,
-		"Nokia",
-		"6300",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
 /* Reported by Olaf Hering &lt;olh@suse.de&gt; from novell bug #105878 */
 UNUSUAL_DEV(  0x0424, 0x0fdc, 0x0210, 0x0210,
 		"SMSC",
@@ -425,83 +368,6 @@ UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
 		US_SC_DEVICE, US_PR_DEVICE,NULL,
 		US_FL_NOT_LOCKABLE ),
 
-/* Reported by Stefan de Konink &lt;skinkie@xs4all.nl&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0401, 0x0200, 0x0200,
-		"NIKON",
-		"NIKON DSC D100",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Tobias Kunze Briseno &lt;t-linux@fictive.com&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0403, 0x0200, 0x0200,
-		"NIKON",
-		"NIKON DSC D2H",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Milinevsky Dmitry &lt;niam.niam@gmail.com&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0409, 0x0100, 0x0100,
-		"NIKON",
-		"NIKON DSC D50",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Andreas Bockhold &lt;andreas@bockionline.de&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
-		"NIKON",
-		"NIKON DSC D70",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Jamie Kitson &lt;jamie@staberinde.fsnet.co.uk&gt; */
-UNUSUAL_DEV(  0x04b0, 0x040d, 0x0100, 0x0100,
-		"NIKON",
-		"NIKON DSC D70s",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Graber and Mike Pagano &lt;mpagano-kernel@mpagano.com&gt; */
-UNUSUAL_DEV(  0x04b0, 0x040f, 0x0100, 0x0200,
-		"NIKON",
-		"NIKON DSC D200",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Emil Larsson &lt;emil@swip.net&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0411, 0x0100, 0x0111,
-		"NIKON",
-		"NIKON DSC D80",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Ortwin Glueck &lt;odi@odi.ch&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0413, 0x0110, 0x0111,
-		"NIKON",
-		"NIKON DSC D40",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Paul Check &lt;paul@openstreet.com&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0415, 0x0100, 0x0100,
-		"NIKON",
-		"NIKON DSC D2Xs",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by Shan Destromp (shansan@gmail.com) */
-UNUSUAL_DEV(  0x04b0, 0x0417, 0x0100, 0x0100,
-		"NIKON",
-		"NIKON DSC D40X",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/* Reported by paul ready &lt;lxtwin@homecall.co.uk&gt; */
-UNUSUAL_DEV(  0x04b0, 0x0419, 0x0100, 0x0200,
-		"NIKON",
-		"NIKON DSC D300",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
 /* Reported by Doug Maxey (dwm@austin.ibm.com) */
 UNUSUAL_DEV(  0x04b3, 0x4001, 0x0110, 0x0110,
 		"IBM",
@@ -2184,27 +2050,6 @@ UNUSUAL_DEV(  0x22b8, 0x3010, 0x0001, 0x0001,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY | US_FL_IGNORE_RESIDUE ),
 
-/*
- * Patch by Pete Zaitcev &lt;zaitcev@redhat.com&gt;
- * Report by Mark Patton. Red Hat bz#208928.
- * Added support for rev 0x0002 (Motorola ROKR W5)
- * by Javier Smaldone &lt;javier@smaldone.com.ar&gt;
- */
-UNUSUAL_DEV(  0x22b8, 0x4810, 0x0001, 0x0002,
-		"Motorola",
-		"RAZR V3i/ROKR W5",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
-/*
- * Patch by Jost Diederichs &lt;jost@qdusa.com&gt;
- */
-UNUSUAL_DEV(0x22b8, 0x6410, 0x0001, 0x9999,
-		"Motorola Inc.",
-		"Motorola Phone (RAZRV3xx)",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY),
-
 /*
  * Patch by Constantin Baranov &lt;const@tltsu.ru&gt;
  * Report by Andreas Koenecke.</pre><hr><pre>commit c838ea4626d6e982489ff519f9ecf5e1649ca90b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 15 10:40:06 2008 -0500

    USB: storage: make the "quirks=" module parameter writable
    
    This patch (as1190) makes usb-storage's "quirks=" module parameter
    writable, so that users can add entries for their devices at runtime
    with no need to reboot or reload usb-storage.
    
    New codes are added for the SANE_SENSE, CAPACITY_HEURISTICS, and
    CAPACITY_OK flags.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 8eb6e35405cd..a58fc8b73398 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2396,14 +2396,21 @@ and is between 256 and 4096 characters. It is defined in the file
 			and Product ID values (4-digit hex numbers) and
 			Flags is a set of characters, each corresponding
 			to a common usb-storage quirk flag as follows:
+				a = SANE_SENSE (collect more than 18 bytes
+					of sense data);
 				c = FIX_CAPACITY (decrease the reported
 					device capacity by one sector);
+				h = CAPACITY_HEURISTICS (decrease the
+					reported device capacity by one
+					sector if the number is odd);
 				i = IGNORE_DEVICE (don't bind to this
 					device);
 				l = NOT_LOCKABLE (don't try to lock and
 					unlock ejectable media);
 				m = MAX_SECTORS_64 (don't transfer more
 					than 64 sectors = 32 KB at a time);
+				o = CAPACITY_OK (accept the capacity
+					reported by the device);
 				r = IGNORE_RESIDUE (the device reports
 					bogus residue values);
 				s = SINGLE_LUN (the device has only one
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 80e234bf4e50..4becf495ca2d 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -111,16 +111,10 @@ static unsigned int delay_use = 5;
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
-static char *quirks;
-module_param(quirks, charp, S_IRUGO);
+static char quirks[128];
+module_param_string(quirks, quirks, sizeof(quirks), S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(quirks, "supplemental list of device IDs and their quirks");
 
-struct quirks_entry {
-	u16	vid, pid;
-	u32	fflags;
-};
-static struct quirks_entry *quirks_list, *quirks_end;
-
 
 /*
  * The entries in this table correspond, line for line,
@@ -481,28 +475,80 @@ static int associate_dev(struct us_data *us, struct usb_interface *intf)
 	return 0;
 }
 
+/* Works only for digits and letters, but small and fast */
+#define TOLOWER(x) ((x) | 0x20)
+
 /* Adjust device flags based on the "quirks=" module parameter */
 static void adjust_quirks(struct us_data *us)
 {
-	u16 vid, pid;
-	struct quirks_entry *q;
-	unsigned int mask = (US_FL_FIX_CAPACITY | US_FL_IGNORE_DEVICE |
+	char *p;
+	u16 vid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idVendor);
+	u16 pid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idProduct);
+	unsigned f = 0;
+	unsigned int mask = (US_FL_SANE_SENSE | US_FL_FIX_CAPACITY |
+			US_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |
 			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
-			US_FL_IGNORE_RESIDUE | US_FL_SINGLE_LUN |
-			US_FL_NO_WP_DETECT);
-
-	vid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idVendor);
-	pid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idProduct);
-
-	for (q = quirks_list; q != quirks_end; ++q) {
-		if (q-&gt;vid == vid &amp;&amp; q-&gt;pid == pid) {
-			us-&gt;fflags = (us-&gt;fflags &amp; ~mask) | q-&gt;fflags;
-			dev_info(&amp;us-&gt;pusb_intf-&gt;dev, "Quirks match for "
-					"vid %04x pid %04x: %x\n",
-					vid, pid, q-&gt;fflags);
+			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
+			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT);
+
+	p = quirks;
+	while (*p) {
+		/* Each entry consists of VID:PID:flags */
+		if (vid == simple_strtoul(p, &amp;p, 16) &amp;&amp;
+				*p == ':' &amp;&amp;
+				pid == simple_strtoul(p+1, &amp;p, 16) &amp;&amp;
+				*p == ':')
 			break;
+
+		/* Move forward to the next entry */
+		while (*p) {
+			if (*p++ == ',')
+				break;
 		}
 	}
+	if (!*p)	/* No match */
+		return;
+
+	/* Collect the flags */
+	while (*++p &amp;&amp; *p != ',') {
+		switch (TOLOWER(*p)) {
+		case 'a':
+			f |= US_FL_SANE_SENSE;
+			break;
+		case 'c':
+			f |= US_FL_FIX_CAPACITY;
+			break;
+		case 'h':
+			f |= US_FL_CAPACITY_HEURISTICS;
+			break;
+		case 'i':
+			f |= US_FL_IGNORE_DEVICE;
+			break;
+		case 'l':
+			f |= US_FL_NOT_LOCKABLE;
+			break;
+		case 'm':
+			f |= US_FL_MAX_SECTORS_64;
+			break;
+		case 'o':
+			f |= US_FL_CAPACITY_OK;
+			break;
+		case 'r':
+			f |= US_FL_IGNORE_RESIDUE;
+			break;
+		case 's':
+			f |= US_FL_SINGLE_LUN;
+			break;
+		case 'w':
+			f |= US_FL_NO_WP_DETECT;
+			break;
+		/* Ignore unrecognized flag characters */
+		}
+	}
+	us-&gt;fflags = (us-&gt;fflags &amp; ~mask) | f;
+	dev_info(&amp;us-&gt;pusb_intf-&gt;dev, "Quirks match for "
+			"vid %04x pid %04x: %x\n",
+			vid, pid, f);
 }
 
 /* Find an unusual_dev descriptor (always succeeds in the current code) */
@@ -1092,88 +1138,11 @@ static struct usb_driver usb_storage_driver = {
 	.soft_unbind =	1,
 };
 
-/* Works only for digits and letters, but small and fast */
-#define TOLOWER(x) ((x) | 0x20)
-
-static void __init parse_quirks(void)
-{
-	int n, i;
-	char *p;
-
-	if (!quirks)
-		return;
-
-	/* Count the ':' characters to get 2 * the number of entries */
-	n = 0;
-	for (p = quirks; *p; ++p) {
-		if (*p == ':')
-			++n;
-	}
-	n /= 2;
-	if (n == 0)
-		return;		/* Don't allocate 0 bytes */
-
-	quirks_list = kmalloc(n * sizeof(*quirks_list), GFP_KERNEL);
-	if (!quirks_list)
-		return;
-
-	p = quirks;
-	quirks_end = quirks_list;
-	for (i = 0; i &lt; n &amp;&amp; *p; ++i) {
-		unsigned f = 0;
-
-		/* Each entry consists of VID:PID:flags */
-		quirks_end-&gt;vid = simple_strtoul(p, &amp;p, 16);
-		if (*p != ':')
-			goto skip_to_next;
-		quirks_end-&gt;pid = simple_strtoul(p+1, &amp;p, 16);
-		if (*p != ':')
-			goto skip_to_next;
-
-		while (*++p &amp;&amp; *p != ',') {
-			switch (TOLOWER(*p)) {
-			case 'c':
-				f |= US_FL_FIX_CAPACITY;
-				break;
-			case 'i':
-				f |= US_FL_IGNORE_DEVICE;
-				break;
-			case 'l':
-				f |= US_FL_NOT_LOCKABLE;
-				break;
-			case 'm':
-				f |= US_FL_MAX_SECTORS_64;
-				break;
-			case 'r':
-				f |= US_FL_IGNORE_RESIDUE;
-				break;
-			case 's':
-				f |= US_FL_SINGLE_LUN;
-				break;
-			case 'w':
-				f |= US_FL_NO_WP_DETECT;
-				break;
-			/* Ignore unrecognized flag characters */
-			}
-		}
-		quirks_end-&gt;fflags = f;
-		++quirks_end;
-
- skip_to_next:
-		/* Entries are separated by commas */
-		while (*p) {
-			if (*p++ == ',')
-				break;
-		}
-	} /* for (i = 0; ...) */
-}
-
 static int __init usb_stor_init(void)
 {
 	int retval;
 
 	printk(KERN_INFO "Initializing USB Mass Storage driver...\n");
-	parse_quirks();
 
 	/* register the driver, return usb_register return code if error */
 	retval = usb_register(&amp;usb_storage_driver);</pre><hr><pre>commit 25ff1c316f6a763f1eefe7f8984b2d8c03888432
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 15 12:43:41 2008 -0500

    USB: storage: add last-sector hacks
    
    This patch (as1189b) adds some hacks to usb-storage for dealing with
    the growing problems involving bad capacity values and last-sector
    accesses:
    
            A new flag, US_FL_CAPACITY_OK, is created to indicate that
            the device is known to report its capacity correctly.  An
            unusual_devs entry for Linux's own File-backed Storage Gadget
            is added with this flag set, since g_file_storage always
            reports the correct capacity and since the capacity need
            not be even (it is determined by the size of the backing
            file).
    
            An entry in unusual_devs.h which has only the CAPACITY_OK
            flag set shouldn't prejudice libusual, since the device will
            work perfectly well with either usb-storage or ub.  So a
            new macro, COMPLIANT_DEV, is added to let libusual know
            about these entries.
    
            When a last-sector access succeeds and the total number of
            sectors is odd (the unexpected case, in which guessing that
            the number is even might cause trouble), a WARN is triggered.
            The kerneloops.org project will collect these warnings,
            allowing us to add CAPACITY_OK flags for the devices in
            question before implementing the default-to-even heuristic.
            If users want to prevent the stack dump produced by the WARN,
            they can disable the hack by adding an unusual_devs entry
            for their device with the CAPACITY_OK flag.
    
            When a last-sector access fails three times in a row and
            neither the FIX_CAPACITY nor the CAPACITY_OK flag is set,
            we assume the last-sector bug is present.  We replace the
            existing status and sense data with values that will cause
            the SCSI core to fail the access immediately rather than
            retry indefinitely.  This should fix the difficulties
            people have been having with Nokia phones.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/libusual.c b/drivers/usb/storage/libusual.c
index d617e8ae6b00..f970b27ba308 100644
--- a/drivers/usb/storage/libusual.c
+++ b/drivers/usb/storage/libusual.c
@@ -46,6 +46,12 @@ static int usu_probe_thread(void *arg);
 { USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin,bcdDeviceMax), \
   .driver_info = (flags)|(USB_US_TYPE_STOR&lt;&lt;24) }
 
+#define COMPLIANT_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \
+		    vendorName, productName, useProtocol, useTransport, \
+		    initFunction, flags) \
+{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \
+  .driver_info = (flags) }
+
 #define USUAL_DEV(useProto, useTrans, useType) \
 { USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, useProto, useTrans), \
   .driver_info = ((useType)&lt;&lt;24) }
@@ -57,6 +63,7 @@ struct usb_device_id storage_usb_ids [] = {
 
 #undef USUAL_DEV
 #undef UNUSUAL_DEV
+#undef COMPLIANT_DEV
 
 MODULE_DEVICE_TABLE(usb, storage_usb_ids);
 EXPORT_SYMBOL_GPL(storage_usb_ids);
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e9d6c196a7ab..8d78084abf9f 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -208,6 +208,14 @@ static int slave_configure(struct scsi_device *sdev)
 		 * sector in a larger then 1 sector read, since the performance
 		 * impact is negible we set this flag for all USB disks */
 		sdev-&gt;last_sector_bug = 1;
+
+		/* Enable last-sector hacks for single-target devices using
+		 * the Bulk-only transport, unless we already know the
+		 * capacity will be decremented or is correct. */
+		if (!(us-&gt;fflags &amp; (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |
+					US_FL_SCM_MULT_TARG)) &amp;&amp;
+				us-&gt;protocol == US_PR_BULK)
+			us-&gt;use_last_sector_hacks = 1;
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 9cc30afd6d31..1d5438e6363b 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -57,6 +57,9 @@
 #include "scsiglue.h"
 #include "debug.h"
 
+#include &lt;linux/blkdev.h&gt;
+#include "../../scsi/sd.h"
+
 
 /***********************************************************************
  * Data transfer routines
@@ -511,6 +514,110 @@ int usb_stor_bulk_transfer_sg(struct us_data* us, unsigned int pipe,
  * Transport routines
  ***********************************************************************/
 
+/* There are so many devices that report the capacity incorrectly,
+ * this routine was written to counteract some of the resulting
+ * problems.
+ */
+static void last_sector_hacks(struct us_data *us, struct scsi_cmnd *srb)
+{
+	struct gendisk *disk;
+	struct scsi_disk *sdkp;
+	u32 sector;
+
+	/* To Report "Medium Error: Record Not Found */
+	static unsigned char record_not_found[18] = {
+		[0]	= 0x70,			/* current error */
+		[2]	= MEDIUM_ERROR,		/* = 0x03 */
+		[7]	= 0x0a,			/* additional length */
+		[12]	= 0x14			/* Record Not Found */
+	};
+
+	/* If last-sector problems can't occur, whether because the
+	 * capacity was already decremented or because the device is
+	 * known to report the correct capacity, then we don't need
+	 * to do anything.
+	 */
+	if (!us-&gt;use_last_sector_hacks)
+		return;
+
+	/* Was this command a READ(10) or a WRITE(10)? */
+	if (srb-&gt;cmnd[0] != READ_10 &amp;&amp; srb-&gt;cmnd[0] != WRITE_10)
+		goto done;
+
+	/* Did this command access the last sector? */
+	sector = (srb-&gt;cmnd[2] &lt;&lt; 24) | (srb-&gt;cmnd[3] &lt;&lt; 16) |
+			(srb-&gt;cmnd[4] &lt;&lt; 8) | (srb-&gt;cmnd[5]);
+	disk = srb-&gt;request-&gt;rq_disk;
+	if (!disk)
+		goto done;
+	sdkp = scsi_disk(disk);
+	if (!sdkp)
+		goto done;
+	if (sector + 1 != sdkp-&gt;capacity)
+		goto done;
+
+	if (srb-&gt;result == SAM_STAT_GOOD &amp;&amp; scsi_get_resid(srb) == 0) {
+
+		/* The command succeeded.  If the capacity is odd
+		 * (i.e., if the sector number is even) then the
+		 * "always-even" heuristic would be wrong for this
+		 * device.  Issue a WARN() so that the kerneloops.org
+		 * project will be notified and we will then know to
+		 * mark the device with a CAPACITY_OK flag.  Hopefully
+		 * this will occur for only a few devices.
+		 *
+		 * Use the sign of us-&gt;last_sector_hacks to tell whether
+		 * the warning has already been issued; we don't need
+		 * more than one warning per device.
+		 */
+		if (!(sector &amp; 1) &amp;&amp; us-&gt;use_last_sector_hacks &gt; 0) {
+			unsigned vid = le16_to_cpu(
+					us-&gt;pusb_dev-&gt;descriptor.idVendor);
+			unsigned pid = le16_to_cpu(
+					us-&gt;pusb_dev-&gt;descriptor.idProduct);
+			unsigned rev = le16_to_cpu(
+					us-&gt;pusb_dev-&gt;descriptor.bcdDevice);
+
+			WARN(1, "%s: Successful last sector success at %u, "
+					"device %04x:%04x:%04x\n",
+					sdkp-&gt;disk-&gt;disk_name, sector,
+					vid, pid, rev);
+			us-&gt;use_last_sector_hacks = -1;
+		}
+
+	} else {
+		/* The command failed.  Allow up to 3 retries in case this
+		 * is some normal sort of failure.  After that, assume the
+		 * capacity is wrong and we're trying to access the sector
+		 * beyond the end.  Replace the result code and sense data
+		 * with values that will cause the SCSI core to fail the
+		 * command immediately, instead of going into an infinite
+		 * (or even just a very long) retry loop.
+		 */
+		if (++us-&gt;last_sector_retries &lt; 3)
+			return;
+		srb-&gt;result = SAM_STAT_CHECK_CONDITION;
+		memcpy(srb-&gt;sense_buffer, record_not_found,
+				sizeof(record_not_found));
+
+		/* In theory we might want to issue a WARN() here if the
+		 * capacity is even, since it could indicate the device
+		 * has the READ CAPACITY bug _and_ the real capacity is
+		 * odd.  But it could also indicate that the device
+		 * simply can't access its last sector, a failure mode
+		 * which is surprisingly common.  So no warning.
+		 */
+	}
+
+ done:
+	/* Don't reset the retry counter for TEST UNIT READY commands,
+	 * because they get issued after device resets which might be
+	 * caused by a failed last-sector access.
+	 */
+	if (srb-&gt;cmnd[0] != TEST_UNIT_READY)
+		us-&gt;last_sector_retries = 0;
+}
+
 /* Invoke the transport and basic error-handling/recovery methods
  *
  * This is used by the protocol layers to actually send the message to
@@ -544,6 +651,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	/* if the transport provided its own sense data, don't auto-sense */
 	if (result == USB_STOR_TRANSPORT_NO_SENSE) {
 		srb-&gt;result = SAM_STAT_CHECK_CONDITION;
+		last_sector_hacks(us, srb);
 		return;
 	}
 
@@ -705,6 +813,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 			scsi_bufflen(srb) - scsi_get_resid(srb) &lt; srb-&gt;underflow)
 		srb-&gt;result = (DID_ERROR &lt;&lt; 16) | (SUGGEST_RETRY &lt;&lt; 24);
 
+	last_sector_hacks(us, srb);
 	return;
 
 	/* Error and abort processing: try to resynchronize with the device
@@ -732,6 +841,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		us-&gt;transport_reset(us);
 	}
 	clear_bit(US_FLIDX_RESETTING, &amp;us-&gt;dflags);
+	last_sector_hacks(us, srb);
 }
 
 /* Stop the current URB transfer */
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 0330ed53ec1c..035bbc5d8231 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -27,7 +27,8 @@
 
 /* IMPORTANT NOTE: This file must be included in another file which does
  * the following thing for it to work:
- * The macro UNUSUAL_DEV() must be defined before this file is included
+ * The UNUSUAL_DEV, COMPLIANT_DEV, and USUAL_DEV macros must be defined
+ * before this file is included.
  */
 
 /* If you edit this file, please try to keep it sorted first by VendorID,
@@ -46,6 +47,12 @@
  * &lt;usb-storage@lists.one-eyed-alien.net&gt;
  */
 
+/* Note: If you add an entry only in order to set the CAPACITY_OK flag,
+ * use the COMPLIANT_DEV macro instead of UNUSUAL_DEV.  This is
+ * because such entries mark devices which actually work correctly,
+ * as opposed to devices that do something strangely or wrongly.
+ */
+
 /* patch submitted by Vivian Bregier &lt;Vivian.Bregier@imag.fr&gt;
  */
 UNUSUAL_DEV(  0x03eb, 0x2002, 0x0100, 0x0100,
@@ -704,6 +711,13 @@ UNUSUAL_DEV(  0x0525, 0xa140, 0x0100, 0x0100,
 		US_SC_8070, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
+/* Added by Alan Stern &lt;stern@rowland.harvard.edu&gt; */
+COMPLIANT_DEV(0x0525, 0xa4a5, 0x0000, 0x9999,
+		"Linux",
+		"File-backed Storage Gadget",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_CAPACITY_OK ),
+
 /* Yakumo Mega Image 37
  * Submitted by Stephan Fuhrmann &lt;atomenergie@t-online.de&gt; */
 UNUSUAL_DEV(  0x052b, 0x1801, 0x0100, 0x0100,
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index ce0b580db5ea..80e234bf4e50 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -134,6 +134,8 @@ static struct quirks_entry *quirks_list, *quirks_end;
 { USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin,bcdDeviceMax), \
   .driver_info = (flags)|(USB_US_TYPE_STOR&lt;&lt;24) }
 
+#define COMPLIANT_DEV	UNUSUAL_DEV
+
 #define USUAL_DEV(useProto, useTrans, useType) \
 { USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, useProto, useTrans), \
   .driver_info = (USB_US_TYPE_STOR&lt;&lt;24) }
@@ -142,6 +144,7 @@ static struct usb_device_id storage_usb_ids [] = {
 
 #	include "unusual_devs.h"
 #undef UNUSUAL_DEV
+#undef COMPLIANT_DEV
 #undef USUAL_DEV
 	/* Terminating entry */
 	{ }
@@ -172,6 +175,8 @@ MODULE_DEVICE_TABLE (usb, storage_usb_ids);
 	.initFunction = init_function,	\
 }
 
+#define COMPLIANT_DEV	UNUSUAL_DEV
+
 #define USUAL_DEV(use_protocol, use_transport, use_type) \
 { \
 	.useProtocol = use_protocol,	\
@@ -181,6 +186,7 @@ MODULE_DEVICE_TABLE (usb, storage_usb_ids);
 static struct us_unusual_dev us_unusual_dev_list[] = {
 #	include "unusual_devs.h" 
 #	undef UNUSUAL_DEV
+#	undef COMPLIANT_DEV
 #	undef USUAL_DEV
 
 	/* Terminating entry */
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index e4674fc715e6..65e674e4be99 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -154,6 +154,10 @@ struct us_data {
 #ifdef CONFIG_PM
 	pm_hook			suspend_resume_hook;
 #endif
+
+	/* hacks for READ CAPACITY bug handling */
+	int			use_last_sector_hacks;
+	int			last_sector_retries;
 };
 
 /* Convert between us_data and the corresponding Scsi_Host */
diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index 998e5cbbf29e..1eea1ab68dc4 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -53,8 +53,10 @@
 		/* Sets max_sectors to arch min */		\
 	US_FLAG(BULK_IGNORE_TAG,0x00004000)			\
 		/* Ignore tag mismatch in bulk operations */    \
-	US_FLAG(SANE_SENSE,     0x00008000)
-		/* Sane Sense (&gt; 18 bytes) */
+	US_FLAG(SANE_SENSE,     0x00008000)			\
+		/* Sane Sense (&gt; 18 bytes) */			\
+	US_FLAG(CAPACITY_OK,	0x00010000)			\
+		/* READ CAPACITY response is correct */
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };</pre>
    <div class="pagination">
        <a href='2_81.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><span>[82]</span><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_83.html'>Next&gt;&gt;</a>
    <div>
</body>

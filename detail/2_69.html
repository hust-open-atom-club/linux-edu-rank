<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_68.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><span>[69]</span><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_70.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3e6e15a862a0bc20128497bbdc54254cdec21835
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 8 23:42:46 2010 -0800

    Input: enable remote wakeup for PNP i8042 keyboard ports
    
    This patch (as1355) enables remote wakeup by default on PNP i8042
    keyboard ports.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Dmitry Torokhov &lt;dtor@mail.ru&gt;

diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h
index 2a5982e532f8..3696cab40598 100644
--- a/drivers/input/serio/i8042-x86ia64io.h
+++ b/drivers/input/serio/i8042-x86ia64io.h
@@ -624,6 +624,9 @@ static int i8042_pnp_kbd_probe(struct pnp_dev *dev, const struct pnp_device_id *
 		strlcat(i8042_pnp_kbd_name, pnp_dev_name(dev), sizeof(i8042_pnp_kbd_name));
 	}
 
+	/* Keyboard ports are always supposed to be wakeup-enabled */
+	device_set_wakeup_enable(&amp;dev-&gt;dev, true);
+
 	i8042_pnp_kbd_devices++;
 	return 0;
 }</pre><hr><pre>commit 1f87158e44e79e62c8250f278c225ce4ab695f4b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 17 10:05:47 2010 -0500

    USB: remove references to port-&gt;port.count from the serial drivers
    
    This patch (as1344) removes references to port-&gt;port.count from the
    USB serial drivers.  Now that serial ports are properly reference
    counted, port.count checking is unnecessary and incorrect.  Drivers
    should assume that the port is in use from the time the open method
    runs until the close method is called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/aircable.c b/drivers/usb/serial/aircable.c
index 2cbdc8f230b8..365db1097bfd 100644
--- a/drivers/usb/serial/aircable.c
+++ b/drivers/usb/serial/aircable.c
@@ -468,10 +468,6 @@ static void aircable_read_bulk_callback(struct urb *urb)
 
 	if (status) {
 		dbg("%s - urb status = %d", __func__, status);
-		if (!port-&gt;port.count) {
-			dbg("%s - port is closed, exiting.", __func__);
-			return;
-		}
 		if (status == -EPROTO) {
 			dbg("%s - caught -EPROTO, resubmitting the urb",
 			    __func__);
@@ -530,23 +526,19 @@ static void aircable_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 
-	/* Schedule the next read _if_ we are still open */
-	if (port-&gt;port.count) {
-		usb_fill_bulk_urb(port-&gt;read_urb, port-&gt;serial-&gt;dev,
-				  usb_rcvbulkpipe(port-&gt;serial-&gt;dev,
-					  port-&gt;bulk_in_endpointAddress),
-				  port-&gt;read_urb-&gt;transfer_buffer,
-				  port-&gt;read_urb-&gt;transfer_buffer_length,
-				  aircable_read_bulk_callback, port);
-
-		result = usb_submit_urb(urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&amp;urb-&gt;dev-&gt;dev,
-				"%s - failed resubmitting read urb, error %d\n",
-				__func__, result);
-	}
-
-	return;
+	/* Schedule the next read */
+	usb_fill_bulk_urb(port-&gt;read_urb, port-&gt;serial-&gt;dev,
+			  usb_rcvbulkpipe(port-&gt;serial-&gt;dev,
+				  port-&gt;bulk_in_endpointAddress),
+			  port-&gt;read_urb-&gt;transfer_buffer,
+			  port-&gt;read_urb-&gt;transfer_buffer_length,
+			  aircable_read_bulk_callback, port);
+
+	result = usb_submit_urb(urb, GFP_ATOMIC);
+	if (result &amp;&amp; result != -EPERM)
+		dev_err(&amp;urb-&gt;dev-&gt;dev,
+			"%s - failed resubmitting read urb, error %d\n",
+			__func__, result);
 }
 
 /* Based on ftdi_sio.c throttle */
diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c
index 3a5d57f89dee..baf74b44e6ed 100644
--- a/drivers/usb/serial/cypress_m8.c
+++ b/drivers/usb/serial/cypress_m8.c
@@ -1321,9 +1321,9 @@ static void cypress_read_int_callback(struct urb *urb)
 continue_read:
 	tty_kref_put(tty);
 
-	/* Continue trying to always read... unless the port has closed. */
+	/* Continue trying to always read */
 
-	if (port-&gt;port.count &gt; 0 &amp;&amp; priv-&gt;comm_is_ok) {
+	if (priv-&gt;comm_is_ok) {
 		usb_fill_int_urb(port-&gt;interrupt_in_urb, port-&gt;serial-&gt;dev,
 				usb_rcvintpipe(port-&gt;serial-&gt;dev,
 					port-&gt;interrupt_in_endpointAddress),
@@ -1332,7 +1332,7 @@ static void cypress_read_int_callback(struct urb *urb)
 				cypress_read_int_callback, port,
 				priv-&gt;read_urb_interval);
 		result = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_ATOMIC);
-		if (result) {
+		if (result &amp;&amp; result != -EPERM) {
 			dev_err(&amp;urb-&gt;dev-&gt;dev, "%s - failed resubmitting "
 					"read urb, error %d\n", __func__,
 					result);
diff --git a/drivers/usb/serial/digi_acceleport.c b/drivers/usb/serial/digi_acceleport.c
index 381722858424..68b0aa5e516c 100644
--- a/drivers/usb/serial/digi_acceleport.c
+++ b/drivers/usb/serial/digi_acceleport.c
@@ -1262,10 +1262,10 @@ static void digi_write_bulk_callback(struct urb *urb)
 		return;
 	}
 
-	/* try to send any buffered data on this port, if it is open */
+	/* try to send any buffered data on this port */
 	spin_lock(&amp;priv-&gt;dp_port_lock);
 	priv-&gt;dp_write_urb_in_use = 0;
-	if (port-&gt;port.count &amp;&amp; priv-&gt;dp_out_buf_len &gt; 0) {
+	if (priv-&gt;dp_out_buf_len &gt; 0) {
 		*((unsigned char *)(port-&gt;write_urb-&gt;transfer_buffer))
 			= (unsigned char)DIGI_CMD_SEND_DATA;
 		*((unsigned char *)(port-&gt;write_urb-&gt;transfer_buffer) + 1)
@@ -1288,7 +1288,7 @@ static void digi_write_bulk_callback(struct urb *urb)
 	schedule_work(&amp;priv-&gt;dp_wakeup_work);
 
 	spin_unlock(&amp;priv-&gt;dp_port_lock);
-	if (ret)
+	if (ret &amp;&amp; ret != -EPERM)
 		dev_err(&amp;port-&gt;dev,
 			"%s: usb_submit_urb failed, ret=%d, port=%d\n",
 			__func__, ret, priv-&gt;dp_port_num);
@@ -1353,8 +1353,7 @@ static int digi_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct digi_port *priv = usb_get_serial_port_data(port);
 	struct ktermios not_termios;
 
-	dbg("digi_open: TOP: port=%d, open_count=%d",
-		priv-&gt;dp_port_num, port-&gt;port.count);
+	dbg("digi_open: TOP: port=%d", priv-&gt;dp_port_num);
 
 	/* be sure the device is started up */
 	if (digi_startup_device(port-&gt;serial) != 0)
@@ -1393,8 +1392,7 @@ static void digi_close(struct usb_serial_port *port)
 	unsigned char buf[32];
 	struct digi_port *priv = usb_get_serial_port_data(port);
 
-	dbg("digi_close: TOP: port=%d, open_count=%d",
-		priv-&gt;dp_port_num, port-&gt;port.count);
+	dbg("digi_close: TOP: port=%d", priv-&gt;dp_port_num);
 
 	mutex_lock(&amp;port-&gt;serial-&gt;disc_mutex);
 	/* if disconnected, just clear flags */
@@ -1629,7 +1627,7 @@ static void digi_read_bulk_callback(struct urb *urb)
 	/* continue read */
 	urb-&gt;dev = port-&gt;serial-&gt;dev;
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
-	if (ret != 0) {
+	if (ret != 0 &amp;&amp; ret != -EPERM) {
 		dev_err(&amp;port-&gt;dev,
 			"%s: failed resubmitting urb, ret=%d, port=%d\n",
 			__func__, ret, priv-&gt;dp_port_num);
@@ -1662,7 +1660,7 @@ static int digi_read_inb_callback(struct urb *urb)
 
 	/* do not process callbacks on closed ports */
 	/* but do continue the read chain */
-	if (port-&gt;port.count == 0)
+	if (urb-&gt;status == -ENOENT)
 		return 0;
 
 	/* short/multiple packet check */
@@ -1767,8 +1765,7 @@ static int digi_read_oob_callback(struct urb *urb)
 
 		tty = tty_port_tty_get(&amp;port-&gt;port);
 		rts = 0;
-		if (port-&gt;port.count)
-			rts = tty-&gt;termios-&gt;c_cflag &amp; CRTSCTS;
+		rts = tty-&gt;termios-&gt;c_cflag &amp; CRTSCTS;
 		
 		if (opcode == DIGI_CMD_READ_INPUT_SIGNALS) {
 			spin_lock(&amp;priv-&gt;dp_port_lock);
diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index 5288203d883f..89fac36684c5 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -20,6 +20,7 @@
 #include &lt;linux/usb/serial.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/kfifo.h&gt;
+#include &lt;linux/serial.h&gt;
 
 static int debug;
 
@@ -585,7 +586,7 @@ int usb_serial_generic_resume(struct usb_serial *serial)
 
 	for (i = 0; i &lt; serial-&gt;num_ports; i++) {
 		port = serial-&gt;port[i];
-		if (!port-&gt;port.count)
+		if (!test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags))
 			continue;
 
 		if (port-&gt;read_urb) {
diff --git a/drivers/usb/serial/ir-usb.c b/drivers/usb/serial/ir-usb.c
index c3e5d506aead..4a0f51974232 100644
--- a/drivers/usb/serial/ir-usb.c
+++ b/drivers/usb/serial/ir-usb.c
@@ -445,11 +445,6 @@ static void ir_read_bulk_callback(struct urb *urb)
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
-	if (!port-&gt;port.count) {
-		dbg("%s - port closed.", __func__);
-		return;
-	}
-
 	switch (status) {
 	case 0: /* Successful */
 		/*
diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index f8c4b07033ff..297163c3c610 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -464,13 +464,9 @@ static void	usa26_indat_callback(struct urb *urb)
 
 	/* Resubmit urb so we continue receiving */
 	urb-&gt;dev = port-&gt;serial-&gt;dev;
-	if (port-&gt;port.count) {
-		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (err != 0)
-			dbg("%s - resubmit read urb failed. (%d)",
-					__func__, err);
-	}
-	return;
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err != 0)
+		dbg("%s - resubmit read urb failed. (%d)", __func__, err);
 }
 
 /* Outdat handling is common for all devices */
@@ -483,8 +479,7 @@ static void	usa2x_outdat_callback(struct urb *urb)
 	p_priv = usb_get_serial_port_data(port);
 	dbg("%s - urb %d", __func__, urb == p_priv-&gt;out_urbs[1]);
 
-	if (port-&gt;port.count)
-		usb_serial_port_softint(port);
+	usb_serial_port_softint(port);
 }
 
 static void	usa26_inack_callback(struct urb *urb)
@@ -615,12 +610,10 @@ static void usa28_indat_callback(struct urb *urb)
 
 		/* Resubmit urb so we continue receiving */
 		urb-&gt;dev = port-&gt;serial-&gt;dev;
-		if (port-&gt;port.count) {
-			err = usb_submit_urb(urb, GFP_ATOMIC);
-			if (err != 0)
-				dbg("%s - resubmit read urb failed. (%d)",
-								__func__, err);
-		}
+		err = usb_submit_urb(urb, GFP_ATOMIC);
+		if (err != 0)
+			dbg("%s - resubmit read urb failed. (%d)",
+							__func__, err);
 		p_priv-&gt;in_flip ^= 1;
 
 		urb = p_priv-&gt;in_urbs[p_priv-&gt;in_flip];
@@ -856,12 +849,9 @@ static void	usa49_indat_callback(struct urb *urb)
 
 	/* Resubmit urb so we continue receiving */
 	urb-&gt;dev = port-&gt;serial-&gt;dev;
-	if (port-&gt;port.count) {
-		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (err != 0)
-			dbg("%s - resubmit read urb failed. (%d)",
-							__func__, err);
-	}
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err != 0)
+		dbg("%s - resubmit read urb failed. (%d)", __func__, err);
 }
 
 static void usa49wg_indat_callback(struct urb *urb)
@@ -904,11 +894,7 @@ static void usa49wg_indat_callback(struct urb *urb)
 				/* no error on any byte */
 				i++;
 				for (x = 1; x &lt; len ; ++x)
-					if (port-&gt;port.count)
-						tty_insert_flip_char(tty,
-								data[i++], 0);
-					else
-						i++;
+					tty_insert_flip_char(tty, data[i++], 0);
 			} else {
 				/*
 				 * some bytes had errors, every byte has status
@@ -922,14 +908,12 @@ static void usa49wg_indat_callback(struct urb *urb)
 					if (stat &amp; RXERROR_PARITY)
 						flag |= TTY_PARITY;
 					/* XXX should handle break (0x10) */
-					if (port-&gt;port.count)
-						tty_insert_flip_char(tty,
+					tty_insert_flip_char(tty,
 							data[i+1], flag);
 					i += 2;
 				}
 			}
-			if (port-&gt;port.count)
-				tty_flip_buffer_push(tty);
+			tty_flip_buffer_push(tty);
 			tty_kref_put(tty);
 		}
 	}
@@ -1013,13 +997,9 @@ static void usa90_indat_callback(struct urb *urb)
 
 	/* Resubmit urb so we continue receiving */
 	urb-&gt;dev = port-&gt;serial-&gt;dev;
-	if (port-&gt;port.count) {
-		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (err != 0)
-			dbg("%s - resubmit read urb failed. (%d)",
-							__func__, err);
-	}
-	return;
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err != 0)
+		dbg("%s - resubmit read urb failed. (%d)", __func__, err);
 }
 
 
@@ -2418,8 +2398,7 @@ static int keyspan_usa90_send_setup(struct usb_serial *serial,
 		msg.portEnabled = 0;
 	/* Sending intermediate configs */
 	else {
-		if (port-&gt;port.count)
-			msg.portEnabled = 1;
+		msg.portEnabled = 1;
 		msg.txBreak = (p_priv-&gt;break_on);
 	}
 
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 68c7457a98ae..db0541c5df79 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -971,9 +971,9 @@ static void option_indat_callback(struct urb *urb)
 		tty_kref_put(tty);
 
 		/* Resubmit urb so we continue receiving */
-		if (port-&gt;port.count &amp;&amp; status != -ESHUTDOWN) {
+		if (status != -ESHUTDOWN) {
 			err = usb_submit_urb(urb, GFP_ATOMIC);
-			if (err)
+			if (err &amp;&amp; err != -EPERM)
 				printk(KERN_ERR "%s: resubmit read urb failed. "
 					"(%d)", __func__, err);
 			else
diff --git a/drivers/usb/serial/oti6858.c b/drivers/usb/serial/oti6858.c
index 839733431832..deeacdea05db 100644
--- a/drivers/usb/serial/oti6858.c
+++ b/drivers/usb/serial/oti6858.c
@@ -585,9 +585,6 @@ static int oti6858_open(struct tty_struct *tty, struct usb_serial_port *port)
 	usb_clear_halt(serial-&gt;dev, port-&gt;write_urb-&gt;pipe);
 	usb_clear_halt(serial-&gt;dev, port-&gt;read_urb-&gt;pipe);
 
-	if (port-&gt;port.count != 1)
-		return 0;
-
 	buf = kmalloc(OTI6858_CTRL_PKT_SIZE, GFP_KERNEL);
 	if (buf == NULL) {
 		dev_err(&amp;port-&gt;dev, "%s(): out of memory!\n", __func__);
@@ -934,10 +931,6 @@ static void oti6858_read_bulk_callback(struct urb *urb)
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
 
 	if (status != 0) {
-		if (!port-&gt;port.count) {
-			dbg("%s(): port is closed, exiting", __func__);
-			return;
-		}
 		/*
 		if (status == -EPROTO) {
 			* PL2303 mysteriously fails with -EPROTO reschedule
@@ -961,14 +954,12 @@ static void oti6858_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 
-	/* schedule the interrupt urb if we are still open */
-	if (port-&gt;port.count != 0) {
-		port-&gt;interrupt_in_urb-&gt;dev = port-&gt;serial-&gt;dev;
-		result = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_ATOMIC);
-		if (result != 0) {
-			dev_err(&amp;port-&gt;dev, "%s(): usb_submit_urb() failed,"
-					" error %d\n", __func__, result);
-		}
+	/* schedule the interrupt urb */
+	port-&gt;interrupt_in_urb-&gt;dev = port-&gt;serial-&gt;dev;
+	result = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_ATOMIC);
+	if (result != 0 &amp;&amp; result != -EPERM) {
+		dev_err(&amp;port-&gt;dev, "%s(): usb_submit_urb() failed,"
+				" error %d\n", __func__, result);
 	}
 }
 
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a3e5a56dc066..571dcf182866 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1071,10 +1071,6 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 
 	if (status) {
 		dbg("%s - urb status = %d", __func__, status);
-		if (!port-&gt;port.count) {
-			dbg("%s - port is closed, exiting.", __func__);
-			return;
-		}
 		if (status == -EPROTO) {
 			/* PL2303 mysteriously fails with -EPROTO reschedule
 			 * the read */
@@ -1107,15 +1103,11 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 	/* Schedule the next read _if_ we are still open */
-	if (port-&gt;port.count) {
-		urb-&gt;dev = port-&gt;serial-&gt;dev;
-		result = usb_submit_urb(urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&amp;urb-&gt;dev-&gt;dev, "%s - failed resubmitting"
-				" read urb, error %d\n", __func__, result);
-	}
-
-	return;
+	urb-&gt;dev = port-&gt;serial-&gt;dev;
+	result = usb_submit_urb(urb, GFP_ATOMIC);
+	if (result &amp;&amp; result != -EPERM)
+		dev_err(&amp;urb-&gt;dev-&gt;dev, "%s - failed resubmitting"
+			" read urb, error %d\n", __func__, result);
 }
 
 static void pl2303_write_bulk_callback(struct urb *urb)
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index c012e51665bd..34e6f894cba9 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -610,10 +610,10 @@ static void sierra_indat_callback(struct urb *urb)
 	}
 
 	/* Resubmit urb so we continue receiving */
-	if (port-&gt;port.count &amp;&amp; status != -ESHUTDOWN &amp;&amp; status != -EPERM) {
+	if (status != -ESHUTDOWN &amp;&amp; status != -EPERM) {
 		usb_mark_last_busy(port-&gt;serial-&gt;dev);
 		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (err)
+		if (err &amp;&amp; err != -EPERM)
 			dev_err(&amp;port-&gt;dev, "resubmit read urb failed."
 				"(%d)\n", err);
 	}
@@ -672,11 +672,11 @@ static void sierra_instat_callback(struct urb *urb)
 		dev_dbg(&amp;port-&gt;dev, "%s: error %d\n", __func__, status);
 
 	/* Resubmit urb so we continue receiving IRQ data */
-	if (port-&gt;port.count &amp;&amp; status != -ESHUTDOWN &amp;&amp; status != -ENOENT) {
+	if (status != -ESHUTDOWN &amp;&amp; status != -ENOENT) {
 		usb_mark_last_busy(serial-&gt;dev);
 		urb-&gt;dev = serial-&gt;dev;
 		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (err)
+		if (err &amp;&amp; err != -EPERM)
 			dev_err(&amp;port-&gt;dev, "%s: resubmit intr urb "
 				"failed. (%d)\n", __func__, err);
 	}
diff --git a/drivers/usb/serial/spcp8x5.c b/drivers/usb/serial/spcp8x5.c
index cf508e26f1c6..5d39191e7244 100644
--- a/drivers/usb/serial/spcp8x5.c
+++ b/drivers/usb/serial/spcp8x5.c
@@ -686,8 +686,6 @@ static void spcp8x5_read_bulk_callback(struct urb *urb)
 
 	/* check the urb status */
 	if (result) {
-		if (!port-&gt;port.count)
-			return;
 		if (result == -EPROTO) {
 			/* spcp8x5 mysteriously fails with -EPROTO */
 			/* reschedule the read */
@@ -734,16 +732,11 @@ static void spcp8x5_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 
-	/* Schedule the next read _if_ we are still open */
-	if (port-&gt;port.count) {
-		urb-&gt;dev = port-&gt;serial-&gt;dev;
-		result = usb_submit_urb(urb , GFP_ATOMIC);
-		if (result)
-			dev_dbg(&amp;port-&gt;dev, "failed submitting read urb %d\n",
-				result);
-	}
-
-	return;
+	/* Schedule the next read */
+	urb-&gt;dev = port-&gt;serial-&gt;dev;
+	result = usb_submit_urb(urb , GFP_ATOMIC);
+	if (result)
+		dev_dbg(&amp;port-&gt;dev, "failed submitting read urb %d\n", result);
 }
 
 /* get data from ring buffer and then write to usb bus */</pre><hr><pre>commit cd780694920fbf869b23c8afb0bd083e7b0448c7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 25 13:19:37 2010 -0500

    USB: fix the idProduct value for USB-3.0 root hubs
    
    This patch (as1346) changes the idProduct value for USB-3.0 root hubs
    from 0x0002 (which we already use for USB-2.0 root hubs) to 0x0003.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index b07ba051118d..2f8cedda8007 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -142,7 +142,7 @@ static const u8 usb3_rh_dev_descriptor[18] = {
 	0x09,       /*  __u8  bMaxPacketSize0; 2^9 = 512 Bytes */
 
 	0x6b, 0x1d, /*  __le16 idVendor; Linux Foundation */
-	0x02, 0x00, /*  __le16 idProduct; device 0x0002 */
+	0x03, 0x00, /*  __le16 idProduct; device 0x0003 */
 	KERNEL_VER, KERNEL_REL, /*  __le16 bcdDevice */
 
 	0x03,       /*  __u8  iManufacturer; */</pre><hr><pre>commit 49d6271b85a3e18062eaf4d6f8d899abe00a7725
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 26 11:49:39 2010 -0500

    usb-storage: use max_hw_sectors instead of max_sectors
    
    This patch (as1347) makes some adjustments to the way usb-storage
    handles the request-queue parameters.
    
    USB host controllers are able to handle arbitrarily long
    scatter-gather lists, since they are limited only by main memory and
    not by the controller hardware.  Hence the sg_tablesize field in the
    host template can be increased to the maximum value.
    
    Drivers like usb-storage aren't supposed to touch the queue's
    max_sectors parameter; instead they are supposed to use the
    max_hw_sectors value.  Accordingly, the patch replaces calls of
    queue_max_sectors() with calls of queue_max_hw_sectors().  Oddly
    enough, the blk_queue_max_sectors() routine is nevertheless still
    appropriate.
    
    The existing code imposes a limit of SCSI_DEFAULT_MAX_SECTORS (1024)
    on the values accepted by the max_sectors attribute file.  There's no
    reason not to accept larger values, so the limit is removed.  (It
    would be nice to change the file's name to max_hw_sectors, but the old
    name is already a well-established API.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index aadc16b5eed7..4cc035562cc2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -133,7 +133,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 		if (us-&gt;fflags &amp; US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE &gt;&gt; 9;
-		if (queue_max_sectors(sdev-&gt;request_queue) &gt; max_sectors)
+		if (queue_max_hw_sectors(sdev-&gt;request_queue) &gt; max_sectors)
 			blk_queue_max_hw_sectors(sdev-&gt;request_queue,
 					      max_sectors);
 	} else if (sdev-&gt;type == TYPE_TAPE) {
@@ -484,7 +484,7 @@ static ssize_t show_max_sectors(struct device *dev, struct device_attribute *att
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
 
-	return sprintf(buf, "%u\n", queue_max_sectors(sdev-&gt;request_queue));
+	return sprintf(buf, "%u\n", queue_max_hw_sectors(sdev-&gt;request_queue));
 }
 
 /* Input routine for the sysfs max_sectors file */
@@ -494,9 +494,9 @@ static ssize_t store_max_sectors(struct device *dev, struct device_attribute *at
 	struct scsi_device *sdev = to_scsi_device(dev);
 	unsigned short ms;
 
-	if (sscanf(buf, "%hu", &amp;ms) &gt; 0 &amp;&amp; ms &lt;= SCSI_DEFAULT_MAX_SECTORS) {
+	if (sscanf(buf, "%hu", &amp;ms) &gt; 0) {
 		blk_queue_max_hw_sectors(sdev-&gt;request_queue, ms);
-		return strlen(buf);
+		return count;
 	}
 	return -EINVAL;	
 }
@@ -539,7 +539,7 @@ struct scsi_host_template usb_stor_host_template = {
 	.slave_configure =		slave_configure,
 
 	/* lots of sg segments can be handled */
-	.sg_tablesize =			SG_ALL,
+	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
 
 	/* limit the total size of a transfer to 120 KB */
 	.max_sectors =                  240,</pre><hr><pre>commit cceffe9348f93188d7811bda95924d4bd3040d0f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 8 09:45:12 2010 -0500

    USB: remove debugging message for uevent constructions
    
    This patch (as1332) removes an unneeded and annoying debugging message
    announcing all USB uevent constructions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 6850ec6576f8..a7037bf81688 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -710,9 +710,6 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct usb_device *usb_dev;
 
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug("usb %s: uevent\n", dev_name(dev));
-
 	if (is_usb_device(dev)) {
 		usb_dev = to_usb_device(dev);
 	} else if (is_usb_interface(dev)) {
@@ -724,6 +721,7 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 	}
 
 	if (usb_dev-&gt;devnum &lt; 0) {
+		/* driver is often null here; dev_dbg() would oops */
 		pr_debug("usb %s: already deleted?\n", dev_name(dev));
 		return -ENODEV;
 	}</pre><hr><pre>commit 9bbdf1e0afe771ca7650f9f476769310bee9d8f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:57:28 2010 -0500

    USB: convert to the runtime PM framework
    
    This patch (as1329) converts the USB stack over to the PM core's
    runtime PM framework.  This involves numerous changes throughout
    usbcore, especially to hub.c and driver.c.  Perhaps the most notable
    change is that CONFIG_USB_SUSPEND now depends on CONFIG_PM_RUNTIME
    instead of CONFIG_PM.
    
    Several fields in the usb_device and usb_interface structures are no
    longer needed.  Some code which used to depend on CONFIG_USB_PM now
    depends on CONFIG_USB_SUSPEND (requiring some rearrangement of header
    files).
    
    The only visible change in behavior should be that following a system
    sleep (resume from RAM or resume from hibernation), autosuspended USB
    devices will be resumed just like everything else.  They won't remain
    suspended.  But if they aren't in use then they will naturally
    autosuspend again in a few seconds.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index e3fa189c257a..2790ad48cfc2 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -2,7 +2,7 @@
 
 		 Alan Stern &lt;stern@rowland.harvard.edu&gt;
 
-			    November 10, 2009
+			    December 11, 2009
 
 
 
@@ -29,9 +29,9 @@ covered to some extent (see Documentation/power/*.txt for more
 information about system PM).
 
 Note: Dynamic PM support for USB is present only if the kernel was
-built with CONFIG_USB_SUSPEND enabled.  System PM support is present
-only if the kernel was built with CONFIG_SUSPEND or CONFIG_HIBERNATION
-enabled.
+built with CONFIG_USB_SUSPEND enabled (which depends on
+CONFIG_PM_RUNTIME).  System PM support is present only if the kernel
+was built with CONFIG_SUSPEND or CONFIG_HIBERNATION enabled.
 
 
 	What is Remote Wakeup?
@@ -326,64 +326,63 @@ driver does so by calling these six functions:
 	void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
 	void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
-The functions work by maintaining a counter in the usb_interface
-structure.  When intf-&gt;pm_usage_count is &gt; 0 then the interface is
-deemed to be busy, and the kernel will not autosuspend the interface's
-device.  When intf-&gt;pm_usage_count is &lt;= 0 then the interface is
-considered to be idle, and the kernel may autosuspend the device.
+The functions work by maintaining a usage counter in the
+usb_interface's embedded device structure.  When the counter is &gt; 0
+then the interface is deemed to be busy, and the kernel will not
+autosuspend the interface's device.  When the usage counter is = 0
+then the interface is considered to be idle, and the kernel may
+autosuspend the device.
 
-(There is a similar pm_usage_count field in struct usb_device,
+(There is a similar usage counter field in struct usb_device,
 associated with the device itself rather than any of its interfaces.
-This field is used only by the USB core.)
-
-Drivers must not modify intf-&gt;pm_usage_count directly; its value
-should be changed only be using the functions listed above.  Drivers
-are responsible for insuring that the overall change to pm_usage_count
-during their lifetime balances out to 0 (it may be necessary for the
-disconnect method to call usb_autopm_put_interface() one or more times
-to fulfill this requirement).  The first two routines use the PM mutex
-in struct usb_device for mutual exclusion; drivers using the async
-routines are responsible for their own synchronization and mutual
-exclusion.
-
-	usb_autopm_get_interface() increments pm_usage_count and
-	attempts an autoresume if the new value is &gt; 0 and the
-	device is suspended.
-
-	usb_autopm_put_interface() decrements pm_usage_count and
-	attempts an autosuspend if the new value is &lt;= 0 and the
-	device isn't suspended.
+This counter is used only by the USB core.)
+
+Drivers need not be concerned about balancing changes to the usage
+counter; the USB core will undo any remaining "get"s when a driver
+is unbound from its interface.  As a corollary, drivers must not call
+any of the usb_autopm_* functions after their diconnect() routine has
+returned.
+
+Drivers using the async routines are responsible for their own
+synchronization and mutual exclusion.
+
+	usb_autopm_get_interface() increments the usage counter and
+	does an autoresume if the device is suspended.  If the
+	autoresume fails, the counter is decremented back.
+
+	usb_autopm_put_interface() decrements the usage counter and
+	attempts an autosuspend if the new value is = 0.
 
 	usb_autopm_get_interface_async() and
 	usb_autopm_put_interface_async() do almost the same things as
-	their non-async counterparts.  The differences are: they do
-	not acquire the PM mutex, and they use a workqueue to do their
+	their non-async counterparts.  The big difference is that they
+	use a workqueue to do the resume or suspend part of their
 	jobs.  As a result they can be called in an atomic context,
 	such as an URB's completion handler, but when they return the
-	device will not generally not yet be in the desired state.
+	device will generally not yet be in the desired state.
 
 	usb_autopm_get_interface_no_resume() and
 	usb_autopm_put_interface_no_suspend() merely increment or
-	decrement the pm_usage_count value; they do not attempt to
-	carry out an autoresume or an autosuspend.  Hence they can be
-	called in an atomic context.
+	decrement the usage counter; they do not attempt to carry out
+	an autoresume or an autosuspend.  Hence they can be called in
+	an atomic context.
 
-The conventional usage pattern is that a driver calls
+The simplest usage pattern is that a driver calls
 usb_autopm_get_interface() in its open routine and
-usb_autopm_put_interface() in its close or release routine.  But
-other patterns are possible.
+usb_autopm_put_interface() in its close or release routine.  But other
+patterns are possible.
 
 The autosuspend attempts mentioned above will often fail for one
 reason or another.  For example, the power/level attribute might be
 set to "on", or another interface in the same device might not be
 idle.  This is perfectly normal.  If the reason for failure was that
-the device hasn't been idle for long enough, a delayed workqueue
-routine is automatically set up to carry out the operation when the
-autosuspend idle-delay has expired.
+the device hasn't been idle for long enough, a timer is scheduled to
+carry out the operation automatically when the autosuspend idle-delay
+has expired.
 
 Autoresume attempts also can fail, although failure would mean that
 the device is no longer present or operating properly.  Unlike
-autosuspend, there's no delay for an autoresume.
+autosuspend, there's no idle-delay for an autoresume.
 
 
 	Other parts of the driver interface
@@ -413,26 +412,27 @@ though, setting this flag won't cause the kernel to autoresume it.
 Normally a driver would set this flag in its probe method, at which
 time the device is guaranteed not to be autosuspended.)
 
-The synchronous usb_autopm_* routines have to run in a sleepable
-process context; they must not be called from an interrupt handler or
-while holding a spinlock.  In fact, the entire autosuspend mechanism
-is not well geared toward interrupt-driven operation.  However there
-is one thing a driver can do in an interrupt handler:
+If a driver does its I/O asynchronously in interrupt context, it
+should call usb_autopm_get_interface_async() before starting output and
+usb_autopm_put_interface_async() when the output queue drains.  When
+it receives an input event, it should call
 
 	usb_mark_last_busy(struct usb_device *udev);
 
-This sets udev-&gt;last_busy to the current time.  udev-&gt;last_busy is the
-field used for idle-delay calculations; updating it will cause any
-pending autosuspend to be moved back.  The usb_autopm_* routines will
-also set the last_busy field to the current time.
-
-Calling urb_mark_last_busy() from within an URB completion handler is
-subject to races: The kernel may have just finished deciding the
-device has been idle for long enough but not yet gotten around to
-calling the driver's suspend method.  The driver would have to be
-responsible for synchronizing its suspend method with its URB
-completion handler and causing the autosuspend to fail with -EBUSY if
-an URB had completed too recently.
+in the event handler.  This sets udev-&gt;last_busy to the current time.
+udev-&gt;last_busy is the field used for idle-delay calculations;
+updating it will cause any pending autosuspend to be moved back.  Most
+of the usb_autopm_* routines will also set the last_busy field to the
+current time.
+
+Asynchronous operation is always subject to races.  For example, a
+driver may call one of the usb_autopm_*_interface_async() routines at
+a time when the core has just finished deciding the device has been
+idle for long enough but not yet gotten around to calling the driver's
+suspend method.  The suspend method must be responsible for
+synchronizing with the output request routine and the URB completion
+handler; it should cause autosuspends to fail with -EBUSY if the
+driver needs to use the device.
 
 External suspend calls should never be allowed to fail in this way,
 only autosuspend calls.  The driver can tell them apart by checking
@@ -440,75 +440,23 @@ the PM_EVENT_AUTO bit in the message.event argument to the suspend
 method; this bit will be set for internal PM events (autosuspend) and
 clear for external PM events.
 
-Many of the ingredients in the autosuspend framework are oriented
-towards interfaces: The usb_interface structure contains the
-pm_usage_cnt field, and the usb_autopm_* routines take an interface
-pointer as their argument.  But somewhat confusingly, a few of the
-pieces (i.e., usb_mark_last_busy()) use the usb_device structure
-instead.  Drivers need to keep this straight; they can call
-interface_to_usbdev() to find the device structure for a given
-interface.
 
+	Mutual exclusion
+	----------------
 
-	Locking requirements
-	--------------------
-
-All three suspend/resume methods are always called while holding the
-usb_device's PM mutex.  For external events -- but not necessarily for
-autosuspend or autoresume -- the device semaphore (udev-&gt;dev.sem) will
-also be held.  This implies that external suspend/resume events are
-mutually exclusive with calls to probe, disconnect, pre_reset, and
-post_reset; the USB core guarantees that this is true of internal
-suspend/resume events as well.
+For external events -- but not necessarily for autosuspend or
+autoresume -- the device semaphore (udev-&gt;dev.sem) will be held when a
+suspend or resume method is called.  This implies that external
+suspend/resume events are mutually exclusive with calls to probe,
+disconnect, pre_reset, and post_reset; the USB core guarantees that
+this is true of autosuspend/autoresume events as well.
 
 If a driver wants to block all suspend/resume calls during some
-critical section, it can simply acquire udev-&gt;pm_mutex. Note that
-calls to resume may be triggered indirectly. Block IO due to memory
-allocations can make the vm subsystem resume a device. Thus while
-holding this lock you must not allocate memory with GFP_KERNEL or
-GFP_NOFS.
-
-Alternatively, if the critical section might call some of the
-usb_autopm_* routines, the driver can avoid deadlock by doing:
-
-	down(&amp;udev-&gt;dev.sem);
-	rc = usb_autopm_get_interface(intf);
-
-and at the end of the critical section:
-
-	if (!rc)
-		usb_autopm_put_interface(intf);
-	up(&amp;udev-&gt;dev.sem);
-
-Holding the device semaphore will block all external PM calls, and the
-usb_autopm_get_interface() will prevent any internal PM calls, even if
-it fails.  (Exercise: Why?)
-
-The rules for locking order are:
-
-	Never acquire any device semaphore while holding any PM mutex.
-
-	Never acquire udev-&gt;pm_mutex while holding the PM mutex for
-	a device that isn't a descendant of udev.
-
-In other words, PM mutexes should only be acquired going up the device
-tree, and they should be acquired only after locking all the device
-semaphores you need to hold.  These rules don't matter to drivers very
-much; they usually affect just the USB core.
-
-Still, drivers do need to be careful.  For example, many drivers use a
-private mutex to synchronize their normal I/O activities with their
-disconnect method.  Now if the driver supports autosuspend then it
-must call usb_autopm_put_interface() from somewhere -- maybe from its
-close method.  It should make the call while holding the private mutex,
-since a driver shouldn't call any of the usb_autopm_* functions for an
-interface from which it has been unbound.
-
-But the usb_autpm_* routines always acquire the device's PM mutex, and
-consequently the locking order has to be: private mutex first, PM
-mutex second.  Since the suspend method is always called with the PM
-mutex held, it mustn't try to acquire the private mutex.  It has to
-synchronize with the driver's I/O activities in some other way.
+critical section, the best way is to lock the device and call
+usb_autopm_get_interface() (and do the reverse at the end of the
+critical section).  Holding the device semaphore will block all
+external PM calls, and the usb_autopm_get_interface() will prevent any
+internal PM calls, even if it fails.  (Exercise: Why?)
 
 
 	Interaction between dynamic PM and system PM
@@ -517,22 +465,11 @@ synchronize with the driver's I/O activities in some other way.
 Dynamic power management and system power management can interact in
 a couple of ways.
 
-Firstly, a device may already be manually suspended or autosuspended
-when a system suspend occurs.  Since system suspends are supposed to
-be as transparent as possible, the device should remain suspended
-following the system resume.  The 2.6.23 kernel obeys this principle
-for manually suspended devices but not for autosuspended devices; they
-do get resumed when the system wakes up.  (Presumably they will be
-autosuspended again after their idle-delay time expires.)  In later
-kernels this behavior will be fixed.
-
-(There is an exception.  If a device would undergo a reset-resume
-instead of a normal resume, and the device is enabled for remote
-wakeup, then the reset-resume takes place even if the device was
-already suspended when the system suspend began.  The justification is
-that a reset-resume is a kind of remote-wakeup event.  Or to put it
-another way, a device which needs a reset won't be able to generate
-normal remote-wakeup signals, so it ought to be resumed immediately.)
+Firstly, a device may already be autosuspended when a system suspend
+occurs.  Since system suspends are supposed to be as transparent as
+possible, the device should remain suspended following the system
+resume.  But this theory may not work out well in practice; over time
+the kernel's behavior in this regard has changed.
 
 Secondly, a dynamic power-management event may occur as a system
 suspend is underway.  The window for this is short, since system
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index ad925946f869..97a819c23ef3 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -91,8 +91,8 @@ config USB_DYNAMIC_MINORS
 	  If you are unsure about this, say N here.
 
 config USB_SUSPEND
-	bool "USB selective suspend/resume and wakeup"
-	depends on USB &amp;&amp; PM
+	bool "USB runtime power management (suspend/resume and wakeup)"
+	depends on USB &amp;&amp; PM_RUNTIME
 	help
 	  If you say Y here, you can use driver calls or the sysfs
 	  "power/level" file to suspend or resume individual USB
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 638d54693a1c..6850ec6576f8 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -25,7 +25,7 @@
 #include &lt;linux/device.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/quirks.h&gt;
-#include &lt;linux/workqueue.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 #include "hcd.h"
 #include "usb.h"
 
@@ -221,7 +221,7 @@ static int usb_probe_device(struct device *dev)
 {
 	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
 	struct usb_device *udev = to_usb_device(dev);
-	int error = -ENODEV;
+	int error = 0;
 
 	dev_dbg(dev, "%s\n", __func__);
 
@@ -230,18 +230,23 @@ static int usb_probe_device(struct device *dev)
 	/* The device should always appear to be in use
 	 * unless the driver suports autosuspend.
 	 */
-	udev-&gt;pm_usage_cnt = !(udriver-&gt;supports_autosuspend);
+	if (!udriver-&gt;supports_autosuspend)
+		error = usb_autoresume_device(udev);
 
-	error = udriver-&gt;probe(udev);
+	if (!error)
+		error = udriver-&gt;probe(udev);
 	return error;
 }
 
 /* called from driver core with dev locked */
 static int usb_unbind_device(struct device *dev)
 {
+	struct usb_device *udev = to_usb_device(dev);
 	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
 
-	udriver-&gt;disconnect(to_usb_device(dev));
+	udriver-&gt;disconnect(udev);
+	if (!udriver-&gt;supports_autosuspend)
+		usb_autosuspend_device(udev);
 	return 0;
 }
 
@@ -293,17 +298,16 @@ static int usb_probe_interface(struct device *dev)
 	if (error)
 		return error;
 
-	/* Interface "power state" doesn't correspond to any hardware
-	 * state whatsoever.  We use it to record when it's bound to
-	 * a driver that may start I/0:  it's not frozen/quiesced.
-	 */
-	mark_active(intf);
 	intf-&gt;condition = USB_INTERFACE_BINDING;
 
-	/* The interface should always appear to be in use
-	 * unless the driver suports autosuspend.
+	/* Bound interfaces are initially active.  They are
+	 * runtime-PM-enabled only if the driver has autosuspend support.
+	 * They are sensitive to their children's power states.
 	 */
-	atomic_set(&amp;intf-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
+	pm_runtime_set_active(dev);
+	pm_suspend_ignore_children(dev, false);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_enable(dev);
 
 	/* Carry out a deferred switch to altsetting 0 */
 	if (intf-&gt;needs_altsetting0) {
@@ -323,10 +327,14 @@ static int usb_probe_interface(struct device *dev)
 	return error;
 
  err:
-	mark_quiesced(intf);
 	intf-&gt;needs_remote_wakeup = 0;
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;
 	usb_cancel_queued_reset(intf);
+
+	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+
 	usb_autosuspend_device(udev);
 	return error;
 }
@@ -376,9 +384,17 @@ static int usb_unbind_interface(struct device *dev)
 	usb_set_intfdata(intf, NULL);
 
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;
-	mark_quiesced(intf);
 	intf-&gt;needs_remote_wakeup = 0;
 
+	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+
+	/* Undo any residual pm_autopm_get_interface_* calls */
+	for (r = atomic_read(&amp;intf-&gt;pm_usage_cnt); r &gt; 0; --r)
+		usb_autopm_put_interface_no_suspend(intf);
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, 0);
+
 	if (!error)
 		usb_autosuspend_device(udev);
 
@@ -409,7 +425,6 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 				struct usb_interface *iface, void *priv)
 {
 	struct device *dev = &amp;iface-&gt;dev;
-	struct usb_device *udev = interface_to_usbdev(iface);
 	int retval = 0;
 
 	if (dev-&gt;driver)
@@ -419,11 +434,16 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	usb_set_intfdata(iface, priv);
 	iface-&gt;needs_binding = 0;
 
-	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
-	mark_active(iface);
-	atomic_set(&amp;iface-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
-	usb_pm_unlock(udev);
+
+	/* Bound interfaces are initially active.  They are
+	 * runtime-PM-enabled only if the driver has autosuspend support.
+	 * They are sensitive to their children's power states.
+	 */
+	pm_runtime_set_active(dev);
+	pm_suspend_ignore_children(dev, false);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_enable(dev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -982,7 +1002,6 @@ static void do_unbind_rebind(struct usb_device *udev, int action)
 	}
 }
 
-/* Caller has locked udev's pm_mutex */
 static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -1006,7 +1025,6 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked udev's pm_mutex */
 static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -1040,27 +1058,20 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked intf's usb_device's pm mutex */
 static int usb_suspend_interface(struct usb_device *udev,
 		struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
 	int			status = 0;
 
-	/* with no hardware, USB interfaces only use FREEZE and ON states */
-	if (udev-&gt;state == USB_STATE_NOTATTACHED || !is_active(intf))
-		goto done;
-
-	/* This can happen; see usb_driver_release_interface() */
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;suspend) {
 		status = driver-&gt;suspend(intf, msg);
-		if (status == 0)
-			mark_quiesced(intf);
-		else if (!(msg.event &amp; PM_EVENT_AUTO))
+		if (status &amp;&amp; !(msg.event &amp; PM_EVENT_AUTO))
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
 	} else {
@@ -1068,7 +1079,6 @@ static int usb_suspend_interface(struct usb_device *udev,
 		intf-&gt;needs_binding = 1;
 		dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
 				"suspend", driver-&gt;name);
-		mark_quiesced(intf);
 	}
 
  done:
@@ -1076,14 +1086,13 @@ static int usb_suspend_interface(struct usb_device *udev,
 	return status;
 }
 
-/* Caller has locked intf's usb_device's pm_mutex */
 static int usb_resume_interface(struct usb_device *udev,
 		struct usb_interface *intf, pm_message_t msg, int reset_resume)
 {
 	struct usb_driver	*driver;
 	int			status = 0;
 
-	if (udev-&gt;state == USB_STATE_NOTATTACHED || is_active(intf))
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		goto done;
 
 	/* Don't let autoresume interfere with unbinding */
@@ -1134,90 +1143,11 @@ static int usb_resume_interface(struct usb_device *udev,
 
 done:
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __func__, status);
-	if (status == 0 &amp;&amp; intf-&gt;condition == USB_INTERFACE_BOUND)
-		mark_active(intf);
 
 	/* Later we will unbind the driver and/or reprobe, if necessary */
 	return status;
 }
 
-#ifdef	CONFIG_USB_SUSPEND
-
-/* Internal routine to check whether we may autosuspend a device. */
-static int autosuspend_check(struct usb_device *udev, int reschedule)
-{
-	int			i;
-	struct usb_interface	*intf;
-	unsigned long		suspend_time, j;
-
-	/* For autosuspend, fail fast if anything is in use or autosuspend
-	 * is disabled.  Also fail if any interfaces require remote wakeup
-	 * but it isn't available.
-	 */
-	if (udev-&gt;pm_usage_cnt &gt; 0)
-		return -EBUSY;
-	if (udev-&gt;autosuspend_delay &lt; 0 || udev-&gt;autosuspend_disabled)
-		return -EPERM;
-
-	suspend_time = udev-&gt;last_busy + udev-&gt;autosuspend_delay;
-	if (udev-&gt;actconfig) {
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			intf = udev-&gt;actconfig-&gt;interface[i];
-			if (!is_active(intf))
-				continue;
-			if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0)
-				return -EBUSY;
-			if (intf-&gt;needs_remote_wakeup &amp;&amp;
-					!udev-&gt;do_remote_wakeup) {
-				dev_dbg(&amp;udev-&gt;dev, "remote wakeup needed "
-						"for autosuspend\n");
-				return -EOPNOTSUPP;
-			}
-
-			/* Don't allow autosuspend if the device will need
-			 * a reset-resume and any of its interface drivers
-			 * doesn't include support.
-			 */
-			if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME) {
-				struct usb_driver *driver;
-
-				driver = to_usb_driver(intf-&gt;dev.driver);
-				if (!driver-&gt;reset_resume ||
-				    intf-&gt;needs_remote_wakeup)
-					return -EOPNOTSUPP;
-			}
-		}
-	}
-
-	/* If everything is okay but the device hasn't been idle for long
-	 * enough, queue a delayed autosuspend request.  If the device
-	 * _has_ been idle for long enough and the reschedule flag is set,
-	 * likewise queue a delayed (1 second) autosuspend request.
-	 */
-	j = jiffies;
-	if (time_before(j, suspend_time))
-		reschedule = 1;
-	else
-		suspend_time = j + HZ;
-	if (reschedule) {
-		if (!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
-			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				round_jiffies_up_relative(suspend_time - j));
-		}
-		return -EAGAIN;
-	}
-	return 0;
-}
-
-#else
-
-static inline int autosuspend_check(struct usb_device *udev, int reschedule)
-{
-	return 0;
-}
-
-#endif	/* CONFIG_USB_SUSPEND */
-
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
  * @udev: the usb_device to suspend
@@ -1229,27 +1159,12 @@ static inline int autosuspend_check(struct usb_device *udev, int reschedule)
  * all the interfaces which were suspended are resumed so that they remain
  * in the same state as the device.
  *
- * If an autosuspend is in progress the routine checks first to make sure
- * that neither the device itself or any of its active interfaces is in use
- * (pm_usage_cnt is greater than 0).  If they are, the autosuspend fails.
- *
- * If the suspend succeeds, the routine recursively queues an autosuspend
- * request for @udev's parent device, thereby propagating the change up
- * the device tree.  If all of the parent's children are now suspended,
- * the parent will autosuspend in turn.
- *
- * The suspend method calls are subject to mutual exclusion under control
- * of @udev's pm_mutex.  Many of these calls are also under the protection
- * of @udev's device lock (including all requests originating outside the
- * USB subsystem), but autosuspend requests generated by a child device or
- * interface driver may not be.  Usbcore will insure that the method calls
- * do not arrive during bind, unbind, or reset operations.  However, drivers
- * must be prepared to handle suspend calls arriving at unpredictable times.
- * The only way to block such calls is to do an autoresume (preventing
- * autosuspends) while holding @udev's device lock (preventing outside
- * suspends).
- *
- * The caller must hold @udev-&gt;pm_mutex.
+ * Autosuspend requests originating from a child device or an interface
+ * driver may be made without the protection of @udev's device lock, but
+ * all other suspend calls will hold the lock.  Usbcore will insure that
+ * method calls do not arrive during bind, unbind, or reset operations.
+ * However drivers must be prepared to handle suspend calls arriving at
+ * unpredictable times.
  *
  * This routine can run only in process context.
  */
@@ -1258,20 +1173,11 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	int			status = 0;
 	int			i = 0;
 	struct usb_interface	*intf;
-	struct usb_device	*parent = udev-&gt;parent;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
 			udev-&gt;state == USB_STATE_SUSPENDED)
 		goto done;
 
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
-
-	if (msg.event &amp; PM_EVENT_AUTO) {
-		status = autosuspend_check(udev, 0);
-		if (status &lt; 0)
-			goto done;
-	}
-
 	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
 		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
@@ -1286,35 +1192,21 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
-		pm_message_t msg2;
-
-		msg2.event = msg.event ^ (PM_EVENT_SUSPEND | PM_EVENT_RESUME);
+		msg.event ^= (PM_EVENT_SUSPEND | PM_EVENT_RESUME);
 		while (--i &gt;= 0) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
-			usb_resume_interface(udev, intf, msg2, 0);
+			usb_resume_interface(udev, intf, msg, 0);
 		}
 
-		/* Try another autosuspend when the interfaces aren't busy */
-		if (msg.event &amp; PM_EVENT_AUTO)
-			autosuspend_check(udev, status == -EBUSY);
-
-	/* If the suspend succeeded then prevent any more URB submissions,
-	 * flush any outstanding URBs, and propagate the suspend up the tree.
+	/* If the suspend succeeded then prevent any more URB submissions
+	 * and flush any outstanding URBs.
 	 */
 	} else {
-		cancel_delayed_work(&amp;udev-&gt;autosuspend);
 		udev-&gt;can_submit = 0;
 		for (i = 0; i &lt; 16; ++i) {
 			usb_hcd_flush_endpoint(udev, udev-&gt;ep_out[i]);
 			usb_hcd_flush_endpoint(udev, udev-&gt;ep_in[i]);
 		}
-
-		/* If this is just a FREEZE or a PRETHAW, udev might
-		 * not really be suspended.  Only true suspends get
-		 * propagated up the device tree.
-		 */
-		if (parent &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
-			usb_autosuspend_device(parent);
 	}
 
  done:
@@ -1331,23 +1223,12 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
  * the resume method for @udev and then calls the resume methods for all
  * the interface drivers in @udev.
  *
- * Before starting the resume, the routine calls itself recursively for
- * the parent device of @udev, thereby propagating the change up the device
- * tree and assuring that @udev will be able to resume.  If the parent is
- * unable to resume successfully, the routine fails.
- *
- * The resume method calls are subject to mutual exclusion under control
- * of @udev's pm_mutex.  Many of these calls are also under the protection
- * of @udev's device lock (including all requests originating outside the
- * USB subsystem), but autoresume requests generated by a child device or
- * interface driver may not be.  Usbcore will insure that the method calls
- * do not arrive during bind, unbind, or reset operations.  However, drivers
- * must be prepared to handle resume calls arriving at unpredictable times.
- * The only way to block such calls is to do an autoresume (preventing
- * other autoresumes) while holding @udev's device lock (preventing outside
- * resumes).
- *
- * The caller must hold @udev-&gt;pm_mutex.
+ * Autoresume requests originating from a child device or an interface
+ * driver may be made without the protection of @udev's device lock, but
+ * all other resume calls will hold the lock.  Usbcore will insure that
+ * method calls do not arrive during bind, unbind, or reset operations.
+ * However drivers must be prepared to handle resume calls arriving at
+ * unpredictable times.
  *
  * This routine can run only in process context.
  */
@@ -1356,48 +1237,18 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	int			status = 0;
 	int			i;
 	struct usb_interface	*intf;
-	struct usb_device	*parent = udev-&gt;parent;
 
-	cancel_delayed_work(&amp;udev-&gt;autosuspend);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED) {
 		status = -ENODEV;
 		goto done;
 	}
 	udev-&gt;can_submit = 1;
 
-	/* Propagate the resume up the tree, if necessary */
-	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		if (parent) {
-			status = usb_autoresume_device(parent);
-			if (status == 0) {
-				status = usb_resume_device(udev, msg);
-				if (status || udev-&gt;state ==
-						USB_STATE_NOTATTACHED) {
-					usb_autosuspend_device(parent);
-
-					/* It's possible usb_resume_device()
-					 * failed after the port was
-					 * unsuspended, causing udev to be
-					 * logically disconnected.  We don't
-					 * want usb_disconnect() to autosuspend
-					 * the parent again, so tell it that
-					 * udev disconnected while still
-					 * suspended. */
-					if (udev-&gt;state ==
-							USB_STATE_NOTATTACHED)
-						udev-&gt;discon_suspended = 1;
-				}
-			}
-		} else {
-
-			/* We can't progagate beyond the USB subsystem,
-			 * so if a root hub's controller is suspended
-			 * then we're stuck. */
-			status = usb_resume_device(udev, msg);
-		}
-	} else if (udev-&gt;reset_resume)
+	/* Resume the device */
+	if (udev-&gt;state == USB_STATE_SUSPENDED || udev-&gt;reset_resume)
 		status = usb_resume_device(udev, msg);
 
+	/* Resume the interfaces */
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -1413,104 +1264,46 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-/**
- * usb_external_suspend_device - external suspend of a USB device and its interfaces
- * @udev: the usb_device to suspend
- * @msg: Power Management message describing this state transition
- *
- * This routine handles external suspend requests: ones not generated
- * internally by a USB driver (autosuspend) but rather coming from the user
- * (via sysfs) or the PM core (system sleep).  The suspend will be carried
- * out regardless of @udev's usage counter or those of its interfaces,
- * and regardless of whether or not remote wakeup is enabled.  Of course,
- * interface drivers still have the option of failing the suspend (if
- * there are unsuspended children, for example).
- *
- * The caller must hold @udev's device lock.
- */
-int usb_external_suspend_device(struct usb_device *udev, pm_message_t msg)
-{
-	int	status;
-
-	do_unbind_rebind(udev, DO_UNBIND);
-	usb_pm_lock(udev);
-	status = usb_suspend_both(udev, msg);
-	usb_pm_unlock(udev);
-	return status;
-}
-
-/**
- * usb_external_resume_device - external resume of a USB device and its interfaces
- * @udev: the usb_device to resume
- * @msg: Power Management message describing this state transition
- *
- * This routine handles external resume requests: ones not generated
- * internally by a USB driver (autoresume) but rather coming from the user
- * (via sysfs), the PM core (system resume), or the device itself (remote
- * wakeup).  @udev's usage counter is unaffected.
- *
- * The caller must hold @udev's device lock.
- */
-int usb_external_resume_device(struct usb_device *udev, pm_message_t msg)
-{
-	int	status;
-
-	usb_pm_lock(udev);
-	status = usb_resume_both(udev, msg);
-	udev-&gt;last_busy = jiffies;
-	usb_pm_unlock(udev);
-	if (status == 0)
-		do_unbind_rebind(udev, DO_REBIND);
-
-	/* Now that the device is awake, we can start trying to autosuspend
-	 * it again. */
-	if (status == 0)
-		usb_try_autosuspend_device(udev);
-	return status;
-}
-
+/* The device lock is held by the PM core */
 int usb_suspend(struct device *dev, pm_message_t msg)
 {
-	struct usb_device	*udev;
-
-	udev = to_usb_device(dev);
+	struct usb_device	*udev = to_usb_device(dev);
 
-	/* If udev is already suspended, we can skip this suspend and
-	 * we should also skip the upcoming system resume.  High-speed
-	 * root hubs are an exception; they need to resume whenever the
-	 * system wakes up in order for USB-PERSIST port handover to work
-	 * properly.
-	 */
-	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		if (udev-&gt;parent || udev-&gt;speed != USB_SPEED_HIGH)
-			udev-&gt;skip_sys_resume = 1;
-		return 0;
-	}
-
-	udev-&gt;skip_sys_resume = 0;
-	return usb_external_suspend_device(udev, msg);
+	do_unbind_rebind(udev, DO_UNBIND);
+	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	return usb_suspend_both(udev, msg);
 }
 
+/* The device lock is held by the PM core */
 int usb_resume(struct device *dev, pm_message_t msg)
 {
-	struct usb_device	*udev;
+	struct usb_device	*udev = to_usb_device(dev);
 	int			status;
 
-	udev = to_usb_device(dev);
+	/* For PM complete calls, all we do is rebind interfaces */
+	if (msg.event == PM_EVENT_ON) {
+		if (udev-&gt;state != USB_STATE_NOTATTACHED)
+			do_unbind_rebind(udev, DO_REBIND);
+		status = 0;
 
-	/* If udev-&gt;skip_sys_resume is set then udev was already suspended
-	 * when the system sleep started, so we don't want to resume it
-	 * during this system wakeup.
+	/* For all other calls, take the device back to full power and
+	 * tell the PM core in case it was autosuspended previously.
 	 */
-	if (udev-&gt;skip_sys_resume)
-		return 0;
-	status = usb_external_resume_device(udev, msg);
+	} else {
+		status = usb_resume_both(udev, msg);
+		if (status == 0) {
+			pm_runtime_disable(dev);
+			pm_runtime_set_active(dev);
+			pm_runtime_enable(dev);
+			udev-&gt;last_busy = jiffies;
+		}
+	}
 
 	/* Avoid PM error messages for devices disconnected while suspended
 	 * as we'll display regular disconnect messages just a bit later.
 	 */
 	if (status == -ENODEV)
-		return 0;
+		status = 0;
 	return status;
 }
 
@@ -1560,54 +1353,6 @@ int usb_disable_autosuspend(struct usb_device *udev)
 }
 EXPORT_SYMBOL_GPL(usb_disable_autosuspend);
 
-/* Internal routine to adjust a device's usage counter and change
- * its autosuspend state.
- */
-static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
-{
-	int	status = 0;
-
-	usb_pm_lock(udev);
-	udev-&gt;pm_usage_cnt += inc_usage_cnt;
-	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
-	if (inc_usage_cnt)
-		udev-&gt;last_busy = jiffies;
-	if (inc_usage_cnt &gt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &gt; 0) {
-		if (udev-&gt;state == USB_STATE_SUSPENDED)
-			status = usb_resume_both(udev, PMSG_AUTO_RESUME);
-		if (status != 0)
-			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-		else if (inc_usage_cnt)
-			udev-&gt;last_busy = jiffies;
-	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &lt;= 0) {
-		status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
-	}
-	usb_pm_unlock(udev);
-	return status;
-}
-
-/* usb_autosuspend_work - callback routine to autosuspend a USB device */
-void usb_autosuspend_work(struct work_struct *work)
-{
-	struct usb_device *udev =
-		container_of(work, struct usb_device, autosuspend.work);
-
-	usb_autopm_do_device(udev, 0);
-}
-
-/* usb_autoresume_work - callback routine to autoresume a USB device */
-void usb_autoresume_work(struct work_struct *work)
-{
-	struct usb_device *udev =
-		container_of(work, struct usb_device, autoresume);
-
-	/* Wake it up, let the drivers do their thing, and then put it
-	 * back to sleep.
-	 */
-	if (usb_autopm_do_device(udev, 1) == 0)
-		usb_autopm_do_device(udev, -1);
-}
-
 /**
  * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
  * @udev: the usb_device to autosuspend
@@ -1616,12 +1361,9 @@ void usb_autoresume_work(struct work_struct *work)
  * @udev and wants to allow it to autosuspend.  Examples would be when
  * @udev's device file in usbfs is closed or after a configuration change.
  *
- * @udev's usage counter is decremented.  If it or any of the usage counters
- * for an active interface is greater than 0, no autosuspend request will be
- * queued.  (If an interface driver does not support autosuspend then its
- * usage counter is permanently positive.)  Furthermore, if an interface
- * driver requires remote-wakeup capability during autosuspend but remote
- * wakeup is disabled, the autosuspend will fail.
+ * @udev's usage counter is decremented; if it drops to 0 and all the
+ * interfaces are inactive then a delayed autosuspend will be attempted.
+ * The attempt may fail (see autosuspend_check()).
  *
  * The caller must hold @udev's device lock.
  *
@@ -1631,9 +1373,11 @@ void usb_autosuspend_device(struct usb_device *udev)
 {
 	int	status;
 
-	status = usb_autopm_do_device(udev, -1);
-	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-			__func__, udev-&gt;pm_usage_cnt);
+	udev-&gt;last_busy = jiffies;
+	status = pm_runtime_put_sync(&amp;udev-&gt;dev);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;udev-&gt;dev.power.usage_count),
+			status);
 }
 
 /**
@@ -1643,9 +1387,9 @@ void usb_autosuspend_device(struct usb_device *udev)
  * This routine should be called when a core subsystem thinks @udev may
  * be ready to autosuspend.
  *
- * @udev's usage counter left unchanged.  If it or any of the usage counters
- * for an active interface is greater than 0, or autosuspend is not allowed
- * for any other reason, no autosuspend request will be queued.
+ * @udev's usage counter left unchanged.  If it is 0 and all the interfaces
+ * are inactive then an autosuspend will be attempted.  The attempt may
+ * fail or be delayed.
  *
  * The caller must hold @udev's device lock.
  *
@@ -1653,9 +1397,12 @@ void usb_autosuspend_device(struct usb_device *udev)
  */
 void usb_try_autosuspend_device(struct usb_device *udev)
 {
-	usb_autopm_do_device(udev, 0);
-	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-			__func__, udev-&gt;pm_usage_cnt);
+	int	status;
+
+	status = pm_runtime_idle(&amp;udev-&gt;dev);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;udev-&gt;dev.power.usage_count),
+			status);
 }
 
 /**
@@ -1664,9 +1411,9 @@ void usb_try_autosuspend_device(struct usb_device *udev)
  *
  * This routine should be called when a core subsystem wants to use @udev
  * and needs to guarantee that it is not suspended.  No autosuspend will
- * occur until usb_autosuspend_device is called.  (Note that this will not
- * prevent suspend events originating in the PM core.)  Examples would be
- * when @udev's device file in usbfs is opened or when a remote-wakeup
+ * occur until usb_autosuspend_device() is called.  (Note that this will
+ * not prevent suspend events originating in the PM core.)  Examples would
+ * be when @udev's device file in usbfs is opened or when a remote-wakeup
  * request is received.
  *
  * @udev's usage counter is incremented to prevent subsequent autosuspends.
@@ -1680,42 +1427,14 @@ int usb_autoresume_device(struct usb_device *udev)
 {
 	int	status;
 
-	status = usb_autopm_do_device(udev, 1);
-	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, udev-&gt;pm_usage_cnt);
-	return status;
-}
-
-/* Internal routine to adjust an interface's usage counter and change
- * its device's autosuspend state.
- */
-static int usb_autopm_do_interface(struct usb_interface *intf,
-		int inc_usage_cnt)
-{
-	struct usb_device	*udev = interface_to_usbdev(intf);
-	int			status = 0;
-
-	usb_pm_lock(udev);
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
-		status = -ENODEV;
-	else {
-		atomic_add(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
-		udev-&gt;last_busy = jiffies;
-		if (inc_usage_cnt &gt;= 0 &amp;&amp;
-				atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0) {
-			if (udev-&gt;state == USB_STATE_SUSPENDED)
-				status = usb_resume_both(udev,
-						PMSG_AUTO_RESUME);
-			if (status != 0)
-				atomic_sub(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
-			else
-				udev-&gt;last_busy = jiffies;
-		} else if (inc_usage_cnt &lt;= 0 &amp;&amp;
-				atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0) {
-			status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
-		}
-	}
-	usb_pm_unlock(udev);
+	status = pm_runtime_get_sync(&amp;udev-&gt;dev);
+	if (status &lt; 0)
+		pm_runtime_put_sync(&amp;udev-&gt;dev);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;udev-&gt;dev.power.usage_count),
+			status);
+	if (status &gt; 0)
+		status = 0;
 	return status;
 }
 
@@ -1729,34 +1448,25 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
  * closed.
  *
  * The routine decrements @intf's usage counter.  When the counter reaches
- * 0, a delayed autosuspend request for @intf's device is queued.  When
- * the delay expires, if @intf-&gt;pm_usage_cnt is still &lt;= 0 along with all
- * the other usage counters for the sibling interfaces and @intf's
- * usb_device, the device and all its interfaces will be autosuspended.
- *
- * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
- * core will not change its value other than the increment and decrement
- * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
- * may use this simple counter-oriented discipline or may set the value
- * any way it likes.
+ * 0, a delayed autosuspend request for @intf's device is attempted.  The
+ * attempt may fail (see autosuspend_check()).
  *
  * If the driver has set @intf-&gt;needs_remote_wakeup then autosuspend will
  * take place only if the device's remote-wakeup facility is enabled.
  *
- * Suspend method calls queued by this routine can arrive at any time
- * while @intf is resumed and its usage counter is equal to 0.  They are
- * not protected by the usb_device's lock but only by its pm_mutex.
- * Drivers must provide their own synchronization.
- *
  * This routine can run only in process context.
  */
 void usb_autopm_put_interface(struct usb_interface *intf)
 {
-	int	status;
+	struct usb_device	*udev = interface_to_usbdev(intf);
+	int			status;
 
-	status = usb_autopm_do_interface(intf, -1);
-	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
+	udev-&gt;last_busy = jiffies;
+	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
+	status = pm_runtime_put_sync(&amp;intf-&gt;dev);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
+			status);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1764,11 +1474,11 @@ EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
  * usb_autopm_put_interface_async - decrement a USB interface's PM-usage counter
  * @intf: the usb_interface whose counter should be decremented
  *
- * This routine does essentially the same thing as
- * usb_autopm_put_interface(): it decrements @intf's usage counter and
- * queues a delayed autosuspend request if the counter is &lt;= 0.  The
- * difference is that it does not acquire the device's pm_mutex;
- * callers must handle all synchronization issues themselves.
+ * This routine does much the same thing as usb_autopm_put_interface():
+ * It decrements @intf's usage counter and schedules a delayed
+ * autosuspend request if the counter is &lt;= 0.  The difference is that it
+ * does not perform any synchronization; callers should hold a private
+ * lock and handle all synchronization issues themselves.
  *
  * Typically a driver would call this routine during an URB's completion
  * handler, if no more URBs were pending.
@@ -1778,27 +1488,57 @@ EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 void usb_autopm_put_interface_async(struct usb_interface *intf)
 {
 	struct usb_device	*udev = interface_to_usbdev(intf);
+	unsigned long		last_busy;
 	int			status = 0;
 
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
-		status = -ENODEV;
-	} else {
-		udev-&gt;last_busy = jiffies;
-		atomic_dec(&amp;intf-&gt;pm_usage_cnt);
-		if (udev-&gt;autosuspend_disabled || udev-&gt;autosuspend_delay &lt; 0)
-			status = -EPERM;
-		else if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0 &amp;&amp;
-				!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
-			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+	last_busy = udev-&gt;last_busy;
+	udev-&gt;last_busy = jiffies;
+	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
+	pm_runtime_put_noidle(&amp;intf-&gt;dev);
+
+	if (!udev-&gt;autosuspend_disabled) {
+		/* Optimization: Don't schedule a delayed autosuspend if
+		 * the timer is already running and the expiration time
+		 * wouldn't change.
+		 *
+		 * We have to use the interface's timer.  Attempts to
+		 * schedule a suspend for the device would fail because
+		 * the interface is still active.
+		 */
+		if (intf-&gt;dev.power.timer_expires == 0 ||
+				round_jiffies_up(last_busy) !=
+				round_jiffies_up(jiffies)) {
+			status = pm_schedule_suspend(&amp;intf-&gt;dev,
+					jiffies_to_msecs(
 					round_jiffies_up_relative(
-						udev-&gt;autosuspend_delay));
+						udev-&gt;autosuspend_delay)));
 		}
 	}
-	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
+	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
+			status);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface_async);
 
+/**
+ * usb_autopm_put_interface_no_suspend - decrement a USB interface's PM-usage counter
+ * @intf: the usb_interface whose counter should be decremented
+ *
+ * This routine decrements @intf's usage counter but does not carry out an
+ * autosuspend.
+ *
+ * This routine can run in atomic context.
+ */
+void usb_autopm_put_interface_no_suspend(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+
+	udev-&gt;last_busy = jiffies;
+	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
+	pm_runtime_put_noidle(&amp;intf-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_autopm_put_interface_no_suspend);
+
 /**
  * usb_autopm_get_interface - increment a USB interface's PM-usage counter
  * @intf: the usb_interface whose counter should be incremented
@@ -1811,25 +1551,8 @@ EXPORT_SYMBOL_GPL(usb_autopm_put_interface_async);
  * or @intf is unbound.  A typical example would be a character-device
  * driver when its device file is opened.
  *
- *
- * The routine increments @intf's usage counter.  (However if the
- * autoresume fails then the counter is re-decremented.)  So long as the
- * counter is greater than 0, autosuspend will not be allowed for @intf
- * or its usb_device.  When the driver is finished using @intf it should
- * call usb_autopm_put_interface() to decrement the usage counter and
- * queue a delayed autosuspend request (if the counter is &lt;= 0).
- *
- *
- * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
- * core will not change its value other than the increment and decrement
- * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
- * may use this simple counter-oriented discipline or may set the value
- * any way it likes.
- *
- * Resume method calls generated by this routine can arrive at any time
- * while @intf is suspended.  They are not protected by the usb_device's
- * lock but only by its pm_mutex.  Drivers must provide their own
- * synchronization.
+ * @intf's usage counter is incremented to prevent subsequent autosuspends.
+ * However if the autoresume fails then the counter is re-decremented.
  *
  * This routine can run only in process context.
  */
@@ -1837,9 +1560,16 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 {
 	int	status;
 
-	status = usb_autopm_do_interface(intf, 1);
-	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
+	status = pm_runtime_get_sync(&amp;intf-&gt;dev);
+	if (status &lt; 0)
+		pm_runtime_put_sync(&amp;intf-&gt;dev);
+	else
+		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
+			status);
+	if (status &gt; 0)
+		status = 0;
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
@@ -1849,41 +1579,201 @@ EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
  * @intf: the usb_interface whose counter should be incremented
  *
  * This routine does much the same thing as
- * usb_autopm_get_interface(): it increments @intf's usage counter and
- * queues an autoresume request if the result is &gt; 0.  The differences
- * are that it does not acquire the device's pm_mutex (callers must
- * handle all synchronization issues themselves), and it does not
- * autoresume the device directly (it only queues a request).  After a
- * successful call, the device will generally not yet be resumed.
+ * usb_autopm_get_interface(): It increments @intf's usage counter and
+ * queues an autoresume request if the device is suspended.  The
+ * differences are that it does not perform any synchronization (callers
+ * should hold a private lock and handle all synchronization issues
+ * themselves), and it does not autoresume the device directly (it only
+ * queues a request).  After a successful call, the device may not yet be
+ * resumed.
  *
  * This routine can run in atomic context.
  */
 int usb_autopm_get_interface_async(struct usb_interface *intf)
 {
-	struct usb_device	*udev = interface_to_usbdev(intf);
-	int			status = 0;
+	int		status = 0;
+	enum rpm_status	s;
 
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
-		status = -ENODEV;
-	else {
+	/* Don't request a resume unless the interface is already suspending
+	 * or suspended.  Doing so would force a running suspend timer to be
+	 * cancelled.
+	 */
+	pm_runtime_get_noresume(&amp;intf-&gt;dev);
+	s = ACCESS_ONCE(intf-&gt;dev.power.runtime_status);
+	if (s == RPM_SUSPENDING || s == RPM_SUSPENDED)
+		status = pm_request_resume(&amp;intf-&gt;dev);
+
+	if (status &lt; 0 &amp;&amp; status != -EINPROGRESS)
+		pm_runtime_put_noidle(&amp;intf-&gt;dev);
+	else
 		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
-		if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0 &amp;&amp;
-				udev-&gt;state == USB_STATE_SUSPENDED)
-			queue_work(ksuspend_usb_wq, &amp;udev-&gt;autoresume);
-	}
-	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
+	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
+			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
+			status);
+	if (status &gt; 0)
+		status = 0;
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface_async);
 
-#else
+/**
+ * usb_autopm_get_interface_no_resume - increment a USB interface's PM-usage counter
+ * @intf: the usb_interface whose counter should be incremented
+ *
+ * This routine increments @intf's usage counter but does not carry out an
+ * autoresume.
+ *
+ * This routine can run in atomic context.
+ */
+void usb_autopm_get_interface_no_resume(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+
+	udev-&gt;last_busy = jiffies;
+	atomic_inc(&amp;intf-&gt;pm_usage_cnt);
+	pm_runtime_get_noresume(&amp;intf-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_autopm_get_interface_no_resume);
+
+/* Internal routine to check whether we may autosuspend a device. */
+static int autosuspend_check(struct usb_device *udev)
+{
+	int			i;
+	struct usb_interface	*intf;
+	unsigned long		suspend_time, j;
+
+	/* Fail if autosuspend is disabled, or any interfaces are in use, or
+	 * any interface drivers require remote wakeup but it isn't available.
+	 */
+	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	if (udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+
+			/* We don't need to check interfaces that are
+			 * disabled for runtime PM.  Either they are unbound
+			 * or else their drivers don't support autosuspend
+			 * and so they are permanently active.
+			 */
+			if (intf-&gt;dev.power.disable_depth)
+				continue;
+			if (atomic_read(&amp;intf-&gt;dev.power.usage_count) &gt; 0)
+				return -EBUSY;
+			if (intf-&gt;needs_remote_wakeup &amp;&amp;
+					!udev-&gt;do_remote_wakeup) {
+				dev_dbg(&amp;udev-&gt;dev, "remote wakeup needed "
+						"for autosuspend\n");
+				return -EOPNOTSUPP;
+			}
+
+			/* Don't allow autosuspend if the device will need
+			 * a reset-resume and any of its interface drivers
+			 * doesn't include support or needs remote wakeup.
+			 */
+			if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME) {
+				struct usb_driver *driver;
+
+				driver = to_usb_driver(intf-&gt;dev.driver);
+				if (!driver-&gt;reset_resume ||
+						intf-&gt;needs_remote_wakeup)
+					return -EOPNOTSUPP;
+			}
+		}
+	}
+
+	/* If everything is okay but the device hasn't been idle for long
+	 * enough, queue a delayed autosuspend request.
+	 */
+	j = ACCESS_ONCE(jiffies);
+	suspend_time = udev-&gt;last_busy + udev-&gt;autosuspend_delay;
+	if (time_before(j, suspend_time)) {
+		pm_schedule_suspend(&amp;udev-&gt;dev, jiffies_to_msecs(
+				round_jiffies_up_relative(suspend_time - j)));
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int usb_runtime_suspend(struct device *dev)
+{
+	int	status = 0;
 
-void usb_autosuspend_work(struct work_struct *work)
-{}
+	/* A USB device can be suspended if it passes the various autosuspend
+	 * checks.  Runtime suspend for a USB device means suspending all the
+	 * interfaces and then the device itself.
+	 */
+	if (is_usb_device(dev)) {
+		struct usb_device	*udev = to_usb_device(dev);
+
+		if (autosuspend_check(udev) != 0)
+			return -EAGAIN;
+
+		status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
+
+		/* If an interface fails the suspend, adjust the last_busy
+		 * time so that we don't get another suspend attempt right
+		 * away.
+		 */
+		if (status) {
+			udev-&gt;last_busy = jiffies +
+					(udev-&gt;autosuspend_delay == 0 ?
+						HZ/2 : 0);
+		}
+
+		/* Prevent the parent from suspending immediately after */
+		else if (udev-&gt;parent) {
+			udev-&gt;parent-&gt;last_busy = jiffies;
+		}
+	}
+
+	/* Runtime suspend for a USB interface doesn't mean anything. */
+	return status;
+}
+
+static int usb_runtime_resume(struct device *dev)
+{
+	/* Runtime resume for a USB device means resuming both the device
+	 * and all its interfaces.
+	 */
+	if (is_usb_device(dev)) {
+		struct usb_device	*udev = to_usb_device(dev);
+		int			status;
+
+		status = usb_resume_both(udev, PMSG_AUTO_RESUME);
+		udev-&gt;last_busy = jiffies;
+		return status;
+	}
+
+	/* Runtime resume for a USB interface doesn't mean anything. */
+	return 0;
+}
+
+static int usb_runtime_idle(struct device *dev)
+{
+	/* An idle USB device can be suspended if it passes the various
+	 * autosuspend checks.  An idle interface can be suspended at
+	 * any time.
+	 */
+	if (is_usb_device(dev)) {
+		struct usb_device	*udev = to_usb_device(dev);
+
+		if (autosuspend_check(udev) != 0)
+			return 0;
+	}
+
+	pm_runtime_suspend(dev);
+	return 0;
+}
+
+static struct dev_pm_ops usb_bus_pm_ops = {
+	.runtime_suspend =	usb_runtime_suspend,
+	.runtime_resume =	usb_runtime_resume,
+	.runtime_idle =		usb_runtime_idle,
+};
+
+#else
 
-void usb_autoresume_work(struct work_struct *work)
-{}
+#define usb_bus_pm_ops	(*(struct dev_pm_ops *) NULL)
 
 #endif /* CONFIG_USB_SUSPEND */
 
@@ -1891,4 +1781,5 @@ struct bus_type usb_bus_type = {
 	.name =		"usb",
 	.match =	usb_device_match,
 	.uevent =	usb_uevent,
+	.pm =		&amp;usb_bus_pm_ops,
 };
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index fc4290b6691c..b07ba051118d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -39,6 +39,7 @@
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;linux/usb.h&gt;
 
@@ -1858,6 +1859,10 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	return status;
 }
 
+#endif	/* CONFIG_PM */
+
+#ifdef	CONFIG_USB_SUSPEND
+
 /* Workqueue routine for root-hub remote wakeup */
 static void hcd_resume_work(struct work_struct *work)
 {
@@ -1884,12 +1889,12 @@ void usb_hcd_resume_root_hub (struct usb_hcd *hcd)
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered)
-		queue_work(ksuspend_usb_wq, &amp;hcd-&gt;wakeup_work);
+		queue_work(pm_wq, &amp;hcd-&gt;wakeup_work);
 	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_hcd_resume_root_hub);
 
-#endif
+#endif	/* CONFIG_USB_SUSPEND */
 
 /*-------------------------------------------------------------------------*/
 
@@ -2034,7 +2039,7 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	init_timer(&amp;hcd-&gt;rh_timer);
 	hcd-&gt;rh_timer.function = rh_timer_func;
 	hcd-&gt;rh_timer.data = (unsigned long) hcd;
-#ifdef CONFIG_PM
+#ifdef CONFIG_USB_SUSPEND
 	INIT_WORK(&amp;hcd-&gt;wakeup_work, hcd_resume_work);
 #endif
 	mutex_init(&amp;hcd-&gt;bandwidth_mutex);
@@ -2234,7 +2239,7 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	hcd-&gt;rh_registered = 0;
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_USB_SUSPEND
 	cancel_work_sync(&amp;hcd-&gt;wakeup_work);
 #endif
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 70a7e490f81b..8953ded69541 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -80,7 +80,7 @@ struct usb_hcd {
 
 	struct timer_list	rh_timer;	/* drives root-hub polling */
 	struct urb		*status_urb;	/* the current status urb */
-#ifdef CONFIG_PM
+#ifdef CONFIG_USB_SUSPEND
 	struct work_struct	wakeup_work;	/* for remote wakeup */
 #endif
 
@@ -464,16 +464,20 @@ extern int usb_find_interface_driver(struct usb_device *dev,
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) &amp; USB_DIR_IN))
 
 #ifdef CONFIG_PM
-extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
 extern void usb_root_hub_lost_power(struct usb_device *rhdev);
 extern int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg);
 extern int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg);
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_USB_SUSPEND
+extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd);
 #else
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
 }
-#endif /* CONFIG_PM */
+#endif /* CONFIG_USB_SUSPEND */
+
 
 /*
  * USB device fs stuff
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 746f26f222ab..0e0a190bbd00 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -22,6 +22,7 @@
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/freezer.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/byteorder.h&gt;
@@ -71,7 +72,6 @@ struct usb_hub {
 
 	unsigned		mA_per_port;	/* current for each child */
 
-	unsigned		init_done:1;
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		disconnected:1;
@@ -820,7 +820,6 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	}
  init3:
 	hub-&gt;quiescing = 0;
-	hub-&gt;init_done = 1;
 
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
 	if (status &lt; 0)
@@ -861,11 +860,6 @@ static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)
 	int i;
 
 	cancel_delayed_work_sync(&amp;hub-&gt;init_work);
-	if (!hub-&gt;init_done) {
-		hub-&gt;init_done = 1;
-		usb_autopm_put_interface_no_suspend(
-				to_usb_interface(hub-&gt;intfdev));
-	}
 
 	/* khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
@@ -1405,10 +1399,8 @@ static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 		if (udev-&gt;children[i])
 			recursively_mark_NOTATTACHED(udev-&gt;children[i]);
 	}
-	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		udev-&gt;discon_suspended = 1;
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
 		udev-&gt;active_duration -= jiffies;
-	}
 	udev-&gt;state = USB_STATE_NOTATTACHED;
 }
 
@@ -1532,31 +1524,6 @@ static void update_address(struct usb_device *udev, int devnum)
 		udev-&gt;devnum = devnum;
 }
 
-#ifdef	CONFIG_USB_SUSPEND
-
-static void usb_stop_pm(struct usb_device *udev)
-{
-	/* Synchronize with the ksuspend thread to prevent any more
-	 * autosuspend requests from being submitted, and decrement
-	 * the parent's count of unsuspended children.
-	 */
-	usb_pm_lock(udev);
-	if (udev-&gt;parent &amp;&amp; !udev-&gt;discon_suspended)
-		usb_autosuspend_device(udev-&gt;parent);
-	usb_pm_unlock(udev);
-
-	/* Stop any autosuspend or autoresume requests already submitted */
-	cancel_delayed_work_sync(&amp;udev-&gt;autosuspend);
-	cancel_work_sync(&amp;udev-&gt;autoresume);
-}
-
-#else
-
-static inline void usb_stop_pm(struct usb_device *udev)
-{ }
-
-#endif
-
 /**
  * usb_disconnect - disconnect a device (usbcore-internal)
  * @pdev: pointer to device being disconnected
@@ -1625,8 +1592,6 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	usb_stop_pm(udev);
-
 	put_device(&amp;udev-&gt;dev);
 }
 
@@ -1803,9 +1768,6 @@ int usb_new_device(struct usb_device *udev)
 	int err;
 
 	if (udev-&gt;parent) {
-		/* Increment the parent's count of unsuspended children */
-		usb_autoresume_device(udev-&gt;parent);
-
 		/* Initialize non-root-hub device wakeup to disabled;
 		 * device (un)configuration controls wakeup capable
 		 * sysfs power/wakeup controls wakeup enabled/disabled
@@ -1814,6 +1776,10 @@ int usb_new_device(struct usb_device *udev)
 		device_set_wakeup_enable(&amp;udev-&gt;dev, 1);
 	}
 
+	/* Tell the runtime-PM framework the device is active */
+	pm_runtime_set_active(&amp;udev-&gt;dev);
+	pm_runtime_enable(&amp;udev-&gt;dev);
+
 	usb_detect_quirks(udev);
 	err = usb_enumerate_device(udev);	/* Read descriptors */
 	if (err &lt; 0)
@@ -1844,7 +1810,8 @@ int usb_new_device(struct usb_device *udev)
 
 fail:
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-	usb_stop_pm(udev);
+	pm_runtime_disable(&amp;udev-&gt;dev);
+	pm_runtime_set_suspended(&amp;udev-&gt;dev);
 	return err;
 }
 
@@ -2408,8 +2375,11 @@ int usb_remote_wakeup(struct usb_device *udev)
 
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
-		usb_mark_last_busy(udev);
-		status = usb_external_resume_device(udev, PMSG_REMOTE_RESUME);
+		status = usb_autoresume_device(udev);
+		if (status == 0) {
+			/* Let the drivers do their thing, then... */
+			usb_autosuspend_device(udev);
+		}
 	}
 	return status;
 }
@@ -2446,11 +2416,6 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-int usb_remote_wakeup(struct usb_device *udev)
-{
-	return 0;
-}
-
 #endif
 
 static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
@@ -3268,7 +3233,7 @@ static void hub_events(void)
 		 * disconnected while waiting for the lock to succeed. */
 		usb_lock_device(hdev);
 		if (unlikely(hub-&gt;disconnected))
-			goto loop2;
+			goto loop_disconnected;
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
@@ -3428,7 +3393,7 @@ static void hub_events(void)
 		 * kick_khubd() and allow autosuspend.
 		 */
 		usb_autopm_put_interface(intf);
- loop2:
+ loop_disconnected:
 		usb_unlock_device(hdev);
 		kref_put(&amp;hub-&gt;kref, hub_release);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index df73574a9cc9..73de41bb2546 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1843,7 +1843,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
 		INIT_WORK(&amp;intf-&gt;reset_ws, __usb_queue_reset_device);
 		device_initialize(&amp;intf-&gt;dev);
-		mark_quiesced(intf);
 		dev_set_name(&amp;intf-&gt;dev, "%d-%s:%d.%d",
 			dev-&gt;bus-&gt;busnum, dev-&gt;devpath,
 			configuration, alt-&gt;desc.bInterfaceNumber);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0daff0d968ba..32966ccdff63 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -49,9 +49,6 @@ const char *usbcore_name = "usbcore";
 
 static int nousb;	/* Disable USB when built into kernel image */
 
-/* Workqueue for autosuspend and for remote wakeup of root hubs */
-struct workqueue_struct *ksuspend_usb_wq;
-
 #ifdef	CONFIG_USB_SUSPEND
 static int usb_autosuspend_delay = 2;		/* Default delay value,
 						 * in seconds */
@@ -264,23 +261,6 @@ static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 #ifdef	CONFIG_PM
 
-static int ksuspend_usb_init(void)
-{
-	/* This workqueue is supposed to be both freezable and
-	 * singlethreaded.  Its job doesn't justify running on more
-	 * than one CPU.
-	 */
-	ksuspend_usb_wq = create_freezeable_workqueue("ksuspend_usbd");
-	if (!ksuspend_usb_wq)
-		return -ENOMEM;
-	return 0;
-}
-
-static void ksuspend_usb_cleanup(void)
-{
-	destroy_workqueue(ksuspend_usb_wq);
-}
-
 /* USB device Power-Management thunks.
  * There's no need to distinguish here between quiescing a USB device
  * and powering it down; the generic_suspend() routine takes care of
@@ -296,7 +276,7 @@ static int usb_dev_prepare(struct device *dev)
 static void usb_dev_complete(struct device *dev)
 {
 	/* Currently used only for rebinding interfaces */
-	usb_resume(dev, PMSG_RESUME);	/* Message event is meaningless */
+	usb_resume(dev, PMSG_ON);	/* FIXME: change to PMSG_COMPLETE */
 }
 
 static int usb_dev_suspend(struct device *dev)
@@ -342,9 +322,7 @@ static const struct dev_pm_ops usb_device_pm_ops = {
 
 #else
 
-#define ksuspend_usb_init()	0
-#define ksuspend_usb_cleanup()	do {} while (0)
-#define usb_device_pm_ops	(*(struct dev_pm_ops *)0)
+#define usb_device_pm_ops	(*(struct dev_pm_ops *) NULL)
 
 #endif	/* CONFIG_PM */
 
@@ -472,9 +450,6 @@ struct usb_device *usb_alloc_dev(struct usb_device *parent,
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
 
 #ifdef	CONFIG_PM
-	mutex_init(&amp;dev-&gt;pm_mutex);
-	INIT_DELAYED_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work);
-	INIT_WORK(&amp;dev-&gt;autoresume, usb_autoresume_work);
 	dev-&gt;autosuspend_delay = usb_autosuspend_delay * HZ;
 	dev-&gt;connect_time = jiffies;
 	dev-&gt;active_duration = -jiffies;
@@ -1117,9 +1092,6 @@ static int __init usb_init(void)
 	if (retval)
 		goto out;
 
-	retval = ksuspend_usb_init();
-	if (retval)
-		goto out;
 	retval = bus_register(&amp;usb_bus_type);
 	if (retval)
 		goto bus_register_failed;
@@ -1159,7 +1131,7 @@ static int __init usb_init(void)
 bus_notifier_failed:
 	bus_unregister(&amp;usb_bus_type);
 bus_register_failed:
-	ksuspend_usb_cleanup();
+	usb_debugfs_cleanup();
 out:
 	return retval;
 }
@@ -1181,7 +1153,6 @@ static void __exit usb_exit(void)
 	usb_hub_cleanup();
 	bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);
 	bus_unregister(&amp;usb_bus_type);
-	ksuspend_usb_cleanup();
 	usb_debugfs_cleanup();
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2b74a7f99c41..cd882203ad34 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -55,25 +55,8 @@ extern void usb_major_cleanup(void);
 extern int usb_suspend(struct device *dev, pm_message_t msg);
 extern int usb_resume(struct device *dev, pm_message_t msg);
 
-extern void usb_autosuspend_work(struct work_struct *work);
-extern void usb_autoresume_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev, pm_message_t msg);
 extern int usb_port_resume(struct usb_device *dev, pm_message_t msg);
-extern int usb_external_suspend_device(struct usb_device *udev,
-		pm_message_t msg);
-extern int usb_external_resume_device(struct usb_device *udev,
-		pm_message_t msg);
-extern int usb_remote_wakeup(struct usb_device *dev);
-
-static inline void usb_pm_lock(struct usb_device *udev)
-{
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
-}
-
-static inline void usb_pm_unlock(struct usb_device *udev)
-{
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
-}
 
 #else
 
@@ -87,14 +70,6 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return 0;
 }
 
-static inline int usb_remote_wakeup(struct usb_device *udev)
-{
-	return 0;
-}
-
-static inline void usb_pm_lock(struct usb_device *udev) {}
-static inline void usb_pm_unlock(struct usb_device *udev) {}
-
 #endif
 
 #ifdef CONFIG_USB_SUSPEND
@@ -102,6 +77,7 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
+extern int usb_remote_wakeup(struct usb_device *dev);
 
 #else
 
@@ -112,9 +88,13 @@ static inline int usb_autoresume_device(struct usb_device *udev)
 	return 0;
 }
 
+static inline int usb_remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
 #endif
 
-extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
@@ -144,23 +124,6 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 			for_devices;
 }
 
-/* Interfaces and their "power state" are owned by usbcore */
-
-static inline void mark_active(struct usb_interface *f)
-{
-	f-&gt;is_active = 1;
-}
-
-static inline void mark_quiesced(struct usb_interface *f)
-{
-	f-&gt;is_active = 0;
-}
-
-static inline int is_active(const struct usb_interface *f)
-{
-	return f-&gt;is_active;
-}
-
 
 /* for labeling diagnostics */
 extern const char *usbcore_name;
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 3dab0c0b196f..707a87da77f8 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1580,10 +1580,6 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 		return -ERESTARTSYS;
 
 	/* FIXME: What if a system sleep starts while a test is running? */
-	if (!intf-&gt;is_active) {
-		mutex_unlock(&amp;dev-&gt;lock);
-		return -EHOSTUNREACH;
-	}
 
 	/* some devices, like ez-usb default devices, need a non-default
 	 * altsetting to have any active endpoints.  some tests change
diff --git a/include/linux/usb.h b/include/linux/usb.h
index e6419ac89ea2..ad50fc8a7ad3 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -122,7 +122,6 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
- * @is_active: flag set when the interface is bound and not suspended.
  * @sysfs_files_created: sysfs attributes exist
  * @ep_devs_created: endpoint child pseudo-devices exist
  * @unregistering: flag set when the interface is being unregistered
@@ -135,8 +134,7 @@ enum usb_interface_condition {
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.
- * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
- *	allowed unless the counter is 0.
+ * @pm_usage_cnt: PM usage counter for this interface
  * @reset_ws: Used for scheduling resets from atomic context.
  * @reset_running: set to 1 if the interface is currently running a
  *      queued reset so that usb_cancel_queued_reset() doesn't try to
@@ -184,7 +182,6 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
-	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned ep_devs_created:1;	/* endpoint "devices" exist */
 	unsigned unregistering:1;	/* unregistration is in progress */
@@ -401,7 +398,6 @@ struct usb_tt;
  * @portnum: parent port number (origin 1)
  * @level: number of USB hub ancestors
  * @can_submit: URBs may be submitted
- * @discon_suspended: disconnected while suspended
  * @persist_enabled:  USB_PERSIST enabled for this device
  * @have_langid: whether string_langid is valid
  * @authorized: policy has said we can use it;
@@ -421,20 +417,15 @@ struct usb_tt;
  * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
  * @children: child devices - USB devices that are attached to this hub
- * @pm_usage_cnt: usage counter for autosuspend
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
- * @autosuspend: for delayed autosuspends
- * @autoresume: for autoresumes requested while in_interrupt
- * @pm_mutex: protects PM operations
  * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
- * @skip_sys_resume: skip the next system resume
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -475,7 +466,6 @@ struct usb_device {
 	u8 level;
 
 	unsigned can_submit:1;
-	unsigned discon_suspended:1;
 	unsigned persist_enabled:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
@@ -499,17 +489,12 @@ struct usb_device {
 	int maxchild;
 	struct usb_device *children[USB_MAXCHILDREN];
 
-	int pm_usage_cnt;
 	u32 quirks;
 	atomic_t urbnum;
 
 	unsigned long active_duration;
 
 #ifdef CONFIG_PM
-	struct delayed_work autosuspend;
-	struct work_struct autoresume;
-	struct mutex pm_mutex;
-
 	unsigned long last_busy;
 	int autosuspend_delay;
 	unsigned long connect_time;
@@ -517,7 +502,6 @@ struct usb_device {
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;
-	unsigned skip_sys_resume:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
@@ -549,17 +533,8 @@ extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
 extern void usb_autopm_put_interface_async(struct usb_interface *intf);
-
-static inline void usb_autopm_get_interface_no_resume(
-		struct usb_interface *intf)
-{
-	atomic_inc(&amp;intf-&gt;pm_usage_cnt);
-}
-static inline void usb_autopm_put_interface_no_suspend(
-		struct usb_interface *intf)
-{
-	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
-}
+extern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
+extern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
 static inline void usb_mark_last_busy(struct usb_device *udev)
 {</pre><hr><pre>commit 0c590e2361511997430130e10e372217c1128da6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:57:14 2010 -0500

    USB: rearrange functions in driver.c
    
    This patch (as1328) reorders the functions in drivers/usb/core/driver.c
    so as to put all the routines dependent on CONFIG_PM in one place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 057eeab06004..638d54693a1c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1413,6 +1413,109 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
+/**
+ * usb_external_suspend_device - external suspend of a USB device and its interfaces
+ * @udev: the usb_device to suspend
+ * @msg: Power Management message describing this state transition
+ *
+ * This routine handles external suspend requests: ones not generated
+ * internally by a USB driver (autosuspend) but rather coming from the user
+ * (via sysfs) or the PM core (system sleep).  The suspend will be carried
+ * out regardless of @udev's usage counter or those of its interfaces,
+ * and regardless of whether or not remote wakeup is enabled.  Of course,
+ * interface drivers still have the option of failing the suspend (if
+ * there are unsuspended children, for example).
+ *
+ * The caller must hold @udev's device lock.
+ */
+int usb_external_suspend_device(struct usb_device *udev, pm_message_t msg)
+{
+	int	status;
+
+	do_unbind_rebind(udev, DO_UNBIND);
+	usb_pm_lock(udev);
+	status = usb_suspend_both(udev, msg);
+	usb_pm_unlock(udev);
+	return status;
+}
+
+/**
+ * usb_external_resume_device - external resume of a USB device and its interfaces
+ * @udev: the usb_device to resume
+ * @msg: Power Management message describing this state transition
+ *
+ * This routine handles external resume requests: ones not generated
+ * internally by a USB driver (autoresume) but rather coming from the user
+ * (via sysfs), the PM core (system resume), or the device itself (remote
+ * wakeup).  @udev's usage counter is unaffected.
+ *
+ * The caller must hold @udev's device lock.
+ */
+int usb_external_resume_device(struct usb_device *udev, pm_message_t msg)
+{
+	int	status;
+
+	usb_pm_lock(udev);
+	status = usb_resume_both(udev, msg);
+	udev-&gt;last_busy = jiffies;
+	usb_pm_unlock(udev);
+	if (status == 0)
+		do_unbind_rebind(udev, DO_REBIND);
+
+	/* Now that the device is awake, we can start trying to autosuspend
+	 * it again. */
+	if (status == 0)
+		usb_try_autosuspend_device(udev);
+	return status;
+}
+
+int usb_suspend(struct device *dev, pm_message_t msg)
+{
+	struct usb_device	*udev;
+
+	udev = to_usb_device(dev);
+
+	/* If udev is already suspended, we can skip this suspend and
+	 * we should also skip the upcoming system resume.  High-speed
+	 * root hubs are an exception; they need to resume whenever the
+	 * system wakes up in order for USB-PERSIST port handover to work
+	 * properly.
+	 */
+	if (udev-&gt;state == USB_STATE_SUSPENDED) {
+		if (udev-&gt;parent || udev-&gt;speed != USB_SPEED_HIGH)
+			udev-&gt;skip_sys_resume = 1;
+		return 0;
+	}
+
+	udev-&gt;skip_sys_resume = 0;
+	return usb_external_suspend_device(udev, msg);
+}
+
+int usb_resume(struct device *dev, pm_message_t msg)
+{
+	struct usb_device	*udev;
+	int			status;
+
+	udev = to_usb_device(dev);
+
+	/* If udev-&gt;skip_sys_resume is set then udev was already suspended
+	 * when the system sleep started, so we don't want to resume it
+	 * during this system wakeup.
+	 */
+	if (udev-&gt;skip_sys_resume)
+		return 0;
+	status = usb_external_resume_device(udev, msg);
+
+	/* Avoid PM error messages for devices disconnected while suspended
+	 * as we'll display regular disconnect messages just a bit later.
+	 */
+	if (status == -ENODEV)
+		return 0;
+	return status;
+}
+
+#endif /* CONFIG_PM */
+
 #ifdef CONFIG_USB_SUSPEND
 
 /**
@@ -1784,109 +1887,6 @@ void usb_autoresume_work(struct work_struct *work)
 
 #endif /* CONFIG_USB_SUSPEND */
 
-/**
- * usb_external_suspend_device - external suspend of a USB device and its interfaces
- * @udev: the usb_device to suspend
- * @msg: Power Management message describing this state transition
- *
- * This routine handles external suspend requests: ones not generated
- * internally by a USB driver (autosuspend) but rather coming from the user
- * (via sysfs) or the PM core (system sleep).  The suspend will be carried
- * out regardless of @udev's usage counter or those of its interfaces,
- * and regardless of whether or not remote wakeup is enabled.  Of course,
- * interface drivers still have the option of failing the suspend (if
- * there are unsuspended children, for example).
- *
- * The caller must hold @udev's device lock.
- */
-int usb_external_suspend_device(struct usb_device *udev, pm_message_t msg)
-{
-	int	status;
-
-	do_unbind_rebind(udev, DO_UNBIND);
-	usb_pm_lock(udev);
-	status = usb_suspend_both(udev, msg);
-	usb_pm_unlock(udev);
-	return status;
-}
-
-/**
- * usb_external_resume_device - external resume of a USB device and its interfaces
- * @udev: the usb_device to resume
- * @msg: Power Management message describing this state transition
- *
- * This routine handles external resume requests: ones not generated
- * internally by a USB driver (autoresume) but rather coming from the user
- * (via sysfs), the PM core (system resume), or the device itself (remote
- * wakeup).  @udev's usage counter is unaffected.
- *
- * The caller must hold @udev's device lock.
- */
-int usb_external_resume_device(struct usb_device *udev, pm_message_t msg)
-{
-	int	status;
-
-	usb_pm_lock(udev);
-	status = usb_resume_both(udev, msg);
-	udev-&gt;last_busy = jiffies;
-	usb_pm_unlock(udev);
-	if (status == 0)
-		do_unbind_rebind(udev, DO_REBIND);
-
-	/* Now that the device is awake, we can start trying to autosuspend
-	 * it again. */
-	if (status == 0)
-		usb_try_autosuspend_device(udev);
-	return status;
-}
-
-int usb_suspend(struct device *dev, pm_message_t msg)
-{
-	struct usb_device	*udev;
-
-	udev = to_usb_device(dev);
-
-	/* If udev is already suspended, we can skip this suspend and
-	 * we should also skip the upcoming system resume.  High-speed
-	 * root hubs are an exception; they need to resume whenever the
-	 * system wakes up in order for USB-PERSIST port handover to work
-	 * properly.
-	 */
-	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		if (udev-&gt;parent || udev-&gt;speed != USB_SPEED_HIGH)
-			udev-&gt;skip_sys_resume = 1;
-		return 0;
-	}
-
-	udev-&gt;skip_sys_resume = 0;
-	return usb_external_suspend_device(udev, msg);
-}
-
-int usb_resume(struct device *dev, pm_message_t msg)
-{
-	struct usb_device	*udev;
-	int			status;
-
-	udev = to_usb_device(dev);
-
-	/* If udev-&gt;skip_sys_resume is set then udev was already suspended
-	 * when the system sleep started, so we don't want to resume it
-	 * during this system wakeup.
-	 */
-	if (udev-&gt;skip_sys_resume)
-		return 0;
-	status = usb_external_resume_device(udev, msg);
-
-	/* Avoid PM error messages for devices disconnected while suspended
-	 * as we'll display regular disconnect messages just a bit later.
-	 */
-	if (status == -ENODEV)
-		return 0;
-	return status;
-}
-
-#endif /* CONFIG_PM */
-
 struct bus_type usb_bus_type = {
 	.name =		"usb",
 	.match =	usb_device_match,</pre><hr><pre>commit 5899f1e020c8d53b2b6fbd6a6cf39c891ccdfade
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:57:02 2010 -0500

    USB: change handling of negative autosuspend delays
    
    This patch (as1327) changes the way negative autosuspend delays
    prevent device from autosuspending.  The current code checks for
    negative values explicitly in the autosuspend_check() routine.  The
    updated code keeps things from getting that far by using
    usb_autoresume_device() to increment the usage counter when a negative
    delay is set, and by using usb_autosuspend_device() to decrement the
    usage counter when a non-negative delay is set.
    
    This complicates the set_autosuspend() attribute method code slightly,
    but it will reduce the overall power management overhead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 4314f259524b..f073c5cb4e7b 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -103,11 +103,21 @@ void usb_detect_quirks(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "USB quirks for this device: %x\n",
 				udev-&gt;quirks);
 
+#ifdef	CONFIG_USB_SUSPEND
+
 	/* By default, disable autosuspend for all devices.  The hub driver
 	 * will enable it for hubs.
 	 */
 	usb_disable_autosuspend(udev);
 
+	/* Autosuspend can also be disabled if the initial autosuspend_delay
+	 * is negative.
+	 */
+	if (udev-&gt;autosuspend_delay &lt; 0)
+		usb_autoresume_device(udev);
+
+#endif
+
 	/* For the present, all devices default to USB-PERSIST enabled */
 #if 0		/* was: #ifdef CONFIG_PM */
 	/* Hubs are automatically enabled for USB-PERSIST */
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 313e241f5ccc..43c002e3a9aa 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -346,7 +346,8 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	struct usb_device *udev = to_usb_device(dev);
-	int value;
+	int value, old_delay;
+	int rc;
 
 	if (sscanf(buf, "%d", &amp;value) != 1 || value &gt;= INT_MAX/HZ ||
 			value &lt;= - INT_MAX/HZ)
@@ -354,13 +355,24 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 	value *= HZ;
 
 	usb_lock_device(udev);
+	old_delay = udev-&gt;autosuspend_delay;
 	udev-&gt;autosuspend_delay = value;
-	if (value &gt;= 0)
-		usb_try_autosuspend_device(udev);
-	else {
-		if (usb_autoresume_device(udev) == 0)
+
+	if (old_delay &lt; 0) {	/* Autosuspend wasn't allowed */
+		if (value &gt;= 0)
 			usb_autosuspend_device(udev);
+	} else {		/* Autosuspend was allowed */
+		if (value &lt; 0) {
+			rc = usb_autoresume_device(udev);
+			if (rc &lt; 0) {
+				count = rc;
+				udev-&gt;autosuspend_delay = old_delay;
+			}
+		} else {
+			usb_try_autosuspend_device(udev);
+		}
 	}
+
 	usb_unlock_device(udev);
 	return count;
 }</pre><hr><pre>commit 088f7fec8a0e683db72fd8826c5d3ab914e197b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:56:54 2010 -0500

    USB: implement usb_enable_autosuspend
    
    This patch (as1326) adds usb_enable_autosuspend() and
    usb_disable_autosuspend() routines for use by drivers.  If a driver
    knows that its device can handle suspends and resumes correctly, it
    can enable autosuspend all by itself.  This is equivalent to the user
    writing "auto" to the device's power/level attribute.
    
    The implementation differs slightly from what it used to be.  Now
    autosuspend is disabled simply by doing usb_autoresume_device() (to
    increment the usage counter) and enabled by doing
    usb_autosuspend_device() (to decrement the usage counter).
    
    The set_level() attribute method is updated to use the new routines,
    and the USB Power-Management documentation is updated.
    
    The patch adds a usb_enable_autosuspend() call to the hub driver's
    probe routine, allowing the special-case code for hubs in quirks.c to
    be removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index 3bf6818c8cf5..e3fa189c257a 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -229,6 +229,11 @@ necessary operations by hand or add them to a udev script.  You can
 also change the idle-delay time; 2 seconds is not the best choice for
 every device.
 
+If a driver knows that its device has proper suspend/resume support,
+it can enable autosuspend all by itself.  For example, the video
+driver for a laptop's webcam might do this, since these devices are
+rarely used and so should normally be autosuspended.
+
 Sometimes it turns out that even when a device does work okay with
 autosuspend there are still problems.  For example, there are
 experimental patches adding autosuspend support to the usbhid driver,
@@ -384,6 +389,19 @@ autosuspend, there's no delay for an autoresume.
 	Other parts of the driver interface
 	-----------------------------------
 
+Drivers can enable autosuspend for their devices by calling
+
+	usb_enable_autosuspend(struct usb_device *udev);
+
+in their probe() routine, if they know that the device is capable of
+suspending and resuming correctly.  This is exactly equivalent to
+writing "auto" to the device's power/level attribute.  Likewise,
+drivers can disable autosuspend by calling
+
+	usb_disable_autosuspend(struct usb_device *udev);
+
+This is exactly the same as writing "on" to the power/level attribute.
+
 Sometimes a driver needs to make sure that remote wakeup is enabled
 during autosuspend.  For example, there's not much point
 autosuspending a keyboard if the user can't cause the keyboard to do a
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2b39583040d0..057eeab06004 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1415,6 +1415,48 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 
 #ifdef CONFIG_USB_SUSPEND
 
+/**
+ * usb_enable_autosuspend - allow a USB device to be autosuspended
+ * @udev: the USB device which may be autosuspended
+ *
+ * This routine allows @udev to be autosuspended.  An autosuspend won't
+ * take place until the autosuspend_delay has elapsed and all the other
+ * necessary conditions are satisfied.
+ *
+ * The caller must hold @udev's device lock.
+ */
+int usb_enable_autosuspend(struct usb_device *udev)
+{
+	if (udev-&gt;autosuspend_disabled) {
+		udev-&gt;autosuspend_disabled = 0;
+		usb_autosuspend_device(udev);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_enable_autosuspend);
+
+/**
+ * usb_disable_autosuspend - prevent a USB device from being autosuspended
+ * @udev: the USB device which may not be autosuspended
+ *
+ * This routine prevents @udev from being autosuspended and wakes it up
+ * if it is already autosuspended.
+ *
+ * The caller must hold @udev's device lock.
+ */
+int usb_disable_autosuspend(struct usb_device *udev)
+{
+	int rc = 0;
+
+	if (!udev-&gt;autosuspend_disabled) {
+		rc = usb_autoresume_device(udev);
+		if (rc == 0)
+			udev-&gt;autosuspend_disabled = 1;
+	}
+	return rc;
+}
+EXPORT_SYMBOL_GPL(usb_disable_autosuspend);
+
 /* Internal routine to adjust a device's usage counter and change
  * its autosuspend state.
  */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bfa6123bbdb5..746f26f222ab 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1224,6 +1224,9 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	desc = intf-&gt;cur_altsetting;
 	hdev = interface_to_usbdev(intf);
 
+	/* Hubs have proper suspend/resume support */
+	usb_enable_autosuspend(hdev);
+
 	if (hdev-&gt;level == MAX_TOPO_LEVEL) {
 		dev_err(&amp;intf-&gt;dev,
 			"Unsupported bus topology: hub nested too deep\n");
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 0b689224394b..4314f259524b 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -103,11 +103,10 @@ void usb_detect_quirks(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "USB quirks for this device: %x\n",
 				udev-&gt;quirks);
 
-	/* By default, disable autosuspend for all non-hubs */
-#ifdef	CONFIG_USB_SUSPEND
-	if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
-		udev-&gt;autosuspend_disabled = 1;
-#endif
+	/* By default, disable autosuspend for all devices.  The hub driver
+	 * will enable it for hubs.
+	 */
+	usb_disable_autosuspend(udev);
 
 	/* For the present, all devices default to USB-PERSIST enabled */
 #if 0		/* was: #ifdef CONFIG_PM */
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 5a1a0e2b6474..313e241f5ccc 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -389,34 +389,25 @@ set_level(struct device *dev, struct device_attribute *attr,
 	struct usb_device *udev = to_usb_device(dev);
 	int len = count;
 	char *cp;
-	int rc = 0;
-	int old_autosuspend_disabled;
+	int rc;
 
 	cp = memchr(buf, '\n', count);
 	if (cp)
 		len = cp - buf;
 
 	usb_lock_device(udev);
-	old_autosuspend_disabled = udev-&gt;autosuspend_disabled;
 
-	/* Setting the flags without calling usb_pm_lock is a subject to
-	 * races, but who cares...
-	 */
 	if (len == sizeof on_string - 1 &amp;&amp;
-			strncmp(buf, on_string, len) == 0) {
-		udev-&gt;autosuspend_disabled = 1;
-		rc = usb_external_resume_device(udev, PMSG_USER_RESUME);
+			strncmp(buf, on_string, len) == 0)
+		rc = usb_disable_autosuspend(udev);
 
-	} else if (len == sizeof auto_string - 1 &amp;&amp;
-			strncmp(buf, auto_string, len) == 0) {
-		udev-&gt;autosuspend_disabled = 0;
-		rc = usb_external_resume_device(udev, PMSG_USER_RESUME);
+	else if (len == sizeof auto_string - 1 &amp;&amp;
+			strncmp(buf, auto_string, len) == 0)
+		rc = usb_enable_autosuspend(udev);
 
-	} else
+	else
 		rc = -EINVAL;
 
-	if (rc)
-		udev-&gt;autosuspend_disabled = old_autosuspend_disabled;
 	usb_unlock_device(udev);
 	return (rc &lt; 0 ? rc : count);
 }
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 332eaea61021..e6419ac89ea2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -542,6 +542,9 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
+extern int usb_enable_autosuspend(struct usb_device *udev);
+extern int usb_disable_autosuspend(struct usb_device *udev);
+
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
@@ -565,6 +568,11 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 
 #else
 
+static inline int usb_enable_autosuspend(struct usb_device *udev)
+{ return 0; }
+static inline int usb_disable_autosuspend(struct usb_device *udev)
+{ return 0; }
+
 static inline int usb_autopm_get_interface(struct usb_interface *intf)
 { return 0; }
 static inline int usb_autopm_get_interface_async(struct usb_interface *intf)</pre><hr><pre>commit 0c4db6df915bc470f0cd32fe48287fa6eb6adfb4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:56:42 2010 -0500

    USB: use the device lock for persist_enabled
    
    This patch (as1325) changes the locking for the persist_enabled flag
    in struct usb_device.  Now it is protected by the device lock, along
    with all its neighboring bit flags, instead of the PM lock (which is
    about to vanish anyway).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index d8f3bfe1559f..5a1a0e2b6474 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -256,9 +256,10 @@ set_persist(struct device *dev, struct device_attribute *attr,
 
 	if (sscanf(buf, "%d", &amp;value) != 1)
 		return -EINVAL;
-	usb_pm_lock(udev);
+
+	usb_lock_device(udev);
 	udev-&gt;persist_enabled = !!value;
-	usb_pm_unlock(udev);
+	usb_unlock_device(udev);
 	return count;
 }
 </pre>
    <div class="pagination">
        <a href='2_68.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><span>[69]</span><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_70.html'>Next&gt;&gt;</a>
    <div>
</body>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_96.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><span>[97]</span><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_98.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 07d29b63ef6b39963ab37818653284d861cf55af
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 11 16:05:30 2007 -0500

    USB: EHCI: add separate IAA watchdog timer
    
    This patch (as1028) was mostly written by David Brownell; I made only
    a few changes (extra log info and a small bug fix -- which might
    account for why David's version had to be reverted).  It adds a new
    watchdog timer to the ehci-hcd driver to be used exclusively for
    detecting lost or missing IAA notifications.
    
    Previously a shared timer had been used, which may have led to some
    problems as reported by Christian Hoffmann.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 39673f8194d9..64ebfc5548a3 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -786,9 +786,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	}
 
 	if (ehci-&gt;reclaim) {
-		temp = scnprintf (next, size, "reclaim qh %p%s\n",
-				ehci-&gt;reclaim,
-				ehci-&gt;reclaim_ready ? " ready" : "");
+		temp = scnprintf(next, size, "reclaim qh %p\n", ehci-&gt;reclaim);
 		size -= temp;
 		next += temp;
 	}
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 264182654f4c..5917c6b7ce33 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,7 +110,7 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_MULT_TT	1
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
-#define EHCI_IAA_JIFFIES	(HZ/100)	/* arbitrary; ~10 msec */
+#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
@@ -267,6 +267,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
+static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
 #include "ehci-hub.c"
@@ -276,25 +277,41 @@ static void ehci_work(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog (unsigned long param)
+static void ehci_iaa_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
 	unsigned long		flags;
+	u32			status, cmd;
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
+	WARN_ON(!ehci-&gt;reclaim);
 
-	/* lost IAA irqs wedge things badly; seen with a vt8235 */
+	status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
+
+	/* lost IAA irqs wedge things badly; seen first with a vt8235 */
 	if (ehci-&gt;reclaim) {
-		u32		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
 		if (status &amp; STS_IAA) {
 			ehci_vdbg (ehci, "lost IAA\n");
 			COUNT (ehci-&gt;stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
-			ehci-&gt;reclaim_ready = 1;
 		}
+		ehci_writel(ehci, cmd &amp; ~CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
+		end_unlink_async(ehci);
 	}
 
- 	/* stop async processing after it's idled a bit */
+	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+}
+
+static void ehci_watchdog(unsigned long param)
+{
+	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
+	/* stop async processing after it's idled a bit */
 	if (test_bit (TIMER_ASYNC_OFF, &amp;ehci-&gt;actions))
 		start_unlink_async (ehci, ehci-&gt;async);
 
@@ -364,8 +381,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-	if (ehci-&gt;reclaim_ready)
-		end_unlink_async (ehci);
 
 	/* another CPU may drop ehci-&gt;lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
@@ -400,6 +415,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&amp;ehci-&gt;watchdog);
+	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	if (HC_IS_RUNNING (hcd-&gt;state))
@@ -448,6 +464,10 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;watchdog.function = ehci_watchdog;
 	ehci-&gt;watchdog.data = (unsigned long) ehci;
 
+	init_timer(&amp;ehci-&gt;iaa_watchdog);
+	ehci-&gt;iaa_watchdog.function = ehci_iaa_watchdog;
+	ehci-&gt;iaa_watchdog.data = (unsigned long) ehci;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -464,7 +484,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
 	ehci-&gt;reclaim = NULL;
-	ehci-&gt;reclaim_ready = 0;
 	ehci-&gt;next_uframe = -1;
 
 	/*
@@ -655,8 +674,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status &amp; STS_IAA) {
 		COUNT (ehci-&gt;stats.reclaim);
-		ehci-&gt;reclaim_ready = 1;
-		bh = 1;
+		end_unlink_async(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */
@@ -762,10 +780,16 @@ static int ehci_urb_enqueue (
 
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* if we need to use IAA and it's busy, defer */
-	if (qh-&gt;qh_state == QH_STATE_LINKED
-			&amp;&amp; ehci-&gt;reclaim
-			&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)) {
+	/* failfast */
+	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))
+		end_unlink_async(ehci);
+
+	/* if it's not linked then there's nothing to do */
+	if (qh-&gt;qh_state != QH_STATE_LINKED)
+		;
+
+	/* defer till later if busy */
+	else if (ehci-&gt;reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci-&gt;reclaim;
@@ -775,12 +799,8 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
 		last-&gt;reclaim = qh;
 
-	/* bypass IAA if the hc can't care */
-	} else if (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state) &amp;&amp; ehci-&gt;reclaim)
-		end_unlink_async (ehci);
-
-	/* something else might have unlinked the qh by now */
-	if (qh-&gt;qh_state == QH_STATE_LINKED)
+	/* start IAA cycle */
+	} else
 		start_unlink_async (ehci, qh);
 }
 
@@ -807,7 +827,19 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
 		if (!qh)
 			break;
-		unlink_async (ehci, qh);
+		switch (qh-&gt;qh_state) {
+		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
+			unlink_async(ehci, qh);
+			break;
+		case QH_STATE_UNLINK:
+		case QH_STATE_UNLINK_WAIT:
+			/* already started */
+			break;
+		case QH_STATE_IDLE:
+			WARN_ON(1);
+			break;
+		}
 		break;
 
 	case PIPE_INTERRUPT:
@@ -899,6 +931,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		unlink_async (ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
+	case QH_STATE_UNLINK_WAIT:
 idle_timeout:
 		spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 		schedule_timeout_uninterruptible(1);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index a165e0a0961c..a249d03a5024 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -134,7 +134,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	}
 	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	if (ehci-&gt;reclaim)
-		ehci-&gt;reclaim_ready = 1;
+		end_unlink_async(ehci);
 	ehci_work(ehci);
 
 	/* Unlike other USB host controller types, EHCI doesn't have
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 45e040000280..3ba01664f821 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -305,7 +305,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* emptying the schedule aborts any urbs */
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	if (ehci-&gt;reclaim)
-		ehci-&gt;reclaim_ready = 1;
+		end_unlink_async(ehci);
 	ehci_work(ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b10f39c047e9..853e5e6396a5 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -973,7 +973,7 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh = ehci-&gt;reclaim;
 	struct ehci_qh		*next;
 
-	timer_action_done (ehci, TIMER_IAA_WATCHDOG);
+	iaa_watchdog_done(ehci);
 
 	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
 	qh-&gt;qh_state = QH_STATE_IDLE;
@@ -983,7 +983,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
 	next = qh-&gt;reclaim;
 	ehci-&gt;reclaim = next;
-	ehci-&gt;reclaim_ready = 0;
 	qh-&gt;reclaim = NULL;
 
 	qh_completions (ehci, qh);
@@ -1059,11 +1058,10 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		return;
 	}
 
-	ehci-&gt;reclaim_ready = 0;
 	cmd |= CMD_IAAD;
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	timer_action (ehci, TIMER_IAA_WATCHDOG);
+	iaa_watchdog_start(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 10e71417c352..eeda4c88ebae 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -74,7 +74,6 @@ struct ehci_hcd {			/* one per controller */
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*reclaim;
-	unsigned		reclaim_ready : 1;
 	unsigned		scanning : 1;
 
 	/* periodic schedule support */
@@ -105,6 +104,7 @@ struct ehci_hcd {			/* one per controller */
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
+	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		stamp;
@@ -148,9 +148,21 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 }
 
 
+static inline void
+iaa_watchdog_start(struct ehci_hcd *ehci)
+{
+	WARN_ON(timer_pending(&amp;ehci-&gt;iaa_watchdog));
+	mod_timer(&amp;ehci-&gt;iaa_watchdog,
+			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
+}
+
+static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
+{
+	del_timer(&amp;ehci-&gt;iaa_watchdog);
+}
+
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
-	TIMER_IAA_WATCHDOG,
 	TIMER_ASYNC_SHRINK,
 	TIMER_ASYNC_OFF,
 };
@@ -168,9 +180,6 @@ timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
 		unsigned long t;
 
 		switch (action) {
-		case TIMER_IAA_WATCHDOG:
-			t = EHCI_IAA_JIFFIES;
-			break;
 		case TIMER_IO_WATCHDOG:
 			t = EHCI_IO_JIFFIES;
 			break;
@@ -187,8 +196,7 @@ timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
 		// async queue SHRINK often precedes IAA.  while it's ready
 		// to go OFF neither can matter, and afterwards the IO
 		// watchdog stops unless there's still periodic traffic.
-		if (action != TIMER_IAA_WATCHDOG
-				&amp;&amp; t &gt; ehci-&gt;watchdog.expires
+		if (time_before_eq(t, ehci-&gt;watchdog.expires)
 				&amp;&amp; timer_pending (&amp;ehci-&gt;watchdog))
 			return;
 		mod_timer (&amp;ehci-&gt;watchdog, t);</pre><hr><pre>commit 2e2eb83ffd1aeb92bf8793eea892b5bc05a993ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 4 14:35:15 2007 -0500

    USB: add usbfs stubs for suspend and resume
    
    This patch (as1022b) adds stub methods for suspend and resume to the
    usbfs driver.  There isn't much they can do since there's no way to
    inform a user task about the events.  But it's important to have the
    stubs, because an upcoming change to usbcore will automatically unbind
    drivers that don't have those methods when a suspend occurs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 85ec65ada123..32e5591ae7b1 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -402,10 +402,25 @@ static void driver_disconnect(struct usb_interface *intf)
 	destroy_async_on_interface(ps, ifnum);
 }
 
+/* The following routines are merely placeholders.  There is no way
+ * to inform a user task about suspend or resumes.
+ */
+static int driver_suspend(struct usb_interface *intf, pm_message_t msg)
+{
+	return 0;
+}
+
+static int driver_resume(struct usb_interface *intf)
+{
+	return 0;
+}
+
 struct usb_driver usbfs_driver = {
 	.name =		"usbfs",
 	.probe =	driver_probe,
 	.disconnect =	driver_disconnect,
+	.suspend =	driver_suspend,
+	.resume =	driver_resume,
 };
 
 static int claimintf(struct dev_state *ps, unsigned int ifnum)</pre><hr><pre>commit 852c4b43bdd0953483e93bb97ca2fac7e5111dcb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 3 15:44:29 2007 -0500

    USB: updates to usb_reset_composite_device()
    
    This patch (as1023) updates the code in usb_reset_composite_device():
    
            Some local variable declarations are moved to inner loops.
    
            The interface locks are not acquired.  This isn't necessary
            any more; its only reason was to prevent an interface from
            being suspended or resumed during the reset.  But now
            interface power management is controlled by the USB device
            lock, not by the interface lock.
    
            The check for whether the interface is registered is removed.
            There doesn't seem to be any reason for checking; a driver
            for a non-registered interface deserves to be informed of
            device resets just as much as any other.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f7c2219c800f..cc93aa9336fe 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3125,16 +3125,12 @@ EXPORT_SYMBOL(usb_reset_device);
  * this from a driver probe() routine after downloading new firmware.
  * For calls that might not occur during probe(), drivers should lock
  * the device using usb_lock_device_for_reset().
- *
- * The interface locks are acquired during the pre_reset stage and released
- * during the post_reset stage.  However if iface is not NULL and is
- * currently being probed, we assume that the caller already owns its
- * lock.
  */
 int usb_reset_composite_device(struct usb_device *udev,
 		struct usb_interface *iface)
 {
 	int ret;
+	int i;
 	struct usb_host_config *config = udev-&gt;actconfig;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
@@ -3151,16 +3147,11 @@ int usb_reset_composite_device(struct usb_device *udev,
 		iface = NULL;
 
 	if (config) {
-		int i;
-		struct usb_interface *cintf;
-		struct usb_driver *drv;
-
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
-			cintf = config-&gt;interface[i];
-			if (cintf != iface)
-				down(&amp;cintf-&gt;dev.sem);
-			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
-					cintf-&gt;dev.driver) {
+			struct usb_interface *cintf = config-&gt;interface[i];
+			struct usb_driver *drv;
+
+			if (cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;pre_reset)
 					(drv-&gt;pre_reset)(cintf);
@@ -3172,21 +3163,16 @@ int usb_reset_composite_device(struct usb_device *udev,
 	ret = usb_reset_device(udev);
 
 	if (config) {
-		int i;
-		struct usb_interface *cintf;
-		struct usb_driver *drv;
-
 		for (i = config-&gt;desc.bNumInterfaces - 1; i &gt;= 0; --i) {
-			cintf = config-&gt;interface[i];
-			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
-					cintf-&gt;dev.driver) {
+			struct usb_interface *cintf = config-&gt;interface[i];
+			struct usb_driver *drv;
+
+			if (cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;post_reset)
 					(drv-&gt;post_reset)(cintf);
 	/* FIXME: Unbind if post_reset returns an error or isn't defined */
 			}
-			if (cintf != iface)
-				up(&amp;cintf-&gt;dev.sem);
 		}
 	}
 </pre><hr><pre>commit 885e97478bf95b46a7cff40df49c2bb1a5503afd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 3 15:42:10 2007 -0500

    USB: repair USBDEVFS_CONNECT ioctl
    
    For as long as I've known about it, the USBDEVFS_CONNECT ioctl hasn't
    done what it's supposed to.  The current code reprobes _all_ the
    unbound USB interfaces; this patch (as1021) makes it reprobe only the
    interface for which it was called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 1f4f6d02fe25..85ec65ada123 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1373,9 +1373,10 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 
 	/* let kernel drivers try to (re)bind to the interface */
 	case USBDEVFS_CONNECT:
-		usb_unlock_device(ps-&gt;dev);
-		retval = bus_rescan_devices(intf-&gt;dev.bus);
-		usb_lock_device(ps-&gt;dev);
+		if (!intf-&gt;dev.driver)
+			retval = device_attach(&amp;intf-&gt;dev);
+		else
+			retval = -EBUSY;
 		break;
 
 	/* talk directly to the interface's driver */</pre><hr><pre>commit 5933101718ea3d283983a923c5524c88138e5564
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 20 16:28:55 2007 -0500

    USB: dummy_hcd: don't register drivers on the platform bus
    
    This patch (as1017) makes dummy_hcd behave more like the other USB
    peripheral controller drivers by no longer registering its
    gadget driver on the platform bus.  Doing that has always been a
    mistake, since a usb_gadget_driver isn't a platform_driver.  Instead
    the gadget driver is left unregistered in sysfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 9db2482bdfa2..1a8a5f33443e 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -772,18 +772,17 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	list_del_init (&amp;dum-&gt;ep [0].ep.ep_list);
 	INIT_LIST_HEAD(&amp;dum-&gt;fifo_req.queue);
 
+	driver-&gt;driver.bus = NULL;
 	dum-&gt;driver = driver;
 	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
 	dev_dbg (udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
-	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0)
-		goto err_bind_gadget;
-
-	driver-&gt;driver.bus = dum-&gt;gadget.dev.parent-&gt;bus;
-	if ((retval = driver_register (&amp;driver-&gt;driver)) != 0)
-		goto err_register;
-	if ((retval = device_bind_driver (&amp;dum-&gt;gadget.dev)) != 0)
-		goto err_bind_driver;
+	retval = driver-&gt;bind(&amp;dum-&gt;gadget);
+	if (retval) {
+		dum-&gt;driver = NULL;
+		dum-&gt;gadget.dev.driver = NULL;
+		return retval;
+	}
 
 	/* khubd will enumerate this in a while */
 	spin_lock_irq (&amp;dum-&gt;lock);
@@ -793,20 +792,6 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
-
-err_bind_driver:
-	driver_unregister (&amp;driver-&gt;driver);
-err_register:
-	if (driver-&gt;unbind)
-		driver-&gt;unbind (&amp;dum-&gt;gadget);
-	spin_lock_irq (&amp;dum-&gt;lock);
-	dum-&gt;pullup = 0;
-	set_link_state (dum);
-	spin_unlock_irq (&amp;dum-&gt;lock);
-err_bind_gadget:
-	dum-&gt;driver = NULL;
-	dum-&gt;gadget.dev.driver = NULL;
-	return retval;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
 
@@ -830,11 +815,9 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	driver-&gt;unbind (&amp;dum-&gt;gadget);
+	dum-&gt;gadget.dev.driver = NULL;
 	dum-&gt;driver = NULL;
 
-	device_release_driver (&amp;dum-&gt;gadget.dev);
-	driver_unregister (&amp;driver-&gt;driver);
-
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
 	dum-&gt;pullup = 0;
 	set_link_state (dum);</pre><hr><pre>commit 269954e542328f014fc07fbb0a986192f7a1cced
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 19 15:57:45 2007 -0500

    USB: don't change HC power state for a FREEZE
    
    This patch (as1016) prevents PCI-based host controllers from
    undergoing a power-state change during a FREEZE or a PRETHAW.  Such
    changes are needed only during a SUSPEND.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 3fb9af80cbf4..424674203fd3 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -250,6 +250,12 @@ int usb_hcd_pci_suspend (struct pci_dev *dev, pm_message_t message)
 			pci_disable_device (dev);
 		}
 
+		if (message.event == PM_EVENT_FREEZE ||
+				message.event == PM_EVENT_PRETHAW) {
+			dev_dbg(hcd-&gt;self.controller, "--&gt; no state change\n");
+			goto done;
+		}
+
 		if (!has_pci_pm) {
 			dev_dbg (hcd-&gt;self.controller, "--&gt; PCI D0/legacy\n");
 			goto done;</pre><hr><pre>commit 4145ed6dc597a9bea5f6ae8c574653b2de10620f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 19 10:15:02 2007 -0500

    USB: make ksuspend_usbd thread non-freezable
    
    This patch (as1012b) makes the ksuspend_usbd kernel thread
    non-freezable.  Since the PM core has been changed to lock all devices
    during a system sleep, the thread no longer needs to be frozen.  It
    won't interfere with a system sleep because before trying to resume a
    root hub device, it acquires the device's lock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 8f142370103d..bc5edacb0c34 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -230,7 +230,7 @@ static int ksuspend_usb_init(void)
 	 * singlethreaded.  Its job doesn't justify running on more
 	 * than one CPU.
 	 */
-	ksuspend_usb_wq = create_freezeable_workqueue("ksuspend_usbd");
+	ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usbd");
 	if (!ksuspend_usb_wq)
 		return -ENOMEM;
 	return 0;</pre><hr><pre>commit 676d3aa16f66d94bf5654781b77d1e070c8b0514
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 8 15:15:28 2007 -0500

    USB: usb-storage: new "lockable" subclass 0x07
    
    This patch (as1011) adds a #define for the newly-created Lockable
    (i.e., password-protected) subclass 0x07 for USB mass-storage devices.
    The private ISD200 entry (which had been mapped to subclass 0x07) is
    moved to 0xf0, which is unlikely to conflict with any official
    subclass designation.
    
    The US_SC_MIN and US_SC_MAX constants aren't used anywhere, so the
    patch removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index a417b09b8b3d..cee0623b3c7b 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -80,10 +80,9 @@ enum { US_DO_ALL_FLAGS };
 #define US_SC_UFI	0x04		/* Floppy */
 #define US_SC_8070	0x05		/* Removable media */
 #define US_SC_SCSI	0x06		/* Transparent */
-#define US_SC_ISD200    0x07		/* ISD200 ATA */
-#define US_SC_MIN	US_SC_RBC
-#define US_SC_MAX	US_SC_ISD200
+#define US_SC_LOCKABLE	0x07		/* Password-protected */
 
+#define US_SC_ISD200    0xf0		/* ISD200 ATA */
 #define US_SC_DEVICE	0xff		/* Use device's value */
 
 /* Protocols */</pre><hr><pre>commit 09f82ea92822a7bbb7e816508abbda47ed54a77f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 19 10:53:40 2007 -0500

    Kobject: drop child-&gt;parent ref at unregistration
    
    This patch (as1015) reverts changes that were made to the driver core
    about four years ago.  The intent back then was to avoid certain kinds
    of invalid memory accesses by leaving kernel objects allocated as long
    as any of their children were still allocated.  The original and
    correct approach was to wait only as long as any children were still
    _registered_; that's what this patch reinstates.
    
    This fixes a problem in the SCSI core made visible by the class_device
    to regular device conversion: A reference loop (scsi_device holds
    reference to request_queue, which is the child of a gendisk, which is
    the child of the scsi_device) prevents the data structures from being
    released, even though they are deregistered okay.
    
    It's possible that this change will cause a few bugs to surface,
    things that have been hidden for several years.  They can be fixed
    easily enough by having the child device take an explicit reference to
    the parent whenever needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/lib/kobject.c b/lib/kobject.c
index 1015f74212d0..493e991abb1b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -149,12 +149,16 @@ void kobject_init(struct kobject * kobj)
 
 static void unlink(struct kobject * kobj)
 {
+	struct kobject *parent = kobj-&gt;parent;
+
 	if (kobj-&gt;kset) {
 		spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);
 		list_del_init(&amp;kobj-&gt;entry);
 		spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);
 	}
+	kobj-&gt;parent = NULL;
 	kobject_put(kobj);
+	kobject_put(parent);
 }
 
 /**
@@ -208,7 +212,6 @@ int kobject_add(struct kobject * kobj)
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
-		kobject_put(parent);
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
@@ -590,7 +593,6 @@ static void kobject_cleanup(struct kobject *kobj)
 {
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj-&gt;kset;
-	struct kobject * parent = kobj-&gt;parent;
 	const char *name = kobj-&gt;k_name;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
@@ -604,7 +606,6 @@ static void kobject_cleanup(struct kobject *kobj)
 	}
 	if (s)
 		kset_put(s);
-	kobject_put(parent);
 }
 
 static void kobject_release(struct kref *kref)</pre><hr><pre>commit ef2c51746dc89c2326ce522f8fb8a57695780e75
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 16 11:57:28 2007 -0500

    Driver core: fix race in __device_release_driver
    
    This patch (as1013) was suggested by David Woodhouse; it fixes a race
    in the driver core.  If a device is unregistered at the same time as
    its driver is unloaded, the driver's code pages may be unmapped while
    the remove method is still running.  The calls to get_driver() and
    put_driver() were intended to prevent this, but they don't work if the
    driver's module count has already dropped to 0.
    
    Instead, the patch keeps the device on the driver's list until after
    the remove method has returned.  This forces the necessary
    synchronization to occur.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Woodhouse &lt;dwmw2@infradead.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 54922647522d..b0726eb6405e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -289,11 +289,10 @@ static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	drv = get_driver(dev-&gt;driver);
+	drv = dev-&gt;driver;
 	if (drv) {
 		driver_sysfs_remove(dev);
 		sysfs_remove_link(&amp;dev-&gt;kobj, "driver");
-		klist_remove(&amp;dev-&gt;knode_driver);
 
 		if (dev-&gt;bus)
 			blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
@@ -306,7 +305,7 @@ static void __device_release_driver(struct device * dev)
 			drv-&gt;remove(dev);
 		devres_release_all(dev);
 		dev-&gt;driver = NULL;
-		put_driver(drv);
+		klist_remove(&amp;dev-&gt;knode_driver);
 	}
 }
 </pre>
    <div class="pagination">
        <a href='2_96.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><span>[97]</span><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_98.html'>Next&gt;&gt;</a>
    <div>
</body>

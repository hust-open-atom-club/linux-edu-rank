<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_31.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><span>[32]</span><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_33.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7c4bb942986fc2aa7ca4fccfed665d24525a0e21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:22 2013 -0400

    USB: add a private-data pointer to struct usb_tt
    
    For improved scheduling of transfers through a Transaction Translator,
    ehci-hcd will need to store a bunch of information associated with the
    FS/LS bus on the downstream side of the TT.  This patch adds a pointer
    for such HCD-private data to the usb_tt structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dbe3cd19ffd8..b8aba196f7f1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -506,6 +506,7 @@ struct usb_tt {
 	struct usb_device	*hub;	/* upstream highspeed hub */
 	int			multi;	/* true means one TT per port */
 	unsigned		think_time;	/* think time in ns */
+	void			*hcpriv;	/* HCD private data */
 
 	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
 	spinlock_t		lock;</pre><hr><pre>commit d0ce5c6b9208c79fc725c578eebdeb5724faf17d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:13 2013 -0400

    USB: EHCI: use a bandwidth-allocation table
    
    This patch significantly changes the scheduling code in ehci-hcd.
    Instead of calculating the current bandwidth utilization by trudging
    through the schedule and adding up the times used by the existing
    transfers, we will now maintain a table holding the time used for each
    of 64 microframes.  This will drastically speed up the bandwidth
    computations.
    
    In addition, it eliminates a theoretical bug.  An isochronous endpoint
    may have bandwidth reserved even at times when it has no transfers
    listed in the schedule.  The table will keep track of the reserved
    bandwidth, whereas adding up entries in the schedule would miss it.
    
    As a corollary, we can keep bandwidth reserved for endpoints even
    when they aren't in active use.  Eventually the bandwidth will be
    reserved when a new alternate setting is installed; for now the
    endpoint's reservation takes place when its first URB is submitted.
    
    A drawback of this approach is that transfers with an interval larger
    than 64 microframes will have to be charged for bandwidth as though
    the interval was 64.  In practice this shouldn't matter much;
    transfers with longer intervals tend to be rather short anyway (things
    like hubs or HID devices).
    
    Another minor drawback is that we will keep track of two different
    period and phase values: the actual ones and the ones used for
    bandwidth allocation (which are limited to 64).  This adds only a
    small amount of overhead: 3 bytes for each endpoint.
    
    The patch also adds a new debugfs file named "bandwidth" to display
    the information stored in the new table.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 09e5bc8e2b98..5bbfb1f9929c 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -334,6 +334,7 @@ static inline void remove_debug_files (struct ehci_hcd *bus) { }
 /* troubleshooting help: expose state in debugfs */
 
 static int debug_async_open(struct inode *, struct file *);
+static int debug_bandwidth_open(struct inode *, struct file *);
 static int debug_periodic_open(struct inode *, struct file *);
 static int debug_registers_open(struct inode *, struct file *);
 
@@ -347,6 +348,13 @@ static const struct file_operations debug_async_fops = {
 	.release	= debug_close,
 	.llseek		= default_llseek,
 };
+static const struct file_operations debug_bandwidth_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_bandwidth_open,
+	.read		= debug_output,
+	.release	= debug_close,
+	.llseek		= default_llseek,
+};
 static const struct file_operations debug_periodic_fops = {
 	.owner		= THIS_MODULE,
 	.open		= debug_periodic_open,
@@ -525,6 +533,41 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 	return strlen(buf-&gt;output_buf);
 }
 
+static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
+{
+	struct ehci_hcd		*ehci;
+	unsigned		temp, size;
+	char			*next;
+	unsigned		i;
+	u8			*bw;
+
+	ehci = hcd_to_ehci(bus_to_hcd(buf-&gt;bus));
+	next = buf-&gt;output_buf;
+	size = buf-&gt;alloc_size;
+
+	*next = 0;
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+
+	/* Dump the HS bandwidth table */
+	temp = scnprintf(next, size,
+			"HS bandwidth allocation (us per microframe)\n");
+	size -= temp;
+	next += temp;
+	for (i = 0; i &lt; EHCI_BANDWIDTH_SIZE; i += 8) {
+		bw = &amp;ehci-&gt;bandwidth[i];
+		temp = scnprintf(next, size,
+				"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",
+				i, bw[0], bw[1], bw[2], bw[3],
+					bw[4], bw[5], bw[6], bw[7]);
+		size -= temp;
+		next += temp;
+	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	return next - buf-&gt;output_buf;
+}
+
 #define DBG_SCHED_LIMIT 64
 static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
@@ -919,6 +962,7 @@ static int debug_close(struct inode *inode, struct file *file)
 
 	return 0;
 }
+
 static int debug_async_open(struct inode *inode, struct file *file)
 {
 	file-&gt;private_data = alloc_buffer(inode-&gt;i_private, fill_async_buffer);
@@ -926,6 +970,14 @@ static int debug_async_open(struct inode *inode, struct file *file)
 	return file-&gt;private_data ? 0 : -ENOMEM;
 }
 
+static int debug_bandwidth_open(struct inode *inode, struct file *file)
+{
+	file-&gt;private_data = alloc_buffer(inode-&gt;i_private,
+			fill_bandwidth_buffer);
+
+	return file-&gt;private_data ? 0 : -ENOMEM;
+}
+
 static int debug_periodic_open(struct inode *inode, struct file *file)
 {
 	struct debug_buffer *buf;
@@ -958,6 +1010,10 @@ static inline void create_debug_files (struct ehci_hcd *ehci)
 						&amp;debug_async_fops))
 		goto file_error;
 
+	if (!debugfs_create_file("bandwidth", S_IRUGO, ehci-&gt;debug_dir, bus,
+						&amp;debug_bandwidth_fops))
+		goto file_error;
+
 	if (!debugfs_create_file("periodic", S_IRUGO, ehci-&gt;debug_dir, bus,
 						&amp;debug_periodic_fops))
 		goto file_error;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b2e4e4b3cfae..398e8fa3032f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -956,6 +956,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			goto idle_timeout;
 
 		/* BUG_ON(!list_empty(&amp;stream-&gt;free_list)); */
+		reserve_release_iso_bandwidth(ehci, stream, -1);
 		kfree(stream);
 		goto done;
 	}
@@ -982,6 +983,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		if (qh-&gt;clearing_tt)
 			goto idle_timeout;
 		if (list_empty (&amp;qh-&gt;qtd_list)) {
+			if (qh-&gt;ps.bw_uperiod)
+				reserve_release_intr_bandwidth(ehci, qh, -1);
 			qh_destroy(ehci, qh);
 			break;
 		}
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9bfaa21707bd..db05bd8ee9d5 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -797,6 +797,8 @@ qh_make (
 	 * For control/bulk requests, the HC or TT handles these.
 	 */
 	if (type == PIPE_INTERRUPT) {
+		unsigned	tmp;
+
 		qh-&gt;ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
@@ -816,6 +818,14 @@ qh_make (
 				urb-&gt;interval = ehci-&gt;periodic_size &lt;&lt; 3;
 			}
 			qh-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
+
+			/* period for bandwidth allocation */
+			tmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,
+					1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
+
+			/* Allow urb-&gt;interval to override */
+			qh-&gt;ps.bw_uperiod = min_t(unsigned, tmp, urb-&gt;interval);
+			qh-&gt;ps.bw_period = qh-&gt;ps.bw_uperiod &gt;&gt; 3;
 		} else {
 			int		think_time;
 
@@ -839,6 +849,15 @@ qh_make (
 			if (urb-&gt;interval &gt; ehci-&gt;periodic_size)
 				urb-&gt;interval = ehci-&gt;periodic_size;
 			qh-&gt;ps.period = urb-&gt;interval;
+
+			/* period for bandwidth allocation */
+			tmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,
+					urb-&gt;ep-&gt;desc.bInterval);
+			tmp = rounddown_pow_of_two(tmp);
+
+			/* Allow urb-&gt;interval to override */
+			qh-&gt;ps.bw_period = min_t(unsigned, tmp, urb-&gt;interval);
+			qh-&gt;ps.bw_uperiod = qh-&gt;ps.bw_period &lt;&lt; 3;
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1fafcda0ae81..790a64c0da5c 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -106,75 +106,53 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
 }
 
-/* how many of the uframe's 125 usecs are allocated? */
-static unsigned short
-periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
+static void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,
+		struct ehci_per_sched *ps)
 {
-	__hc32			*hw_p = &amp;ehci-&gt;periodic [frame];
-	union ehci_shadow	*q = &amp;ehci-&gt;pshadow [frame];
-	unsigned		usecs = 0;
-	struct ehci_qh_hw	*hw;
+	dev_dbg(&amp;ps-&gt;udev-&gt;dev,
+			"ep %02x: %s %s @ %u+%u (%u.%u+%u) [%u/%u us] mask %04x\n",
+			ps-&gt;ep-&gt;desc.bEndpointAddress,
+			(sign &gt;= 0 ? "reserve" : "release"), type,
+			(ps-&gt;bw_phase &lt;&lt; 3) + ps-&gt;phase_uf, ps-&gt;bw_uperiod,
+			ps-&gt;phase, ps-&gt;phase_uf, ps-&gt;period,
+			ps-&gt;usecs, ps-&gt;c_usecs, ps-&gt;cs_mask);
+}
 
-	while (q-&gt;ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_QH:
-			hw = q-&gt;qh-&gt;hw;
-			/* is it in the S-mask? */
-			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; uframe))
-				usecs += q-&gt;qh-&gt;ps.usecs;
-			/* ... or C-mask? */
-			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci,
-					1 &lt;&lt; (8 + uframe)))
-				usecs += q-&gt;qh-&gt;ps.c_usecs;
-			hw_p = &amp;hw-&gt;hw_next;
-			q = &amp;q-&gt;qh-&gt;qh_next;
-			break;
-		// case Q_TYPE_FSTN:
-		default:
-			/* for "save place" FSTNs, count the relevant INTR
-			 * bandwidth from the previous frame
-			 */
-			if (q-&gt;fstn-&gt;hw_prev != EHCI_LIST_END(ehci)) {
-				ehci_dbg (ehci, "ignoring FSTN cost ...\n");
-			}
-			hw_p = &amp;q-&gt;fstn-&gt;hw_next;
-			q = &amp;q-&gt;fstn-&gt;fstn_next;
-			break;
-		case Q_TYPE_ITD:
-			if (q-&gt;itd-&gt;hw_transaction[uframe])
-				usecs += q-&gt;itd-&gt;stream-&gt;ps.usecs;
-			hw_p = &amp;q-&gt;itd-&gt;hw_next;
-			q = &amp;q-&gt;itd-&gt;itd_next;
-			break;
-		case Q_TYPE_SITD:
-			/* is it in the S-mask?  (count SPLIT, DATA) */
-			if (q-&gt;sitd-&gt;hw_uframe &amp; cpu_to_hc32(ehci,
-					1 &lt;&lt; uframe)) {
-				if (q-&gt;sitd-&gt;hw_fullspeed_ep &amp;
-						cpu_to_hc32(ehci, 1&lt;&lt;31))
-					usecs += q-&gt;sitd-&gt;stream-&gt;ps.usecs;
-				else	/* worst case for OUT start-split */
-					usecs += HS_USECS_ISO (188);
-			}
+static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
+		struct ehci_qh *qh, int sign)
+{
+	unsigned		start_uf;
+	unsigned		i, j, m;
+	int			usecs = qh-&gt;ps.usecs;
+	int			c_usecs = qh-&gt;ps.c_usecs;
 
-			/* ... C-mask?  (count CSPLIT, DATA) */
-			if (q-&gt;sitd-&gt;hw_uframe &amp;
-					cpu_to_hc32(ehci, 1 &lt;&lt; (8 + uframe))) {
-				/* worst case for IN complete-split */
-				usecs += q-&gt;sitd-&gt;stream-&gt;ps.c_usecs;
-			}
+	if (qh-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
+		return;
+	start_uf = qh-&gt;ps.bw_phase &lt;&lt; 3;
 
-			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
-			q = &amp;q-&gt;sitd-&gt;sitd_next;
-			break;
+	bandwidth_dbg(ehci, sign, "intr", &amp;qh-&gt;ps);
+
+	if (sign &lt; 0) {		/* Release bandwidth */
+		usecs = -usecs;
+		c_usecs = -c_usecs;
+	}
+
+	/* Entire transaction (high speed) or start-split (full/low speed) */
+	for (i = start_uf + qh-&gt;ps.phase_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+			i += qh-&gt;ps.bw_uperiod)
+		ehci-&gt;bandwidth[i] += usecs;
+
+	/* Complete-split (full/low speed) */
+	if (qh-&gt;ps.c_usecs) {
+		/* NOTE: adjustments needed for FSTN */
+		for (i = start_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += qh-&gt;ps.bw_uperiod) {
+			for ((j = 2, m = 1 &lt;&lt; (j+8)); j &lt; 8; (++j, m &lt;&lt;= 1)) {
+				if (qh-&gt;ps.cs_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += c_usecs;
+			}
 		}
 	}
-#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
-	if (usecs &gt; ehci-&gt;uframe_periodic_max)
-		ehci_err (ehci, "uframe %d sched overrun: %d usecs\n",
-			frame * 8 + uframe, usecs);
-#endif
-	return usecs;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -524,8 +502,8 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;exception = 0;
 
 	/* update per-qh bandwidth for debugfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.period
-		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.bw_period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.bw_period)
 		: (qh-&gt;ps.usecs * 8);
 
 	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
@@ -562,8 +540,8 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		periodic_unlink (ehci, i, qh);
 
 	/* update per-qh bandwidth for debugfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.period
-		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.bw_period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.bw_period)
 		: (qh-&gt;ps.usecs * 8);
 
 	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
@@ -693,11 +671,9 @@ static int check_period (
 	struct ehci_hcd *ehci,
 	unsigned	frame,
 	unsigned	uframe,
-	unsigned	period,
+	unsigned	uperiod,
 	unsigned	usecs
 ) {
-	int		claimed;
-
 	/* complete split running into next frame?
 	 * given FSTN support, we could sometimes check...
 	 */
@@ -707,25 +683,10 @@ static int check_period (
 	/* convert "usecs we need" to "max already claimed" */
 	usecs = ehci-&gt;uframe_periodic_max - usecs;
 
-	/* we "know" 2 and 4 uframe intervals were rejected; so
-	 * for period 0, check _every_ microframe in the schedule.
-	 */
-	if (unlikely (period == 0)) {
-		do {
-			for (uframe = 0; uframe &lt; 7; uframe++) {
-				claimed = periodic_usecs (ehci, frame, uframe);
-				if (claimed &gt; usecs)
-					return 0;
-			}
-		} while ((frame += 1) &lt; ehci-&gt;periodic_size);
-
-	/* just check the specified uframe, at that period */
-	} else {
-		do {
-			claimed = periodic_usecs (ehci, frame, uframe);
-			if (claimed &gt; usecs)
-				return 0;
-		} while ((frame += period) &lt; ehci-&gt;periodic_size);
+	for (uframe += frame &lt;&lt; 3; uframe &lt; EHCI_BANDWIDTH_SIZE;
+			uframe += uperiod) {
+		if (ehci-&gt;bandwidth[uframe] &gt; usecs)
+			return 0;
 	}
 
 	// success!
@@ -746,7 +707,7 @@ static int check_intr_schedule (
 	if (qh-&gt;ps.c_usecs &amp;&amp; uframe &gt;= 6)	/* FSTN territory? */
 		goto done;
 
-	if (!check_period(ehci, frame, uframe, qh-&gt;ps.period, qh-&gt;ps.usecs))
+	if (!check_period(ehci, frame, uframe, qh-&gt;ps.bw_uperiod, qh-&gt;ps.usecs))
 		goto done;
 	if (!qh-&gt;ps.c_usecs) {
 		retval = 0;
@@ -755,21 +716,21 @@ static int check_intr_schedule (
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, uframe,
+	if (tt_available(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, uframe,
 				qh-&gt;ps.tt_usecs)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
 		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
 			if (!check_period(ehci, frame, i,
-					qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+					qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 				goto done;
 			else
 				mask |= 1 &lt;&lt; i;
 
 		retval = 0;
 
-		*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
+		*c_maskp = mask;
 	}
 #else
 	/* Make sure this tt's buffer is also available for CSPLITs.
@@ -780,15 +741,15 @@ static int check_intr_schedule (
 	 * one smart pass...
 	 */
 	mask = 0x03 &lt;&lt; (uframe + qh-&gt;gap_uf);
-	*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
+	*c_maskp = mask;
 
 	mask |= 1 &lt;&lt; uframe;
-	if (tt_no_collision(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, mask)) {
+	if (tt_no_collision(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, mask)) {
 		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf + 1,
-				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+				qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 			goto done;
 		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf,
-				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+				qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 			goto done;
 		retval = 0;
 	}
@@ -804,60 +765,57 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	int		status;
 	unsigned	uframe;
-	__hc32		c_mask;
-	unsigned	frame;		/* 0..(qh-&gt;period - 1), or NO_FRAME */
+	unsigned	c_mask;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	frame = qh-&gt;ps.phase;
 
 	/* reuse the previous schedule slots, if we can */
-	if (frame != NO_FRAME) {
-		uframe = ffs(hc32_to_cpup(ehci, &amp;hw-&gt;hw_info2) &amp; QH_SMASK);
-		status = check_intr_schedule (ehci, frame, --uframe,
-				qh, &amp;c_mask);
-	} else {
-		uframe = 0;
-		c_mask = 0;
-		status = -ENOSPC;
+	if (qh-&gt;ps.phase != NO_FRAME) {
+		ehci_dbg(ehci, "reused qh %p schedule\n", qh);
+		return 0;
 	}
 
+	uframe = 0;
+	c_mask = 0;
+	status = -ENOSPC;
+
 	/* else scan the schedule to find a group of slots such that all
 	 * uframes have enough periodic bandwidth available.
 	 */
-	if (status) {
-		/* "normal" case, uframing flexible except with splits */
-		if (qh-&gt;ps.period) {
-			int		i;
-
-			for (i = qh-&gt;ps.period; status &amp;&amp; i &gt; 0; --i) {
-				frame = ++ehci-&gt;random_frame % qh-&gt;ps.period;
-				for (uframe = 0; uframe &lt; 8; uframe++) {
-					status = check_intr_schedule (ehci,
-							frame, uframe, qh,
-							&amp;c_mask);
-					if (status == 0)
-						break;
-				}
+	/* "normal" case, uframing flexible except with splits */
+	if (qh-&gt;ps.bw_period) {
+		int		i;
+		unsigned	frame;
+
+		for (i = qh-&gt;ps.bw_period; status &amp;&amp; i &gt; 0; --i) {
+			frame = ++ehci-&gt;random_frame &amp; (qh-&gt;ps.bw_period - 1);
+			for (uframe = 0; uframe &lt; 8; uframe++) {
+				status = check_intr_schedule(ehci,
+						frame, uframe, qh, &amp;c_mask);
+				if (status == 0)
+					break;
 			}
-
-		/* qh-&gt;ps.period == 0 means every uframe */
-		} else {
-			frame = 0;
-			status = check_intr_schedule (ehci, 0, 0, qh, &amp;c_mask);
 		}
-		if (status)
-			goto done;
-		qh-&gt;ps.phase = frame;
 
-		/* reset S-frame and (maybe) C-frame masks */
-		hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
-		hw-&gt;hw_info2 |= qh-&gt;ps.period
-			? cpu_to_hc32(ehci, 1 &lt;&lt; uframe)
-			: cpu_to_hc32(ehci, QH_SMASK);
-		hw-&gt;hw_info2 |= c_mask;
-	} else
-		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
+	/* qh-&gt;ps.bw_period == 0 means every uframe */
+	} else {
+		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask);
+	}
+	if (status)
+		goto done;
+	qh-&gt;ps.phase = (qh-&gt;ps.period ? ehci-&gt;random_frame &amp;
+			(qh-&gt;ps.period - 1) : 0);
+	qh-&gt;ps.bw_phase = qh-&gt;ps.phase &amp; (qh-&gt;ps.bw_period - 1);
+	qh-&gt;ps.phase_uf = uframe;
+	qh-&gt;ps.cs_mask = qh-&gt;ps.period ?
+			(c_mask &lt;&lt; 8) | (1 &lt;&lt; uframe) :
+			QH_SMASK;
+
+	/* reset S-frame and (maybe) C-frame masks */
+	hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
+	hw-&gt;hw_info2 |= cpu_to_hc32(ehci, qh-&gt;ps.cs_mask);
+	reserve_release_intr_bandwidth(ehci, qh, 1);
 
 done:
 	return status;
@@ -969,6 +927,7 @@ iso_stream_alloc (gfp_t mem_flags)
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
 		stream-&gt;next_uframe = NO_FRAME;
+		stream-&gt;ps.phase = NO_FRAME;
 	}
 	return stream;
 }
@@ -983,10 +942,10 @@ iso_stream_init (
 	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
 
 	struct usb_device	*dev = urb-&gt;dev;
-	unsigned		interval = urb-&gt;interval;
 	u32			buf1;
 	unsigned		epnum, maxp;
 	int			is_input;
+	unsigned		tmp;
 
 	/*
 	 * this might be a "high bandwidth" highspeed endpoint,
@@ -1020,9 +979,17 @@ iso_stream_init (
 		 */
 		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
 
-		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 / interval;
-		stream-&gt;uperiod = interval;
-		stream-&gt;ps.period = interval &gt;&gt; 3;
+		/* period for bandwidth allocation */
+		tmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,
+				1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
+
+		/* Allow urb-&gt;interval to override */
+		stream-&gt;ps.bw_uperiod = min_t(unsigned, tmp, urb-&gt;interval);
+
+		stream-&gt;uperiod = urb-&gt;interval;
+		stream-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
+		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 /
+				stream-&gt;ps.bw_uperiod;
 
 	} else {
 		u32		addr;
@@ -1047,20 +1014,28 @@ iso_stream_init (
 			addr |= 1 &lt;&lt; 31;
 			stream-&gt;ps.c_usecs = stream-&gt;ps.usecs;
 			stream-&gt;ps.usecs = HS_USECS_ISO(1);
-			stream-&gt;raw_mask = 1;
+			stream-&gt;ps.cs_mask = 1;
 
 			/* c-mask as specified in USB 2.0 11.18.4 3.c */
 			tmp = (1 &lt;&lt; (hs_transfers + 2)) - 1;
-			stream-&gt;raw_mask |= tmp &lt;&lt; (8 + 2);
+			stream-&gt;ps.cs_mask |= tmp &lt;&lt; (8 + 2);
 		} else
-			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
+			stream-&gt;ps.cs_mask = smask_out[hs_transfers - 1];
+
+		/* period for bandwidth allocation */
+		tmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,
+				1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
 
+		/* Allow urb-&gt;interval to override */
+		stream-&gt;ps.bw_period = min_t(unsigned, tmp, urb-&gt;interval);
+		stream-&gt;ps.bw_uperiod = stream-&gt;ps.bw_period &lt;&lt; 3;
+
+		stream-&gt;ps.period = urb-&gt;interval;
+		stream-&gt;uperiod = urb-&gt;interval &lt;&lt; 3;
 		stream-&gt;bandwidth = (stream-&gt;ps.usecs + stream-&gt;ps.c_usecs) /
-				interval;
-		stream-&gt;uperiod = interval &lt;&lt; 3;
-		stream-&gt;ps.period = interval;
+				stream-&gt;ps.bw_period;
 
-		/* stream-&gt;splits gets created from raw_mask later */
+		/* stream-&gt;splits gets created from cs_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);
 	}
 
@@ -1249,45 +1224,84 @@ itd_urb_transaction (
 
 /*-------------------------------------------------------------------------*/
 
+static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
+		struct ehci_iso_stream *stream, int sign)
+{
+	unsigned		uframe;
+	unsigned		i, j;
+	unsigned		s_mask, c_mask, m;
+	int			usecs = stream-&gt;ps.usecs;
+	int			c_usecs = stream-&gt;ps.c_usecs;
+
+	if (stream-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
+		return;
+	uframe = stream-&gt;ps.bw_phase &lt;&lt; 3;
+
+	bandwidth_dbg(ehci, sign, "iso", &amp;stream-&gt;ps);
+
+	if (sign &lt; 0) {		/* Release bandwidth */
+		usecs = -usecs;
+		c_usecs = -c_usecs;
+	}
+
+	if (!stream-&gt;splits) {		/* High speed */
+		for (i = uframe + stream-&gt;ps.phase_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += stream-&gt;ps.bw_uperiod)
+			ehci-&gt;bandwidth[i] += usecs;
+
+	} else {			/* Full speed */
+		s_mask = stream-&gt;ps.cs_mask;
+		c_mask = s_mask &gt;&gt; 8;
+
+		/* NOTE: adjustment needed for frame overflow */
+		for (i = uframe; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += stream-&gt;ps.bw_uperiod) {
+			for ((j = stream-&gt;ps.phase_uf, m = 1 &lt;&lt; j); j &lt; 8;
+					(++j, m &lt;&lt;= 1)) {
+				if (s_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += usecs;
+				else if (c_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += c_usecs;
+			}
+		}
+	}
+}
+
 static inline int
 itd_slot_ok (
 	struct ehci_hcd		*ehci,
-	u32			mod,
-	u32			uframe,
-	u8			usecs,
-	u32			period
+	struct ehci_iso_stream	*stream,
+	unsigned		uframe
 )
 {
-	uframe %= period;
-	do {
-		/* can't commit more than uframe_periodic_max usec */
-		if (periodic_usecs (ehci, uframe &gt;&gt; 3, uframe &amp; 0x7)
-				&gt; (ehci-&gt;uframe_periodic_max - usecs))
-			return 0;
+	unsigned		usecs;
+
+	/* convert "usecs we need" to "max already claimed" */
+	usecs = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
 
-		/* we know urb-&gt;interval is 2^N uframes */
-		uframe += period;
-	} while (uframe &lt; mod);
+	for (uframe &amp;= stream-&gt;ps.bw_uperiod - 1; uframe &lt; EHCI_BANDWIDTH_SIZE;
+			uframe += stream-&gt;ps.bw_uperiod) {
+		if (ehci-&gt;bandwidth[uframe] &gt; usecs)
+			return 0;
+	}
 	return 1;
 }
 
 static inline int
 sitd_slot_ok (
 	struct ehci_hcd		*ehci,
-	u32			mod,
 	struct ehci_iso_stream	*stream,
-	u32			uframe,
-	struct ehci_iso_sched	*sched,
-	u32			period_uframes
+	unsigned		uframe,
+	struct ehci_iso_sched	*sched
 )
 {
-	u32			mask, tmp;
-	u32			frame, uf;
+	unsigned		mask, tmp;
+	unsigned		frame, uf;
 
-	mask = stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7);
+	mask = stream-&gt;ps.cs_mask &lt;&lt; (uframe &amp; 7);
 
 	/* for OUT, don't wrap SSPLIT into H-microframe 7 */
-	if (((stream-&gt;raw_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
+	if (((stream-&gt;ps.cs_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
 		return 0;
 
 	/* for IN, don't wrap CSPLIT into the next frame */
@@ -1295,7 +1309,7 @@ sitd_slot_ok (
 		return 0;
 
 	/* check bandwidth */
-	uframe %= period_uframes;
+	uframe &amp;= stream-&gt;ps.bw_uperiod - 1;
 	frame = uframe &gt;&gt; 3;
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
@@ -1303,55 +1317,49 @@ sitd_slot_ok (
 	 * tt_available scheduling guarantees 10+% for control/bulk.
 	 */
 	uf = uframe &amp; 7;
-	if (!tt_available(ehci, period_uframes &gt;&gt; 3,
+	if (!tt_available(ehci, stream-&gt;ps.bw_period,
 			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
 	 * assume scheduling slop leaves 10+% for control/bulk.
 	 */
-	if (!tt_no_collision(ehci, period_uframes &gt;&gt; 3,
+	if (!tt_no_collision(ehci, stream-&gt;ps.bw_period,
 			stream-&gt;ps.udev, frame, mask))
 		return 0;
 #endif
 
-	/* this multi-pass logic is simple, but performance may
-	 * suffer when the schedule data isn't cached.
-	 */
 	do {
-		u32		max_used;
-
-		frame = uframe &gt;&gt; 3;
-		uf = uframe &amp; 7;
+		unsigned	max_used;
+		unsigned	i;
 
 		/* check starts (OUT uses more than one) */
+		uf = uframe;
 		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
-		for (tmp = stream-&gt;raw_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
-			if (periodic_usecs (ehci, frame, uf) &gt; max_used)
+		for (tmp = stream-&gt;ps.cs_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
+			if (ehci-&gt;bandwidth[uf] &gt; max_used)
 				return 0;
 		}
 
 		/* for IN, check CSPLIT */
 		if (stream-&gt;ps.c_usecs) {
-			uf = uframe &amp; 7;
 			max_used = ehci-&gt;uframe_periodic_max -
 					stream-&gt;ps.c_usecs;
-			do {
-				tmp = 1 &lt;&lt; uf;
-				tmp &lt;&lt;= 8;
-				if ((stream-&gt;raw_mask &amp; tmp) == 0)
+			uf = uframe &amp; ~7;
+			tmp = 1 &lt;&lt; (2+8);
+			for (i = (uframe &amp; 7) + 2; i &lt; 8; (++i, tmp &lt;&lt;= 1)) {
+				if ((stream-&gt;ps.cs_mask &amp; tmp) == 0)
 					continue;
-				if (periodic_usecs (ehci, frame, uf)
-						&gt; max_used)
+				if (ehci-&gt;bandwidth[uf+i] &gt; max_used)
 					return 0;
-			} while (++uf &lt; 8);
+			}
 		}
 
-		/* we know urb-&gt;interval is 2^N uframes */
-		uframe += period_uframes;
-	} while (uframe &lt; mod);
+		uframe += stream-&gt;ps.bw_uperiod;
+	} while (uframe &lt; EHCI_BANDWIDTH_SIZE);
 
-	stream-&gt;splits = cpu_to_hc32(ehci, stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7));
+	stream-&gt;ps.cs_mask &lt;&lt;= uframe &amp; 7;
+	stream-&gt;splits = cpu_to_hc32(ehci, stream-&gt;ps.cs_mask);
 	return 1;
 }
 
@@ -1382,12 +1390,10 @@ iso_stream_schedule (
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 	bool			empty = list_empty(&amp;stream-&gt;td_list);
 
-	period = urb-&gt;interval;
+	period = stream-&gt;uperiod;
 	span = sched-&gt;span;
-	if (!stream-&gt;highspeed) {
-		period &lt;&lt;= 3;
+	if (!stream-&gt;highspeed)
 		span &lt;&lt;= 3;
-	}
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
@@ -1404,47 +1410,55 @@ iso_stream_schedule (
 	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
 	next = (next - base) &amp; (mod - 1);
 
-	/*
-	 * Need to schedule; when's the next (u)frame we could start?
-	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the delay should handle reasonably slow cpus.  It
-	 * can also help high bandwidth if the dma and irq loads don't
-	 * jump until after the queue is primed.
-	 */
+	/* Start a new isochronous stream? */
 	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
 			ehci_to_hcd(ehci), urb-&gt;ep))) {
-		int done = 0;
 
-		start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+		/* Schedule the endpoint */
+		if (stream-&gt;ps.phase == NO_FRAME) {
+			int		done = 0;
 
-		/* find a uframe slot with enough bandwidth.
-		 * Early uframes are more precious because full-speed
-		 * iso IN transfers can't use late uframes,
-		 * and therefore they should be allocated last.
-		 */
-		next = start;
-		start += period;
-		do {
-			start--;
-			/* check schedule: enough space? */
-			if (stream-&gt;highspeed) {
-				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;ps.usecs, period))
-					done = 1;
-			} else {
-				if ((start % 8) &gt;= 6)
-					continue;
-				if (sitd_slot_ok(ehci, mod, stream,
-						start, sched, period))
-					done = 1;
+			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+
+			/* find a uframe slot with enough bandwidth.
+			 * Early uframes are more precious because full-speed
+			 * iso IN transfers can't use late uframes,
+			 * and therefore they should be allocated last.
+			 */
+			next = start;
+			start += period;
+			do {
+				start--;
+				/* check schedule: enough space? */
+				if (stream-&gt;highspeed) {
+					if (itd_slot_ok(ehci, stream, start))
+						done = 1;
+				} else {
+					if ((start % 8) &gt;= 6)
+						continue;
+					if (sitd_slot_ok(ehci, stream, start,
+							sched))
+						done = 1;
+				}
+			} while (start &gt; next &amp;&amp; !done);
+
+			/* no room in the schedule */
+			if (!done) {
+				ehci_dbg(ehci, "iso sched full %p", urb);
+				status = -ENOSPC;
+				goto fail;
 			}
-		} while (start &gt; next &amp;&amp; !done);
+			stream-&gt;ps.phase = (start &gt;&gt; 3) &amp;
+					(stream-&gt;ps.period - 1);
+			stream-&gt;ps.bw_phase = stream-&gt;ps.phase &amp;
+					(stream-&gt;ps.bw_period - 1);
+			stream-&gt;ps.phase_uf = start &amp; 7;
+			reserve_release_iso_bandwidth(ehci, stream, 1);
+		}
 
-		/* no room in the schedule */
-		if (!done) {
-			ehci_dbg(ehci, "iso sched full %p", urb);
-			status = -ENOSPC;
-			goto fail;
+		/* New stream is already scheduled; use the upcoming slot */
+		else {
+			start = (stream-&gt;ps.phase &lt;&lt; 3) + stream-&gt;ps.phase_uf;
 		}
 
 		start = (start - base) &amp; (mod - 1);
@@ -1452,7 +1466,7 @@ iso_stream_schedule (
 	}
 
 	/*
-	 * Typical case: reuse current schedule, stream is still active.
+	 * Typical case: reuse current schedule, stream may still be active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 14ced00ba220..f6459dfb6f54 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -97,8 +97,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 {
 	struct ehci_hcd		*ehci;
 	unsigned		uframe_periodic_max;
-	unsigned		frame, uframe;
-	unsigned short		allocated_max;
+	unsigned		uframe;
 	unsigned long		flags;
 	ssize_t			ret;
 
@@ -122,16 +121,14 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 	/*
 	 * for request to decrease max periodic bandwidth, we have to check
-	 * every microframe in the schedule to see whether the decrease is
-	 * possible.
+	 * to see whether the decrease is possible.
 	 */
 	if (uframe_periodic_max &lt; ehci-&gt;uframe_periodic_max) {
-		allocated_max = 0;
+		u8		allocated_max = 0;
 
-		for (frame = 0; frame &lt; ehci-&gt;periodic_size; ++frame)
-			for (uframe = 0; uframe &lt; 7; ++uframe)
-				allocated_max = max(allocated_max,
-						    periodic_usecs (ehci, frame, uframe));
+		for (uframe = 0; uframe &lt; EHCI_BANDWIDTH_SIZE; ++uframe)
+			allocated_max = max(allocated_max,
+					ehci-&gt;bandwidth[uframe]);
 
 		if (allocated_max &gt; uframe_periodic_max) {
 			ehci_info(ehci,
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index e2b64c40d94f..12504fbded56 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -62,10 +62,16 @@ struct ehci_per_sched {
 	struct usb_device	*udev;		/* access to the TT */
 	struct usb_host_endpoint *ep;
 	u16			tt_usecs;	/* time on the FS/LS bus */
+	u16			cs_mask;	/* C-mask and S-mask bytes */
 	u16			period;		/* actual period in frames */
 	u16			phase;		/* actual phase, frame part */
+	u8			bw_phase;	/* same, for bandwidth
+						   reservation */
 	u8			phase_uf;	/* uframe part of the phase */
 	u8			usecs, c_usecs;	/* times on the HS bus */
+	u8			bw_uperiod;	/* period in microframes, for
+						   bandwidth reservation */
+	u8			bw_period;	/* same, in frames */
 };
 #define NO_FRAME	29999			/* frame not assigned yet */
 
@@ -245,6 +251,12 @@ struct ehci_hcd {			/* one per controller */
 	struct dentry		*debug_dir;
 #endif
 
+	/* bandwidth usage */
+#define EHCI_BANDWIDTH_SIZE	64
+#define EHCI_BANDWIDTH_FRAMES	(EHCI_BANDWIDTH_SIZE &gt;&gt; 3)
+	u8			bandwidth[EHCI_BANDWIDTH_SIZE];
+						/* us allocated per uframe */
+
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
 };
@@ -469,7 +481,6 @@ struct ehci_iso_stream {
 	 */
 	u16			uperiod;	/* period in uframes */
 	u16			maxp;
-	u16			raw_mask;
 	unsigned		bandwidth;
 
 	/* This is used to initialize iTD's hw_bufp fields */</pre><hr><pre>commit ffa0248e643175cea3887c7058916af53104d8e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:03 2013 -0400

    USB: EHCI: create a "periodic schedule info" struct
    
    This patch begins the process of unifying the scheduling parameters
    that ehci-hcd uses for interrupt and isochronous transfers.  It
    creates an ehci_per_sched structure, which will be stored in both
    ehci_qh and ehci_iso_stream structures, and will contain the common
    scheduling information needed for both.
    
    Initially we merely create the new structure and move some existing
    fields into it.  Later patches will add more fields and utilize these
    structures in improved scheduling algorithms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index da7d7fcccb8a..09e5bc8e2b98 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -571,7 +571,7 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 			case Q_TYPE_QH:
 				hw = p.qh-&gt;hw;
 				temp = scnprintf (next, size, " qh%d-%04x/%p",
-						p.qh-&gt;period,
+						p.qh-&gt;ps.period,
 						hc32_to_cpup(ehci,
 							&amp;hw-&gt;hw_info2)
 							/* uframe masks */
@@ -618,7 +618,8 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 						speed_char (scratch),
 						scratch &amp; 0x007f,
 						(scratch &gt;&gt; 8) &amp; 0x000f, type,
-						p.qh-&gt;usecs, p.qh-&gt;c_usecs,
+						p.qh-&gt;ps.usecs,
+						p.qh-&gt;ps.c_usecs,
 						temp,
 						0x7ff &amp; (scratch &gt;&gt; 16));
 
@@ -645,7 +646,7 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 			case Q_TYPE_SITD:
 				temp = scnprintf (next, size,
 					" sitd%d-%04x/%p",
-					p.sitd-&gt;stream-&gt;interval,
+					p.sitd-&gt;stream-&gt;ps.period,
 					hc32_to_cpup(ehci, &amp;p.sitd-&gt;hw_uframe)
 						&amp; 0x0000ffff,
 					p.sitd);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 652018f93632..b2e4e4b3cfae 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1029,7 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
+			usb_settoggle(qh-&gt;ps.udev, epnum, is_out, 0);
 			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e321804c3475..9bfaa21707bd 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -105,9 +105,9 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 
 		is_out = qh-&gt;is_out;
 		epnum = (hc32_to_cpup(ehci, &amp;hw-&gt;hw_info1) &gt;&gt; 8) &amp; 0x0f;
-		if (unlikely (!usb_gettoggle (qh-&gt;dev, epnum, is_out))) {
+		if (unlikely(!usb_gettoggle(qh-&gt;ps.udev, epnum, is_out))) {
 			hw-&gt;hw_token &amp;= ~cpu_to_hc32(ehci, QTD_TOGGLE);
-			usb_settoggle (qh-&gt;dev, epnum, is_out, 1);
+			usb_settoggle(qh-&gt;ps.udev, epnum, is_out, 1);
 		}
 	}
 
@@ -797,26 +797,25 @@ qh_make (
 	 * For control/bulk requests, the HC or TT handles these.
 	 */
 	if (type == PIPE_INTERRUPT) {
-		qh-&gt;usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
+		qh-&gt;ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
-		qh-&gt;start = NO_FRAME;
+		qh-&gt;ps.phase = NO_FRAME;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
-			qh-&gt;c_usecs = 0;
+			qh-&gt;ps.c_usecs = 0;
 			qh-&gt;gap_uf = 0;
 
-			qh-&gt;period = urb-&gt;interval &gt;&gt; 3;
-			if (qh-&gt;period == 0 &amp;&amp; urb-&gt;interval != 1) {
+			if (urb-&gt;interval &gt; 1 &amp;&amp; urb-&gt;interval &lt; 8) {
 				/* NOTE interval 2 or 4 uframes could work.
 				 * But interval 1 scheduling is simpler, and
 				 * includes high bandwidth.
 				 */
 				urb-&gt;interval = 1;
-			} else if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
-				qh-&gt;period = ehci-&gt;periodic_size;
-				urb-&gt;interval = qh-&gt;period &lt;&lt; 3;
+			} else if (urb-&gt;interval &gt; ehci-&gt;periodic_size &lt;&lt; 3) {
+				urb-&gt;interval = ehci-&gt;periodic_size &lt;&lt; 3;
 			}
+			qh-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
 		} else {
 			int		think_time;
 
@@ -826,27 +825,26 @@ qh_make (
 
 			/* FIXME this just approximates SPLIT/CSPLIT times */
 			if (is_input) {		// SPLIT, gap, CSPLIT+DATA
-				qh-&gt;c_usecs = qh-&gt;usecs + HS_USECS (0);
-				qh-&gt;usecs = HS_USECS (1);
+				qh-&gt;ps.c_usecs = qh-&gt;ps.usecs + HS_USECS(0);
+				qh-&gt;ps.usecs = HS_USECS(1);
 			} else {		// SPLIT+DATA, gap, CSPLIT
-				qh-&gt;usecs += HS_USECS (1);
-				qh-&gt;c_usecs = HS_USECS (0);
+				qh-&gt;ps.usecs += HS_USECS(1);
+				qh-&gt;ps.c_usecs = HS_USECS(0);
 			}
 
 			think_time = tt ? tt-&gt;think_time : 0;
-			qh-&gt;tt_usecs = NS_TO_US (think_time +
+			qh-&gt;ps.tt_usecs = NS_TO_US(think_time +
 					usb_calc_bus_time (urb-&gt;dev-&gt;speed,
 					is_input, 0, max_packet (maxp)));
-			qh-&gt;period = urb-&gt;interval;
-			if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
-				qh-&gt;period = ehci-&gt;periodic_size;
-				urb-&gt;interval = qh-&gt;period;
-			}
+			if (urb-&gt;interval &gt; ehci-&gt;periodic_size)
+				urb-&gt;interval = ehci-&gt;periodic_size;
+			qh-&gt;ps.period = urb-&gt;interval;
 		}
 	}
 
 	/* support for tt scheduling, and access to toggles */
-	qh-&gt;dev = urb-&gt;dev;
+	qh-&gt;ps.udev = urb-&gt;dev;
+	qh-&gt;ps.ep = urb-&gt;ep;
 
 	/* using TT? */
 	switch (urb-&gt;dev-&gt;speed) {
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 37e97a70894a..1fafcda0ae81 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -121,11 +121,11 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			hw = q-&gt;qh-&gt;hw;
 			/* is it in the S-mask? */
 			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; uframe))
-				usecs += q-&gt;qh-&gt;usecs;
+				usecs += q-&gt;qh-&gt;ps.usecs;
 			/* ... or C-mask? */
 			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci,
 					1 &lt;&lt; (8 + uframe)))
-				usecs += q-&gt;qh-&gt;c_usecs;
+				usecs += q-&gt;qh-&gt;ps.c_usecs;
 			hw_p = &amp;hw-&gt;hw_next;
 			q = &amp;q-&gt;qh-&gt;qh_next;
 			break;
@@ -142,7 +142,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			break;
 		case Q_TYPE_ITD:
 			if (q-&gt;itd-&gt;hw_transaction[uframe])
-				usecs += q-&gt;itd-&gt;stream-&gt;usecs;
+				usecs += q-&gt;itd-&gt;stream-&gt;ps.usecs;
 			hw_p = &amp;q-&gt;itd-&gt;hw_next;
 			q = &amp;q-&gt;itd-&gt;itd_next;
 			break;
@@ -152,7 +152,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 					1 &lt;&lt; uframe)) {
 				if (q-&gt;sitd-&gt;hw_fullspeed_ep &amp;
 						cpu_to_hc32(ehci, 1&lt;&lt;31))
-					usecs += q-&gt;sitd-&gt;stream-&gt;usecs;
+					usecs += q-&gt;sitd-&gt;stream-&gt;ps.usecs;
 				else	/* worst case for OUT start-split */
 					usecs += HS_USECS_ISO (188);
 			}
@@ -161,7 +161,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			if (q-&gt;sitd-&gt;hw_uframe &amp;
 					cpu_to_hc32(ehci, 1 &lt;&lt; (8 + uframe))) {
 				/* worst case for IN complete-split */
-				usecs += q-&gt;sitd-&gt;stream-&gt;c_usecs;
+				usecs += q-&gt;sitd-&gt;stream-&gt;ps.c_usecs;
 			}
 
 			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
@@ -258,9 +258,9 @@ periodic_tt_usecs (
 			q = &amp;q-&gt;itd-&gt;itd_next;
 			continue;
 		case Q_TYPE_QH:
-			if (same_tt(dev, q-&gt;qh-&gt;dev)) {
+			if (same_tt(dev, q-&gt;qh-&gt;ps.udev)) {
 				uf = tt_start_uframe(ehci, q-&gt;qh-&gt;hw-&gt;hw_info2);
-				tt_usecs[uf] += q-&gt;qh-&gt;tt_usecs;
+				tt_usecs[uf] += q-&gt;qh-&gt;ps.tt_usecs;
 			}
 			hw_p = &amp;q-&gt;qh-&gt;hw-&gt;hw_next;
 			q = &amp;q-&gt;qh-&gt;qh_next;
@@ -268,7 +268,7 @@ periodic_tt_usecs (
 		case Q_TYPE_SITD:
 			if (same_tt(dev, q-&gt;sitd-&gt;urb-&gt;dev)) {
 				uf = tt_start_uframe(ehci, q-&gt;sitd-&gt;hw_uframe);
-				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;tt_usecs;
+				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;ps.tt_usecs;
 			}
 			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
 			q = &amp;q-&gt;sitd-&gt;sitd_next;
@@ -391,7 +391,7 @@ static int tt_no_collision (
 				continue;
 			case Q_TYPE_QH:
 				hw = here.qh-&gt;hw;
-				if (same_tt (dev, here.qh-&gt;dev)) {
+				if (same_tt(dev, here.qh-&gt;ps.udev)) {
 					u32		mask;
 
 					mask = hc32_to_cpu(ehci,
@@ -471,19 +471,19 @@ static void disable_periodic(struct ehci_hcd *ehci)
 static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
-	unsigned	period = qh-&gt;period;
+	unsigned	period = qh-&gt;ps.period;
 
-	dev_dbg (&amp;qh-&gt;dev-&gt;dev,
+	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
 		"link qh%d-%04x/%p start %d [%d/%d us]\n",
 		period, hc32_to_cpup(ehci, &amp;qh-&gt;hw-&gt;hw_info2)
 			&amp; (QH_CMASK | QH_SMASK),
-		qh, qh-&gt;start, qh-&gt;usecs, qh-&gt;c_usecs);
+		qh, qh-&gt;ps.phase, qh-&gt;ps.usecs, qh-&gt;ps.c_usecs);
 
 	/* high bandwidth, or otherwise every microframe */
 	if (period == 0)
 		period = 1;
 
-	for (i = qh-&gt;start; i &lt; ehci-&gt;periodic_size; i += period) {
+	for (i = qh-&gt;ps.phase; i &lt; ehci-&gt;periodic_size; i += period) {
 		union ehci_shadow	*prev = &amp;ehci-&gt;pshadow[i];
 		__hc32			*hw_p = &amp;ehci-&gt;periodic[i];
 		union ehci_shadow	here = *prev;
@@ -503,7 +503,7 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 * enables sharing interior tree nodes
 		 */
 		while (here.ptr &amp;&amp; qh != here.qh) {
-			if (qh-&gt;period &gt; here.qh-&gt;period)
+			if (qh-&gt;ps.period &gt; here.qh-&gt;ps.period)
 				break;
 			prev = &amp;here.qh-&gt;qh_next;
 			hw_p = &amp;here.qh-&gt;hw-&gt;hw_next;
@@ -523,10 +523,10 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;xacterrs = 0;
 	qh-&gt;exception = 0;
 
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;period
-		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
-		: (qh-&gt;usecs * 8);
+	/* update per-qh bandwidth for debugfs */
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+		: (qh-&gt;ps.usecs * 8);
 
 	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
 
@@ -556,22 +556,21 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 */
 
 	/* high bandwidth, or otherwise part of every microframe */
-	if ((period = qh-&gt;period) == 0)
-		period = 1;
+	period = qh-&gt;ps.period ? : 1;
 
-	for (i = qh-&gt;start; i &lt; ehci-&gt;periodic_size; i += period)
+	for (i = qh-&gt;ps.phase; i &lt; ehci-&gt;periodic_size; i += period)
 		periodic_unlink (ehci, i, qh);
 
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;period
-		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
-		: (qh-&gt;usecs * 8);
+	/* update per-qh bandwidth for debugfs */
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+		: (qh-&gt;ps.usecs * 8);
 
-	dev_dbg (&amp;qh-&gt;dev-&gt;dev,
+	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
 		"unlink qh%d-%04x/%p start %d [%d/%d us]\n",
-		qh-&gt;period,
+		qh-&gt;ps.period,
 		hc32_to_cpup(ehci, &amp;qh-&gt;hw-&gt;hw_info2) &amp; (QH_CMASK | QH_SMASK),
-		qh, qh-&gt;start, qh-&gt;usecs, qh-&gt;c_usecs);
+		qh, qh-&gt;ps.phase, qh-&gt;ps.usecs, qh-&gt;ps.c_usecs);
 
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
@@ -744,26 +743,26 @@ static int check_intr_schedule (
 	int		retval = -ENOSPC;
 	u8		mask = 0;
 
-	if (qh-&gt;c_usecs &amp;&amp; uframe &gt;= 6)		/* FSTN territory? */
+	if (qh-&gt;ps.c_usecs &amp;&amp; uframe &gt;= 6)	/* FSTN territory? */
 		goto done;
 
-	if (!check_period (ehci, frame, uframe, qh-&gt;period, qh-&gt;usecs))
+	if (!check_period(ehci, frame, uframe, qh-&gt;ps.period, qh-&gt;ps.usecs))
 		goto done;
-	if (!qh-&gt;c_usecs) {
+	if (!qh-&gt;ps.c_usecs) {
 		retval = 0;
 		*c_maskp = 0;
 		goto done;
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available (ehci, qh-&gt;period, qh-&gt;dev, frame, uframe,
-				qh-&gt;tt_usecs)) {
+	if (tt_available(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, uframe,
+				qh-&gt;ps.tt_usecs)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
 		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
-			if (!check_period (ehci, frame, i,
-						qh-&gt;period, qh-&gt;c_usecs))
+			if (!check_period(ehci, frame, i,
+					qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 				goto done;
 			else
 				mask |= 1 &lt;&lt; i;
@@ -784,12 +783,12 @@ static int check_intr_schedule (
 	*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
 
 	mask |= 1 &lt;&lt; uframe;
-	if (tt_no_collision (ehci, qh-&gt;period, qh-&gt;dev, frame, mask)) {
-		if (!check_period (ehci, frame, uframe + qh-&gt;gap_uf + 1,
-					qh-&gt;period, qh-&gt;c_usecs))
+	if (tt_no_collision(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, mask)) {
+		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf + 1,
+				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 			goto done;
-		if (!check_period (ehci, frame, uframe + qh-&gt;gap_uf,
-					qh-&gt;period, qh-&gt;c_usecs))
+		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf,
+				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 			goto done;
 		retval = 0;
 	}
@@ -810,7 +809,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	frame = qh-&gt;start;
+	frame = qh-&gt;ps.phase;
 
 	/* reuse the previous schedule slots, if we can */
 	if (frame != NO_FRAME) {
@@ -828,11 +827,11 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 */
 	if (status) {
 		/* "normal" case, uframing flexible except with splits */
-		if (qh-&gt;period) {
+		if (qh-&gt;ps.period) {
 			int		i;
 
-			for (i = qh-&gt;period; status &amp;&amp; i &gt; 0; --i) {
-				frame = ++ehci-&gt;random_frame % qh-&gt;period;
+			for (i = qh-&gt;ps.period; status &amp;&amp; i &gt; 0; --i) {
+				frame = ++ehci-&gt;random_frame % qh-&gt;ps.period;
 				for (uframe = 0; uframe &lt; 8; uframe++) {
 					status = check_intr_schedule (ehci,
 							frame, uframe, qh,
@@ -842,18 +841,18 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 				}
 			}
 
-		/* qh-&gt;period == 0 means every uframe */
+		/* qh-&gt;ps.period == 0 means every uframe */
 		} else {
 			frame = 0;
 			status = check_intr_schedule (ehci, 0, 0, qh, &amp;c_mask);
 		}
 		if (status)
 			goto done;
-		qh-&gt;start = frame;
+		qh-&gt;ps.phase = frame;
 
 		/* reset S-frame and (maybe) C-frame masks */
 		hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
-		hw-&gt;hw_info2 |= qh-&gt;period
+		hw-&gt;hw_info2 |= qh-&gt;ps.period
 			? cpu_to_hc32(ehci, 1 &lt;&lt; uframe)
 			: cpu_to_hc32(ehci, QH_SMASK);
 		hw-&gt;hw_info2 |= c_mask;
@@ -978,25 +977,24 @@ static void
 iso_stream_init (
 	struct ehci_hcd		*ehci,
 	struct ehci_iso_stream	*stream,
-	struct usb_device	*dev,
-	int			pipe,
-	unsigned		interval
+	struct urb		*urb
 )
 {
 	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
 
+	struct usb_device	*dev = urb-&gt;dev;
+	unsigned		interval = urb-&gt;interval;
 	u32			buf1;
 	unsigned		epnum, maxp;
 	int			is_input;
-	long			bandwidth;
 
 	/*
 	 * this might be a "high bandwidth" highspeed endpoint,
 	 * as encoded in the ep descriptor's wMaxPacket field
 	 */
-	epnum = usb_pipeendpoint (pipe);
-	is_input = usb_pipein (pipe) ? USB_DIR_IN : 0;
-	maxp = usb_maxpacket(dev, pipe, !is_input);
+	epnum = usb_pipeendpoint(urb-&gt;pipe);
+	is_input = usb_pipein(urb-&gt;pipe) ? USB_DIR_IN : 0;
+	maxp = usb_endpoint_maxp(&amp;urb-&gt;ep-&gt;desc);
 	if (is_input) {
 		buf1 = (1 &lt;&lt; 11);
 	} else {
@@ -1020,9 +1018,11 @@ iso_stream_init (
 		/* usbfs wants to report the average usecs per frame tied up
 		 * when transfers on this endpoint are scheduled ...
 		 */
-		stream-&gt;usecs = HS_USECS_ISO (maxp);
-		bandwidth = stream-&gt;usecs * 8;
-		bandwidth /= interval;
+		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
+
+		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 / interval;
+		stream-&gt;uperiod = interval;
+		stream-&gt;ps.period = interval &gt;&gt; 3;
 
 	} else {
 		u32		addr;
@@ -1036,17 +1036,17 @@ iso_stream_init (
 			addr |= dev-&gt;tt-&gt;hub-&gt;devnum &lt;&lt; 16;
 		addr |= epnum &lt;&lt; 8;
 		addr |= dev-&gt;devnum;
-		stream-&gt;usecs = HS_USECS_ISO (maxp);
+		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
 		think_time = dev-&gt;tt ? dev-&gt;tt-&gt;think_time : 0;
-		stream-&gt;tt_usecs = NS_TO_US (think_time + usb_calc_bus_time (
+		stream-&gt;ps.tt_usecs = NS_TO_US(think_time + usb_calc_bus_time(
 				dev-&gt;speed, is_input, 1, maxp));
 		hs_transfers = max (1u, (maxp + 187) / 188);
 		if (is_input) {
 			u32	tmp;
 
 			addr |= 1 &lt;&lt; 31;
-			stream-&gt;c_usecs = stream-&gt;usecs;
-			stream-&gt;usecs = HS_USECS_ISO (1);
+			stream-&gt;ps.c_usecs = stream-&gt;ps.usecs;
+			stream-&gt;ps.usecs = HS_USECS_ISO(1);
 			stream-&gt;raw_mask = 1;
 
 			/* c-mask as specified in USB 2.0 11.18.4 3.c */
@@ -1054,18 +1054,20 @@ iso_stream_init (
 			stream-&gt;raw_mask |= tmp &lt;&lt; (8 + 2);
 		} else
 			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
-		bandwidth = stream-&gt;usecs + stream-&gt;c_usecs;
-		bandwidth /= interval;
+
+		stream-&gt;bandwidth = (stream-&gt;ps.usecs + stream-&gt;ps.c_usecs) /
+				interval;
+		stream-&gt;uperiod = interval &lt;&lt; 3;
+		stream-&gt;ps.period = interval;
 
 		/* stream-&gt;splits gets created from raw_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);
 	}
-	stream-&gt;bandwidth = bandwidth;
 
-	stream-&gt;udev = dev;
+	stream-&gt;ps.udev = dev;
+	stream-&gt;ps.ep = urb-&gt;ep;
 
 	stream-&gt;bEndpointAddress = is_input | epnum;
-	stream-&gt;interval = interval;
 	stream-&gt;maxp = maxp;
 }
 
@@ -1090,9 +1092,7 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 		stream = iso_stream_alloc(GFP_ATOMIC);
 		if (likely (stream != NULL)) {
 			ep-&gt;hcpriv = stream;
-			stream-&gt;ep = ep;
-			iso_stream_init(ehci, stream, urb-&gt;dev, urb-&gt;pipe,
-					urb-&gt;interval);
+			iso_stream_init(ehci, stream, urb);
 		}
 
 	/* if dev-&gt;ep [epnum] is a QH, hw is set */
@@ -1137,7 +1137,7 @@ itd_sched_init(
 	dma_addr_t	dma = urb-&gt;transfer_dma;
 
 	/* how many uframes are needed for these transfers */
-	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;interval;
+	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;uperiod;
 
 	/* figure out per-uframe itd fields that we'll need later
 	 * when we fit new itds into the schedule.
@@ -1304,14 +1304,14 @@ sitd_slot_ok (
 	 */
 	uf = uframe &amp; 7;
 	if (!tt_available(ehci, period_uframes &gt;&gt; 3,
-			stream-&gt;udev, frame, uf, stream-&gt;tt_usecs))
+			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
 	 * assume scheduling slop leaves 10+% for control/bulk.
 	 */
 	if (!tt_no_collision(ehci, period_uframes &gt;&gt; 3,
-			stream-&gt;udev, frame, mask))
+			stream-&gt;ps.udev, frame, mask))
 		return 0;
 #endif
 
@@ -1325,16 +1325,17 @@ sitd_slot_ok (
 		uf = uframe &amp; 7;
 
 		/* check starts (OUT uses more than one) */
-		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;usecs;
+		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
 		for (tmp = stream-&gt;raw_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
 			if (periodic_usecs (ehci, frame, uf) &gt; max_used)
 				return 0;
 		}
 
 		/* for IN, check CSPLIT */
-		if (stream-&gt;c_usecs) {
+		if (stream-&gt;ps.c_usecs) {
 			uf = uframe &amp; 7;
-			max_used = ehci-&gt;uframe_periodic_max - stream-&gt;c_usecs;
+			max_used = ehci-&gt;uframe_periodic_max -
+					stream-&gt;ps.c_usecs;
 			do {
 				tmp = 1 &lt;&lt; uf;
 				tmp &lt;&lt;= 8;
@@ -1428,7 +1429,7 @@ iso_stream_schedule (
 			/* check schedule: enough space? */
 			if (stream-&gt;highspeed) {
 				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;usecs, period))
+						stream-&gt;ps.usecs, period))
 					done = 1;
 			} else {
 				if ((start % 8) &gt;= 6)
@@ -1668,7 +1669,7 @@ static void itd_link_urb(
 
 		itd_patch(ehci, itd, iso_sched, packet, uframe);
 
-		next_uframe += stream-&gt;interval;
+		next_uframe += stream-&gt;uperiod;
 		next_uframe &amp;= mod - 1;
 		packet++;
 
@@ -1808,9 +1809,9 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		ehci_dbg (ehci, "can't get iso stream\n");
 		return -ENOMEM;
 	}
-	if (unlikely (urb-&gt;interval != stream-&gt;interval)) {
+	if (unlikely(urb-&gt;interval != stream-&gt;uperiod)) {
 		ehci_dbg (ehci, "can't change iso interval %d --&gt; %d\n",
-			stream-&gt;interval, urb-&gt;interval);
+			stream-&gt;uperiod, urb-&gt;interval);
 		goto done;
 	}
 
@@ -1875,7 +1876,7 @@ sitd_sched_init(
 	dma_addr_t	dma = urb-&gt;transfer_dma;
 
 	/* how many frames are needed for these transfers */
-	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;interval;
+	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;ps.period;
 
 	/* figure out per-frame sitd fields that we'll need later
 	 * when we fit new sitds into the schedule.
@@ -2069,7 +2070,7 @@ static void sitd_link_urb(
 		sitd_link(ehci, (next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 				sitd);
 
-		next_uframe += stream-&gt;interval &lt;&lt; 3;
+		next_uframe += stream-&gt;uperiod;
 	}
 	stream-&gt;next_uframe = next_uframe &amp; (mod - 1);
 
@@ -2188,9 +2189,9 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		ehci_dbg (ehci, "can't get iso stream\n");
 		return -ENOMEM;
 	}
-	if (urb-&gt;interval != stream-&gt;interval) {
+	if (urb-&gt;interval != stream-&gt;ps.period) {
 		ehci_dbg (ehci, "can't change iso interval %d --&gt; %d\n",
-			stream-&gt;interval, urb-&gt;interval);
+			stream-&gt;ps.period, urb-&gt;interval);
 		goto done;
 	}
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index b93eb59bb529..e2b64c40d94f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -54,6 +54,19 @@ struct ehci_stats {
 	unsigned long		unlink;
 };
 
+/*
+ * Scheduling and budgeting information for periodic transfers, for both
+ * high-speed devices and full/low-speed devices lying behind a TT.
+ */
+struct ehci_per_sched {
+	struct usb_device	*udev;		/* access to the TT */
+	struct usb_host_endpoint *ep;
+	u16			tt_usecs;	/* time on the FS/LS bus */
+	u16			period;		/* actual period in frames */
+	u16			phase;		/* actual phase, frame part */
+	u8			phase_uf;	/* uframe part of the phase */
+	u8			usecs, c_usecs;	/* times on the HS bus */
+};
 #define NO_FRAME	29999			/* frame not assigned yet */
 
 /* ehci_hcd-&gt;lock guards shared data against other CPUs:
@@ -387,6 +400,7 @@ struct ehci_qh {
 	struct list_head	intr_node;	/* list of intr QHs */
 	struct ehci_qtd		*dummy;
 	struct list_head	unlink_node;
+	struct ehci_per_sched	ps;		/* scheduling info */
 
 	unsigned		unlink_cycle;
 
@@ -400,15 +414,8 @@ struct ehci_qh {
 	u8			xacterrs;	/* XactErr retry counter */
 #define	QH_XACTERR_MAX		32		/* XactErr retry limit */
 
-	/* periodic schedule info */
-	u8			usecs;		/* intr bandwidth */
 	u8			gap_uf;		/* uframes split/csplit gap */
-	u8			c_usecs;	/* ... split completion bw */
-	u16			tt_usecs;	/* tt downstream bandwidth */
-	unsigned short		period;		/* polling interval */
-	unsigned short		start;		/* where polling starts */
 
-	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
 	unsigned		dequeue_during_giveback:1;
@@ -451,20 +458,16 @@ struct ehci_iso_stream {
 	u8			highspeed;
 	struct list_head	td_list;	/* queued itds/sitds */
 	struct list_head	free_list;	/* list of unused itds/sitds */
-	struct usb_device	*udev;
-	struct usb_host_endpoint *ep;
 
 	/* output of (re)scheduling */
+	struct ehci_per_sched	ps;		/* scheduling info */
 	unsigned		next_uframe;
 	__hc32			splits;
 
 	/* the rest is derived from the endpoint descriptor,
-	 * trusting urb-&gt;interval == f(epdesc-&gt;bInterval) and
 	 * including the extra info for hw_bufp[0..2]
 	 */
-	u8			usecs, c_usecs;
-	u16			interval;
-	u16			tt_usecs;
+	u16			uperiod;	/* period in uframes */
 	u16			maxp;
 	u16			raw_mask;
 	unsigned		bandwidth;</pre><hr><pre>commit 91a99b5e78849db90dc2f5e8dfa034af43bdb760
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:52 2013 -0400

    USB: EHCI: use consistent NO_FRAME value
    
    ehci-hcd is inconsistent in the sentinel values it uses to indicate
    that no frame number has been assigned for a periodic transfer.  Some
    places it uses NO_FRAME (defined as 65535), other places it uses -1,
    and elsewhere it uses 9999.
    
    This patch defines a value for NO_FRAME which can fit in a 16-bit
    signed integer, and changes the code to use it everywhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1fc2befc4fdc..37e97a70894a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -813,7 +813,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	frame = qh-&gt;start;
 
 	/* reuse the previous schedule slots, if we can */
-	if (frame &lt; qh-&gt;period) {
+	if (frame != NO_FRAME) {
 		uframe = ffs(hc32_to_cpup(ehci, &amp;hw-&gt;hw_info2) &amp; QH_SMASK);
 		status = check_intr_schedule (ehci, frame, --uframe,
 				qh, &amp;c_mask);
@@ -969,7 +969,7 @@ iso_stream_alloc (gfp_t mem_flags)
 	if (likely (stream != NULL)) {
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
-		stream-&gt;next_uframe = -1;
+		stream-&gt;next_uframe = NO_FRAME;
 	}
 	return stream;
 }
@@ -1236,7 +1236,7 @@ itd_urb_transaction (
 
 		memset (itd, 0, sizeof *itd);
 		itd-&gt;itd_dma = itd_dma;
-		itd-&gt;frame = 9999;		/* an invalid value */
+		itd-&gt;frame = NO_FRAME;
 		list_add (&amp;itd-&gt;itd_list, &amp;sched-&gt;td_list);
 	}
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
@@ -1967,7 +1967,7 @@ sitd_urb_transaction (
 
 		memset (sitd, 0, sizeof *sitd);
 		sitd-&gt;sitd_dma = sitd_dma;
-		sitd-&gt;frame = 9999;		/* an invalid value */
+		sitd-&gt;frame = NO_FRAME;
 		list_add (&amp;sitd-&gt;sitd_list, &amp;iso_sched-&gt;td_list);
 	}
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2d401927e143..b93eb59bb529 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -54,6 +54,8 @@ struct ehci_stats {
 	unsigned long		unlink;
 };
 
+#define NO_FRAME	29999			/* frame not assigned yet */
+
 /* ehci_hcd-&gt;lock guards shared data against other CPUs:
  *   ehci_hcd:	async, unlink, periodic (and shadow), ...
  *   usb_host_endpoint: hcpriv
@@ -405,7 +407,6 @@ struct ehci_qh {
 	u16			tt_usecs;	/* tt downstream bandwidth */
 	unsigned short		period;		/* polling interval */
 	unsigned short		start;		/* where polling starts */
-#define NO_FRAME ((unsigned short)~0)			/* pick new start */
 
 	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
@@ -454,7 +455,7 @@ struct ehci_iso_stream {
 	struct usb_host_endpoint *ep;
 
 	/* output of (re)scheduling */
-	int			next_uframe;
+	unsigned		next_uframe;
 	__hc32			splits;
 
 	/* the rest is derived from the endpoint descriptor,</pre><hr><pre>commit 27c4a31d6739095d613c6e72fb44867bc28c699f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:44 2013 -0400

    USB: EHCI: change toggle only upon successful reset
    
    ehci-hcd uses a value of 0 in an endpoint's toggle flag to indicate
    that the endpoint has been reset (and therefore the Data Toggle bit
    needs to be cleared in the endpoint's QH overlay region).
    
    The toggle flag should be set to 0 only when ehci_endpoint_reset()
    succeeds.  This patch moves the usb_settoggle() call into the
    appropriate branch of the "if" statement.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3e3ca839e6ce..652018f93632 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1022,7 +1022,6 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * the toggle bit in the QH.
 	 */
 	if (qh) {
-		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
 		} else {
@@ -1030,6 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);</pre><hr><pre>commit 8c05dc598e5bc0eb33791de23157cf1e47cb580e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:31 2013 -0400

    USB: EHCI: No SSPLIT allowed in uframe 7
    
    The scheduling code in ehci-hcd contains an error.  For full-speed
    isochronous-OUT transfers, the EHCI spec forbids scheduling
    Start-Split transactions in H-microframe 7, but the driver allows it
    anyway.  This patch adds a check to prevent it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 4b0903c6c616..1fc2befc4fdc 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1286,6 +1286,10 @@ sitd_slot_ok (
 
 	mask = stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7);
 
+	/* for OUT, don't wrap SSPLIT into H-microframe 7 */
+	if (((stream-&gt;raw_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
+		return 0;
+
 	/* for IN, don't wrap CSPLIT into the next frame */
 	if (mask &amp; ~0xffff)
 		return 0;</pre><hr><pre>commit 2b90f01b219e390e1f1bf68dd7a2333efb3e3eff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:21 2013 -0400

    USB: EHCI: compute full-speed bandwidth usage correctly
    
    Although the bandwidth statistics maintained by ehci-hcd show up only
    in the /sys/kernel/debug/usb/devices file, they ought to be calculated
    correctly.  The calculation for full-speed isochronous endpoints is
    wrong; it mistakenly yields bytes per microframe instead of bytes per
    frame.  The "interval" value, which is in frames, should not be
    converted to microframes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 34b5945fafa5..4b0903c6c616 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1055,7 +1055,7 @@ iso_stream_init (
 		} else
 			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
 		bandwidth = stream-&gt;usecs + stream-&gt;c_usecs;
-		bandwidth /= interval &lt;&lt; 3;
+		bandwidth /= interval;
 
 		/* stream-&gt;splits gets created from raw_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);</pre><hr><pre>commit e24371a6be9c5c00b56607bd425cc409cba75d88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:12 2013 -0400

    USB: EHCI: check the right uframes for CSPLIT
    
    The check_intr_schedule() routine in ehci-hcd looks at the wrong
    microframes when checking to see if a full-speed or low-speed
    interrupt endpoint will fit in the periodic schedule.  If the
    Start-Split transaction is scheduled for microframe N then the
    Complete-Split transactions get scheduled for microframes N+2, N+3, and
    N+4.  However the code considers N+1, N+2, and N+3 instead.
    
    This patch fixes the limits on the "for" loop and also improves the
    use of whitespace.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index dcbaad94d607..34b5945fafa5 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -761,7 +761,7 @@ static int check_intr_schedule (
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
-		for (i=uframe+1; i&lt;8 &amp;&amp; i&lt;uframe+4; i++)
+		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
 			if (!check_period (ehci, frame, i,
 						qh-&gt;period, qh-&gt;c_usecs))
 				goto done;</pre><hr><pre>commit 63fb3a280061c5a1d9190015e5a074213f9d23c0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:02 2013 -0400

    USB: NS_TO_US should round up
    
    Host controller drivers use the NS_TO_US macro to convert transaction
    times, which are computed in nanoseconds, to microseconds for
    scheduling.  Periodic scheduling requires worst-case estimates, but
    the macro does its conversion using round-to-nearest.  This patch
    changes it to use round-up, giving a correct worst-case value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index fc64b6825f5e..dbe3cd19ffd8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -564,9 +564,8 @@ extern void usb_ep0_reinit(struct usb_device *);
 		 * of (7/6 * 8 * bytecount) = 9.33 * bytecount */
 		/* bytecount = data payload byte count */
 
-#define NS_TO_US(ns)	((ns + 500L) / 1000L)
-			/* convert &amp; round nanoseconds to microseconds */
-
+#define NS_TO_US(ns)	DIV_ROUND_UP(ns, 1000L)
+			/* convert nanoseconds to microseconds, rounding up */
 
 /*
  * Full/low speed bandwidth allocation constants/support.</pre><hr><pre>commit 976b6c064a957445eb0573b270f2d0282630e9b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:51:58 2013 -0400

    ALSA: improve buffer size computations for USB PCM audio
    
    This patch changes the way URBs are allocated and their sizes are
    determined for PCM playback in the snd-usb-audio driver.  Currently
    the driver allocates too few URBs for endpoints that don't use
    implicit sync, making underruns more likely to occur.  This may be a
    holdover from before I/O delays could be measured accurately; in any
    case, it is no longer necessary.
    
    The patch allocates as many URBs as possible, subject to four
    limitations:
    
            The total number of URBs for the endpoint is not allowed to
            exceed MAX_URBS (which the patch increases from 8 to 12).
    
            The total number of packets per URB is not allowed to exceed
            MAX_PACKS (or MAX_PACKS_HS for high-speed devices), which is
            decreased from 20 to 6.
    
            The total duration of queued data is not allowed to exceed
            MAX_QUEUE, which is decreased from 24 ms to 18 ms.
    
            The total number of ALSA frames in the output queue is not
            allowed to exceed the ALSA buffer size.
    
    The last requirement is the hardest to implement.  Currently the
    number of URBs needed to fill a buffer cannot be determined in
    advance, because a buffer contains a fixed number of frames whereas
    the number of frames in an URB varies to match shifts in the device's
    clock rate.  To solve this problem, the patch changes the logic for
    deciding how many packets an URB should contain.  Rather than using as
    many as possible without exceeding an ALSA period boundary, now the
    driver uses only as many packets as needed to transfer a predetermined
    number of frames.  As a result, unless the device's clock has an
    exceedingly variable rate, the number of URBs making up each period
    (and hence each buffer) will remain constant.
    
    The overall effect of the patch is that playback works better in
    low-latency settings.  The user can still specify values for
    frames/period and periods/buffer that exceed the capabilities of the
    hardware, of course.  But for values that are within those
    capabilities, the performance will be improved.  For example, testing
    shows that a high-speed device can handle 32 frames/period and 3
    periods/buffer at 48 KHz, whereas the current driver starts to get
    glitchy at 64 frames/period and 2 periods/buffer.
    
    A side effect of these changes is that the "nrpacks" module parameter
    is no longer used.  The patch removes it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    Tested-by: Daniel Mack &lt;zonque@gmail.com&gt;
    Tested-by: Eldad Zack &lt;eldad@fogrefinery.com&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 64952e2d3ed1..d1f54dfe41d5 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -79,7 +79,6 @@ static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card *
 /* Vendor/product IDs for this card */
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
-static int nrpacks = 8;		/* max. number of packets per urb */
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 static bool autoclock = true;
@@ -94,8 +93,6 @@ module_param_array(vid, int, NULL, 0444);
 MODULE_PARM_DESC(vid, "Vendor ID for the USB audio device.");
 module_param_array(pid, int, NULL, 0444);
 MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
-module_param(nrpacks, int, 0644);
-MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
 module_param_array(device_setup, int, NULL, 0444);
 MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
 module_param(ignore_ctl_error, bool, 0444);
@@ -374,7 +371,6 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip-&gt;dev = dev;
 	chip-&gt;card = card;
 	chip-&gt;setup = device_setup[idx];
-	chip-&gt;nrpacks = nrpacks;
 	chip-&gt;autoclock = autoclock;
 	chip-&gt;probing = 1;
 
@@ -756,10 +752,6 @@ static struct usb_driver usb_audio_driver = {
 
 static int __init snd_usb_audio_init(void)
 {
-	if (nrpacks &lt; 1 || nrpacks &gt; MAX_PACKS) {
-		printk(KERN_WARNING "invalid nrpacks value.\n");
-		return -EINVAL;
-	}
 	return usb_register(&amp;usb_audio_driver);
 }
 
diff --git a/sound/usb/card.h b/sound/usb/card.h
index 5ecacaa90b53..ca98a9b915c9 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -2,11 +2,11 @@
 #define __USBAUDIO_CARD_H
 
 #define MAX_NR_RATES	1024
-#define MAX_PACKS	20
+#define MAX_PACKS	6		/* per URB */
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
-#define MAX_URBS	8
+#define MAX_URBS	12
 #define SYNC_URBS	4	/* always four urbs for sync */
-#define MAX_QUEUE	24	/* try not to exceed this queue length, in ms */
+#define MAX_QUEUE	18	/* try not to exceed this queue length, in ms */
 
 struct audioformat {
 	struct list_head list;
@@ -87,6 +87,7 @@ struct snd_usb_endpoint {
 	unsigned int phase;		/* phase accumulator */
 	unsigned int maxpacksize;	/* max packet size in bytes */
 	unsigned int maxframesize;      /* max packet size in frames */
+	unsigned int max_urb_frames;	/* max URB size in frames */
 	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
 	unsigned int curframesize;      /* current packet size in frames (for capture) */
 	unsigned int syncmaxsize;	/* sync endpoint packet size */
@@ -116,6 +117,8 @@ struct snd_usb_substream {
 	unsigned int channels_max;	/* max channels in the all audiofmts */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
+	unsigned int period_frames;	/* current frames per period */
+	unsigned int buffer_periods;	/* current periods per buffer */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
@@ -125,6 +128,7 @@ struct snd_usb_substream {
 
 	unsigned int hwptr_done;	/* processed byte position in the buffer */
 	unsigned int transfer_done;		/* processed frames since last period update */
+	unsigned int frame_limit;	/* limits number of packets in URB */
 
 	/* data and sync endpoints for this stream */
 	unsigned int ep_num;		/* the endpoint number */
diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c
index 93e970f2b3c0..21dc6422d747 100644
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@ -574,11 +574,14 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 			      snd_pcm_format_t pcm_format,
 			      unsigned int channels,
 			      unsigned int period_bytes,
+			      unsigned int frames_per_period,
+			      unsigned int periods_per_buffer,
 			      struct audioformat *fmt,
 			      struct snd_usb_endpoint *sync_ep)
 {
-	unsigned int maxsize, i, urb_packs, total_packs, packs_per_ms;
-	int is_playback = usb_pipeout(ep-&gt;pipe);
+	unsigned int maxsize, minsize, packs_per_ms, max_packs_per_urb;
+	unsigned int max_packs_per_period, urbs_per_period, urb_packs;
+	unsigned int max_urbs, i;
 	int frame_bits = snd_pcm_format_physical_width(pcm_format) * channels;
 
 	if (pcm_format == SNDRV_PCM_FORMAT_DSD_U16_LE &amp;&amp; fmt-&gt;dsd_dop) {
@@ -611,58 +614,67 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 	else
 		ep-&gt;curpacksize = maxsize;
 
-	if (snd_usb_get_speed(ep-&gt;chip-&gt;dev) != USB_SPEED_FULL)
+	if (snd_usb_get_speed(ep-&gt;chip-&gt;dev) != USB_SPEED_FULL) {
 		packs_per_ms = 8 &gt;&gt; ep-&gt;datainterval;
-	else
-		packs_per_ms = 1;
-
-	if (is_playback &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep)) {
-		urb_packs = max(ep-&gt;chip-&gt;nrpacks, 1);
-		urb_packs = min(urb_packs, (unsigned int) MAX_PACKS);
+		max_packs_per_urb = MAX_PACKS_HS;
 	} else {
-		urb_packs = 1;
+		packs_per_ms = 1;
+		max_packs_per_urb = MAX_PACKS;
 	}
+	if (sync_ep &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep))
+		max_packs_per_urb = min(max_packs_per_urb,
+					1U &lt;&lt; sync_ep-&gt;syncinterval);
+	max_packs_per_urb = max(1u, max_packs_per_urb &gt;&gt; ep-&gt;datainterval);
 
-	urb_packs *= packs_per_ms;
+	/*
+	 * Capture endpoints need to use small URBs because there's no way
+	 * to tell in advance where the next period will end, and we don't
+	 * want the next URB to complete much after the period ends.
+	 *
+	 * Playback endpoints with implicit sync much use the same parameters
+	 * as their corresponding capture endpoint.
+	 */
+	if (usb_pipein(ep-&gt;pipe) ||
+			snd_usb_endpoint_implicit_feedback_sink(ep)) {
 
-	if (sync_ep &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep))
-		urb_packs = min(urb_packs, 1U &lt;&lt; sync_ep-&gt;syncinterval);
+		/* make capture URBs &lt;= 1 ms and smaller than a period */
+		urb_packs = min(max_packs_per_urb, packs_per_ms);
+		while (urb_packs &gt; 1 &amp;&amp; urb_packs * maxsize &gt;= period_bytes)
+			urb_packs &gt;&gt;= 1;
+		ep-&gt;nurbs = MAX_URBS;
 
-	/* decide how many packets to be used */
-	if (is_playback &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep)) {
-		unsigned int minsize, maxpacks;
+	/*
+	 * Playback endpoints without implicit sync are adjusted so that
+	 * a period fits as evenly as possible in the smallest number of
+	 * URBs.  The total number of URBs is adjusted to the size of the
+	 * ALSA buffer, subject to the MAX_URBS and MAX_QUEUE limits.
+	 */
+	} else {
 		/* determine how small a packet can be */
-		minsize = (ep-&gt;freqn &gt;&gt; (16 - ep-&gt;datainterval))
-			  * (frame_bits &gt;&gt; 3);
+		minsize = (ep-&gt;freqn &gt;&gt; (16 - ep-&gt;datainterval)) *
+				(frame_bits &gt;&gt; 3);
 		/* with sync from device, assume it can be 12% lower */
 		if (sync_ep)
 			minsize -= minsize &gt;&gt; 3;
 		minsize = max(minsize, 1u);
-		total_packs = (period_bytes + minsize - 1) / minsize;
-		/* we need at least two URBs for queueing */
-		if (total_packs &lt; 2) {
-			total_packs = 2;
-		} else {
-			/* and we don't want too long a queue either */
-			maxpacks = max(MAX_QUEUE * packs_per_ms, urb_packs * 2);
-			total_packs = min(total_packs, maxpacks);
-		}
-	} else {
-		while (urb_packs &gt; 1 &amp;&amp; urb_packs * maxsize &gt;= period_bytes)
-			urb_packs &gt;&gt;= 1;
-		total_packs = MAX_URBS * urb_packs;
-	}
 
-	ep-&gt;nurbs = (total_packs + urb_packs - 1) / urb_packs;
-	if (ep-&gt;nurbs &gt; MAX_URBS) {
-		/* too much... */
-		ep-&gt;nurbs = MAX_URBS;
-		total_packs = MAX_URBS * urb_packs;
-	} else if (ep-&gt;nurbs &lt; 2) {
-		/* too little - we need at least two packets
-		 * to ensure contiguous playback/capture
-		 */
-		ep-&gt;nurbs = 2;
+		/* how many packets will contain an entire ALSA period? */
+		max_packs_per_period = DIV_ROUND_UP(period_bytes, minsize);
+
+		/* how many URBs will contain a period? */
+		urbs_per_period = DIV_ROUND_UP(max_packs_per_period,
+				max_packs_per_urb);
+		/* how many packets are needed in each URB? */
+		urb_packs = DIV_ROUND_UP(max_packs_per_period, urbs_per_period);
+
+		/* limit the number of frames in a single URB */
+		ep-&gt;max_urb_frames = DIV_ROUND_UP(frames_per_period,
+					urbs_per_period);
+
+		/* try to use enough URBs to contain an entire ALSA buffer */
+		max_urbs = min((unsigned) MAX_URBS,
+				MAX_QUEUE * packs_per_ms / urb_packs);
+		ep-&gt;nurbs = min(max_urbs, urbs_per_period * periods_per_buffer);
 	}
 
 	/* allocate and initialize data urbs */
@@ -670,8 +682,7 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 		struct snd_urb_ctx *u = &amp;ep-&gt;urb[i];
 		u-&gt;index = i;
 		u-&gt;ep = ep;
-		u-&gt;packets = (i + 1) * total_packs / ep-&gt;nurbs
-			- i * total_packs / ep-&gt;nurbs;
+		u-&gt;packets = urb_packs;
 		u-&gt;buffer_size = maxsize * u-&gt;packets;
 
 		if (fmt-&gt;fmt_type == UAC_FORMAT_TYPE_II)
@@ -748,6 +759,8 @@ static int sync_ep_set_params(struct snd_usb_endpoint *ep,
  * @pcm_format: the audio fomat.
  * @channels: the number of audio channels.
  * @period_bytes: the number of bytes in one alsa period.
+ * @period_frames: the number of frames in one alsa period.
+ * @buffer_periods: the number of periods in one alsa buffer.
  * @rate: the frame rate.
  * @fmt: the USB audio format information
  * @sync_ep: the sync endpoint to use, if any
@@ -760,6 +773,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				snd_pcm_format_t pcm_format,
 				unsigned int channels,
 				unsigned int period_bytes,
+				unsigned int period_frames,
+				unsigned int buffer_periods,
 				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep)
@@ -793,7 +808,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 	switch (ep-&gt;type) {
 	case  SND_USB_ENDPOINT_TYPE_DATA:
 		err = data_ep_set_params(ep, pcm_format, channels,
-					 period_bytes, fmt, sync_ep);
+					 period_bytes, period_frames,
+					 buffer_periods, fmt, sync_ep);
 		break;
 	case  SND_USB_ENDPOINT_TYPE_SYNC:
 		err = sync_ep_set_params(ep, fmt);
diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 2287adf5ca59..3bd02f0d226c 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -12,6 +12,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				snd_pcm_format_t pcm_format,
 				unsigned int channels,
 				unsigned int period_bytes,
+				unsigned int period_frames,
+				unsigned int buffer_periods,
 				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index b375d58871e7..19e79953f2e3 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -595,6 +595,7 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
 						   subs-&gt;pcm_format,
 						   subs-&gt;channels,
 						   subs-&gt;period_bytes,
+						   0, 0,
 						   subs-&gt;cur_rate,
 						   subs-&gt;cur_audiofmt,
 						   NULL);
@@ -631,6 +632,7 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
 					  subs-&gt;pcm_format,
 					  sync_fp-&gt;channels,
 					  sync_period_bytes,
+					  0, 0,
 					  subs-&gt;cur_rate,
 					  sync_fp,
 					  NULL);
@@ -653,6 +655,8 @@ static int configure_endpoint(struct snd_usb_substream *subs)
 					  subs-&gt;pcm_format,
 					  subs-&gt;channels,
 					  subs-&gt;period_bytes,
+					  subs-&gt;period_frames,
+					  subs-&gt;buffer_periods,
 					  subs-&gt;cur_rate,
 					  subs-&gt;cur_audiofmt,
 					  subs-&gt;sync_endpoint);
@@ -689,6 +693,8 @@ static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 
 	subs-&gt;pcm_format = params_format(hw_params);
 	subs-&gt;period_bytes = params_period_bytes(hw_params);
+	subs-&gt;period_frames = params_period_size(hw_params);
+	subs-&gt;buffer_periods = params_periods(hw_params);
 	subs-&gt;channels = params_channels(hw_params);
 	subs-&gt;cur_rate = params_rate(hw_params);
 
@@ -1363,6 +1369,7 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 	frames = 0;
 	urb-&gt;number_of_packets = 0;
 	spin_lock_irqsave(&amp;subs-&gt;lock, flags);
+	subs-&gt;frame_limit += ep-&gt;max_urb_frames;
 	for (i = 0; i &lt; ctx-&gt;packets; i++) {
 		if (ctx-&gt;packet_size[i])
 			counts = ctx-&gt;packet_size[i];
@@ -1377,6 +1384,7 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 		subs-&gt;transfer_done += counts;
 		if (subs-&gt;transfer_done &gt;= runtime-&gt;period_size) {
 			subs-&gt;transfer_done -= runtime-&gt;period_size;
+			subs-&gt;frame_limit = 0;
 			period_elapsed = 1;
 			if (subs-&gt;fmt_type == UAC_FORMAT_TYPE_II) {
 				if (subs-&gt;transfer_done &gt; 0) {
@@ -1399,8 +1407,10 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 				break;
 			}
 		}
-		if (period_elapsed &amp;&amp;
-		    !snd_usb_endpoint_implicit_feedback_sink(subs-&gt;data_endpoint)) /* finish at the period boundary */
+		/* finish at the period boundary or after enough frames */
+		if ((period_elapsed ||
+				subs-&gt;transfer_done &gt;= subs-&gt;frame_limit) &amp;&amp;
+		    !snd_usb_endpoint_implicit_feedback_sink(ep))
 			break;
 	}
 	bytes = frames * ep-&gt;stride;
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index caabe9b3af49..5d2fe0530745 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -55,7 +55,6 @@ struct snd_usb_audio {
 	struct list_head mixer_list;	/* list of mixer interfaces */
 
 	int setup;			/* from the 'device_setup' module param */
-	int nrpacks;			/* from the 'nrpacks' module param */
 	bool autoclock;			/* from the 'autoclock' module param */
 
 	struct usb_host_interface *ctrl_intf;	/* the audio control interface */</pre>
    <div class="pagination">
        <a href='2_31.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><span>[32]</span><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_33.html'>Next&gt;&gt;</a>
    <div>
</body>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_46.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><span>[47]</span><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_48.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 99ac5b1e9536f142461681fa6143a947d66b4279
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:38 2012 -0400

    USB: EHCI: rename "reclaim"
    
    This patch (as1569) renames the ehci-&gt;reclaim list in ehci-hcd.  The
    word "reclaim" is used in the EHCI specification to mean something
    quite different, and "unlink_next" is more descriptive of the list's
    purpose anyway.
    
    Similarly, the "reclaim" field in the ehci_stats structure is renamed
    "iaa", which is more meaningful (to experts, anyway) and is a better
    match for the "lost_iaa" field.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 97338abff296..76120957d60a 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -538,12 +538,13 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (qh = ehci-&gt;async-&gt;qh_next.qh; size &gt; 0 &amp;&amp; qh; qh = qh-&gt;qh_next.qh)
 		qh_lines (ehci, qh, &amp;next, &amp;size);
-	if (ehci-&gt;reclaim &amp;&amp; size &gt; 0) {
-		temp = scnprintf (next, size, "\nreclaim =\n");
+	if (ehci-&gt;async_unlink &amp;&amp; size &gt; 0) {
+		temp = scnprintf(next, size, "\nunlink =\n");
 		size -= temp;
 		next += temp;
 
-		for (qh = ehci-&gt;reclaim; size &gt; 0 &amp;&amp; qh; qh = qh-&gt;reclaim)
+		for (qh = ehci-&gt;async_unlink; size &gt; 0 &amp;&amp; qh;
+				qh = qh-&gt;unlink_next)
 			qh_lines (ehci, qh, &amp;next, &amp;size);
 	}
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
@@ -841,16 +842,17 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 		}
 	}
 
-	if (ehci-&gt;reclaim) {
-		temp = scnprintf(next, size, "reclaim qh %p\n", ehci-&gt;reclaim);
+	if (ehci-&gt;async_unlink) {
+		temp = scnprintf(next, size, "async unlink qh %p\n",
+				ehci-&gt;async_unlink);
 		size -= temp;
 		next += temp;
 	}
 
 #ifdef EHCI_STATS
 	temp = scnprintf (next, size,
-		"irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci-&gt;stats.normal, ehci-&gt;stats.error, ehci-&gt;stats.reclaim,
+		"irq normal %ld err %ld iaa %ld (lost %ld)\n",
+		ehci-&gt;stats.normal, ehci-&gt;stats.error, ehci-&gt;stats.iaa,
 		ehci-&gt;stats.lost_iaa);
 	size -= temp;
 	next += temp;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index cdb15769468a..efee426a2465 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -403,7 +403,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;reclaim
+	if (ehci-&gt;async_unlink
 			&amp;&amp; !timer_pending(&amp;ehci-&gt;iaa_watchdog)
 			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		u32 cmd, status;
@@ -583,8 +583,8 @@ static void ehci_stop (struct usb_hcd *hcd)
 		usb_amd_dev_put();
 
 #ifdef	EHCI_STATS
-	ehci_dbg (ehci, "irq normal %ld err %ld reclaim %ld (lost %ld)\n",
-		ehci-&gt;stats.normal, ehci-&gt;stats.error, ehci-&gt;stats.reclaim,
+	ehci_dbg(ehci, "irq normal %ld err %ld iaa %ld (lost %ld)\n",
+		ehci-&gt;stats.normal, ehci-&gt;stats.error, ehci-&gt;stats.iaa,
 		ehci-&gt;stats.lost_iaa);
 	ehci_dbg (ehci, "complete %ld unlink %ld\n",
 		ehci-&gt;stats.complete, ehci-&gt;stats.unlink);
@@ -651,7 +651,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	else					// N microframes cached
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
-	ehci-&gt;reclaim = NULL;
 	ehci-&gt;next_uframe = -1;
 	ehci-&gt;clock_frame = -1;
 
@@ -896,11 +895,11 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;reclaim) {
-			COUNT(ehci-&gt;stats.reclaim);
+		if (ehci-&gt;async_unlink) {
+			COUNT(ehci-&gt;stats.iaa);
 			end_unlink_async(ehci);
 		} else
-			ehci_dbg(ehci, "IAA with nothing to reclaim?\n");
+			ehci_dbg(ehci, "IAA with nothing unlinked?\n");
 	}
 
 	/* remote wakeup [4.3.1] */
@@ -1027,7 +1026,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING &amp;&amp; ehci-&gt;reclaim)
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING &amp;&amp; ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1041,15 +1040,15 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* defer till later if busy */
-	if (ehci-&gt;reclaim) {
+	if (ehci-&gt;async_unlink) {
 		struct ehci_qh		*last;
 
-		for (last = ehci-&gt;reclaim;
-				last-&gt;reclaim;
-				last = last-&gt;reclaim)
+		for (last = ehci-&gt;async_unlink;
+				last-&gt;unlink_next;
+				last = last-&gt;unlink_next)
 			continue;
 		qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
-		last-&gt;reclaim = qh;
+		last-&gt;unlink_next = qh;
 
 	/* start IAA cycle */
 	} else
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 1daaa96f527d..77d3324b4b28 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -301,7 +301,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
-	if (ehci-&gt;reclaim)
+	if (ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
 
 	/* allow remote wakeup */
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 156504787711..8e80cde8c35e 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1153,11 +1153,11 @@ submit_async (
 
 /*-------------------------------------------------------------------------*/
 
-/* the async qh for the qtds being reclaimed are now unlinked from the HC */
+/* the async qh for the qtds being unlinked are now gone from the HC */
 
 static void end_unlink_async (struct ehci_hcd *ehci)
 {
-	struct ehci_qh		*qh = ehci-&gt;reclaim;
+	struct ehci_qh		*qh = ehci-&gt;async_unlink;
 	struct ehci_qh		*next;
 
 	iaa_watchdog_done(ehci);
@@ -1167,9 +1167,9 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	qh-&gt;qh_next.qh = NULL;
 
 	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
-	next = qh-&gt;reclaim;
-	ehci-&gt;reclaim = next;
-	qh-&gt;reclaim = NULL;
+	next = qh-&gt;unlink_next;
+	ehci-&gt;async_unlink = next;
+	qh-&gt;unlink_next = NULL;
 
 	qh_completions (ehci, qh);
 
@@ -1185,7 +1185,7 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	}
 
 	if (next) {
-		ehci-&gt;reclaim = NULL;
+		ehci-&gt;async_unlink = NULL;
 		start_unlink_async (ehci, next);
 	}
 
@@ -1203,7 +1203,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 #ifdef DEBUG
 	assert_spin_locked(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim
+	if (ehci-&gt;async_unlink
 			|| (qh-&gt;qh_state != QH_STATE_LINKED
 				&amp;&amp; qh-&gt;qh_state != QH_STATE_UNLINK_WAIT)
 			)
@@ -1214,7 +1214,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (unlikely (qh == ehci-&gt;async)) {
 		/* can't get here without STS_ASS set */
 		if (ehci-&gt;rh_state != EHCI_RH_HALTED
-				&amp;&amp; !ehci-&gt;reclaim) {
+				&amp;&amp; !ehci-&gt;async_unlink) {
 			/* ... and CMD_IAAD clear */
 			ehci-&gt;command &amp;= ~CMD_ASE;
 			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
@@ -1226,7 +1226,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	qh-&gt;qh_state = QH_STATE_UNLINK;
-	ehci-&gt;reclaim = qh;
+	ehci-&gt;async_unlink = qh;
 
 	prev = ehci-&gt;async;
 	while (prev-&gt;qh_next.qh != qh)
@@ -1240,7 +1240,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state != EHCI_RH_RUNNING)) {
-		/* if (unlikely (qh-&gt;reclaim != 0))
+		/* if (unlikely (qh-&gt;unlink_next != 0))
 		 *	this will recurse, probably not much
 		 */
 		end_unlink_async (ehci);
@@ -1295,7 +1295,7 @@ static void scan_async (struct ehci_hcd *ehci)
 		 */
 		if (list_empty(&amp;qh-&gt;qtd_list)
 				&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-			if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
+			if (!ehci-&gt;async_unlink &amp;&amp; (stopped ||
 					time_after_eq(jiffies, qh-&gt;unlink_time)))
 				start_unlink_async(ehci, qh);
 			else
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 195449db1b18..3c6c07c0956a 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -42,7 +42,7 @@ struct ehci_stats {
 	/* irq usage */
 	unsigned long		normal;
 	unsigned long		error;
-	unsigned long		reclaim;
+	unsigned long		iaa;
 	unsigned long		lost_iaa;
 
 	/* termination of urbs from core */
@@ -51,7 +51,7 @@ struct ehci_stats {
 };
 
 /* ehci_hcd-&gt;lock guards shared data against other CPUs:
- *   ehci_hcd:	async, reclaim, periodic (and shadow), ...
+ *   ehci_hcd:	async, unlink, periodic (and shadow), ...
  *   usb_host_endpoint: hcpriv
  *   ehci_qh:	qh_next, qtd_list
  *   ehci_qtd:	qtd_list
@@ -81,7 +81,7 @@ struct ehci_hcd {			/* one per controller */
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
-	struct ehci_qh		*reclaim;
+	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
 
@@ -354,7 +354,7 @@ struct ehci_qh {
 	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
 	struct list_head	qtd_list;	/* sw qtd list */
 	struct ehci_qtd		*dummy;
-	struct ehci_qh		*reclaim;	/* next to reclaim */
+	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
 	unsigned long		unlink_time;
 	unsigned		stamp;
@@ -364,7 +364,7 @@ struct ehci_qh {
 #define	QH_STATE_LINKED		1		/* HC sees this */
 #define	QH_STATE_UNLINK		2		/* HC may still see this */
 #define	QH_STATE_IDLE		3		/* HC doesn't see this */
-#define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on reclaim q */
+#define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on unlink q */
 #define	QH_STATE_COMPLETING	5		/* don't touch token.HALT */
 
 	u8			xacterrs;	/* XactErr retry counter */</pre><hr><pre>commit 4c53de72109759c931744734ca75f9cecb3baef1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:32 2012 -0400

    USB: EHCI: add symbolic constants for QHs
    
    This patch (as1568) introduces symbolic constants for some of the
    less-frequently used bitfields in the QH structure.  This makes the
    code a little easier to read and understand.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 7561966fbdc4..97338abff296 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -404,9 +404,9 @@ struct debug_buffer {
 
 #define speed_char(info1) ({ char tmp; \
 		switch (info1 &amp; (3 &lt;&lt; 12)) { \
-		case 0 &lt;&lt; 12: tmp = 'f'; break; \
-		case 1 &lt;&lt; 12: tmp = 'l'; break; \
-		case 2 &lt;&lt; 12: tmp = 'h'; break; \
+		case QH_FULL_SPEED: tmp = 'f'; break; \
+		case QH_LOW_SPEED:  tmp = 'l'; break; \
+		case QH_HIGH_SPEED: tmp = 'h'; break; \
 		default: tmp = '?'; break; \
 		}; tmp; })
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1f8f792eec86..cdb15769468a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -667,7 +667,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	hw-&gt;hw_next = QH_NEXT(ehci, ehci-&gt;async-&gt;qh_dma);
 	hw-&gt;hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
 #if defined(CONFIG_PPC_PS3)
-	hw-&gt;hw_info1 |= cpu_to_hc32(ehci, (1 &lt;&lt; 7));	/* I = 1 */
+	hw-&gt;hw_info1 |= cpu_to_hc32(ehci, QH_INACTIVATE);
 #endif
 	hw-&gt;hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	hw-&gt;hw_qtd_next = EHCI_LIST_END(ehci);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7d117bbffac1..156504787711 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -100,7 +100,7 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 	 * and set the pseudo-toggle in udev. Only usb_clear_halt() will
 	 * ever clear it.
 	 */
-	if (!(hw-&gt;hw_info1 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; 14))) {
+	if (!(hw-&gt;hw_info1 &amp; cpu_to_hc32(ehci, QH_TOGGLE_CTL))) {
 		unsigned	is_out, epnum;
 
 		is_out = qh-&gt;is_out;
@@ -886,7 +886,7 @@ qh_make (
 	/* using TT? */
 	switch (urb-&gt;dev-&gt;speed) {
 	case USB_SPEED_LOW:
-		info1 |= (1 &lt;&lt; 12);	/* EPS "low" */
+		info1 |= QH_LOW_SPEED;
 		/* FALL THROUGH */
 
 	case USB_SPEED_FULL:
@@ -894,8 +894,8 @@ qh_make (
 		if (type != PIPE_INTERRUPT)
 			info1 |= (EHCI_TUNE_RL_TT &lt;&lt; 28);
 		if (type == PIPE_CONTROL) {
-			info1 |= (1 &lt;&lt; 27);	/* for TT */
-			info1 |= 1 &lt;&lt; 14;	/* toggle from qtd */
+			info1 |= QH_CONTROL_EP;		/* for TT */
+			info1 |= QH_TOGGLE_CTL;		/* toggle from qtd */
 		}
 		info1 |= maxp &lt;&lt; 16;
 
@@ -920,11 +920,11 @@ qh_make (
 		break;
 
 	case USB_SPEED_HIGH:		/* no TT involved */
-		info1 |= (2 &lt;&lt; 12);	/* EPS "high" */
+		info1 |= QH_HIGH_SPEED;
 		if (type == PIPE_CONTROL) {
 			info1 |= (EHCI_TUNE_RL_HS &lt;&lt; 28);
 			info1 |= 64 &lt;&lt; 16;	/* usb2 fixed maxpacket */
-			info1 |= 1 &lt;&lt; 14;	/* toggle from qtd */
+			info1 |= QH_TOGGLE_CTL;	/* toggle from qtd */
 			info2 |= (EHCI_TUNE_MULT_HS &lt;&lt; 30);
 		} else if (type == PIPE_BULK) {
 			info1 |= (EHCI_TUNE_RL_HS &lt;&lt; 28);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index f7a59f5d70c6..195449db1b18 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -324,7 +324,13 @@ union ehci_shadow {
 struct ehci_qh_hw {
 	__hc32			hw_next;	/* see EHCI 3.6.1 */
 	__hc32			hw_info1;       /* see EHCI 3.6.2 */
-#define	QH_HEAD		0x00008000
+#define	QH_CONTROL_EP	(1 &lt;&lt; 27)	/* FS/LS control endpoint */
+#define	QH_HEAD		(1 &lt;&lt; 15)	/* Head of async reclamation list */
+#define	QH_TOGGLE_CTL	(1 &lt;&lt; 14)	/* Data toggle control */
+#define	QH_HIGH_SPEED	(2 &lt;&lt; 12)	/* Endpoint speed */
+#define	QH_LOW_SPEED	(1 &lt;&lt; 12)
+#define	QH_FULL_SPEED	(0 &lt;&lt; 12)
+#define	QH_INACTIVATE	(1 &lt;&lt; 7)	/* Inactivate on next transaction */
 	__hc32			hw_info2;        /* see EHCI 3.6.2 */
 #define	QH_SMASK	0x000000ff
 #define	QH_CMASK	0x0000ff00</pre><hr><pre>commit c83e1a9ff68a6535b81c40dc8fda99348ab480fb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:25 2012 -0400

    USB: EHCI: don't refcount QHs
    
    This patch (as1567) removes ehci-hcd's reference counting of QH
    structures.  It's not necessary to refcount these things because they
    always get deallocated at exactly one spot in ehci_endpoint_disable()
    (except for two special QHs, ehci-&gt;async and ehci-&gt;dummy) and are
    never used again.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ab7306de8d16..1f8f792eec86 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1179,7 +1179,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		if (qh-&gt;clearing_tt)
 			goto idle_timeout;
 		if (list_empty (&amp;qh-&gt;qtd_list)) {
-			qh_put (qh);
+			qh_destroy(ehci, qh);
 			break;
 		}
 		/* else FALL THROUGH */
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 12f70c302b0b..93132d8ad360 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -64,10 +64,8 @@ static inline void ehci_qtd_free (struct ehci_hcd *ehci, struct ehci_qtd *qtd)
 }
 
 
-static void qh_destroy(struct ehci_qh *qh)
+static void qh_destroy(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_hcd *ehci = qh-&gt;ehci;
-
 	/* clean qtds first, and know this is not linked */
 	if (!list_empty (&amp;qh-&gt;qtd_list) || qh-&gt;qh_next.ptr) {
 		ehci_dbg (ehci, "unused qh not empty!\n");
@@ -92,8 +90,6 @@ static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
 	if (!qh-&gt;hw)
 		goto fail;
 	memset(qh-&gt;hw, 0, sizeof *qh-&gt;hw);
-	qh-&gt;refcount = 1;
-	qh-&gt;ehci = ehci;
 	qh-&gt;qh_dma = dma;
 	// INIT_LIST_HEAD (&amp;qh-&gt;qh_list);
 	INIT_LIST_HEAD (&amp;qh-&gt;qtd_list);
@@ -113,20 +109,6 @@ static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
 	return NULL;
 }
 
-/* to share a qh (cpu threads, or hc) */
-static inline struct ehci_qh *qh_get (struct ehci_qh *qh)
-{
-	WARN_ON(!qh-&gt;refcount);
-	qh-&gt;refcount++;
-	return qh;
-}
-
-static inline void qh_put (struct ehci_qh *qh)
-{
-	if (!--qh-&gt;refcount)
-		qh_destroy(qh);
-}
-
 /*-------------------------------------------------------------------------*/
 
 /* The queue heads and transfer descriptors are managed from pools tied
@@ -138,11 +120,11 @@ static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
 	free_cached_lists(ehci);
 	if (ehci-&gt;async)
-		qh_put (ehci-&gt;async);
+		qh_destroy(ehci, ehci-&gt;async);
 	ehci-&gt;async = NULL;
 
 	if (ehci-&gt;dummy)
-		qh_put(ehci-&gt;dummy);
+		qh_destroy(ehci, ehci-&gt;dummy);
 	ehci-&gt;dummy = NULL;
 
 	/* DMA consistent memory and pools */
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 4378bf72bbac..7d117bbffac1 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -265,7 +265,6 @@ __acquires(ehci-&gt;lock)
 			/* ... update hc-wide periodic stats (for usbfs) */
 			ehci_to_hcd(ehci)-&gt;self.bandwidth_int_reqs--;
 		}
-		qh_put (qh);
 	}
 
 	if (unlikely(urb-&gt;unlinked)) {
@@ -946,7 +945,7 @@ qh_make (
 		ehci_dbg(ehci, "bogus dev %p speed %d\n", urb-&gt;dev,
 			urb-&gt;dev-&gt;speed);
 done:
-		qh_put (qh);
+		qh_destroy(ehci, qh);
 		return NULL;
 	}
 
@@ -1003,7 +1002,6 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw-&gt;hw_next = dma;
 
-	qh_get(qh);
 	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
@@ -1090,7 +1088,7 @@ static struct ehci_qh *qh_append_tds (
 			wmb ();
 			dummy-&gt;hw_token = token;
 
-			urb-&gt;hcpriv = qh_get (qh);
+			urb-&gt;hcpriv = qh;
 		}
 	}
 	return qh;
@@ -1167,7 +1165,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	qh-&gt;qh_next.qh = NULL;
-	qh_put (qh);			// refcount from reclaim
 
 	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
 	next = qh-&gt;reclaim;
@@ -1186,7 +1183,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
 			timer_action (ehci, TIMER_ASYNC_OFF);
 	}
-	qh_put(qh);			/* refcount from async list */
 
 	if (next) {
 		ehci-&gt;reclaim = NULL;
@@ -1230,7 +1226,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	qh-&gt;qh_state = QH_STATE_UNLINK;
-	ehci-&gt;reclaim = qh = qh_get (qh);
+	ehci-&gt;reclaim = qh;
 
 	prev = ehci-&gt;async;
 	while (prev-&gt;qh_next.qh != qh)
@@ -1283,12 +1279,10 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
 			 * in start_unlink_async().
 			 */
-			qh = qh_get(qh);
 			temp = qh_completions(ehci, qh);
 			if (qh-&gt;needs_rescan)
 				unlink_async(ehci, qh);
 			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
-			qh_put(qh);
 			if (temp != 0)
 				goto rescan;
 		}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 33182c6d1ff9..027df3de2dc9 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -606,7 +606,6 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	qh-&gt;xacterrs = 0;
-	qh_get (qh);
 
 	/* update per-qh bandwidth for usbfs */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;period
@@ -650,7 +649,6 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
-	qh_put (qh);
 
 	/* maybe turn off periodic schedule */
 	return disable_periodic(ehci);
@@ -2340,7 +2338,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_QH:
 				/* handle any completions */
-				temp.qh = qh_get (q.qh);
+				temp.qh = q.qh;
 				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
 				q = q.qh-&gt;qh_next;
 				if (temp.qh-&gt;stamp != ehci-&gt;periodic_stamp) {
@@ -2351,7 +2349,6 @@ scan_periodic (struct ehci_hcd *ehci)
 							temp.qh-&gt;needs_rescan))
 						intr_deschedule(ehci, temp.qh);
 				}
-				qh_put (temp.qh);
 				break;
 			case Q_TYPE_FSTN:
 				/* for "save place" FSTNs, look at QH entries
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 85c3572155d1..f7a59f5d70c6 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -350,16 +350,7 @@ struct ehci_qh {
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*reclaim;	/* next to reclaim */
 
-	struct ehci_hcd		*ehci;
 	unsigned long		unlink_time;
-
-	/*
-	 * Do NOT use atomic operations for QH refcounting. On some CPUs
-	 * (PPC7448 for example), atomic operations cannot be performed on
-	 * memory that is cache-inhibited (i.e. being used for DMA).
-	 * Spinlocks are used to protect all QH fields.
-	 */
-	u32			refcount;
 	unsigned		stamp;
 
 	u8			needs_rescan;	/* Dequeue during giveback */</pre><hr><pre>commit 15be105b4a18c461b95fa683907f6da6deae1b75
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:17 2012 -0400

    USB: EHCI: remove unneeded suspend/resume code
    
    This patch (as1566) removes the code in ehci-hcd's resume routines
    which tries to restart or cancel any transfers left active while the
    root hub or controller was asleep.  This code isn't necessary, because
    all URBs are terminated before the root hub is suspended.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8727f4ea343f..ab7306de8d16 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1312,13 +1312,6 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
 
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index b3e2d66e95bb..1daaa96f527d 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -424,23 +424,12 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
 		}
 	}
-	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-	/* maybe re-activate the schedule(s) */
-	temp = 0;
-	if (ehci-&gt;async-&gt;qh_next.qh)
-		temp |= CMD_ASE;
-	if (ehci-&gt;periodic_sched)
-		temp |= CMD_PSE;
-	if (temp) {
-		ehci-&gt;command |= temp;
-		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	}
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(5);
 
 	/* Now we can safely re-enable irqs */
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
+	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	ehci_handover_companion_ports(ehci);</pre><hr><pre>commit 631fe9d9d20e28fffdf750d12dd2cd275bd654e9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:09 2012 -0400

    USB: EHCI: initialize data before resetting hardware
    
    Currently, EHCI initialization turns off the controller (in case it
    was left running by the firmware) before setting up the ehci_hcd data
    structure.  This patch (as1565) reverses that order.
    
    Although it doesn't matter now, it will matter later on when future
    additions to ehci_halt() will want to acquire a spinlock that gets
    initialized by ehci_init().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f9a783bfa1fe..8727f4ea343f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -823,12 +823,12 @@ static int ehci_setup(struct usb_hcd *hcd)
 
 	ehci-&gt;sbrn = HCD_USB2;
 
-	retval = ehci_halt(ehci);
+	/* data structure init */
+	retval = ehci_init(hcd);
 	if (retval)
 		return retval;
 
-	/* data structure init */
-	retval = ehci_init(hcd);
+	retval = ehci_halt(ehci);
 	if (retval)
 		return retval;
 </pre><hr><pre>commit dbf0e4c7257f8d684ec1a3c919853464293de66e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 9 11:09:21 2012 -0400

    PCI: EHCI: fix crash during suspend on ASUS computers
    
    Quite a few ASUS computers experience a nasty problem, related to the
    EHCI controllers, when going into system suspend.  It was observed
    that the problem didn't occur if the controllers were not put into the
    D3 power state before starting the suspend, and commit
    151b61284776be2d6f02d48c23c3625678960b97 (USB: EHCI: fix crash during
    suspend on ASUS computers) was created to do this.
    
    It turned out this approach messed up other computers that didn't have
    the problem -- it prevented USB wakeup from working.  Consequently
    commit c2fb8a3fa25513de8fedb38509b1f15a5bbee47b (USB: add
    NO_D3_DURING_SLEEP flag and revert 151b61284776be2) was merged; it
    reverted the earlier commit and added a whitelist of known good board
    names.
    
    Now we know the actual cause of the problem.  Thanks to AceLan Kao for
    tracking it down.
    
    According to him, an engineer at ASUS explained that some of their
    BIOSes contain a bug that was added in an attempt to work around a
    problem in early versions of Windows.  When the computer goes into S3
    suspend, the BIOS tries to verify that the EHCI controllers were first
    quiesced by the OS.  Nothing's wrong with this, but the BIOS does it
    by checking that the PCI COMMAND registers contain 0 without checking
    the controllers' power state.  If the register isn't 0, the BIOS
    assumes the controller needs to be quiesced and tries to do so.  This
    involves making various MMIO accesses to the controller, which don't
    work very well if the controller is already in D3.  The end result is
    a system hang or memory corruption.
    
    Since the value in the PCI COMMAND register doesn't matter once the
    controller has been suspended, and since the value will be restored
    anyway when the controller is resumed, we can work around the BIOS bug
    simply by setting the register to 0 during system suspend.  This patch
    (as1590) does so and also reverts the second commit mentioned above,
    which is now unnecessary.
    
    In theory we could do this for every PCI device.  However to avoid
    introducing new problems, the patch restricts itself to EHCI host
    controllers.
    
    Finally the affected systems can suspend with USB wakeup working
    properly.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=37632
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=42728
    Based-on-patch-by: AceLan Kao &lt;acelan.kao@canonical.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: DÃ¢niel Fraga &lt;fragabr@gmail.com&gt;
    Tested-by: Javier Marcet &lt;jmarcet@gmail.com&gt;
    Tested-by: Andrey Rahmatullin &lt;wrar@wrar.name&gt;
    Tested-by: Oleksij Rempel &lt;bug-track@fisher-privat.net&gt;
    Tested-by: Pavel Pisa &lt;pisa@cmp.felk.cvut.cz&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Acked-by: Bjorn Helgaas &lt;bhelgaas@google.com&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index bf0cee629b60..099f46cd8e87 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -748,6 +748,18 @@ static int pci_pm_suspend_noirq(struct device *dev)
 
 	pci_pm_set_unknown_state(pci_dev);
 
+	/*
+	 * Some BIOSes from ASUS have a bug: If a USB EHCI host controller's
+	 * PCI COMMAND register isn't 0, the BIOS assumes that the controller
+	 * hasn't been quiesced and tries to turn it off.  If the controller
+	 * is already in D3, this can hang or cause memory corruption.
+	 *
+	 * Since the value of the COMMAND register doesn't matter once the
+	 * device has been suspended, we can safely set it to 0 here.
+	 */
+	if (pci_dev-&gt;class == PCI_CLASS_SERIAL_USB_EHCI)
+		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
+
 	return 0;
 }
 
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 77cb54a65cde..447e83472c01 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1744,11 +1744,6 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
-	/* Some devices mustn't be in D3 during system sleep */
-	if (target_state == PCI_D3hot &amp;&amp;
-			(dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_D3_DURING_SLEEP))
-		return 0;
-
 	pci_enable_wake(dev, target_state, device_may_wakeup(&amp;dev-&gt;dev));
 
 	error = pci_set_power_state(dev, target_state);
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 194b243a2817..2a7521677541 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -2929,32 +2929,6 @@ static void __devinit disable_igfx_irq(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0102, disable_igfx_irq);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
 
-/*
- * The Intel 6 Series/C200 Series chipset's EHCI controllers on many
- * ASUS motherboards will cause memory corruption or a system crash
- * if they are in D3 while the system is put into S3 sleep.
- */
-static void __devinit asus_ehci_no_d3(struct pci_dev *dev)
-{
-	const char *sys_info;
-	static const char good_Asus_board[] = "P8Z68-V";
-
-	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_D3_DURING_SLEEP)
-		return;
-	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_ASUSTEK)
-		return;
-	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
-	if (sys_info &amp;&amp; memcmp(sys_info, good_Asus_board,
-			sizeof(good_Asus_board) - 1) == 0)
-		return;
-
-	dev_info(&amp;dev-&gt;dev, "broken D3 during system sleep on ASUS\n");
-	dev-&gt;dev_flags |= PCI_DEV_FLAGS_NO_D3_DURING_SLEEP;
-	device_set_wakeup_capable(&amp;dev-&gt;dev, false);
-}
-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c26, asus_ehci_no_d3);
-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c2d, asus_ehci_no_d3);
-
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
 {
diff --git a/include/linux/pci.h b/include/linux/pci.h
index fefb4e19bf6a..d8c379dba6ad 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -176,8 +176,6 @@ enum pci_dev_flags {
 	PCI_DEV_FLAGS_NO_D3 = (__force pci_dev_flags_t) 2,
 	/* Provide indication device is assigned by a Virtual Machine Manager */
 	PCI_DEV_FLAGS_ASSIGNED = (__force pci_dev_flags_t) 4,
-	/* Device causes system crash if in D3 during S3 sleep */
-	PCI_DEV_FLAGS_NO_D3_DURING_SLEEP = (__force pci_dev_flags_t) 8,
 };
 
 enum pci_irq_reroute_variant {</pre><hr><pre>commit 1a49e2ac9651df7349867a5cf44e2c83de1046af
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 9 15:55:14 2012 -0400

    EHCI: centralize controller initialization
    
    This patch (as1564c) converts the EHCI platform drivers to use the
    central ehci_setup() routine for generic controller initialization
    rather than each having its own idiosyncratic approach.
    
    The major point of difficulty lies in ehci-pci's many vendor- and
    device-specific workarounds.  Some of them have to be applied before
    calling ehci_setup() and some after, which necessitates a fair amount
    of code motion.  The other platform drivers require much smaller
    changes.
    
    One point not addressed by the patch is whether ports should be
    powered on or off following initialization.  The different drivers
    appear to handle this pretty much at random.  In fact it shouldn't
    matter, because the hub driver turns on power to all ports when it
    binds to the root hub.  Straightening that out will be left for
    another day.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-atmel.c b/drivers/usb/host/ehci-atmel.c
index cf14c95a6700..a47e2cffaaf8 100644
--- a/drivers/usb/host/ehci-atmel.c
+++ b/drivers/usb/host/ehci-atmel.c
@@ -53,30 +53,15 @@ static void atmel_stop_ehci(struct platform_device *pdev)
 static int ehci_atmel_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	int retval = 0;
+	int retval;
 
 	/* registers start at offset 0x0 */
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
 
-	/* data structure init */
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	ehci-&gt;sbrn = 0x20;
-
-	ehci_reset(ehci);
 	ehci_port_power(ehci, 0);
 
 	return retval;
diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 182d39565906..cba10d625a5d 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -20,10 +20,12 @@ extern int usb_disabled(void);
 static int au1xxx_ehci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	int ret = ehci_init(hcd);
+	int ret;
+
+	ehci-&gt;caps = hcd-&gt;regs;
+	ret = ehci_setup(hcd);
 
 	ehci-&gt;need_io_watchdog = 0;
-	ehci_reset(ehci);
 	return ret;
 }
 
@@ -78,7 +80,6 @@ static const struct hc_driver ehci_au1xxx_hc_driver = {
 static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
 	struct resource *res;
 	int ret;
 
@@ -116,13 +117,6 @@ static int ehci_hcd_au1xxx_drv_probe(struct platform_device *pdev)
 		goto err3;
 	}
 
-	ehci = hcd_to_ehci(hcd);
-	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, readl(&amp;ehci-&gt;caps-&gt;hc_capbase));
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = readl(&amp;ehci-&gt;caps-&gt;hcs_params);
-
 	ret = usb_add_hcd(hcd, pdev-&gt;resource[1].start,
 			  IRQF_SHARED);
 	if (ret == 0) {
diff --git a/drivers/usb/host/ehci-cns3xxx.c b/drivers/usb/host/ehci-cns3xxx.c
index 6536abdea6e6..caaa3e5be334 100644
--- a/drivers/usb/host/ehci-cns3xxx.c
+++ b/drivers/usb/host/ehci-cns3xxx.c
@@ -33,14 +33,10 @@ static int cns3xxx_ehci_init(struct usb_hcd *hcd)
 	}
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs
-		+ HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	hcd-&gt;has_tt = 0;
-	ehci_reset(ehci);
 
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 74914de8b9bf..ab52db684b63 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -348,29 +348,13 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 
 	/* EHCI registers start at offset 0x100 */
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
-	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	hcd-&gt;has_tt = 1;
 
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/* data structure init */
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	ehci-&gt;sbrn = 0x20;
-
-	ehci_reset(ehci);
-
 	if (of_device_is_compatible(dev-&gt;parent-&gt;of_node,
 				    "fsl,mpc5121-usb2-dr")) {
 		/*
diff --git a/drivers/usb/host/ehci-grlib.c b/drivers/usb/host/ehci-grlib.c
index fdfd8c5b639b..22ca45c079a4 100644
--- a/drivers/usb/host/ehci-grlib.c
+++ b/drivers/usb/host/ehci-grlib.c
@@ -40,18 +40,13 @@ static int ehci_grlib_setup(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 	int		retval;
 
-	retval = ehci_halt(ehci);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci-&gt;sbrn = 0x20;
 	ehci_port_power(ehci, 1);
 
-	return ehci_reset(ehci);
+	return retval;
 }
 
 
@@ -164,12 +159,6 @@ static int __devinit ehci_hcd_grlib_probe(struct platform_device *op)
 		ehci-&gt;big_endian_capbase = 1;
 	}
 
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
 	rv = usb_add_hcd(hcd, irq, 0);
 	if (rv)
 		goto err_ehci;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e6823a0cf642..f9a783bfa1fe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -808,7 +808,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	return 0;
 }
 
-static int __maybe_unused ehci_setup (struct usb_hcd *hcd)
+static int ehci_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
@@ -832,6 +832,9 @@ static int __maybe_unused ehci_setup (struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
+	if (ehci_is_TDI(ehci))
+		tdi_reset(ehci);
+
 	ehci_reset(ehci);
 
 	return 0;
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index c4460f3d009f..488d401942e9 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -22,14 +22,10 @@ static int ixp4xx_ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;big_endian_mmio = 1;
 
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
-	ehci-&gt;regs = hcd-&gt;regs + 0x100
-		+ HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	hcd-&gt;has_tt = 1;
-	ehci_reset(ehci);
 
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
diff --git a/drivers/usb/host/ehci-mv.c b/drivers/usb/host/ehci-mv.c
index 0e8c168ca24c..f6df1ccc9617 100644
--- a/drivers/usb/host/ehci-mv.c
+++ b/drivers/usb/host/ehci-mv.c
@@ -77,7 +77,6 @@ static void mv_ehci_disable(struct ehci_hcd_mv *ehci_mv)
 
 static int mv_ehci_reset(struct usb_hcd *hcd)
 {
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct device *dev = hcd-&gt;self.controller;
 	struct ehci_hcd_mv *ehci_mv = dev_get_drvdata(dev);
 	int retval;
@@ -87,25 +86,13 @@ static int mv_ehci_reset(struct usb_hcd *hcd)
 		return -ENODEV;
 	}
 
-	/*
-	 * data structure init
-	 */
-	retval = ehci_init(hcd);
-	if (retval) {
-		dev_err(dev, "ehci_init failed %d\n", retval);
-		return retval;
-	}
-
 	hcd-&gt;has_tt = 1;
-	ehci-&gt;sbrn = 0x20;
 
-	retval = ehci_reset(ehci);
-	if (retval) {
-		dev_err(dev, "ehci_reset failed %d\n", retval);
-		return retval;
-	}
+	retval = ehci_setup(hcd);
+	if (retval)
+		dev_err(dev, "ehci_setup failed %d\n", retval);
 
-	return 0;
+	return retval;
 }
 
 static const struct hc_driver mv_ehci_hc_driver = {
@@ -248,8 +235,6 @@ static int mv_ehci_probe(struct platform_device *pdev)
 
 	ehci = hcd_to_ehci(hcd);
 	ehci-&gt;caps = (struct ehci_caps *) ehci_mv-&gt;cap_regs;
-	ehci-&gt;regs = (struct ehci_regs *) ehci_mv-&gt;op_regs;
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	ehci_mv-&gt;mode = pdata-&gt;mode;
 	if (ehci_mv-&gt;mode == MV_USB_MODE_OTG) {
diff --git a/drivers/usb/host/ehci-mxc.c b/drivers/usb/host/ehci-mxc.c
index c778ffe4e4e5..34201372c85f 100644
--- a/drivers/usb/host/ehci-mxc.c
+++ b/drivers/usb/host/ehci-mxc.c
@@ -42,27 +42,12 @@ static int ehci_mxc_setup(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
 
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
 	hcd-&gt;has_tt = 1;
 
-	retval = ehci_halt(ehci);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci-&gt;sbrn = 0x20;
-
-	ehci_reset(ehci);
-
 	ehci_port_power(ehci, 0);
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-octeon.c b/drivers/usb/host/ehci-octeon.c
index c0104882c72d..ba26957abf46 100644
--- a/drivers/usb/host/ehci-octeon.c
+++ b/drivers/usb/host/ehci-octeon.c
@@ -56,7 +56,7 @@ static const struct hc_driver ehci_octeon_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_init,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
@@ -150,12 +150,6 @@ static int ehci_octeon_drv_probe(struct platform_device *pdev)
 #endif
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	ehci_reset(ehci);
 
 	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (ret) {
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
index 6e15fc87cf60..6133d93808dc 100644
--- a/drivers/usb/host/ehci-omap.c
+++ b/drivers/usb/host/ehci-omap.c
@@ -145,6 +145,56 @@ static void omap_ehci_soft_phy_reset(struct platform_device *pdev, u8 port)
 	}
 }
 
+static int omap_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	int			rc;
+	struct ehci_hcd_omap_platform_data	*pdata;
+
+	pdata = hcd-&gt;self.controller-&gt;platform_data;
+	if (pdata-&gt;phy_reset) {
+		if (gpio_is_valid(pdata-&gt;reset_gpio_port[0]))
+			gpio_request_one(pdata-&gt;reset_gpio_port[0],
+					 GPIOF_OUT_INIT_LOW, "USB1 PHY reset");
+
+		if (gpio_is_valid(pdata-&gt;reset_gpio_port[1]))
+			gpio_request_one(pdata-&gt;reset_gpio_port[1],
+					 GPIOF_OUT_INIT_LOW, "USB2 PHY reset");
+
+		/* Hold the PHY in RESET for enough time till DIR is high */
+		udelay(10);
+	}
+
+	/* Soft reset the PHY using PHY reset command over ULPI */
+	if (pdata-&gt;port_mode[0] == OMAP_EHCI_PORT_MODE_PHY)
+		omap_ehci_soft_phy_reset(pdev, 0);
+	if (pdata-&gt;port_mode[1] == OMAP_EHCI_PORT_MODE_PHY)
+		omap_ehci_soft_phy_reset(pdev, 1);
+
+	/* we know this is the memory we want, no need to ioremap again */
+	ehci-&gt;caps = hcd-&gt;regs;
+
+	rc = ehci_setup(hcd);
+
+	if (pdata-&gt;phy_reset) {
+		/* Hold the PHY in RESET for enough time till
+		 * PHY is settled and ready
+		 */
+		udelay(10);
+
+		if (gpio_is_valid(pdata-&gt;reset_gpio_port[0]))
+			gpio_set_value_cansleep(pdata-&gt;reset_gpio_port[0], 1);
+
+		if (gpio_is_valid(pdata-&gt;reset_gpio_port[1]))
+			gpio_set_value_cansleep(pdata-&gt;reset_gpio_port[1], 1);
+	}
+
+	/* root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	return rc;
+}
+
 static int omap_ehci_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -219,7 +269,6 @@ static int ehci_hcd_omap_probe(struct platform_device *pdev)
 	struct resource				*res;
 	struct usb_hcd				*hcd;
 	void __iomem				*regs;
-	struct ehci_hcd				*omap_ehci;
 	int					ret = -ENODEV;
 	int					irq;
 	int					i;
@@ -281,19 +330,6 @@ static int ehci_hcd_omap_probe(struct platform_device *pdev)
 		}
 	}
 
-	if (pdata-&gt;phy_reset) {
-		if (gpio_is_valid(pdata-&gt;reset_gpio_port[0]))
-			gpio_request_one(pdata-&gt;reset_gpio_port[0],
-					 GPIOF_OUT_INIT_LOW, "USB1 PHY reset");
-
-		if (gpio_is_valid(pdata-&gt;reset_gpio_port[1]))
-			gpio_request_one(pdata-&gt;reset_gpio_port[1],
-					 GPIOF_OUT_INIT_LOW, "USB2 PHY reset");
-
-		/* Hold the PHY in RESET for enough time till DIR is high */
-		udelay(10);
-	}
-
 	pm_runtime_enable(dev);
 	pm_runtime_get_sync(dev);
 
@@ -309,50 +345,12 @@ static int ehci_hcd_omap_probe(struct platform_device *pdev)
 	ehci_write(regs, EHCI_INSNREG04,
 				EHCI_INSNREG04_DISABLE_UNSUSPEND);
 
-	/* Soft reset the PHY using PHY reset command over ULPI */
-	if (pdata-&gt;port_mode[0] == OMAP_EHCI_PORT_MODE_PHY)
-		omap_ehci_soft_phy_reset(pdev, 0);
-	if (pdata-&gt;port_mode[1] == OMAP_EHCI_PORT_MODE_PHY)
-		omap_ehci_soft_phy_reset(pdev, 1);
-
-	omap_ehci = hcd_to_ehci(hcd);
-	omap_ehci-&gt;sbrn = 0x20;
-
-	/* we know this is the memory we want, no need to ioremap again */
-	omap_ehci-&gt;caps = hcd-&gt;regs;
-	omap_ehci-&gt;regs = hcd-&gt;regs
-		+ HC_LENGTH(ehci, readl(&amp;omap_ehci-&gt;caps-&gt;hc_capbase));
-
-	dbg_hcs_params(omap_ehci, "reset");
-	dbg_hcc_params(omap_ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	omap_ehci-&gt;hcs_params = readl(&amp;omap_ehci-&gt;caps-&gt;hcs_params);
-
-	ehci_reset(omap_ehci);
-
-	if (pdata-&gt;phy_reset) {
-		/* Hold the PHY in RESET for enough time till
-		 * PHY is settled and ready
-		 */
-		udelay(10);
-
-		if (gpio_is_valid(pdata-&gt;reset_gpio_port[0]))
-			gpio_set_value_cansleep(pdata-&gt;reset_gpio_port[0], 1);
-
-		if (gpio_is_valid(pdata-&gt;reset_gpio_port[1]))
-			gpio_set_value_cansleep(pdata-&gt;reset_gpio_port[1], 1);
-	}
-
 	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (ret) {
 		dev_err(dev, "failed to add hcd with err %d\n", ret);
 		goto err_pm_runtime;
 	}
 
-	/* root ports should always stay powered */
-	ehci_port_power(omap_ehci, 1);
-
 	/* get clocks */
 	utmi_p1_fck = clk_get(dev, "utmi_p1_gfclk");
 	if (IS_ERR(utmi_p1_fck)) {
@@ -512,7 +510,7 @@ static const struct hc_driver ehci_omap_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_init,
+	.reset			= omap_ehci_init,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 82de1073aa52..3e411230953b 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -106,21 +106,10 @@ static int ehci_orion_setup(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
 
-	hcd-&gt;has_tt = 1;
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/*
-	 * data structure init
-	 */
-	retval = ehci_init(hcd);
+	retval = ehci_setup(ehci);
 	if (retval)
 		return retval;
 
-	ehci_reset(ehci);
-
 	ehci_port_power(ehci, 0);
 
 	return retval;
@@ -261,11 +250,7 @@ static int __devinit ehci_orion_drv_probe(struct platform_device *pdev)
 
 	ehci = hcd_to_ehci(hcd);
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
-	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 	hcd-&gt;has_tt = 1;
-	ehci-&gt;sbrn = 0x20;
 
 	/*
 	 * (Re-)program MBUS remapping windows if we are asked to.
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6e767bce0605..21e5f963f331 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -54,6 +54,17 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	u32			temp;
 	int			retval;
 
+	ehci-&gt;caps = hcd-&gt;regs;
+
+	/*
+	 * ehci_init() causes memory for DMA transfers to be
+	 * allocated.  Thus, any vendor-specific workarounds based on
+	 * limiting the type of memory used for DMA transfers must
+	 * happen before ehci_setup() is called.
+	 *
+	 * Most other workarounds can be done either before or after
+	 * init and reset; they are located here too.
+	 */
 	switch (pdev-&gt;vendor) {
 	case PCI_VENDOR_ID_TOSHIBA_2:
 		/* celleb's companion chip */
@@ -66,20 +77,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 		}
 		break;
-	}
-
-	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-        /* ehci_init() causes memory for DMA transfers to be
-         * allocated.  Thus, any vendor-specific workarounds based on
-         * limiting the type of memory used for DMA transfers must
-         * happen before ehci_init() is called. */
-	switch (pdev-&gt;vendor) {
 	case PCI_VENDOR_ID_NVIDIA:
 		/* NVidia reports that certain chips don't handle
 		 * QH, ITD, or SITD addresses above 2GB.  (But TD,
@@ -95,61 +92,28 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 				ehci_warn(ehci, "can't enable NVidia "
 					"workaround for &gt;2GB RAM\n");
 			break;
-		}
-		break;
-	}
 
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	if ((pdev-&gt;vendor == PCI_VENDOR_ID_AMD &amp;&amp; pdev-&gt;device == 0x7808) ||
-	    (pdev-&gt;vendor == PCI_VENDOR_ID_ATI &amp;&amp; pdev-&gt;device == 0x4396)) {
-		/* EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
-		 * read/write memory space which does not belong to it when
-		 * there is NULL pointer with T-bit set to 1 in the frame list
-		 * table. To avoid the issue, the frame list link pointer
-		 * should always contain a valid pointer to a inactive qh.
+		/* Some NForce2 chips have problems with selective suspend;
+		 * fixed in newer silicon.
 		 */
-		ehci-&gt;use_dummy_qh = 1;
-		ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI "
-				"dummy qh workaround\n");
-	}
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	switch (pdev-&gt;vendor) {
-	case PCI_VENDOR_ID_NEC:
-		ehci-&gt;need_io_watchdog = 0;
+		case 0x0068:
+			if (pdev-&gt;revision &lt; 0xa4)
+				ehci-&gt;no_selective_suspend = 1;
+			break;
+		}
 		break;
 	case PCI_VENDOR_ID_INTEL:
-		ehci-&gt;need_io_watchdog = 0;
 		ehci-&gt;fs_i_thresh = 1;
 		if (pdev-&gt;device == 0x27cc) {
 			ehci-&gt;broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");
 		}
-		if (pdev-&gt;device == 0x0806 || pdev-&gt;device == 0x0811
-				|| pdev-&gt;device == 0x0829) {
-			ehci_info(ehci, "disable lpm for langwell/penwell\n");
-			ehci-&gt;has_lpm = 0;
-		}
-		if (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CE4100_USB) {
+		if (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd-&gt;has_tt = 1;
-			tdi_reset(ehci);
-		}
 		break;
 	case PCI_VENDOR_ID_TDI:
-		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
+		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI)
 			hcd-&gt;has_tt = 1;
-			tdi_reset(ehci);
-		}
 		break;
 	case PCI_VENDOR_ID_AMD:
 		/* AMD PLL quirk */
@@ -161,28 +125,17 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			retval = -EIO;
 			goto done;
 		}
-		break;
-	case PCI_VENDOR_ID_NVIDIA:
-		switch (pdev-&gt;device) {
-		/* Some NForce2 chips have problems with selective suspend;
-		 * fixed in newer silicon.
-		 */
-		case 0x0068:
-			if (pdev-&gt;revision &lt; 0xa4)
-				ehci-&gt;no_selective_suspend = 1;
-			break;
 
-		/* MCP89 chips on the MacBookAir3,1 give EPROTO when
-		 * fetching device descriptors unless LPM is disabled.
-		 * There are also intermittent problems enumerating
-		 * devices with PPCD enabled.
+		/*
+		 * EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
+		 * read/write memory space which does not belong to it when
+		 * there is NULL pointer with T-bit set to 1 in the frame list
+		 * table. To avoid the issue, the frame list link pointer
+		 * should always contain a valid pointer to a inactive qh.
 		 */
-		case 0x0d9d:
-			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
-			ehci-&gt;has_lpm = 0;
-			ehci-&gt;has_ppcd = 0;
-			ehci-&gt;command &amp;= ~CMD_PPCEE;
-			break;
+		if (pdev-&gt;device == 0x7808) {
+			ehci-&gt;use_dummy_qh = 1;
+			ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");
 		}
 		break;
 	case PCI_VENDOR_ID_VIA:
@@ -203,6 +156,18 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		/* AMD PLL quirk */
 		if (usb_amd_find_chipset_info())
 			ehci-&gt;amd_pll_fix = 1;
+
+		/*
+		 * EHCI controller on AMD SB700/SB800/Hudson-2/3 platforms may
+		 * read/write memory space which does not belong to it when
+		 * there is NULL pointer with T-bit set to 1 in the frame list
+		 * table. To avoid the issue, the frame list link pointer
+		 * should always contain a valid pointer to a inactive qh.
+		 */
+		if (pdev-&gt;device == 0x4396) {
+			ehci-&gt;use_dummy_qh = 1;
+			ehci_info(ehci, "applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\n");
+		}
 		/* SB600 and old version of SB700 have a bug in EHCI controller,
 		 * which causes usb devices lose response in some cases.
 		 */
@@ -231,6 +196,40 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	}
 
+	retval = ehci_setup(hcd);
+	if (retval)
+		return retval;
+
+	/* These workarounds need to be applied after ehci_setup() */
+	switch (pdev-&gt;vendor) {
+	case PCI_VENDOR_ID_NEC:
+		ehci-&gt;need_io_watchdog = 0;
+		break;
+	case PCI_VENDOR_ID_INTEL:
+		ehci-&gt;need_io_watchdog = 0;
+		if (pdev-&gt;device == 0x0806 || pdev-&gt;device == 0x0811
+				|| pdev-&gt;device == 0x0829) {
+			ehci_info(ehci, "disable lpm for langwell/penwell\n");
+			ehci-&gt;has_lpm = 0;
+		}
+		break;
+	case PCI_VENDOR_ID_NVIDIA:
+		switch (pdev-&gt;device) {
+		/* MCP89 chips on the MacBookAir3,1 give EPROTO when
+		 * fetching device descriptors unless LPM is disabled.
+		 * There are also intermittent problems enumerating
+		 * devices with PPCD enabled.
+		 */
+		case 0x0d9d:
+			ehci_info(ehci, "disable lpm/ppcd for nvidia mcp89");
+			ehci-&gt;has_lpm = 0;
+			ehci-&gt;has_ppcd = 0;
+			ehci-&gt;command &amp;= ~CMD_PPCEE;
+			break;
+		}
+		break;
+	}
+
 	/* optional debug port, normally in the first BAR */
 	temp = pci_find_capability(pdev, 0x0a);
 	if (temp) {
@@ -238,7 +237,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		temp &gt;&gt;= 16;
 		if ((temp &amp; (3 &lt;&lt; 13)) == (1 &lt;&lt; 13)) {
 			temp &amp;= 0x1fff;
-			ehci-&gt;debug = ehci_to_hcd(ehci)-&gt;regs + temp;
+			ehci-&gt;debug = hcd-&gt;regs + temp;
 			temp = ehci_readl(ehci, &amp;ehci-&gt;debug-&gt;control);
 			ehci_info(ehci, "debug port %d%s\n",
 				HCS_DEBUG_PORT(ehci-&gt;hcs_params),
@@ -250,8 +249,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 	}
 
-	ehci_reset(ehci);
-
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci-&gt;hcs_params) * HCS_N_PCC(ehci-&gt;hcs_params);
 	temp &amp;= 0x0f;
@@ -275,10 +272,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	}
 
 	/* Serial Bus Release Number is at PCI 0x60 offset */
-	pci_read_config_byte(pdev, 0x60, &amp;ehci-&gt;sbrn);
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_STMICRO
 	    &amp;&amp; pdev-&gt;device == PCI_DEVICE_ID_STMICRO_USB_HOST)
-		ehci-&gt;sbrn = 0x20; /* ConneXT has no sbrn register */
+		;	/* ConneXT has no sbrn register */
+	else
+		pci_read_config_byte(pdev, 0x60, &amp;ehci-&gt;sbrn);
 
 	/* Keep this around for a while just in case some EHCI
 	 * implementation uses legacy PCI PM support.  This test
diff --git a/drivers/usb/host/ehci-pmcmsp.c b/drivers/usb/host/ehci-pmcmsp.c
index e8d54de44acc..087aee2a904f 100644
--- a/drivers/usb/host/ehci-pmcmsp.c
+++ b/drivers/usb/host/ehci-pmcmsp.c
@@ -78,27 +78,14 @@ static int ehci_msp_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	int			retval;
+
 	ehci-&gt;big_endian_mmio = 1;
 	ehci-&gt;big_endian_desc = 1;
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 	hcd-&gt;has_tt = 1;
 
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	ehci_reset(ehci);
-
-	/* data structure init */
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index 41d11fe14252..bbbe89dfd886 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -17,24 +17,6 @@
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_platform.h&gt;
 
-/* called during probe() after chip reset completes */
-static int ehci_ppc_of_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	int		retval;
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci-&gt;sbrn = 0x20;
-	return ehci_reset(ehci);
-}
-
 
 static const struct hc_driver ehci_ppc_of_hc_driver = {
 	.description		= hcd_name,
@@ -50,7 +32,7 @@ static const struct hc_driver ehci_ppc_of_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_ppc_of_setup,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
@@ -178,11 +160,6 @@ static int __devinit ehci_hcd_ppc_of_probe(struct platform_device *op)
 		ehci-&gt;big_endian_desc = 1;
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	if (of_device_is_compatible(dn, "ibm,usb-ehci-440epx")) {
 		rv = ppc44x_enable_bmt(dn);
diff --git a/drivers/usb/host/ehci-ps3.c b/drivers/usb/host/ehci-ps3.c
index a20e496eb479..45a356e9f138 100644
--- a/drivers/usb/host/ehci-ps3.c
+++ b/drivers/usb/host/ehci-ps3.c
@@ -55,28 +55,12 @@ static int ps3_ehci_hc_reset(struct usb_hcd *hcd)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 	ehci-&gt;big_endian_mmio = 1;
-
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs + HC_LENGTH(ehci, ehci_readl(ehci,
-		&amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	result = ehci_halt(ehci);
 
+	result = ehci_setup(hcd);
 	if (result)
 		return result;
 
-	result = ehci_init(hcd);
-
-	if (result)
-		return result;
-
-	ehci_reset(ehci);
-
 	ps3_ehci_setup_insnreg(ehci);
 
 	return result;
diff --git a/drivers/usb/host/ehci-s5p.c b/drivers/usb/host/ehci-s5p.c
index c7e0936d4a7c..13c179fb2ee2 100644
--- a/drivers/usb/host/ehci-s5p.c
+++ b/drivers/usb/host/ehci-s5p.c
@@ -40,7 +40,7 @@ static const struct hc_driver s5p_ehci_hc_driver = {
 	.irq			= ehci_irq,
 	.flags			= HCD_MEMORY | HCD_USB2,
 
-	.reset			= ehci_init,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
@@ -134,20 +134,10 @@ static int __devinit s5p_ehci_probe(struct platform_device *pdev)
 
 	ehci = hcd_to_ehci(hcd);
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, readl(&amp;ehci-&gt;caps-&gt;hc_capbase));
 
 	/* DMA burst Enable */
 	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd-&gt;regs));
 
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = readl(&amp;ehci-&gt;caps-&gt;hcs_params);
-
-	ehci_reset(ehci);
-
 	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (err) {
 		dev_err(&amp;pdev-&gt;dev, "Failed to add USB HCD\n");
diff --git a/drivers/usb/host/ehci-sh.c b/drivers/usb/host/ehci-sh.c
index e7cb3925abf8..b3f1e3650da0 100644
--- a/drivers/usb/host/ehci-sh.c
+++ b/drivers/usb/host/ehci-sh.c
@@ -24,25 +24,11 @@ static int ehci_sh_reset(struct usb_hcd *hcd)
 	int ret;
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs + HC_LENGTH(ehci, ehci_readl(ehci,
-		&amp;ehci-&gt;caps-&gt;hc_capbase));
 
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	ret = ehci_halt(ehci);
-	if (unlikely(ret))
-		return ret;
-
-	ret = ehci_init(hcd);
+	ret = ehci_setup(hcd);
 	if (unlikely(ret))
 		return ret;
 
-	ehci-&gt;sbrn = 0x20;
-
-	ehci_reset(ehci);
 	ehci_port_power(ehci, 0);
 
 	return ret;
diff --git a/drivers/usb/host/ehci-spear.c b/drivers/usb/host/ehci-spear.c
index 7ed533e6cca8..c718a065e154 100644
--- a/drivers/usb/host/ehci-spear.c
+++ b/drivers/usb/host/ehci-spear.c
@@ -41,19 +41,11 @@ static int ehci_spear_setup(struct usb_hcd *hcd)
 
 	/* registers start at offset 0x0 */
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs + HC_LENGTH(ehci, ehci_readl(ehci,
-				&amp;ehci-&gt;caps-&gt;hc_capbase));
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
 
-	retval = ehci_init(hcd);
+	retval = ehci_setup(hcd);
 	if (retval)
 		return retval;
 
-	ehci_reset(ehci);
 	ehci_port_power(ehci, 0);
 
 	return retval;
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 477ecfa05154..f7f3ce3275b8 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -281,30 +281,14 @@ static int tegra_ehci_setup(struct usb_hcd *hcd)
 
 	/* EHCI registers start at offset 0x100 */
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
-	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
-		HC_LENGTH(ehci, readl(&amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = readl(&amp;ehci-&gt;caps-&gt;hcs_params);
 
 	/* switch to host mode */
 	hcd-&gt;has_tt = 1;
-	ehci_reset(ehci);
 
-	retval = ehci_halt(ehci);
+	retval = ehci_setup(ehci);
 	if (retval)
 		return retval;
 
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci-&gt;sbrn = 0x20;
-
 	ehci_port_power(ehci, 1);
 	return retval;
 }
diff --git a/drivers/usb/host/ehci-vt8500.c b/drivers/usb/host/ehci-vt8500.c
index c1eda73916cd..4d147c4e33f5 100644
--- a/drivers/usb/host/ehci-vt8500.c
+++ b/drivers/usb/host/ehci-vt8500.c
@@ -48,7 +48,7 @@ static const struct hc_driver vt8500_ehci_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_init,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
@@ -121,18 +121,6 @@ static int vt8500_ehci_drv_probe(struct platform_device *pdev)
 
 	ehci = hcd_to_ehci(hcd);
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, readl(&amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = readl(&amp;ehci-&gt;caps-&gt;hcs_params);
-
-	ehci_port_power(ehci, 1);
-
-	ehci_reset(ehci);
 
 	ret = usb_add_hcd(hcd, pdev-&gt;resource[1].start,
 			  IRQF_SHARED);
diff --git a/drivers/usb/host/ehci-w90x900.c b/drivers/usb/host/ehci-w90x900.c
index 3d2e26cbb34c..ec598082c14b 100644
--- a/drivers/usb/host/ehci-w90x900.c
+++ b/drivers/usb/host/ehci-w90x900.c
@@ -71,21 +71,14 @@ static int __devinit usb_w90x900_probe(const struct hc_driver *driver,
 	val |= ENPHY;
 	__raw_writel(val, ehci-&gt;regs+PHY1_CTR);
 
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-	ehci-&gt;sbrn = 0x20;
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq &lt; 0)
 		goto err4;
 
-	ehci_reset(ehci);
-
 	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 
-	ehci_writel(ehci, 1, &amp;ehci-&gt;regs-&gt;configured_flag);
-
 	return retval;
 err4:
 	iounmap(hcd-&gt;regs);
@@ -120,7 +113,7 @@ static const struct hc_driver ehci_w90x900_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset = ehci_init,
+	.reset = ehci_setup,
 	.start = ehci_run,
 
 	.stop = ehci_stop,
diff --git a/drivers/usb/host/ehci-xilinx-of.c b/drivers/usb/host/ehci-xilinx-of.c
index e9713d589e30..39f24fa37ebe 100644
--- a/drivers/usb/host/ehci-xilinx-of.c
+++ b/drivers/usb/host/ehci-xilinx-of.c
@@ -31,30 +31,6 @@
 #include &lt;linux/of_platform.h&gt;
 #include &lt;linux/of_address.h&gt;
 
-/**
- * ehci_xilinx_of_setup - Initialize the device for ehci_reset()
- * @hcd:	Pointer to the usb_hcd device to which the host controller bound
- *
- * called during probe() after chip reset completes.
- */
-static int ehci_xilinx_of_setup(struct usb_hcd *hcd)
-{
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	int		retval;
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci-&gt;sbrn = 0x20;
-
-	return ehci_reset(ehci);
-}
-
 /**
  * ehci_xilinx_port_handed_over - hand the port out if failed to enable it
  * @hcd:	Pointer to the usb_hcd device to which the host controller bound
@@ -107,7 +83,7 @@ static const struct hc_driver ehci_xilinx_of_hc_driver = {
 	/*
 	 * basic lifecycle operations
 	 */
-	.reset			= ehci_xilinx_of_setup,
+	.reset			= ehci_setup,
 	.start			= ehci_run,
 	.stop			= ehci_stop,
 	.shutdown		= ehci_shutdown,
@@ -219,11 +195,6 @@ static int __devinit ehci_hcd_xilinx_of_probe(struct platform_device *op)
 	/* Debug registers are at the first 0x100 region
 	 */
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
-	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
 	rv = usb_add_hcd(hcd, irq, 0);
 	if (rv == 0)
diff --git a/drivers/usb/host/ehci-xls.c b/drivers/usb/host/ehci-xls.c
index 72f08196f8cd..99c353a85ae4 100644
--- a/drivers/usb/host/ehci-xls.c
+++ b/drivers/usb/host/ehci-xls.c
@@ -14,30 +14,11 @@
 
 static int ehci_xls_setup(struct usb_hcd *hcd)
 {
-	int	retval;
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 	ehci-&gt;caps = hcd-&gt;regs;
-	ehci-&gt;regs = hcd-&gt;regs +
-		HC_LENGTH(ehci, ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
 
-	/* cache this readonly data; minimize chip reads */
-	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
-
-	/* data structure init */
-	retval = ehci_init(hcd);
-	if (retval)
-		return retval;
-
-	ehci_reset(ehci);
-
-	return retval;
+	return ehci_setup(ehci);
 }
 
 int ehci_xls_probe_internal(const struct hc_driver *driver,</pre><hr><pre>commit c5cf9212a368d88fe1e25797699b167f6daa64a5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 28 11:19:02 2012 -0400

    EHCI: centralize controller suspend/resume
    
    This patch (as1563) removes a lot of duplicated code by moving the
    EHCI controller suspend/resume routines into the core driver, where
    the various platform drivers can invoke them as needed.
    
    Not only does this simplify these platform drivers, this also makes it
    easier for other platform drivers to add suspend/resume support in the
    future.
    
    Note: The patch does not touch the ehci-fsl.c file, because its
    approach to suspend and resume is so different from all the others.
    It will have to be handled specially by its maintainer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index bf7441afed16..182d39565906 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -158,28 +158,10 @@ static int ehci_hcd_au1xxx_drv_remove(struct platform_device *pdev)
 static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	unsigned long flags;
-	int rc = 0;
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(10);
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible.  The PM and USB cores make sure that
-	 * the root hub is either suspended or stopped.
-	 */
-	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
-
-	// could save FLADJ in case of Vaux power loss
-	// ... we'd only use it to handle clock skew
+	bool do_wakeup = device_may_wakeup(dev);
+	int rc;
 
+	rc = ehci_suspend(hcd, do_wakeup);
 	alchemy_usb_control(ALCHEMY_USB_EHCI0, 0);
 
 	return rc;
@@ -188,56 +170,9 @@ static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
 static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 
 	alchemy_usb_control(ALCHEMY_USB_EHCI0, 1);
-
-	// maybe restore FLADJ
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	/* If CF is still set, we maintained PCI Vaux power.
-	 * Just undo the effect of ehci_pci_suspend().
-	 */
-	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
-		int	mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
-			mask &amp;= ~STS_PCD;
-		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
-		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-		return 0;
-	}
-
-	ehci_dbg(ehci, "lost power, restarting\n");
-	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having let BIOS kick in during reboot.
-	 */
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
+	ehci_resume(hcd, false);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c49fc1e7895d..e6823a0cf642 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1242,6 +1242,95 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 }
 
 /*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_PM
+
+/* suspend/resume, section 4.3 */
+
+/* These routines handle the generic parts of controller suspend/resume */
+
+static int __maybe_unused ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci-&gt;next_statechange))
+		msleep(10);
+
+	/*
+	 * Root hub was already suspended.  Disable IRQ emission and
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
+	 */
+	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
+	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	return 0;
+}
+
+/* Returns 0 if power was preserved, 1 if power was lost */
+static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	if (time_before(jiffies, ehci-&gt;next_statechange))
+		msleep(100);
+
+	/* Mark hardware accessible again as we are back to full power by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+
+	/*
+	 * If CF is still set and we aren't resuming from hibernation
+	 * then we maintained suspend power.
+	 * Just undo the effect of ehci_suspend().
+	 */
+	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF &amp;&amp;
+			!hibernated) {
+		int	mask = INTR_MASK;
+
+		ehci_prepare_ports_for_controller_resume(ehci);
+		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
+			mask &amp;= ~STS_PCD;
+		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
+		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+		return 0;
+	}
+
+	/*
+	 * Else reset, to cope with power loss or resume from hibernation
+	 * having let the firmware kick in during reboot.
+	 */
+	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;reclaim)
+		end_unlink_async(ehci);
+	ehci_work(ehci);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
+	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
+
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
+	return 1;
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * The EHCI in ChipIdea HDRC cannot be a separate module or device,
  * because its registers (and irq) are shared between host/gadget/otg
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index db05e358677a..b3e2d66e95bb 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -107,7 +107,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	ehci-&gt;owned_ports = 0;
 }
 
-static int __maybe_unused ehci_port_change(struct ehci_hcd *ehci)
+static int ehci_port_change(struct ehci_hcd *ehci)
 {
 	int i = HCS_N_PORTS(ehci-&gt;hcs_params);
 
@@ -128,7 +128,7 @@ static int __maybe_unused ehci_port_change(struct ehci_hcd *ehci)
 	return 0;
 }
 
-static __maybe_unused void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
+static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 		bool suspending, bool do_wakeup)
 {
 	int		port;
diff --git a/drivers/usb/host/ehci-msm.c b/drivers/usb/host/ehci-msm.c
index 6b4ffb598db1..17dd9e94001e 100644
--- a/drivers/usb/host/ehci-msm.c
+++ b/drivers/usb/host/ehci-msm.c
@@ -198,24 +198,11 @@ static int __devexit ehci_msm_remove(struct platform_device *pdev)
 static int ehci_msm_pm_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	bool wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev);
 
 	dev_dbg(dev, "ehci-msm PM suspend\n");
 
-	/*
-	 * EHCI helper function has also the same check before manipulating
-	 * port wakeup flags.  We do check here the same condition before
-	 * calling the same helper function to avoid bringing hardware
-	 * from Low power mode when there is no need for adjusting port
-	 * wakeup flags.
-	 */
-	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup &amp;&amp; !wakeup) {
-		pm_runtime_resume(dev);
-		ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
-				wakeup);
-	}
-
-	return 0;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static int ehci_msm_pm_resume(struct device *dev)
@@ -223,7 +210,7 @@ static int ehci_msm_pm_resume(struct device *dev)
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 
 	dev_dbg(dev, "ehci-msm PM resume\n");
-	ehci_prepare_ports_for_controller_resume(hcd_to_ehci(hcd));
+	ehci_resume(hcd, false);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 123481793a47..6e767bce0605 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -331,29 +331,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 
 static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
-	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned long		flags;
-	int			rc = 0;
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(10);
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible.  The PM and USB cores make sure that
-	 * the root hub is either suspended or stopped.
-	 */
-	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
-	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-
-	// could save FLADJ in case of Vaux power loss
-	// ... we'd only use it to handle clock skew
-
-	return rc;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static bool usb_is_intel_switchable_ehci(struct pci_dev *pdev)
@@ -402,54 +380,8 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (usb_is_intel_switchable_ehci(pdev))
 		ehci_enable_xhci_companion();
 
-	// maybe restore FLADJ
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	/* If CF is still set and we aren't resuming from hibernation
-	 * then we maintained PCI Vaux power.
-	 * Just undo the effect of ehci_pci_suspend().
-	 */
-	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF &amp;&amp;
-				!hibernated) {
-		int	mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
-			mask &amp;= ~STS_PCD;
-		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
-		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-		return 0;
-	}
-
-	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having let BIOS kick in during reboot.
-	 */
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-	(void) ehci_pci_reinit(ehci, pdev);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
+	if (ehci_resume(hcd, hibernated) != 0)
+		(void) ehci_pci_reinit(ehci, pdev);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ehci-platform.c b/drivers/usb/host/ehci-platform.c
index dfe881a34ae2..4b1d896d5a22 100644
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@ -153,17 +153,16 @@ static int __devexit ehci_platform_remove(struct platform_device *dev)
 static int ehci_platform_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	bool wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev);
 
-	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd), wakeup);
-	return 0;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static int ehci_platform_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 
-	ehci_prepare_ports_for_controller_resume(hcd_to_ehci(hcd));
+	ehci_resume(hcd, false);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-s5p.c b/drivers/usb/host/ehci-s5p.c
index 1e483f052ff7..c7e0936d4a7c 100644
--- a/drivers/usb/host/ehci-s5p.c
+++ b/drivers/usb/host/ehci-s5p.c
@@ -200,27 +200,12 @@ static int s5p_ehci_suspend(struct device *dev)
 {
 	struct s5p_ehci_hcd *s5p_ehci = dev_get_drvdata(dev);
 	struct usb_hcd *hcd = s5p_ehci-&gt;hcd;
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	bool do_wakeup = device_may_wakeup(dev);
 	struct platform_device *pdev = to_platform_device(dev);
 	struct s5p_ehci_platdata *pdata = pdev-&gt;dev.platform_data;
-	unsigned long flags;
-	int rc = 0;
+	int rc;
 
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(20);
-
-	/*
-	 * Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible.  The PM and USB cores make sure that
-	 * the root hub is either suspended or stopped.
-	 */
-	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	rc = ehci_suspend(hcd, do_wakeup);
 
 	if (pdata &amp;&amp; pdata-&gt;phy_exit)
 		pdata-&gt;phy_exit(pdev, S5P_USB_PHY_HOST);
@@ -234,7 +219,6 @@ static int s5p_ehci_resume(struct device *dev)
 {
 	struct s5p_ehci_hcd *s5p_ehci = dev_get_drvdata(dev);
 	struct usb_hcd *hcd = s5p_ehci-&gt;hcd;
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct platform_device *pdev = to_platform_device(dev);
 	struct s5p_ehci_platdata *pdata = pdev-&gt;dev.platform_data;
 
@@ -246,44 +230,7 @@ static int s5p_ehci_resume(struct device *dev)
 	/* DMA burst Enable */
 	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd-&gt;regs));
 
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
-		int	mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
-			mask &amp;= ~STS_PCD;
-		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
-		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-		return 0;
-	}
-
-	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
-
+	ehci_resume(hcd, false);
 	return 0;
 }
 #else
diff --git a/drivers/usb/host/ehci-sead3.c b/drivers/usb/host/ehci-sead3.c
index cc199e87a7a9..58c96bd50d22 100644
--- a/drivers/usb/host/ehci-sead3.c
+++ b/drivers/usb/host/ehci-sead3.c
@@ -160,84 +160,16 @@ static int ehci_hcd_sead3_drv_remove(struct platform_device *pdev)
 static int ehci_hcd_sead3_drv_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	unsigned long flags;
-	int rc = 0;
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(20);
-
-	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible.  The PM and USB cores make sure that
-	 * the root hub is either suspended or stopped.
-	 */
-	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	bool do_wakeup = device_may_wakeup(dev);
 
-	/* could save FLADJ in case of Vaux power loss
-	 * ... we'd only use it to handle clock skew
-	 */
-
-	return rc;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static int ehci_hcd_sead3_drv_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-
-	/* maybe restore FLADJ. */
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(100);
-
-	/* Mark hardware accessible again as we are out of D3 state by now */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	/* If CF is still set, we maintained PCI Vaux power.
-	 * Just undo the effect of ehci_pci_suspend().
-	 */
-	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
-		int	mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
-			mask &amp;= ~STS_PCD;
-		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
-		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-		return 0;
-	}
-
-	ehci_dbg(ehci, "lost power, restarting\n");
-	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-
-	/* Else reset, to cope with power loss or flush-to-storage
-	 * style "resume" having let BIOS kick in during reboot.
-	 */
-	(void) ehci_halt(ehci);
-	(void) ehci_reset(ehci);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
-
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
+	ehci_resume(hcd, false);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-spear.c b/drivers/usb/host/ehci-spear.c
index 37ba8c8d2fd0..7ed533e6cca8 100644
--- a/drivers/usb/host/ehci-spear.c
+++ b/drivers/usb/host/ehci-spear.c
@@ -97,71 +97,16 @@ static const struct hc_driver ehci_spear_hc_driver = {
 static int ehci_spear_drv_suspend(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	unsigned long flags;
-	int rc = 0;
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(10);
-
-	/*
-	 * Root hub was already suspended. Disable irq emission and mark HW
-	 * unaccessible. The PM and USB cores make sure that the root hub is
-	 * either suspended or stopped.
-	 */
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
-	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	bool do_wakeup = device_may_wakeup(dev);
 
-	return rc;
+	return ehci_suspend(hcd, do_wakeup);
 }
 
 static int ehci_spear_drv_resume(struct device *dev)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-
-	if (time_before(jiffies, ehci-&gt;next_statechange))
-		msleep(100);
-
-	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
-		int mask = INTR_MASK;
-
-		ehci_prepare_ports_for_controller_resume(ehci);
-
-		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
-			mask &amp;= ~STS_PCD;
-
-		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
-		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-		return 0;
-	}
-
-	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-
-	/*
-	 * Else reset, to cope with power loss or flush-to-storage style
-	 * "resume" having let BIOS kick in during reboot.
-	 */
-	ehci_halt(ehci);
-	ehci_reset(ehci);
-
-	/* emptying the schedule aborts any urbs */
-	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;reclaim)
-		end_unlink_async(ehci);
-
-	ehci_work(ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
-
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
-	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
+	ehci_resume(hcd, false);
 	return 0;
 }
 #endif /* CONFIG_PM */</pre><hr><pre>commit a46af4ebf9ffec35eea0390e89935197b833dc61
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 25 12:19:03 2012 -0400

    USB: EHCI: define extension registers like normal ones
    
    This patch (as1562) cleans up the definitions of the EHCI extended
    registers to be consistent with the definitions of the standard
    registers.  This makes the code look a lot nicer, with no functional
    change.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 800be38c78b4..c49fc1e7895d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -203,11 +203,9 @@ static int handshake (struct ehci_hcd *ehci, void __iomem *ptr,
 /* check TDI/ARC silicon is in host mode */
 static int tdi_in_host_mode (struct ehci_hcd *ehci)
 {
-	u32 __iomem	*reg_ptr;
 	u32		tmp;
 
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci-&gt;regs) + USBMODE);
-	tmp = ehci_readl(ehci, reg_ptr);
+	tmp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;usbmode);
 	return (tmp &amp; 3) == USBMODE_CM_HC;
 }
 
@@ -303,11 +301,9 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
-	u32 __iomem	*reg_ptr;
 	u32		tmp;
 
-	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci-&gt;regs) + USBMODE);
-	tmp = ehci_readl(ehci, reg_ptr);
+	tmp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;usbmode);
 	tmp |= USBMODE_CM_HC;
 	/* The default byte access to MMR space is LE after
 	 * controller reset. Set the required endian mode
@@ -315,7 +311,7 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	 */
 	if (ehci_big_endian_mmio(ehci))
 		tmp |= USBMODE_BE;
-	ehci_writel(ehci, tmp, reg_ptr);
+	ehci_writel(ehci, tmp, &amp;ehci-&gt;regs-&gt;usbmode);
 }
 
 /* reset a non-running (STS_HALT == 1) controller */
@@ -339,9 +335,8 @@ static int ehci_reset (struct ehci_hcd *ehci)
 
 	if (ehci-&gt;has_hostpc) {
 		ehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,
-			(u32 __iomem *)(((u8 *)ehci-&gt;regs) + USBMODE_EX));
-		ehci_writel(ehci, TXFIFO_DEFAULT,
-			(u32 __iomem *)(((u8 *)ehci-&gt;regs) + TXFILLTUNING));
+				&amp;ehci-&gt;regs-&gt;usbmode_ex);
+		ehci_writel(ehci, TXFIFO_DEFAULT, &amp;ehci-&gt;regs-&gt;txfill_tuning);
 	}
 	if (retval)
 		return retval;
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index dd5eef6af6df..db05e358677a 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -149,10 +149,8 @@ static __maybe_unused void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (ehci-&gt;has_hostpc) {
 		port = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (port--) {
-			u32 __iomem	*hostpc_reg;
+			u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[port];
 
-			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
-					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
 			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD, hostpc_reg);
 		}
@@ -185,10 +183,8 @@ static __maybe_unused void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (ehci-&gt;has_hostpc) {
 		port = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (port--) {
-			u32 __iomem	*hostpc_reg;
+			u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[port];
 
-			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
-					+ HOSTPC0 + 4 * port);
 			temp = ehci_readl(ehci, hostpc_reg);
 			ehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);
 		}
@@ -285,11 +281,9 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 		port = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (port--) {
-			u32 __iomem	*hostpc_reg;
+			u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[port];
 			u32		t3;
 
-			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
-					+ HOSTPC0 + 4 * port);
 			t3 = ehci_readl(ehci, hostpc_reg);
 			ehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);
 			t3 = ehci_readl(ehci, hostpc_reg);
@@ -388,10 +382,9 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		i = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (i--) {
 			if (test_bit(i, &amp;ehci-&gt;bus_suspended)) {
-				u32 __iomem	*hostpc_reg;
+				u32 __iomem	*hostpc_reg =
+							&amp;ehci-&gt;regs-&gt;hostpc[i];
 
-				hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
-						+ HOSTPC0 + 4 * i);
 				temp = ehci_readl(ehci, hostpc_reg);
 				ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD,
 						hostpc_reg);
@@ -667,7 +660,7 @@ static int ehci_hub_control (
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
 	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[
 				(wIndex &amp; 0xff) - 1];
-	u32 __iomem	*hostpc_reg = NULL;
+	u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[(wIndex &amp; 0xff) - 1];
 	u32		temp, temp1, status;
 	unsigned long	flags;
 	int		retval = 0;
@@ -680,9 +673,6 @@ static int ehci_hub_control (
 	 * power, "this is the one", etc.  EHCI spec supports this.
 	 */
 
-	if (ehci-&gt;has_hostpc)
-		hostpc_reg = (u32 __iomem *)((u8 *)ehci-&gt;regs
-				+ HOSTPC0 + 4 * ((wIndex &amp; 0xff) - 1));
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	switch (typeReq) {
 	case ClearHubFeature:
@@ -734,7 +724,7 @@ static int ehci_hub_control (
 				goto error;
 
 			/* clear phy low-power mode before resume */
-			if (hostpc_reg) {
+			if (ehci-&gt;has_hostpc) {
 				temp1 = ehci_readl(ehci, hostpc_reg);
 				ehci_writel(ehci, temp1 &amp; ~HOSTPC_PHCD,
 						hostpc_reg);
@@ -984,7 +974,7 @@ static int ehci_hub_control (
 			temp &amp;= ~PORT_WKCONN_E;
 			temp |= PORT_WKDISC_E | PORT_WKOC_E;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
-			if (hostpc_reg) {
+			if (ehci-&gt;has_hostpc) {
 				spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 				msleep(5);/* 5ms for HCD enter low pwr mode */
 				spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
diff --git a/include/linux/usb/ehci_def.h b/include/linux/usb/ehci_def.h
index 7cc95ee3606b..de4b9ed5d5dd 100644
--- a/include/linux/usb/ehci_def.h
+++ b/include/linux/usb/ehci_def.h
@@ -111,7 +111,13 @@ struct ehci_regs {
 	/* ASYNCLISTADDR: offset 0x18 */
 	u32		async_next;	/* address of next async queue head */
 
-	u32		reserved[9];
+	u32		reserved1[2];
+
+	/* TXFILLTUNING: offset 0x24 */
+	u32		txfill_tuning;	/* TX FIFO Tuning register */
+#define TXFIFO_DEFAULT	(8&lt;&lt;16)		/* FIFO burst threshold 8 */
+
+	u32		reserved2[6];
 
 	/* CONFIGFLAG: offset 0x40 */
 	u32		configured_flag;
@@ -155,26 +161,34 @@ struct ehci_regs {
 #define PORT_CSC	(1&lt;&lt;1)		/* connect status change */
 #define PORT_CONNECT	(1&lt;&lt;0)		/* device connected */
 #define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)
-};
 
-#define USBMODE		0x68		/* USB Device mode */
+	u32		reserved3[9];
+
+	/* USBMODE: offset 0x68 */
+	u32		usbmode;	/* USB Device mode */
 #define USBMODE_SDIS	(1&lt;&lt;3)		/* Stream disable */
 #define USBMODE_BE	(1&lt;&lt;2)		/* BE/LE endianness select */
 #define USBMODE_CM_HC	(3&lt;&lt;0)		/* host controller mode */
 #define USBMODE_CM_IDLE	(0&lt;&lt;0)		/* idle state */
 
+	u32		reserved4[7];
+
 /* Moorestown has some non-standard registers, partially due to the fact that
  * its EHCI controller has both TT and LPM support. HOSTPCx are extensions to
  * PORTSCx
  */
-#define HOSTPC0		0x84		/* HOSTPC extension */
+	/* HOSTPC: offset 0x84 */
+	u32		hostpc[0];	/* HOSTPC extension */
 #define HOSTPC_PHCD	(1&lt;&lt;22)		/* Phy clock disable */
 #define HOSTPC_PSPD	(3&lt;&lt;25)		/* Port speed detection */
-#define USBMODE_EX	0xc8		/* USB Device mode extension */
+
+	u32		reserved5[17];
+
+	/* USBMODE_EX: offset 0xc8 */
+	u32		usbmode_ex;	/* USB Device mode extension */
 #define USBMODE_EX_VBPS	(1&lt;&lt;5)		/* VBus Power Select On */
 #define USBMODE_EX_HC	(3&lt;&lt;0)		/* host controller mode */
-#define TXFILLTUNING	0x24		/* TX FIFO Tuning register */
-#define TXFIFO_DEFAULT	(8&lt;&lt;16)		/* FIFO burst threshold 8 */
+};
 
 /* Appendix C, Debug port ... intended for use with special "debug devices"
  * that can help if there's no serial console.  (nonstandard enumeration.)</pre><hr><pre>commit 4661e3568a7d14a93d4e428d246cdb86f4bac6e7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 22 17:12:19 2012 -0400

    printk: fix regression in SYSLOG_ACTION_CLEAR
    
    Commit 7ff9554bb578ba02166071d2d487b7fc7d860d62 (printk: convert
    byte-buffer to variable-length record buffer) introduced a regression
    by accidentally removing a "break" statement from inside the big
    switch in printk's do_syslog().  The symptom of this bug is that the
    "dmesg -C" command doesn't only clear the kernel's log buffer; it also
    disables console logging.
    
    This patch (as1561) fixes the regression by adding the missing
    "break".
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Kay Sievers &lt;kay@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/kernel/printk.c b/kernel/printk.c
index a2276b916769..d6a1412f6b09 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -1040,6 +1040,7 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 	/* Clear ring buffer */
 	case SYSLOG_ACTION_CLEAR:
 		syslog_print_all(NULL, 0, true);
+		break;
 	/* Disable logging to console */
 	case SYSLOG_ACTION_CONSOLE_OFF:
 		if (saved_console_loglevel == -1)</pre>
    <div class="pagination">
        <a href='2_46.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><span>[47]</span><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_48.html'>Next&gt;&gt;</a>
    <div>
</body>

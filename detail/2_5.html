<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_4.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><span>[5]</span><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_6.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fc274c1e997314bf47f6a62c79b5d7e554ed59c4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:35:51 2022 -0400

    USB: gadget: Add a new bus for gadgets
    
    This patch adds a "gadget" bus and uses it for registering gadgets and
    their drivers.  From now on, bindings will be managed by the driver
    core rather than through ad-hoc manipulations in the UDC core.
    
    As part of this change, the driver_pending_list is removed.  The UDC
    core won't need to keep track of unbound drivers for later binding,
    because the driver core handles all of that for us.
    
    However, we do need one new feature: a way to prevent gadget drivers
    from being bound to more than one gadget at a time.  The existing code
    does this automatically, but the driver core doesn't -- it's perfectly
    happy to bind a single driver to all the matching devices on the bus.
    The patch adds a new bitflag to the usb_gadget_driver structure for
    this purpose.
    
    A nice side effect of this change is a reduction in the total lines of
    code, since now the driver core will do part of the work that the UDC
    used to do.
    
    A possible future patch could add udc devices to the gadget bus, say
    as a separate device type.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSpdxaDNeC2BBOf@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index a878e7afacdd..61790592b2c8 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -23,6 +23,8 @@
 
 #include "trace.h"
 
+static struct bus_type gadget_bus_type;
+
 /**
  * struct usb_udc - describes one usb device controller
  * @driver: the gadget driver pointer. For use by the class code
@@ -47,11 +49,9 @@ struct usb_udc {
 
 static struct class *udc_class;
 static LIST_HEAD(udc_list);
-static LIST_HEAD(gadget_driver_pending_list);
-static DEFINE_MUTEX(udc_lock);
 
-static int udc_bind_to_driver(struct usb_udc *udc,
-		struct usb_gadget_driver *driver);
+/* Protects udc_list, udc-&gt;driver, driver-&gt;is_bound, and related calls */
+static DEFINE_MUTEX(udc_lock);
 
 /* ------------------------------------------------------------------------- */
 
@@ -1238,24 +1238,6 @@ static void usb_udc_nop_release(struct device *dev)
 	dev_vdbg(dev, "%s\n", __func__);
 }
 
-/* should be called with udc_lock held */
-static int check_pending_gadget_drivers(struct usb_udc *udc)
-{
-	struct usb_gadget_driver *driver;
-	int ret = 0;
-
-	list_for_each_entry(driver, &amp;gadget_driver_pending_list, pending)
-		if (!driver-&gt;udc_name || strcmp(driver-&gt;udc_name,
-						dev_name(&amp;udc-&gt;dev)) == 0) {
-			ret = udc_bind_to_driver(udc, driver);
-			if (ret != -EPROBE_DEFER)
-				list_del_init(&amp;driver-&gt;pending);
-			break;
-		}
-
-	return ret;
-}
-
 /**
  * usb_initialize_gadget - initialize a gadget and its embedded struct device
  * @parent: the parent device to this udc. Usually the controller driver's
@@ -1276,6 +1258,7 @@ void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
 	device_initialize(&amp;gadget-&gt;dev);
+	gadget-&gt;dev.bus = &amp;gadget_bus_type;
 }
 EXPORT_SYMBOL_GPL(usb_initialize_gadget);
 
@@ -1312,6 +1295,7 @@ int usb_add_gadget(struct usb_gadget *gadget)
 
 	mutex_lock(&amp;udc_lock);
 	list_add_tail(&amp;udc-&gt;list, &amp;udc_list);
+	mutex_unlock(&amp;udc_lock);
 
 	ret = device_add(&amp;udc-&gt;dev);
 	if (ret)
@@ -1324,23 +1308,14 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	if (ret)
 		goto err_del_udc;
 
-	/* pick up one of pending gadget drivers */
-	ret = check_pending_gadget_drivers(udc);
-	if (ret)
-		goto err_del_gadget;
-
-	mutex_unlock(&amp;udc_lock);
-
 	return 0;
 
- err_del_gadget:
-	device_del(&amp;gadget-&gt;dev);
-
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
 
  err_unlist_udc:
+	mutex_lock(&amp;udc_lock);
 	list_del(&amp;udc-&gt;list);
 	mutex_unlock(&amp;udc_lock);
 
@@ -1419,24 +1394,6 @@ int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc);
 
-static void usb_gadget_remove_driver(struct usb_udc *udc)
-{
-	dev_dbg(&amp;udc-&gt;dev, "unregistering UDC driver [%s]\n",
-			udc-&gt;driver-&gt;function);
-
-	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
-
-	usb_gadget_disconnect(udc-&gt;gadget);
-	usb_gadget_disable_async_callbacks(udc);
-	if (udc-&gt;gadget-&gt;irq)
-		synchronize_irq(udc-&gt;gadget-&gt;irq);
-	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
-	usb_gadget_udc_stop(udc);
-
-	udc-&gt;driver = NULL;
-	udc-&gt;gadget-&gt;dev.driver = NULL;
-}
-
 /**
  * usb_del_gadget - deletes a gadget and unregisters its udc
  * @gadget: the gadget to be deleted.
@@ -1455,13 +1412,6 @@ void usb_del_gadget(struct usb_gadget *gadget)
 
 	mutex_lock(&amp;udc_lock);
 	list_del(&amp;udc-&gt;list);
-
-	if (udc-&gt;driver) {
-		struct usb_gadget_driver *driver = udc-&gt;driver;
-
-		usb_gadget_remove_driver(udc);
-		list_add(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);
-	}
 	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
@@ -1486,123 +1436,147 @@ EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
 /* ------------------------------------------------------------------------- */
 
-static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
+static int gadget_match_driver(struct device *dev, struct device_driver *drv)
 {
-	int ret;
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = container_of(drv,
+			struct usb_gadget_driver, driver);
+
+	/* If the driver specifies a udc_name, it must match the UDC's name */
+	if (driver-&gt;udc_name &amp;&amp;
+			strcmp(driver-&gt;udc_name, dev_name(&amp;udc-&gt;dev)) != 0)
+		return 0;
+
+	/* If the driver is already bound to a gadget, it doesn't match */
+	if (driver-&gt;is_bound)
+		return 0;
+
+	/* Otherwise any gadget driver matches any UDC */
+	return 1;
+}
 
-	dev_dbg(&amp;udc-&gt;dev, "registering UDC driver [%s]\n",
-			driver-&gt;function);
+static int gadget_bind_driver(struct device *dev)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = container_of(dev-&gt;driver,
+			struct usb_gadget_driver, driver);
+	int ret = 0;
 
+	mutex_lock(&amp;udc_lock);
+	if (driver-&gt;is_bound) {
+		mutex_unlock(&amp;udc_lock);
+		return -ENXIO;		/* Driver binds to only one gadget */
+	}
+	driver-&gt;is_bound = true;
 	udc-&gt;driver = driver;
-	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;
+	mutex_unlock(&amp;udc_lock);
+
+	dev_dbg(&amp;udc-&gt;dev, "binding gadget driver [%s]\n", driver-&gt;function);
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
 
+	mutex_lock(&amp;udc_lock);
 	ret = driver-&gt;bind(udc-&gt;gadget, driver);
 	if (ret)
-		goto err1;
+		goto err_bind;
+
 	ret = usb_gadget_udc_start(udc);
-	if (ret) {
-		driver-&gt;unbind(udc-&gt;gadget);
-		goto err1;
-	}
+	if (ret)
+		goto err_start;
 	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
+	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 	return 0;
-err1:
+
+ err_start:
+	driver-&gt;unbind(udc-&gt;gadget);
+
+ err_bind:
 	if (ret != -EISNAM)
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
-			udc-&gt;driver-&gt;function, ret);
+			driver-&gt;function, ret);
+
 	udc-&gt;driver = NULL;
-	udc-&gt;gadget-&gt;dev.driver = NULL;
+	driver-&gt;is_bound = false;
+	mutex_unlock(&amp;udc_lock);
+
 	return ret;
 }
 
-int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+static void gadget_unbind_driver(struct device *dev)
+{
+	struct usb_gadget *gadget = dev_to_usb_gadget(dev);
+	struct usb_udc *udc = gadget-&gt;udc;
+	struct usb_gadget_driver *driver = udc-&gt;driver;
+
+	dev_dbg(&amp;udc-&gt;dev, "unbinding gadget driver [%s]\n", driver-&gt;function);
+
+	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
+
+	mutex_lock(&amp;udc_lock);
+	usb_gadget_disconnect(gadget);
+	usb_gadget_disable_async_callbacks(udc);
+	if (gadget-&gt;irq)
+		synchronize_irq(gadget-&gt;irq);
+	udc-&gt;driver-&gt;unbind(gadget);
+	usb_gadget_udc_stop(udc);
+
+	driver-&gt;is_bound = false;
+	udc-&gt;driver = NULL;
+	mutex_unlock(&amp;udc_lock);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,
+		struct module *owner, const char *mod_name)
 {
-	struct usb_udc		*udc = NULL, *iter;
-	int			ret = -ENODEV;
+	int ret;
 
 	if (!driver || !driver-&gt;bind || !driver-&gt;setup)
 		return -EINVAL;
 
+	driver-&gt;driver.bus = &amp;gadget_bus_type;
+	driver-&gt;driver.owner = owner;
+	driver-&gt;driver.mod_name = mod_name;
+	ret = driver_register(&amp;driver-&gt;driver);
+	if (ret) {
+		pr_warn("%s: driver registration failed: %d\n",
+				driver-&gt;function, ret);
+		return ret;
+	}
+
 	mutex_lock(&amp;udc_lock);
-	if (driver-&gt;udc_name) {
-		list_for_each_entry(iter, &amp;udc_list, list) {
-			ret = strcmp(driver-&gt;udc_name, dev_name(&amp;iter-&gt;dev));
-			if (ret)
-				continue;
-			udc = iter;
-			break;
-		}
-		if (ret)
-			ret = -ENODEV;
-		else if (udc-&gt;driver)
+	if (!driver-&gt;is_bound) {
+		if (driver-&gt;match_existing_only) {
+			pr_warn("%s: couldn't find an available UDC or it's busy\n",
+					driver-&gt;function);
 			ret = -EBUSY;
-		else
-			goto found;
-	} else {
-		list_for_each_entry(iter, &amp;udc_list, list) {
-			/* For now we take the first one */
-			if (iter-&gt;driver)
-				continue;
-			udc = iter;
-			goto found;
+		} else {
+			pr_info("%s: couldn't find an available UDC\n",
+					driver-&gt;function);
 		}
-	}
-
-	if (!driver-&gt;match_existing_only) {
-		list_add_tail(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);
-		pr_info("couldn't find an available UDC - added [%s] to list of pending drivers\n",
-			driver-&gt;function);
 		ret = 0;
 	}
-
 	mutex_unlock(&amp;udc_lock);
+
 	if (ret)
-		pr_warn("couldn't find an available UDC or it's busy: %d\n", ret);
-	return ret;
-found:
-	ret = udc_bind_to_driver(udc, driver);
-	mutex_unlock(&amp;udc_lock);
+		driver_unregister(&amp;driver-&gt;driver);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(usb_gadget_register_driver);
+EXPORT_SYMBOL_GPL(usb_gadget_register_driver_owner);
 
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
-	struct usb_udc		*udc = NULL;
-	int			ret = -ENODEV;
-
 	if (!driver || !driver-&gt;unbind)
 		return -EINVAL;
 
-	mutex_lock(&amp;udc_lock);
-	list_for_each_entry(udc, &amp;udc_list, list) {
-		if (udc-&gt;driver == driver) {
-			usb_gadget_remove_driver(udc);
-			usb_gadget_set_state(udc-&gt;gadget,
-					     USB_STATE_NOTATTACHED);
-
-			/* Maybe there is someone waiting for this UDC? */
-			check_pending_gadget_drivers(udc);
-			/*
-			 * For now we ignore bind errors as probably it's
-			 * not a valid reason to fail other's gadget unbind
-			 */
-			ret = 0;
-			break;
-		}
-	}
-
-	if (ret) {
-		list_del(&amp;driver-&gt;pending);
-		ret = 0;
-	}
-	mutex_unlock(&amp;udc_lock);
-	return ret;
+	driver_unregister(&amp;driver-&gt;driver);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_gadget_unregister_driver);
 
@@ -1754,8 +1728,17 @@ static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static struct bus_type gadget_bus_type = {
+	.name = "gadget",
+	.probe = gadget_bind_driver,
+	.remove = gadget_unbind_driver,
+	.match = gadget_match_driver,
+};
+
 static int __init usb_udc_init(void)
 {
+	int rc;
+
 	udc_class = class_create(THIS_MODULE, "udc");
 	if (IS_ERR(udc_class)) {
 		pr_err("failed to create udc class --&gt; %ld\n",
@@ -1764,12 +1747,17 @@ static int __init usb_udc_init(void)
 	}
 
 	udc_class-&gt;dev_uevent = usb_udc_uevent;
-	return 0;
+
+	rc = bus_register(&amp;gadget_bus_type);
+	if (rc)
+		class_destroy(udc_class);
+	return rc;
 }
 subsys_initcall(usb_udc_init);
 
 static void __exit usb_udc_exit(void)
 {
+	bus_unregister(&amp;gadget_bus_type);
 	class_destroy(udc_class);
 }
 module_exit(usb_udc_exit);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 5830b8a903da..cf7af8a0a6e9 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -664,9 +664,9 @@ static inline int usb_gadget_check_config(struct usb_gadget *gadget)
  * @driver: Driver model state for this driver.
  * @udc_name: A name of UDC this driver should be bound to. If udc_name is NULL,
  *	this driver will be bound to any available UDC.
- * @pending: UDC core private data used for deferred probe of this driver.
- * @match_existing_only: If udc is not found, return an error and don't add this
- *      gadget driver to list of pending driver
+ * @match_existing_only: If udc is not found, return an error and fail
+ *	the driver registration
+ * @is_bound: Allow a driver to be bound to only one gadget
  *
  * Devices are disabled till a gadget driver successfully bind()s, which
  * means the driver will handle setup() requests needed to enumerate (and
@@ -729,8 +729,8 @@ struct usb_gadget_driver {
 	struct device_driver	driver;
 
 	char			*udc_name;
-	struct list_head	pending;
 	unsigned                match_existing_only:1;
+	bool			is_bound:1;
 };
 
 
@@ -740,22 +740,30 @@ struct usb_gadget_driver {
 /* driver modules register and unregister, as usual.
  * these calls must be made in a context that can sleep.
  *
- * these will usually be implemented directly by the hardware-dependent
- * usb bus interface driver, which will only support a single driver.
+ * A gadget driver can be bound to only one gadget at a time.
  */
 
 /**
- * usb_gadget_register_driver - register a gadget driver
+ * usb_gadget_register_driver_owner - register a gadget driver
  * @driver: the driver being registered
+ * @owner: the driver module
+ * @mod_name: the driver module's build name
  * Context: can sleep
  *
  * Call this in your gadget driver's module initialization function,
- * to tell the underlying usb controller driver about your driver.
+ * to tell the underlying UDC controller driver about your driver.
  * The @bind() function will be called to bind it to a gadget before this
  * registration call returns.  It's expected that the @bind() function will
  * be in init sections.
+ *
+ * Use the macro defined below instead of calling this directly.
  */
-int usb_gadget_register_driver(struct usb_gadget_driver *driver);
+int usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,
+		struct module *owner, const char *mod_name);
+
+/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */
+#define usb_gadget_register_driver(driver) \
+	usb_gadget_register_driver_owner(driver, THIS_MODULE, KBUILD_MODNAME)
 
 /**
  * usb_gadget_unregister_driver - unregister a gadget driver</pre><hr><pre>commit d59f6d958596b54b722605657c3b56a79843695a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:34:34 2022 -0400

    USB: gadget: Fix mistakes in UDC core kerneldoc
    
    This patch fixes some minor mistakes in the UDC core's kerneldoc.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSpKpnWR8WWEk/p@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 014daa07eb8c..a878e7afacdd 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1262,9 +1262,6 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
  * device.
  * @gadget: the gadget to be initialized.
  * @release: a gadget release function.
- *
- * Returns zero on success, negative errno otherwise.
- * Calls the gadget release function in the latter case.
  */
 void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
@@ -1441,11 +1438,10 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 }
 
 /**
- * usb_del_gadget - deletes @udc from udc_list
- * @gadget: the gadget to be removed.
+ * usb_del_gadget - deletes a gadget and unregisters its udc
+ * @gadget: the gadget to be deleted.
  *
- * This will call usb_gadget_unregister_driver() if
- * the @udc is still busy.
+ * This will unbind @gadget, if it is bound.
  * It will not do a final usb_put_gadget().
  */
 void usb_del_gadget(struct usb_gadget *gadget)
@@ -1476,8 +1472,8 @@ void usb_del_gadget(struct usb_gadget *gadget)
 EXPORT_SYMBOL_GPL(usb_del_gadget);
 
 /**
- * usb_del_gadget_udc - deletes @udc from udc_list
- * @gadget: the gadget to be removed.
+ * usb_del_gadget_udc - unregisters a gadget
+ * @gadget: the gadget to be unregistered.
  *
  * Calls usb_del_gadget() and does a final usb_put_gadget().
  */</pre><hr><pre>commit 6ebb449f9f25e0da804d1247b4ffcc361321494d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 21:33:29 2022 -0400

    USB: gadget: Register udc before gadget
    
    In preparation for adding a "gadget" bus, this patch reverses the
    order of registration of udc and gadget devices in usb_add_gadget().
    
    The current code adds the gadget device first, probably because that
    was more convenient at the time and the order didn't really matter.
    But with the upcoming change, adding the gadget will cause driver
    probing to occur.  Unwinding that on the error pathway will become
    much more obtrusive, not to mention the fact that a gadget driver
    might not work properly before the udc is registered.  It's better to
    register the udc device first, particularly since that doesn't involve
    a bus or driver binding and therefore is simpler to unwind.
    
    For symmetry, the order of unregistration in usb_del_gadget() is
    likewise reversed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSo6fU1FlNq8cOZ@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index f0cce482b74a..014daa07eb8c 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1308,10 +1308,6 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	if (ret)
 		goto err_put_udc;
 
-	ret = device_add(&amp;gadget-&gt;dev);
-	if (ret)
-		goto err_put_udc;
-
 	udc-&gt;gadget = gadget;
 	gadget-&gt;udc = udc;
 
@@ -1327,15 +1323,22 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 	udc-&gt;vbus = true;
 
+	ret = device_add(&amp;gadget-&gt;dev);
+	if (ret)
+		goto err_del_udc;
+
 	/* pick up one of pending gadget drivers */
 	ret = check_pending_gadget_drivers(udc);
 	if (ret)
-		goto err_del_udc;
+		goto err_del_gadget;
 
 	mutex_unlock(&amp;udc_lock);
 
 	return 0;
 
+ err_del_gadget:
+	device_del(&amp;gadget-&gt;dev);
+
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
@@ -1344,8 +1347,6 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	list_del(&amp;udc-&gt;list);
 	mutex_unlock(&amp;udc_lock);
 
-	device_del(&amp;gadget-&gt;dev);
-
  err_put_udc:
 	put_device(&amp;udc-&gt;dev);
 
@@ -1469,8 +1470,8 @@ void usb_del_gadget(struct usb_gadget *gadget)
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
-	device_unregister(&amp;udc-&gt;dev);
 	device_del(&amp;gadget-&gt;dev);
+	device_unregister(&amp;udc-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget);
 </pre><hr><pre>commit af1969a2d734d6272c0640b50c3ed31e59e203a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 23 20:42:03 2022 -0400

    USB: gadget: Rename usb_gadget_probe_driver()
    
    In preparation for adding a "gadget" bus, this patch renames
    usb_gadget_probe_driver() to usb_gadget_register_driver().  The new
    name will be more accurate, since gadget drivers will be registered on
    the gadget bus and the probing will be done by the driver core, not
    the UDC core.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YmSc29YZvxgT5fEJ@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 2eaeaae96759..403563c06477 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -2505,7 +2505,7 @@ int usb_composite_probe(struct usb_composite_driver *driver)
 	gadget_driver-&gt;driver.name = driver-&gt;name;
 	gadget_driver-&gt;max_speed = driver-&gt;max_speed;
 
-	return usb_gadget_probe_driver(gadget_driver);
+	return usb_gadget_register_driver(gadget_driver);
 }
 EXPORT_SYMBOL_GPL(usb_composite_probe);
 
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index 1fb837d9271e..4141206bb0ed 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -284,7 +284,7 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 			goto err;
 		}
 		gi-&gt;composite.gadget_driver.udc_name = name;
-		ret = usb_gadget_probe_driver(&amp;gi-&gt;composite.gadget_driver);
+		ret = usb_gadget_register_driver(&amp;gi-&gt;composite.gadget_driver);
 		if (ret) {
 			gi-&gt;composite.gadget_driver.udc_name = NULL;
 			goto err;
diff --git a/drivers/usb/gadget/legacy/dbgp.c b/drivers/usb/gadget/legacy/dbgp.c
index 6bcbad382580..b62e45235e8e 100644
--- a/drivers/usb/gadget/legacy/dbgp.c
+++ b/drivers/usb/gadget/legacy/dbgp.c
@@ -422,7 +422,7 @@ static struct usb_gadget_driver dbgp_driver = {
 
 static int __init dbgp_init(void)
 {
-	return usb_gadget_probe_driver(&amp;dbgp_driver);
+	return usb_gadget_register_driver(&amp;dbgp_driver);
 }
 
 static void __exit dbgp_exit(void)
diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 0c01e749f9ea..79990597c39f 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1873,7 +1873,7 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	else
 		gadgetfs_driver.max_speed = USB_SPEED_FULL;
 
-	value = usb_gadget_probe_driver(&amp;gadgetfs_driver);
+	value = usb_gadget_register_driver(&amp;gadgetfs_driver);
 	if (value != 0) {
 		spin_lock_irq(&amp;dev-&gt;lock);
 		goto fail;
diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 8d40a1f2ec57..b3be8db1ff63 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -510,12 +510,12 @@ static int raw_ioctl_run(struct raw_dev *dev, unsigned long value)
 	}
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
-	ret = usb_gadget_probe_driver(&amp;dev-&gt;driver);
+	ret = usb_gadget_register_driver(&amp;dev-&gt;driver);
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	if (ret) {
 		dev_err(dev-&gt;dev,
-			"fail, usb_gadget_probe_driver returned %d\n", ret);
+			"fail, usb_gadget_register_driver returned %d\n", ret);
 		dev-&gt;state = STATE_DEV_FAILED;
 		goto out_unlock;
 	}
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 85b194011a16..f0cce482b74a 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1523,7 +1523,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 	return ret;
 }
 
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	struct usb_udc		*udc = NULL, *iter;
 	int			ret = -ENODEV;
@@ -1572,7 +1572,7 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
 	mutex_unlock(&amp;udc_lock);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(usb_gadget_probe_driver);
+EXPORT_SYMBOL_GPL(usb_gadget_register_driver);
 
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 10fe57cf40be..5830b8a903da 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -745,7 +745,7 @@ struct usb_gadget_driver {
  */
 
 /**
- * usb_gadget_probe_driver - probe a gadget driver
+ * usb_gadget_register_driver - register a gadget driver
  * @driver: the driver being registered
  * Context: can sleep
  *
@@ -755,7 +755,7 @@ struct usb_gadget_driver {
  * registration call returns.  It's expected that the @bind() function will
  * be in init sections.
  */
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver);
+int usb_gadget_register_driver(struct usb_gadget_driver *driver);
 
 /**
  * usb_gadget_unregister_driver - unregister a gadget driver</pre><hr><pre>commit 1892bf90677abcad7f06e897e308f5c3e3618dd4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 17 16:39:10 2022 -0400

    USB: usb-storage: Fix use of bitfields for hardware data in ene_ub6250.c
    
    The kernel test robot found a problem with the ene_ub6250 subdriver in
    usb-storage: It uses structures containing bitfields to represent
    hardware bits in its SD_STATUS, MS_STATUS, and SM_STATUS bytes.  This
    is not safe; it presumes a particular bit ordering and it assumes the
    compiler will not insert padding, neither of which is guaranteed.
    
    This patch fixes the problem by changing the structures to simple u8
    values, with the bitfields replaced by bitmask constants.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YjOcbuU106UpJ/V8@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 5f7d678502be..6012603f3630 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -237,36 +237,33 @@ static struct us_unusual_dev ene_ub6250_unusual_dev_list[] = {
 #define memstick_logaddr(logadr1, logadr0) ((((u16)(logadr1)) &lt;&lt; 8) | (logadr0))
 
 
-struct SD_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    IsMMC:1;
-	u8    HiCapacity:1;
-	u8    HiSpeed:1;
-	u8    WtP:1;
-	u8    Reserved:1;
-};
-
-struct MS_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    IsMSPro:1;
-	u8    IsMSPHG:1;
-	u8    Reserved1:1;
-	u8    WtP:1;
-	u8    Reserved2:1;
-};
-
-struct SM_STATUS {
-	u8    Insert:1;
-	u8    Ready:1;
-	u8    MediaChange:1;
-	u8    Reserved:3;
-	u8    WtP:1;
-	u8    IsMS:1;
-};
+/* SD_STATUS bits */
+#define SD_Insert	BIT(0)
+#define SD_Ready	BIT(1)
+#define SD_MediaChange	BIT(2)
+#define SD_IsMMC	BIT(3)
+#define SD_HiCapacity	BIT(4)
+#define SD_HiSpeed	BIT(5)
+#define SD_WtP		BIT(6)
+			/* Bit 7 reserved */
+
+/* MS_STATUS bits */
+#define MS_Insert	BIT(0)
+#define MS_Ready	BIT(1)
+#define MS_MediaChange	BIT(2)
+#define MS_IsMSPro	BIT(3)
+#define MS_IsMSPHG	BIT(4)
+			/* Bit 5 reserved */
+#define MS_WtP		BIT(6)
+			/* Bit 7 reserved */
+
+/* SM_STATUS bits */
+#define SM_Insert	BIT(0)
+#define SM_Ready	BIT(1)
+#define SM_MediaChange	BIT(2)
+			/* Bits 3-5 reserved */
+#define SM_WtP		BIT(6)
+#define SM_IsMS		BIT(7)
 
 struct ms_bootblock_cis {
 	u8 bCistplDEVICE[6];    /* 0 */
@@ -437,9 +434,9 @@ struct ene_ub6250_info {
 	u8		*bbuf;
 
 	/* for 6250 code */
-	struct SD_STATUS	SD_Status;
-	struct MS_STATUS	MS_Status;
-	struct SM_STATUS	SM_Status;
+	u8		SD_Status;
+	u8		MS_Status;
+	u8		SM_Status;
 
 	/* ----- SD Control Data ---------------- */
 	/*SD_REGISTER SD_Regs; */
@@ -602,7 +599,7 @@ static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 
-	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready)
+	if ((info-&gt;SD_Status &amp; SD_Insert) &amp;&amp; (info-&gt;SD_Status &amp; SD_Ready))
 		return USB_STOR_TRANSPORT_GOOD;
 	else {
 		ene_sd_init(us);
@@ -622,7 +619,7 @@ static int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 		0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,
 		0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };
 
-	if (info-&gt;SD_Status.WtP)
+	if (info-&gt;SD_Status &amp; SD_WtP)
 		usb_stor_set_xfer_buf(mediaWP, 12, srb);
 	else
 		usb_stor_set_xfer_buf(mediaNoWP, 12, srb);
@@ -641,9 +638,9 @@ static int sd_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 
 	usb_stor_dbg(us, "sd_scsi_read_capacity\n");
-	if (info-&gt;SD_Status.HiCapacity) {
+	if (info-&gt;SD_Status &amp; SD_HiCapacity) {
 		bl_len = 0x200;
-		if (info-&gt;SD_Status.IsMMC)
+		if (info-&gt;SD_Status &amp; SD_IsMMC)
 			bl_num = info-&gt;HC_C_SIZE-1;
 		else
 			bl_num = (info-&gt;HC_C_SIZE + 1) * 1024 - 1;
@@ -693,7 +690,7 @@ static int sd_scsi_read(struct us_data *us, struct scsi_cmnd *srb)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	if (info-&gt;SD_Status.HiCapacity)
+	if (info-&gt;SD_Status &amp; SD_HiCapacity)
 		bnByte = bn;
 
 	/* set up the command wrapper */
@@ -733,7 +730,7 @@ static int sd_scsi_write(struct us_data *us, struct scsi_cmnd *srb)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	if (info-&gt;SD_Status.HiCapacity)
+	if (info-&gt;SD_Status &amp; SD_HiCapacity)
 		bnByte = bn;
 
 	/* set up the command wrapper */
@@ -1456,7 +1453,7 @@ static int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
 	/* pr_info("MS_SCSI_Test_Unit_Ready\n"); */
-	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
+	if ((info-&gt;MS_Status &amp; MS_Insert) &amp;&amp; (info-&gt;MS_Status &amp; MS_Ready)) {
 		return USB_STOR_TRANSPORT_GOOD;
 	} else {
 		ene_ms_init(us);
@@ -1476,7 +1473,7 @@ static int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 		0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,
 		0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };
 
-	if (info-&gt;MS_Status.WtP)
+	if (info-&gt;MS_Status &amp; MS_WtP)
 		usb_stor_set_xfer_buf(mediaWP, 12, srb);
 	else
 		usb_stor_set_xfer_buf(mediaNoWP, 12, srb);
@@ -1495,7 +1492,7 @@ static int ms_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)
 
 	usb_stor_dbg(us, "ms_scsi_read_capacity\n");
 	bl_len = 0x200;
-	if (info-&gt;MS_Status.IsMSPro)
+	if (info-&gt;MS_Status &amp; MS_IsMSPro)
 		bl_num = info-&gt;MSP_TotalBlock - 1;
 	else
 		bl_num = info-&gt;MS_Lib.NumberOfLogBlock * info-&gt;MS_Lib.blockSize * 2 - 1;
@@ -1650,7 +1647,7 @@ static int ms_scsi_read(struct us_data *us, struct scsi_cmnd *srb)
 	if (bn &gt; info-&gt;bl_num)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	if (info-&gt;MS_Status.IsMSPro) {
+	if (info-&gt;MS_Status &amp; MS_IsMSPro) {
 		result = ene_load_bincode(us, MSP_RW_PATTERN);
 		if (result != USB_STOR_XFER_GOOD) {
 			usb_stor_dbg(us, "Load MPS RW pattern Fail !!\n");
@@ -1751,7 +1748,7 @@ static int ms_scsi_write(struct us_data *us, struct scsi_cmnd *srb)
 	if (bn &gt; info-&gt;bl_num)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	if (info-&gt;MS_Status.IsMSPro) {
+	if (info-&gt;MS_Status &amp; MS_IsMSPro) {
 		result = ene_load_bincode(us, MSP_RW_PATTERN);
 		if (result != USB_STOR_XFER_GOOD) {
 			pr_info("Load MSP RW pattern Fail !!\n");
@@ -1859,12 +1856,12 @@ static int ene_get_card_status(struct us_data *us, u8 *buf)
 
 	tmpreg = (u16) reg4b;
 	reg4b = *(u32 *)(&amp;buf[0x14]);
-	if (info-&gt;SD_Status.HiCapacity &amp;&amp; !info-&gt;SD_Status.IsMMC)
+	if ((info-&gt;SD_Status &amp; SD_HiCapacity) &amp;&amp; !(info-&gt;SD_Status &amp; SD_IsMMC))
 		info-&gt;HC_C_SIZE = (reg4b &gt;&gt; 8) &amp; 0x3fffff;
 
 	info-&gt;SD_C_SIZE = ((tmpreg &amp; 0x03) &lt;&lt; 10) | (u16)(reg4b &gt;&gt; 22);
 	info-&gt;SD_C_SIZE_MULT = (u8)(reg4b &gt;&gt; 7)  &amp; 0x07;
-	if (info-&gt;SD_Status.HiCapacity &amp;&amp; info-&gt;SD_Status.IsMMC)
+	if ((info-&gt;SD_Status &amp; SD_HiCapacity) &amp;&amp; (info-&gt;SD_Status &amp; SD_IsMMC))
 		info-&gt;HC_C_SIZE = *(u32 *)(&amp;buf[0x100]);
 
 	if (info-&gt;SD_READ_BL_LEN &gt; SD_BLOCK_LEN) {
@@ -2076,6 +2073,7 @@ static int ene_ms_init(struct us_data *us)
 	u16 MSP_BlockSize, MSP_UserAreaBlocks;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
 	u8 *bbuf = info-&gt;bbuf;
+	unsigned int s;
 
 	printk(KERN_INFO "transport --- ENE_MSInit\n");
 
@@ -2100,15 +2098,16 @@ static int ene_ms_init(struct us_data *us)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	/* the same part to test ENE */
-	info-&gt;MS_Status = *(struct MS_STATUS *) bbuf;
-
-	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
-		printk(KERN_INFO "Insert     = %x\n", info-&gt;MS_Status.Insert);
-		printk(KERN_INFO "Ready      = %x\n", info-&gt;MS_Status.Ready);
-		printk(KERN_INFO "IsMSPro    = %x\n", info-&gt;MS_Status.IsMSPro);
-		printk(KERN_INFO "IsMSPHG    = %x\n", info-&gt;MS_Status.IsMSPHG);
-		printk(KERN_INFO "WtP= %x\n", info-&gt;MS_Status.WtP);
-		if (info-&gt;MS_Status.IsMSPro) {
+	info-&gt;MS_Status = bbuf[0];
+
+	s = info-&gt;MS_Status;
+	if ((s &amp; MS_Insert) &amp;&amp; (s &amp; MS_Ready)) {
+		printk(KERN_INFO "Insert     = %x\n", !!(s &amp; MS_Insert));
+		printk(KERN_INFO "Ready      = %x\n", !!(s &amp; MS_Ready));
+		printk(KERN_INFO "IsMSPro    = %x\n", !!(s &amp; MS_IsMSPro));
+		printk(KERN_INFO "IsMSPHG    = %x\n", !!(s &amp; MS_IsMSPHG));
+		printk(KERN_INFO "WtP= %x\n", !!(s &amp; MS_WtP));
+		if (s &amp; MS_IsMSPro) {
 			MSP_BlockSize      = (bbuf[6] &lt;&lt; 8) | bbuf[7];
 			MSP_UserAreaBlocks = (bbuf[10] &lt;&lt; 8) | bbuf[11];
 			info-&gt;MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;
@@ -2169,17 +2168,17 @@ static int ene_sd_init(struct us_data *us)
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	info-&gt;SD_Status =  *(struct SD_STATUS *) bbuf;
-	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready) {
-		struct SD_STATUS *s = &amp;info-&gt;SD_Status;
+	info-&gt;SD_Status = bbuf[0];
+	if ((info-&gt;SD_Status &amp; SD_Insert) &amp;&amp; (info-&gt;SD_Status &amp; SD_Ready)) {
+		unsigned int s = info-&gt;SD_Status;
 
 		ene_get_card_status(us, bbuf);
-		usb_stor_dbg(us, "Insert     = %x\n", s-&gt;Insert);
-		usb_stor_dbg(us, "Ready      = %x\n", s-&gt;Ready);
-		usb_stor_dbg(us, "IsMMC      = %x\n", s-&gt;IsMMC);
-		usb_stor_dbg(us, "HiCapacity = %x\n", s-&gt;HiCapacity);
-		usb_stor_dbg(us, "HiSpeed    = %x\n", s-&gt;HiSpeed);
-		usb_stor_dbg(us, "WtP        = %x\n", s-&gt;WtP);
+		usb_stor_dbg(us, "Insert     = %x\n", !!(s &amp; SD_Insert));
+		usb_stor_dbg(us, "Ready      = %x\n", !!(s &amp; SD_Ready));
+		usb_stor_dbg(us, "IsMMC      = %x\n", !!(s &amp; SD_IsMMC));
+		usb_stor_dbg(us, "HiCapacity = %x\n", !!(s &amp; SD_HiCapacity));
+		usb_stor_dbg(us, "HiSpeed    = %x\n", !!(s &amp; SD_HiSpeed));
+		usb_stor_dbg(us, "WtP        = %x\n", !!(s &amp; SD_WtP));
 	} else {
 		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
@@ -2201,14 +2200,14 @@ static int ene_init(struct us_data *us)
 
 	misc_reg03 = bbuf[0];
 	if (misc_reg03 &amp; 0x01) {
-		if (!info-&gt;SD_Status.Ready) {
+		if (!(info-&gt;SD_Status &amp; SD_Ready)) {
 			result = ene_sd_init(us);
 			if (result != USB_STOR_XFER_GOOD)
 				return USB_STOR_TRANSPORT_ERROR;
 		}
 	}
 	if (misc_reg03 &amp; 0x02) {
-		if (!info-&gt;MS_Status.Ready) {
+		if (!(info-&gt;MS_Status &amp; MS_Ready)) {
 			result = ene_ms_init(us);
 			if (result != USB_STOR_XFER_GOOD)
 				return USB_STOR_TRANSPORT_ERROR;
@@ -2307,14 +2306,14 @@ static int ene_transport(struct scsi_cmnd *srb, struct us_data *us)
 
 	/*US_DEBUG(usb_stor_show_command(us, srb)); */
 	scsi_set_resid(srb, 0);
-	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready)))
+	if (unlikely(!(info-&gt;SD_Status &amp; SD_Ready) || (info-&gt;MS_Status &amp; MS_Ready)))
 		result = ene_init(us);
 	if (result == USB_STOR_XFER_GOOD) {
 		result = USB_STOR_TRANSPORT_ERROR;
-		if (info-&gt;SD_Status.Ready)
+		if (info-&gt;SD_Status &amp; SD_Ready)
 			result = sd_scsi_irp(us, srb);
 
-		if (info-&gt;MS_Status.Ready)
+		if (info-&gt;MS_Status &amp; MS_Ready)
 			result = ms_scsi_irp(us, srb);
 	}
 	return result;
@@ -2378,7 +2377,6 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 
 static int ene_ub6250_resume(struct usb_interface *iface)
 {
-	u8 tmp = 0;
 	struct us_data *us = usb_get_intfdata(iface);
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
@@ -2390,17 +2388,16 @@ static int ene_ub6250_resume(struct usb_interface *iface)
 	mutex_unlock(&amp;us-&gt;dev_mutex);
 
 	info-&gt;Power_IsResum = true;
-	/*info-&gt;SD_Status.Ready = 0; */
-	info-&gt;SD_Status = *(struct SD_STATUS *)&amp;tmp;
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;tmp;
-	info-&gt;SM_Status = *(struct SM_STATUS *)&amp;tmp;
+	/* info-&gt;SD_Status &amp;= ~SD_Ready; */
+	info-&gt;SD_Status = 0;
+	info-&gt;MS_Status = 0;
+	info-&gt;SM_Status = 0;
 
 	return 0;
 }
 
 static int ene_ub6250_reset_resume(struct usb_interface *iface)
 {
-	u8 tmp = 0;
 	struct us_data *us = usb_get_intfdata(iface);
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
@@ -2412,10 +2409,10 @@ static int ene_ub6250_reset_resume(struct usb_interface *iface)
 	 * the device
 	 */
 	info-&gt;Power_IsResum = true;
-	/*info-&gt;SD_Status.Ready = 0; */
-	info-&gt;SD_Status = *(struct SD_STATUS *)&amp;tmp;
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;tmp;
-	info-&gt;SM_Status = *(struct SM_STATUS *)&amp;tmp;
+	/* info-&gt;SD_Status &amp;= ~SD_Ready; */
+	info-&gt;SD_Status = 0;
+	info-&gt;MS_Status = 0;
+	info-&gt;SM_Status = 0;
 
 	return 0;
 }</pre><hr><pre>commit 16b1941eac2bd499f065a6739a40ce0011a3d740
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Mar 5 21:47:22 2022 -0500

    usb: gadget: Fix use-after-free bug by not setting udc-&gt;dev.driver
    
    The syzbot fuzzer found a use-after-free bug:
    
    BUG: KASAN: use-after-free in dev_uevent+0x712/0x780 drivers/base/core.c:2320
    Read of size 8 at addr ffff88802b934098 by task udevd/3689
    
    CPU: 2 PID: 3689 Comm: udevd Not tainted 5.17.0-rc4-syzkaller-00229-g4f12b742eb2b #0
    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     print_address_description.constprop.0.cold+0x8d/0x303 mm/kasan/report.c:255
     __kasan_report mm/kasan/report.c:442 [inline]
     kasan_report.cold+0x83/0xdf mm/kasan/report.c:459
     dev_uevent+0x712/0x780 drivers/base/core.c:2320
     uevent_show+0x1b8/0x380 drivers/base/core.c:2391
     dev_attr_show+0x4b/0x90 drivers/base/core.c:2094
    
    Although the bug manifested in the driver core, the real cause was a
    race with the gadget core.  dev_uevent() does:
    
            if (dev-&gt;driver)
                    add_uevent_var(env, "DRIVER=%s", dev-&gt;driver-&gt;name);
    
    and between the test and the dereference of dev-&gt;driver, the gadget
    core sets dev-&gt;driver to NULL.
    
    The race wouldn't occur if the gadget core registered its devices on
    a real bus, using the standard synchronization techniques of the
    driver core.  However, it's not necessary to make such a large change
    in order to fix this bug; all we need to do is make sure that
    udc-&gt;dev.driver is always NULL.
    
    In fact, there is no reason for udc-&gt;dev.driver ever to be set to
    anything, let alone to the value it currently gets: the address of the
    gadget's driver.  After all, a gadget driver only knows how to manage
    a gadget, not how to manage a UDC.
    
    This patch simply removes the statements in the gadget core that touch
    udc-&gt;dev.driver.
    
    Fixes: 2ccea03a8f7e ("usb: gadget: introduce UDC Class")
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+348b571beb5eeb70a582@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YiQgukfFFbBnwJ/9@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 568534a0d17c..c109b069f511 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1436,7 +1436,6 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	usb_gadget_udc_stop(udc);
 
 	udc-&gt;driver = NULL;
-	udc-&gt;dev.driver = NULL;
 	udc-&gt;gadget-&gt;dev.driver = NULL;
 }
 
@@ -1498,7 +1497,6 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 			driver-&gt;function);
 
 	udc-&gt;driver = driver;
-	udc-&gt;dev.driver = &amp;driver-&gt;driver;
 	udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
@@ -1521,7 +1519,6 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
 			udc-&gt;driver-&gt;function, ret);
 	udc-&gt;driver = NULL;
-	udc-&gt;dev.driver = NULL;
 	udc-&gt;gadget-&gt;dev.driver = NULL;
 	return ret;
 }</pre><hr><pre>commit e9b667a82cdcfe21d590344447d65daed52b353b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 3 16:00:17 2022 -0500

    usb: usbtmc: Fix bug in pipe direction for control transfers
    
    The syzbot fuzzer reported a minor bug in the usbtmc driver:
    
    usb 5-1: BOGUS control dir, pipe 80001e80 doesn't match bRequestType 0
    WARNING: CPU: 0 PID: 3813 at drivers/usb/core/urb.c:412
    usb_submit_urb+0x13a5/0x1970 drivers/usb/core/urb.c:410
    Modules linked in:
    CPU: 0 PID: 3813 Comm: syz-executor122 Not tainted
    5.17.0-rc5-syzkaller-00306-g2293be58d6a1 #0
    ...
    Call Trace:
     &lt;TASK&gt;
     usb_start_wait_urb+0x113/0x530 drivers/usb/core/message.c:58
     usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
     usb_control_msg+0x2a5/0x4b0 drivers/usb/core/message.c:153
     usbtmc_ioctl_request drivers/usb/class/usbtmc.c:1947 [inline]
    
    The problem is that usbtmc_ioctl_request() uses usb_rcvctrlpipe() for
    all of its transfers, whether they are in or out.  It's easy to fix.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+a48e3d1a875240cab5de@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YiEsYTPEE6lOCOA5@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c
index 73f419adce61..4bb6d304eb4b 100644
--- a/drivers/usb/class/usbtmc.c
+++ b/drivers/usb/class/usbtmc.c
@@ -1919,6 +1919,7 @@ static int usbtmc_ioctl_request(struct usbtmc_device_data *data,
 	struct usbtmc_ctrlrequest request;
 	u8 *buffer = NULL;
 	int rv;
+	unsigned int is_in, pipe;
 	unsigned long res;
 
 	res = copy_from_user(&amp;request, arg, sizeof(struct usbtmc_ctrlrequest));
@@ -1928,12 +1929,14 @@ static int usbtmc_ioctl_request(struct usbtmc_device_data *data,
 	if (request.req.wLength &gt; USBTMC_BUFSIZE)
 		return -EMSGSIZE;
 
+	is_in = request.req.bRequestType &amp; USB_DIR_IN;
+
 	if (request.req.wLength) {
 		buffer = kmalloc(request.req.wLength, GFP_KERNEL);
 		if (!buffer)
 			return -ENOMEM;
 
-		if ((request.req.bRequestType &amp; USB_DIR_IN) == 0) {
+		if (!is_in) {
 			/* Send control data to device */
 			res = copy_from_user(buffer, request.data,
 					     request.req.wLength);
@@ -1944,8 +1947,12 @@ static int usbtmc_ioctl_request(struct usbtmc_device_data *data,
 		}
 	}
 
+	if (is_in)
+		pipe = usb_rcvctrlpipe(data-&gt;usb_dev, 0);
+	else
+		pipe = usb_sndctrlpipe(data-&gt;usb_dev, 0);
 	rv = usb_control_msg(data-&gt;usb_dev,
-			usb_rcvctrlpipe(data-&gt;usb_dev, 0),
+			pipe,
 			request.req.bRequest,
 			request.req.bRequestType,
 			request.req.wValue,
@@ -1957,7 +1964,7 @@ static int usbtmc_ioctl_request(struct usbtmc_device_data *data,
 		goto exit;
 	}
 
-	if (rv &amp;&amp; (request.req.bRequestType &amp; USB_DIR_IN)) {
+	if (rv &amp;&amp; is_in) {
 		/* Read control data from device */
 		res = copy_to_user(request.data, buffer, rv);
 		if (res)</pre><hr><pre>commit f6a9a2d64dd168b7d71076c0e6b2be7db7cb7399
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 25 09:38:25 2022 -0500

    USB: core: Update kerneldoc for usb_get_dev() and usb_get_intf()
    
    The kerneldoc for usb_get_dev() and usb_get_intf() says that drivers
    should always refcount the references they hold for the usb_device or
    usb_interface structure, respectively.  But this is an overstatement:
    In many cases drivers do not access these references after they have
    been unbound, and in such cases refcounting is unnecessary.
    
    This patch updates the kerneldoc for the two routines, explaining when
    a driver does not need to increment and decrement the refcount.  This
    should help dispel misconceptions which might otherwise afflict
    programmers new to the USB subsystem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/Yhjp4Rp9Alipmwtq@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 2ce3667ec6fa..2f71636af6e1 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -688,6 +688,10 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
  * Drivers for USB interfaces should normally record such references in
  * their probe() methods, when they bind to an interface, and release
  * them by calling usb_put_dev(), in their disconnect() methods.
+ * However, if a driver does not access the usb_device structure after
+ * its disconnect() method returns then refcounting is not necessary,
+ * because the USB core guarantees that a usb_device will not be
+ * deallocated until after all of its interface drivers have been unbound.
  *
  * Return: A pointer to the device with the incremented reference counter.
  */
@@ -722,6 +726,10 @@ EXPORT_SYMBOL_GPL(usb_put_dev);
  * Drivers for USB interfaces should normally record such references in
  * their probe() methods, when they bind to an interface, and release
  * them by calling usb_put_intf(), in their disconnect() methods.
+ * However, if a driver does not access the usb_interface structure after
+ * its disconnect() method returns then refcounting is not necessary,
+ * because the USB core guarantees that a usb_interface will not be
+ * deallocated until after its driver has been unbound.
  *
  * Return: A pointer to the interface with the incremented reference counter.
  */</pre><hr><pre>commit e2b665f612ca2ddc61c3d54817a3a780aee6b251
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 1 14:00:08 2022 -0500

    tools/memory-model: Explain syntactic and semantic dependencies
    
    Paul Heidekrger pointed out that the Linux Kernel Memory Model
    documentation doesn't mention the distinction between syntactic and
    semantic dependencies.  This is an important difference, because the
    compiler can easily break dependencies that are only syntactic, not
    semantic.
    
    This patch adds a few paragraphs to the LKMM documentation explaining
    these issues and illustrating how they can matter.
    
    Suggested-by: Paul Heidekrger &lt;paul.heidekrueger@in.tum.de&gt;
    Reviewed-by: Akira Yokosawa &lt;akiyks@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 394ee57d58f2..ee819a402b69 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -485,6 +485,57 @@ have R -&gt;po X.  It wouldn't make sense for a computation to depend
 somehow on a value that doesn't get loaded from shared memory until
 later in the code!
 
+Here's a trick question: When is a dependency not a dependency?  Answer:
+When it is purely syntactic rather than semantic.  We say a dependency
+between two accesses is purely syntactic if the second access doesn't
+actually depend on the result of the first.  Here is a trivial example:
+
+	r1 = READ_ONCE(x);
+	WRITE_ONCE(y, r1 * 0);
+
+There appears to be a data dependency from the load of x to the store
+of y, since the value to be stored is computed from the value that was
+loaded.  But in fact, the value stored does not really depend on
+anything since it will always be 0.  Thus the data dependency is only
+syntactic (it appears to exist in the code) but not semantic (the
+second access will always be the same, regardless of the value of the
+first access).  Given code like this, a compiler could simply discard
+the value returned by the load from x, which would certainly destroy
+any dependency.  (The compiler is not permitted to eliminate entirely
+the load generated for a READ_ONCE() -- that's one of the nice
+properties of READ_ONCE() -- but it is allowed to ignore the load's
+value.)
+
+It's natural to object that no one in their right mind would write
+code like the above.  However, macro expansions can easily give rise
+to this sort of thing, in ways that often are not apparent to the
+programmer.
+
+Another mechanism that can lead to purely syntactic dependencies is
+related to the notion of "undefined behavior".  Certain program
+behaviors are called "undefined" in the C language specification,
+which means that when they occur there are no guarantees at all about
+the outcome.  Consider the following example:
+
+	int a[1];
+	int i;
+
+	r1 = READ_ONCE(i);
+	r2 = READ_ONCE(a[r1]);
+
+Access beyond the end or before the beginning of an array is one kind
+of undefined behavior.  Therefore the compiler doesn't have to worry
+about what will happen if r1 is nonzero, and it can assume that r1
+will always be zero regardless of the value actually loaded from i.
+(If the assumption turns out to be wrong the resulting behavior will
+be undefined anyway, so the compiler doesn't care!)  Thus the value
+from the load can be discarded, breaking the address dependency.
+
+The LKMM is unaware that purely syntactic dependencies are different
+from semantic dependencies and therefore mistakenly predicts that the
+accesses in the two examples above will be ordered.  This is another
+example of how the compiler can undermine the memory model.  Be warned.
+
 
 THE READS-FROM RELATION: rf, rfi, and rfe
 -----------------------------------------</pre><hr><pre>commit 26fbe9772b8c459687930511444ce443011f86bf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 24 15:23:45 2022 -0500

    USB: core: Fix hang in usb_kill_urb by adding memory barriers
    
    The syzbot fuzzer has identified a bug in which processes hang waiting
    for usb_kill_urb() to return.  It turns out the issue is not unlinking
    the URB; that works just fine.  Rather, the problem arises when the
    wakeup notification that the URB has completed is not received.
    
    The reason is memory-access ordering on SMP systems.  In outline form,
    usb_kill_urb() and __usb_hcd_giveback_urb() operating concurrently on
    different CPUs perform the following actions:
    
    CPU 0                                   CPU 1
    ----------------------------            ---------------------------------
    usb_kill_urb():                         __usb_hcd_giveback_urb():
      ...                                     ...
      atomic_inc(&amp;urb-&gt;reject);               atomic_dec(&amp;urb-&gt;use_count);
      ...                                     ...
      wait_event(usb_kill_urb_queue,
            atomic_read(&amp;urb-&gt;use_count) == 0);
                                              if (atomic_read(&amp;urb-&gt;reject))
                                                    wake_up(&amp;usb_kill_urb_queue);
    
    Confining your attention to urb-&gt;reject and urb-&gt;use_count, you can
    see that the overall pattern of accesses on CPU 0 is:
    
            write urb-&gt;reject, then read urb-&gt;use_count;
    
    whereas the overall pattern of accesses on CPU 1 is:
    
            write urb-&gt;use_count, then read urb-&gt;reject.
    
    This pattern is referred to in memory-model circles as SB (for "Store
    Buffering"), and it is well known that without suitable enforcement of
    the desired order of accesses -- in the form of memory barriers -- it
    is entirely possible for one or both CPUs to execute their reads ahead
    of their writes.  The end result will be that sometimes CPU 0 sees the
    old un-decremented value of urb-&gt;use_count while CPU 1 sees the old
    un-incremented value of urb-&gt;reject.  Consequently CPU 0 ends up on
    the wait queue and never gets woken up, leading to the observed hang
    in usb_kill_urb().
    
    The same pattern of accesses occurs in usb_poison_urb() and the
    failure pathway of usb_hcd_submit_urb().
    
    The problem is fixed by adding suitable memory barriers.  To provide
    proper memory-access ordering in the SB pattern, a full barrier is
    required on both CPUs.  The atomic_inc() and atomic_dec() accesses
    themselves don't provide any memory ordering, but since they are
    present, we can use the optimized smp_mb__after_atomic() memory
    barrier in the various routines to obtain the desired effect.
    
    This patch adds the necessary memory barriers.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+76629376e06e2c2ad626@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/Ye8K0QYee0Q0Nna2@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 3e01dd6e509b..d9712c2602af 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1563,6 +1563,13 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 		urb-&gt;hcpriv = NULL;
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
+		/*
+		 * Order the write of urb-&gt;use_count above before the read
+		 * of urb-&gt;reject below.  Pairs with the memory barriers in
+		 * usb_kill_urb() and usb_poison_urb().
+		 */
+		smp_mb__after_atomic();
+
 		atomic_dec(&amp;urb-&gt;dev-&gt;urbnum);
 		if (atomic_read(&amp;urb-&gt;reject))
 			wake_up(&amp;usb_kill_urb_queue);
@@ -1665,6 +1672,13 @@ static void __usb_hcd_giveback_urb(struct urb *urb)
 
 	usb_anchor_resume_wakeups(anchor);
 	atomic_dec(&amp;urb-&gt;use_count);
+	/*
+	 * Order the write of urb-&gt;use_count above before the read
+	 * of urb-&gt;reject below.  Pairs with the memory barriers in
+	 * usb_kill_urb() and usb_poison_urb().
+	 */
+	smp_mb__after_atomic();
+
 	if (unlikely(atomic_read(&amp;urb-&gt;reject)))
 		wake_up(&amp;usb_kill_urb_queue);
 	usb_put_urb(urb);
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 30727729a44c..33d62d7e3929 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -715,6 +715,12 @@ void usb_kill_urb(struct urb *urb)
 	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;ep))
 		return;
 	atomic_inc(&amp;urb-&gt;reject);
+	/*
+	 * Order the write of urb-&gt;reject above before the read
+	 * of urb-&gt;use_count below.  Pairs with the barriers in
+	 * __usb_hcd_giveback_urb() and usb_hcd_submit_urb().
+	 */
+	smp_mb__after_atomic();
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&amp;urb-&gt;use_count) == 0);
@@ -756,6 +762,12 @@ void usb_poison_urb(struct urb *urb)
 	if (!urb)
 		return;
 	atomic_inc(&amp;urb-&gt;reject);
+	/*
+	 * Order the write of urb-&gt;reject above before the read
+	 * of urb-&gt;use_count below.  Pairs with the barriers in
+	 * __usb_hcd_giveback_urb() and usb_hcd_submit_urb().
+	 */
+	smp_mb__after_atomic();
 
 	if (!urb-&gt;dev || !urb-&gt;ep)
 		return;</pre>
    <div class="pagination">
        <a href='2_4.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><span>[5]</span><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_6.html'>Next&gt;&gt;</a>
    <div>
</body>

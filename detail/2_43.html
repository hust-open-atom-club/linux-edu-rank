<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_42.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><span>[43]</span><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_44.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4005ad4390bf698e3bdae9567e79242ec0584097
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:32:01 2012 -0400

    EHCI: implement new semantics for URB_ISO_ASAP
    
    This patch (as1612) updates the isochronous scheduling and processing
    in ehci-hcd to match the new semantics for URB_ISO_ASAP.  It also adds
    a missing "unlikely" in sitd_complete() to match the corresponding
    statement in itd_complete(), and it increments urb-&gt;error_count in a
    couple of places that had been overlooked.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index e08e65d8e004..b538a4d62d5e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1386,8 +1386,8 @@ iso_stream_schedule (
 
 	/* Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
-	 * (irq delays etc), but if there are we'll take the next
-	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
+	 * (irq delays etc).  If there are, the behavior depends on
+	 * whether URB_ISO_ASAP is set.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 
@@ -1414,9 +1414,25 @@ iso_stream_schedule (
 			goto fail;
 		}
 
-		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
-		if (unlikely(start &lt; next))
-			start += (next - start + period - 1) &amp; (- period);
+		/* Behind the scheduling threshold? */
+		if (unlikely(start &lt; next)) {
+
+			/* USB_ISO_ASAP: Round up to the first available slot */
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+				start += (next - start + period - 1) &amp; -period;
+
+			/*
+			 * Not ASAP: Use the next slot in the stream.  If
+			 * the entire URB falls before the threshold, fail.
+			 */
+			else if (start + span - period &lt; next) {
+				ehci_dbg(ehci, "iso urb late %p (%u+%u &lt; %u)\n",
+						urb, start + base,
+						span - period, next + base);
+				status = -EXDEV;
+				goto fail;
+			}
+		}
 
 		start += base;
 	}
@@ -1699,7 +1715,7 @@ static bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)
 			urb-&gt;actual_length += desc-&gt;actual_length;
 		} else {
 			/* URB was too late */
-			desc-&gt;status = -EXDEV;
+			urb-&gt;error_count++;
 		}
 	}
 
@@ -2072,7 +2088,7 @@ static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
 	t = hc32_to_cpup(ehci, &amp;sitd-&gt;hw_results);
 
 	/* report transfer status */
-	if (t &amp; SITD_ERRS) {
+	if (unlikely(t &amp; SITD_ERRS)) {
 		urb-&gt;error_count++;
 		if (t &amp; SITD_STS_DBE)
 			desc-&gt;status = usb_pipein (urb-&gt;pipe)
@@ -2082,6 +2098,9 @@ static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
 			desc-&gt;status = -EOVERFLOW;
 		else /* XACT, MMF, etc */
 			desc-&gt;status = -EPROTO;
+	} else if (unlikely(t &amp; SITD_STS_ACTIVE)) {
+		/* URB was too late */
+		urb-&gt;error_count++;
 	} else {
 		desc-&gt;status = 0;
 		desc-&gt;actual_length = desc-&gt;length - SITD_LENGTH(t);</pre><hr><pre>commit a03bede5c73a6876fa891cfe82a65460dc9f4698
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 1 10:31:53 2012 -0400

    USB: update documentation for URB_ISO_ASAP
    
    This patch (as1611) updates the USB documentation and kerneldoc to
    give a more precise meaning for the URB_ISO_ASAP flag and to explain
    more of the details of scheduling for isochronous URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/usb/error-codes.txt b/Documentation/usb/error-codes.txt
index b3f606b81a03..8d1e2a9ebbba 100644
--- a/Documentation/usb/error-codes.txt
+++ b/Documentation/usb/error-codes.txt
@@ -35,9 +35,8 @@ USB-specific:
 		d) ISO: number_of_packets is &lt; 0
 		e) various other cases
 
--EAGAIN		a) specified ISO start frame too early
-		b) (using ISO-ASAP) too much scheduled for the future
-		   wait some time and try again.
+-EXDEV		ISO: URB_ISO_ASAP wasn't specified and all the frames
+		the URB would be scheduled in have already expired.
 
 -EFBIG		Host controller driver can't schedule that many ISO frames.
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9d912bfdcffe..3662287e2f4f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -214,9 +214,25 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * urb-&gt;interval is modified to reflect the actual transfer period used
  * (normally some power of two units).  And for isochronous urbs,
  * urb-&gt;start_frame is modified to reflect when the URB's transfers were
- * scheduled to start.  Not all isochronous transfer scheduling policies
- * will work, but most host controller drivers should easily handle ISO
- * queues going from now until 10-200 msec into the future.
+ * scheduled to start.
+ *
+ * Not all isochronous transfer scheduling policies will work, but most
+ * host controller drivers should easily handle ISO queues going from now
+ * until 10-200 msec into the future.  Drivers should try to keep at
+ * least one or two msec of data in the queue; many controllers require
+ * that new transfers start at least 1 msec in the future when they are
+ * added.  If the driver is unable to keep up and the queue empties out,
+ * the behavior for new submissions is governed by the URB_ISO_ASAP flag.
+ * If the flag is set, or if the queue is idle, then the URB is always
+ * assigned to the first available (and not yet expired) slot in the
+ * endpoint's schedule.  If the flag is not set and the queue is active
+ * then the URB is always assigned to the next slot in the schedule
+ * following the end of the endpoint's previous URB, even if that slot is
+ * in the past.  When a packet is assigned in this way to a slot that has
+ * already expired, the packet is not transmitted and the corresponding
+ * usb_iso_packet_descriptor's status field will return -EXDEV.  If this
+ * would happen to all the packets in the URB, submission fails with a
+ * -EXDEV error code.
  *
  * For control endpoints, the synchronous usb_control_msg() call is
  * often used (in non-interrupt context) instead of this call.
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 10278d18709c..f92cdf0c1457 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1129,8 +1129,8 @@ extern int usb_disabled(void);
  * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
-					 * ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only; use the first unexpired
+					 * slot in the schedule */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
@@ -1309,15 +1309,20 @@ typedef void (*usb_complete_t)(struct urb *);
  * the transfer interval in the endpoint descriptor is logarithmic.
  * Device drivers must convert that value to linear units themselves.)
  *
- * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling
- * the host controller to schedule the transfer as soon as bandwidth
- * utilization allows, and then set start_frame to reflect the actual frame
- * selected during submission.  Otherwise drivers must specify the start_frame
- * and handle the case where the transfer can't begin then.  However, drivers
- * won't know how bandwidth is currently allocated, and while they can
- * find the current frame using usb_get_current_frame_number () they can't
- * know the range for that frame number.  (Ranges for frame counter values
- * are HC-specific, and can go from 256 to 65536 frames from "now".)
+ * If an isochronous endpoint queue isn't already running, the host
+ * controller will schedule a new URB to start as soon as bandwidth
+ * utilization allows.  If the queue is running then a new URB will be
+ * scheduled to start in the first transfer slot following the end of the
+ * preceding URB, if that slot has not already expired.  If the slot has
+ * expired (which can happen when IRQ delivery is delayed for a long time),
+ * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
+ * is clear then the URB will be scheduled to start in the expired slot,
+ * implying that some of its packets will not be transferred; if the flag
+ * is set then the URB will be scheduled in the first unexpired slot,
+ * breaking the queue's synchronization.  Upon URB completion, the
+ * start_frame field will be set to the (micro)frame number in which the
+ * transfer was scheduled.  Ranges for frame counter values are HC-specific
+ * and can go from as low as 256 to as high as 65536 frames.
  *
  * Isochronous URBs have a different data transfer model, in part because
  * the quality of service is only "best effort".  Callers provide specially</pre><hr><pre>commit 72675479925f53af051ae8a78bcfafeaa47b3eef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:40 2012 -0400

    EHCI: replace mult/div with bit-mask operation
    
    This patch (as1610) replaces multiplication and divison operations in
    ehci-hcd's isochronous scheduling code with a bit-mask operation,
    taking advantage of the fact that isochronous periods are always
    powers of 2.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b764cab2ab9a..e08e65d8e004 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1416,7 +1416,7 @@ iso_stream_schedule (
 
 		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
 		if (unlikely(start &lt; next))
-			start += period * DIV_ROUND_UP(next - start, period);
+			start += (next - start + period - 1) &amp; (- period);
 
 		start += base;
 	}</pre><hr><pre>commit 98cae42d82fe9c9e2b5dacdf391edaa007e147e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:34 2012 -0400

    EHCI: use the isochronous scheduling threshold
    
    This patch (as1609) changes the way ehci-hcd uses the "Isochronous
    Scheduling Threshold" in its calculations.  Until now the code has
    ignored the threshold except for certain Intel PCI-based controllers.
    This violates the EHCI spec.
    
    The new code takes the threshold into account always, removing the
    need for the fs_i_thresh quirk flag.  In addition it implements the
    "full frame cache" setting more efficiently, moving forward only as
    far as the next frame boundary instead of always moving forward 8
    microframes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6bf6c42481e8..61eac96441de 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -503,7 +503,7 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	/* controllers may cache some of the periodic schedule ... */
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
-		ehci-&gt;i_thresh = 2 + 8;
+		ehci-&gt;i_thresh = 0;
 	else					// N microframes cached
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 2cb7d370c4ef..d1407f8d42b1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -103,7 +103,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		}
 		break;
 	case PCI_VENDOR_ID_INTEL:
-		ehci-&gt;fs_i_thresh = 1;
 		if (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd-&gt;has_tt = 1;
 		break;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7eb242f27c00..b764cab2ab9a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1391,15 +1391,11 @@ iso_stream_schedule (
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 
-		/* For high speed devices, allow scheduling within the
-		 * isochronous scheduling threshold.  For full speed devices
-		 * and Intel PCI-based controllers, don't (work around for
-		 * Intel ICH9 bug).
-		 */
-		if (!stream-&gt;highspeed &amp;&amp; ehci-&gt;fs_i_thresh)
-			next = now + ehci-&gt;i_thresh;
+		/* Take the isochronous scheduling threshold into account */
+		if (ehci-&gt;i_thresh)
+			next = now + ehci-&gt;i_thresh;	/* uframe cache */
 		else
-			next = now;
+			next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
 
 		/*
 		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 0564a63f5eb3..4ddf7c51616b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -193,7 +193,6 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_amcc_usb23:1;
 	unsigned		need_io_watchdog:1;
 	unsigned		amd_pll_fix:1;
-	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/
 	unsigned		has_synopsys_hc_bug:1; /* Synopsys HC */
 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */</pre><hr><pre>commit c3ee9b76aa93fbf59727e02fac9914c7355108f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 28 16:01:23 2012 -0400

    EHCI: improved logic for isochronous scheduling
    
    This patch (as1608) reworks the logic used by ehci-hcd for scheduling
    isochronous transfers.  Now the modular calculations are all based on
    a window that starts at the last frame scanned for isochronous
    completions.  No transfer descriptors for any earlier frames can
    possibly remain on the schedule, so there can be no confusion from
    schedule wrap-around.  This removes the need for a "slop" region of
    arbitrary size.
    
    There's no need to check for URBs that are longer than the schedule
    length.  With the old code they could throw things off by wrapping
    around and appearing to end in the near future rather than the distant
    future.  Now such confusion isn't possible, and the existing test for
    submissions that extend too far into the future will also catch those
    that exceed the schedule length.  (But there still has to be an
    initial test to handle the case where the schedule already extends as
    far into the future as possible.)
    
    Delays caused by IRQ latency won't confuse the algorithm unless they
    are ridiculously long (over 250 ms); they will merely reduce how far
    into the future new transfers can be scheduled.  A few people have
    reported problems caused by delays of 50 ms or so.  Now instead of
    failing completely, isochronous transfers will experience a brief
    glitch and then continue normally.
    
    (Whether this is truly a good thing is debatable.  A latency as large
    as 50 ms generally indicates a bug is present, and complete failure of
    audio or video transfers draws people's attention pretty vividly.
    Making the transfers more robust also makes it easier for such bugs to
    remain undetected.)
    
    Finally, ehci-&gt;next_frame is renamed to ehci-&gt;last_iso_frame, because
    that better describes what it is: the last frame to have been scanned
    for isochronous completions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7cf3da7babf0..7eb242f27c00 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1361,7 +1361,7 @@ sitd_slot_ok (
  * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!
  */
 
-#define SCHEDULE_SLOP	80	/* microframes */
+#define SCHEDULING_DELAY	40	/* microframes */
 
 static int
 iso_stream_schedule (
@@ -1370,7 +1370,7 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, next, start, period, span;
+	u32			now, base, next, start, period, span;
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
@@ -1382,12 +1382,6 @@ iso_stream_schedule (
 		span &lt;&lt;= 3;
 	}
 
-	if (span &gt; mod - SCHEDULE_SLOP) {
-		ehci_dbg (ehci, "iso request %p too long\n", urb);
-		status = -EFBIG;
-		goto fail;
-	}
-
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1396,7 +1390,6 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		u32	excess;
 
 		/* For high speed devices, allow scheduling within the
 		 * isochronous scheduling threshold.  For full speed devices
@@ -1408,36 +1401,41 @@ iso_stream_schedule (
 		else
 			next = now;
 
-		/* Fell behind (by up to twice the slop amount)?
-		 * We decide based on the time of the last currently-scheduled
-		 * slot, not the time of the next available slot.
+		/*
+		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+		 * TDs scheduled for earlier than that.
 		 */
-		excess = (stream-&gt;next_uframe - period - next) &amp; (mod - 1);
-		if (excess &gt;= mod - 2 * SCHEDULE_SLOP)
-			start = next + excess - mod + period *
-					DIV_ROUND_UP(mod - excess, period);
-		else
-			start = next + excess + period;
-		if (start - now &gt;= mod) {
-			ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
-					urb, start - now - period, period,
-					mod);
-			status = -EFBIG;
+		base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+		next = (next - base) &amp; (mod - 1);
+		start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+
+		/* Is the schedule already full? */
+		if (unlikely(start &lt; period)) {
+			ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
+					urb, stream-&gt;next_uframe, base,
+					period, mod);
+			status = -ENOSPC;
 			goto fail;
 		}
+
+		/* Behind the scheduling threshold?  Assume URB_ISO_ASAP. */
+		if (unlikely(start &lt; next))
+			start += period * DIV_ROUND_UP(next - start, period);
+
+		start += base;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
 	 * this is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the slop should handle reasonably slow cpus.  it
+	 * isn't free, the delay should handle reasonably slow cpus.  it
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
 	else {
 		int done = 0;
-		start = SCHEDULE_SLOP + (now &amp; ~0x07);
 
-		/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
+		base = now &amp; ~0x07;
+		start = base + SCHEDULING_DELAY;
 
 		/* find a uframe slot with enough bandwidth.
 		 * Early uframes are more precious because full-speed
@@ -1464,19 +1462,16 @@ iso_stream_schedule (
 
 		/* no room in the schedule */
 		if (!done) {
-			ehci_dbg(ehci, "iso resched full %p (now %d max %d)\n",
-				urb, now, now + mod);
+			ehci_dbg(ehci, "iso sched full %p", urb);
 			status = -ENOSPC;
 			goto fail;
 		}
 	}
 
 	/* Tried to schedule too far into the future? */
-	if (unlikely(start - now + span - period
-				&gt;= mod - 2 * SCHEDULE_SLOP)) {
-		ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
-				urb, start - now, span - period,
-				mod - 2 * SCHEDULE_SLOP);
+	if (unlikely(start - base + span - period &gt;= mod)) {
+		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",
+				urb, start - base, span - period, mod);
 		status = -EFBIG;
 		goto fail;
 	}
@@ -1490,7 +1485,7 @@ iso_stream_schedule (
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
-		ehci-&gt;next_frame = now &gt;&gt; 3;
+		ehci-&gt;last_iso_frame = now &gt;&gt; 3;
 	return 0;
 
  fail:
@@ -2220,16 +2215,16 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		now_frame = (uf &gt;&gt; 3) &amp; fmask;
 		live = true;
 	} else  {
-		now_frame = (ehci-&gt;next_frame - 1) &amp; fmask;
+		now_frame = (ehci-&gt;last_iso_frame - 1) &amp; fmask;
 		live = false;
 	}
 	ehci-&gt;now_frame = now_frame;
 
-	frame = ehci-&gt;next_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
 
+		frame = ehci-&gt;last_iso_frame;
 restart:
 		/* scan each element in frame's queue for completions */
 		q_p = &amp;ehci-&gt;pshadow [frame];
@@ -2334,7 +2329,6 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		/* Stop when we have reached the current frame */
 		if (frame == now_frame)
 			break;
-		frame = (frame + 1) &amp; fmask;
+		ehci-&gt;last_iso_frame = (frame + 1) &amp; fmask;
 	}
-	ehci-&gt;next_frame = now_frame;
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index da07d98f7d1d..0564a63f5eb3 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -143,7 +143,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
 	unsigned		now_frame;	/* frame from HC hardware */
-	unsigned		next_frame;	/* scan periodic, start here */
+	unsigned		last_iso_frame;	/* last frame scanned for iso */
 	unsigned		intr_count;	/* intr activity count */
 	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */</pre><hr><pre>commit db5c8b524444d4fc6b1f32d368a50a3729e50002
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 10 14:10:21 2012 -0400

    USB: fix port probing and removal in garmin_gps
    
    This patch (as1615) fixes a bug in the Garmin USB serial driver.  It
    uses attach, disconnect, and release routines to carry out actions
    that should be handled by port_probe and port_remove routines, because
    they access port-specific data.
    
    The bug causes an oops when the device in unplugged, because the
    private data for each port structure now gets erased when the port is
    unbound from the driver, resulting in a null-pointer dereference.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported--by: Markus Schauler &lt;mschauler@gmail.com&gt;
    Tested-by: Markus Schauler &lt;mschauler@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c
index 3ee92648c02d..203358d7e7bc 100644
--- a/drivers/usb/serial/garmin_gps.c
+++ b/drivers/usb/serial/garmin_gps.c
@@ -1405,11 +1405,10 @@ static void timeout_handler(unsigned long data)
 
 
 
-static int garmin_attach(struct usb_serial *serial)
+static int garmin_port_probe(struct usb_serial_port *port)
 {
-	int status = 0;
-	struct usb_serial_port *port = serial-&gt;port[0];
-	struct garmin_data *garmin_data_p = NULL;
+	int status;
+	struct garmin_data *garmin_data_p;
 
 	garmin_data_p = kzalloc(sizeof(struct garmin_data), GFP_KERNEL);
 	if (garmin_data_p == NULL) {
@@ -1434,22 +1433,14 @@ static int garmin_attach(struct usb_serial *serial)
 }
 
 
-static void garmin_disconnect(struct usb_serial *serial)
+static int garmin_port_remove(struct usb_serial_port *port)
 {
-	struct usb_serial_port *port = serial-&gt;port[0];
 	struct garmin_data *garmin_data_p = usb_get_serial_port_data(port);
 
 	usb_kill_urb(port-&gt;interrupt_in_urb);
 	del_timer_sync(&amp;garmin_data_p-&gt;timer);
-}
-
-
-static void garmin_release(struct usb_serial *serial)
-{
-	struct usb_serial_port *port = serial-&gt;port[0];
-	struct garmin_data *garmin_data_p = usb_get_serial_port_data(port);
-
 	kfree(garmin_data_p);
+	return 0;
 }
 
 
@@ -1466,9 +1457,8 @@ static struct usb_serial_driver garmin_device = {
 	.close               = garmin_close,
 	.throttle            = garmin_throttle,
 	.unthrottle          = garmin_unthrottle,
-	.attach              = garmin_attach,
-	.disconnect          = garmin_disconnect,
-	.release             = garmin_release,
+	.port_probe		= garmin_port_probe,
+	.port_remove		= garmin_port_remove,
 	.write               = garmin_write,
 	.write_room          = garmin_write_room,
 	.write_bulk_callback = garmin_write_bulk_callback,</pre><hr><pre>commit 0d00dc2611abbe6ad244d50569c2ee82ce42846c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 26 13:09:53 2012 -0400

    USB: Fix race condition when removing host controllers
    
    This patch (as1607) fixes a race that can occur if a USB host
    controller is removed while a process is reading the
    /sys/kernel/debug/usb/devices file.
    
    The usb_device_read() routine uses the bus-&gt;root_hub pointer to
    determine whether or not the root hub is registered.  The is not a
    valid test, because the pointer is set before the root hub gets
    registered and remains set even after the root hub is unregistered and
    deallocated.  As a result, usb_device_read() or usb_device_dump() can
    access freed memory, causing an oops.
    
    The patch changes the test to use the hcd-&gt;rh_registered flag, which
    does get set and cleared at the appropriate times.  It also makes sure
    to hold the usb_bus_list_lock mutex while setting the flag, so that
    usb_device_read() will become aware of new root hubs as soon as they
    are registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Don Zickus &lt;dzickus@redhat.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index d95696584762..3440812b4a84 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -624,7 +624,7 @@ static ssize_t usb_device_read(struct file *file, char __user *buf,
 	/* print devices for all busses */
 	list_for_each_entry(bus, &amp;usb_bus_list, bus_list) {
 		/* recurse through all children of the root hub */
-		if (!bus-&gt;root_hub)
+		if (!bus_to_hcd(bus)-&gt;rh_registered)
 			continue;
 		usb_lock_device(bus-&gt;root_hub);
 		ret = usb_device_dump(&amp;buf, &amp;nbytes, &amp;skip_bytes, ppos,
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index bc84106ac057..75ba2091f9b4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1011,10 +1011,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 	if (retval) {
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
 				dev_name(&amp;usb_dev-&gt;dev), retval);
-	}
-	mutex_unlock(&amp;usb_bus_list_lock);
-
-	if (retval == 0) {
+	} else {
 		spin_lock_irq (&amp;hcd_root_hub_lock);
 		hcd-&gt;rh_registered = 1;
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
@@ -1023,6 +1020,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		if (HCD_DEAD(hcd))
 			usb_hc_died (hcd);	/* This time clean up */
 	}
+	mutex_unlock(&amp;usb_bus_list_lock);
 
 	return retval;
 }</pre><hr><pre>commit 0a2314035cab62cafc38ea11ec5b6f95cf347b38
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 26 13:09:53 2012 -0400

    USB: Fix race condition when removing host controllers
    
    This patch (as1607) fixes a race that can occur if a USB host
    controller is removed while a process is reading the
    /sys/kernel/debug/usb/devices file.
    
    The usb_device_read() routine uses the bus-&gt;root_hub pointer to
    determine whether or not the root hub is registered.  The is not a
    valid test, because the pointer is set before the root hub gets
    registered and remains set even after the root hub is unregistered and
    deallocated.  As a result, usb_device_read() or usb_device_dump() can
    access freed memory, causing an oops.
    
    The patch changes the test to use the hcd-&gt;rh_registered flag, which
    does get set and cleared at the appropriate times.  It also makes sure
    to hold the usb_bus_list_lock mutex while setting the flag, so that
    usb_device_read() will become aware of new root hubs as soon as they
    are registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Don Zickus &lt;dzickus@redhat.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index f4ead1296820..f460de31acee 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -623,7 +623,7 @@ static ssize_t usb_device_read(struct file *file, char __user *buf,
 	/* print devices for all busses */
 	list_for_each_entry(bus, &amp;usb_bus_list, bus_list) {
 		/* recurse through all children of the root hub */
-		if (!bus-&gt;root_hub)
+		if (!bus_to_hcd(bus)-&gt;rh_registered)
 			continue;
 		usb_lock_device(bus-&gt;root_hub);
 		ret = usb_device_dump(&amp;buf, &amp;nbytes, &amp;skip_bytes, ppos,
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 35b52f6e1c5e..1e741bca0265 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1011,10 +1011,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 	if (retval) {
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
 				dev_name(&amp;usb_dev-&gt;dev), retval);
-	}
-	mutex_unlock(&amp;usb_bus_list_lock);
-
-	if (retval == 0) {
+	} else {
 		spin_lock_irq (&amp;hcd_root_hub_lock);
 		hcd-&gt;rh_registered = 1;
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
@@ -1023,6 +1020,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		if (HCD_DEAD(hcd))
 			usb_hc_died (hcd);	/* This time clean up */
 	}
+	mutex_unlock(&amp;usb_bus_list_lock);
 
 	return retval;
 }</pre><hr><pre>commit d16ba48774913d244c7eb894d28d8ae2c019a827
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 17:02:29 2012 -0400

    USB: EHCI: convert warning messages to debug-level
    
    This patch (as1606) converts two warning messages in the ehci-hcd
    driver to debug messages, and adds a little extra information to each.
    
    The log messages occur when an EHCI controller takes too long (more
    than 20 ms) to turn its async or periodic schedule on or off.  If this
    happens at all, it's liable to happen quite often and there's no point
    spamming the system log with these warnings.  Furthermore, there's
    nothing much we can do about it when the problem happens.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Thomas Voegtle &lt;tv@lio96.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt; # [3.6]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index eb896a2c8f2e..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -118,7 +118,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci-&gt;ASS_poll_count = 0;
 
@@ -163,7 +164,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the periodic schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci-&gt;PSS_poll_count = 0;
 </pre><hr><pre>commit 17dcfc9bd3dfb699e00205ec9d431b5a5cb00b34
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 17:00:55 2012 -0400

    USB: EHCI: remove useless test
    
    This patch (as1605) removes a useless test from the EHCI debugfs
    code.  There's no point checking whether p.qh is non-NULL; we already
    know it is and in any case it gets dereferenced aerlier in the
    function.
    
    The useless test was identified by smatch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Fengguang Wu &lt;fengguang.wu@intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index f0c00de035ef..1599806e3d47 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -653,10 +653,8 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 						seen [seen_count++].qh = p.qh;
 				} else
 					temp = 0;
-				if (p.qh) {
-					tag = Q_NEXT_TYPE(ehci, hw-&gt;hw_next);
-					p = p.qh-&gt;qh_next;
-				}
+				tag = Q_NEXT_TYPE(ehci, hw-&gt;hw_next);
+				p = p.qh-&gt;qh_next;
 				break;
 			case Q_TYPE_FSTN:
 				temp = scnprintf (next, size,</pre>
    <div class="pagination">
        <a href='2_42.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><span>[43]</span><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_44.html'>Next&gt;&gt;</a>
    <div>
</body>

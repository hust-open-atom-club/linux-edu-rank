<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_132.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><span>[133]</span><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_134.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0a1ef3b5a765a6f20e7b8caf295aad3276243966
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:38:24 2005 -0400

    [PATCH] usbcore: Use kzalloc instead of kmalloc/memset
    
    This patch (as590) fixes up all the remaining places where usbcore can
    use kzalloc rather than kmalloc/memset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 99595e07b653..63f374e62db2 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -188,10 +188,9 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	}
 
 	len = sizeof(struct usb_host_endpoint) * num_ep;
-	alt-&gt;endpoint = kmalloc(len, GFP_KERNEL);
+	alt-&gt;endpoint = kzalloc(len, GFP_KERNEL);
 	if (!alt-&gt;endpoint)
 		return -ENOMEM;
-	memset(alt-&gt;endpoint, 0, len);
 
 	/* Parse all the endpoint descriptors */
 	n = 0;
@@ -353,10 +352,9 @@ static int usb_parse_configuration(struct device *ddev, int cfgidx,
 		}
 
 		len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;
-		config-&gt;intf_cache[i] = intfc = kmalloc(len, GFP_KERNEL);
+		config-&gt;intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);
 		if (!intfc)
 			return -ENOMEM;
-		memset(intfc, 0, len);
 		kref_init(&amp;intfc-&gt;ref);
 	}
 
@@ -459,16 +457,14 @@ int usb_get_configuration(struct usb_device *dev)
 	}
 
 	length = ncfg * sizeof(struct usb_host_config);
-	dev-&gt;config = kmalloc(length, GFP_KERNEL);
+	dev-&gt;config = kzalloc(length, GFP_KERNEL);
 	if (!dev-&gt;config)
 		goto err2;
-	memset(dev-&gt;config, 0, length);
 
 	length = ncfg * sizeof(char *);
-	dev-&gt;rawdescriptors = kmalloc(length, GFP_KERNEL);
+	dev-&gt;rawdescriptors = kzalloc(length, GFP_KERNEL);
 	if (!dev-&gt;rawdescriptors)
 		goto err2;
-	memset(dev-&gt;rawdescriptors, 0, length);
 
 	buffer = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);
 	if (!buffer)
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index ffb2e242b100..942cd437dc48 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -210,10 +210,10 @@ static ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes, l
 static struct async *alloc_async(unsigned int numisoframes)
 {
         unsigned int assize = sizeof(struct async) + numisoframes * sizeof(struct usb_iso_packet_descriptor);
-        struct async *as = kmalloc(assize, GFP_KERNEL);
+        struct async *as = kzalloc(assize, GFP_KERNEL);
+
         if (!as)
                 return NULL;
-        memset(as, 0, assize);
 	as-&gt;urb = usb_alloc_urb(numisoframes, GFP_KERNEL);
 	if (!as-&gt;urb) {
 		kfree(as);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index e8f2b8d8f14d..61ef9943757e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -744,10 +744,9 @@ struct usb_bus *usb_alloc_bus (struct usb_operations *op)
 {
 	struct usb_bus *bus;
 
-	bus = kmalloc (sizeof *bus, GFP_KERNEL);
+	bus = kzalloc (sizeof *bus, GFP_KERNEL);
 	if (!bus)
 		return NULL;
-	memset(bus, 0, sizeof(struct usb_bus));
 	usb_bus_init (bus);
 	bus-&gt;op = op;
 	return bus;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6a2ebd89916f..8ba5854e5387 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -865,14 +865,12 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	/* We found a hub */
 	dev_info (&amp;intf-&gt;dev, "USB hub found\n");
 
-	hub = kmalloc(sizeof(*hub), GFP_KERNEL);
+	hub = kzalloc(sizeof(*hub), GFP_KERNEL);
 	if (!hub) {
 		dev_dbg (&amp;intf-&gt;dev, "couldn't kmalloc hub struct\n");
 		return -ENOMEM;
 	}
 
-	memset(hub, 0, sizeof(*hub));
-
 	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
 	hub-&gt;intfdev = &amp;intf-&gt;dev;
 	hub-&gt;hdev = hdev;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5ad0d5e28119..3519f317898e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1350,7 +1350,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 
 		for (; n &lt; nintf; ++n) {
-			new_interfaces[n] = kmalloc(
+			new_interfaces[n] = kzalloc(
 					sizeof(struct usb_interface),
 					GFP_KERNEL);
 			if (!new_interfaces[n]) {
@@ -1391,7 +1391,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 			struct usb_host_interface *alt;
 
 			cp-&gt;interface[i] = intf = new_interfaces[i];
-			memset(intf, 0, sizeof(*intf));
 			intfc = cp-&gt;intf_cache[i];
 			intf-&gt;altsetting = intfc-&gt;altsetting;
 			intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 4eca4904938f..0eefff7bcb3c 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -704,12 +704,10 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 {
 	struct usb_device *dev;
 
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return NULL;
 
-	memset(dev, 0, sizeof(*dev));
-
 	bus = usb_bus_get(bus);
 	if (!bus) {
 		kfree(dev);</pre><hr><pre>commit b724ae77969fd832be71419dca74bece9af287ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:36:00 2005 -0400

    [PATCH] usbcore: Wrap lines before column 80
    
    I can't stand text lines that wrap-around in my 80-column windows.  This
    patch (as589) makes cosmetic changes to a couple of source files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index f18317fb49ee..4cca77cf0c48 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -221,7 +221,8 @@ static void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
 
 /* Active configuration fields */
 #define usb_actconfig_show(field, multiplier, format_string)		\
-static ssize_t  show_##field (struct device *dev, struct device_attribute *attr, char *buf)		\
+static ssize_t  show_##field (struct device *dev,			\
+		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
 	struct usb_host_config *actconfig;				\
@@ -243,7 +244,8 @@ usb_actconfig_attr (bNumInterfaces, 1, "%2d\n")
 usb_actconfig_attr (bmAttributes, 1, "%2x\n")
 usb_actconfig_attr (bMaxPower, 2, "%3dmA\n")
 
-static ssize_t show_configuration_string(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_configuration_string(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
@@ -266,7 +268,8 @@ static DEVICE_ATTR(configuration, S_IRUGO, show_configuration_string, NULL);
 usb_actconfig_show(bConfigurationValue, 1, "%u\n");
 
 static ssize_t
-set_bConfigurationValue (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+set_bConfigurationValue (struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct usb_device	*udev = udev = to_usb_device (dev);
 	int			config, value;
@@ -284,7 +287,8 @@ static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR,
 
 /* String fields */
 #define usb_string_attr(name)						\
-static ssize_t  show_##name(struct device *dev, struct device_attribute *attr, char *buf)		\
+static ssize_t  show_##name(struct device *dev,				\
+		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
 	int len;							\
@@ -364,7 +368,8 @@ static DEVICE_ATTR(maxchild, S_IRUGO, show_maxchild, NULL);
 /* Descriptor fields */
 #define usb_descriptor_attr_le16(field, format_string)			\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_device *udev;					\
 									\
@@ -380,7 +385,8 @@ usb_descriptor_attr_le16(bcdDevice, "%04x\n")
 
 #define usb_descriptor_attr(field, format_string)			\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_device *udev;					\
 									\
@@ -455,11 +461,13 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 /* Interface fields */
 #define usb_intf_attr(field, format_string)				\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_interface *intf = to_usb_interface (dev);		\
 									\
-	return sprintf (buf, format_string, intf-&gt;cur_altsetting-&gt;desc.field); \
+	return sprintf (buf, format_string,				\
+			intf-&gt;cur_altsetting-&gt;desc.field); 		\
 }									\
 static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
@@ -470,7 +478,8 @@ usb_intf_attr (bInterfaceClass, "%02x\n")
 usb_intf_attr (bInterfaceSubClass, "%02x\n")
 usb_intf_attr (bInterfaceProtocol, "%02x\n")
 
-static ssize_t show_interface_string(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_interface_string(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_interface *intf;
 	struct usb_device *udev;
@@ -487,7 +496,8 @@ static ssize_t show_interface_string(struct device *dev, struct device_attribute
 }
 static DEVICE_ATTR(interface, S_IRUGO, show_interface_string, NULL);
 
-static ssize_t show_modalias(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_modalias(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_interface *intf;
 	struct usb_device *udev;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 465ff4585ca5..c500d6b5a16d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -137,7 +137,8 @@ struct usb_interface {
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
-	int minor;			/* minor number this interface is bound to */
+	int minor;			/* minor number this interface is
+					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
@@ -249,7 +250,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	__usb_get_extra_descriptor((ifpoint)-&gt;extra,(ifpoint)-&gt;extralen,\
 		type,(void**)ptr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 struct usb_operations;
 
@@ -269,7 +270,8 @@ struct usb_bus {
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
 
-	int devnum_next;		/* Next open device number in round-robin allocation */
+	int devnum_next;		/* Next open device number in
+					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_operations *op;	/* Operations (specific to the HC) */
@@ -290,15 +292,16 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* handles reference counting this bus */
-	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
+	struct kref kref;		/* reference counting for this bus */
+	void (*release)(struct usb_bus *bus);
+
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* This is arbitrary.
  * From USB 2.0 spec Table 11-13, offset 7, a hub can
@@ -327,7 +330,8 @@ struct usb_device {
 
 	struct semaphore serialize;
 
-	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
+	unsigned int toggle[2];		/* one bit for each endpoint
+					 * ([0] = IN, [1] = OUT) */
 
 	struct usb_device *parent;	/* our hub, unless we're the root */
 	struct usb_bus *bus;		/* Bus we're part of */
@@ -344,7 +348,7 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
-	int have_langid;		/* whether string_langid is valid yet */
+	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	char *product;
@@ -441,22 +445,31 @@ extern struct usb_host_interface *usb_altnum_to_altsetting(
  * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
  * high speed, and a different one if they are full or low speed.
  */
-static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
+static inline int usb_make_path (struct usb_device *dev, char *buf,
+		size_t size)
 {
 	int actual;
-	actual = snprintf (buf, size, "usb-%s-%s", dev-&gt;bus-&gt;bus_name, dev-&gt;devpath);
+	actual = snprintf (buf, size, "usb-%s-%s", dev-&gt;bus-&gt;bus_name,
+			dev-&gt;devpath);
 	return (actual &gt;= (int)size) ? -1 : actual;
 }
 
 /*-------------------------------------------------------------------------*/
 
-#define USB_DEVICE_ID_MATCH_DEVICE		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
-#define USB_DEVICE_ID_MATCH_DEV_RANGE		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
-#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION	(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
+#define USB_DEVICE_ID_MATCH_DEVICE \
+		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
+#define USB_DEVICE_ID_MATCH_DEV_RANGE \
+		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
+#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \
+		(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
 #define USB_DEVICE_ID_MATCH_DEV_INFO \
-	(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_DEV_CLASS | \
+		USB_DEVICE_ID_MATCH_DEV_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
 #define USB_DEVICE_ID_MATCH_INT_INFO \
-	(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_INT_CLASS | \
+		USB_DEVICE_ID_MATCH_INT_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_INT_PROTOCOL)
 
 /**
  * USB_DEVICE - macro used to describe a specific usb device
@@ -467,9 +480,11 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device.
  */
 #define USB_DEVICE(vend,prod) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), \
+			.idProduct = (prod)
 /**
- * USB_DEVICE_VER - macro used to describe a specific usb device with a version range
+ * USB_DEVICE_VER - macro used to describe a specific usb device with a
+ *		version range
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @lo: the bcdDevice_lo value
@@ -479,7 +494,9 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device, with a version range.
  */
 #define USB_DEVICE_VER(vend,prod,lo,hi) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
 
 /**
  * USB_DEVICE_INFO - macro used to describe a class of usb devices
@@ -491,7 +508,8 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of devices.
  */
 #define USB_DEVICE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), \
+	.bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
 
 /**
  * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces 
@@ -503,9 +521,10 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of interfaces.
  */
 #define USB_INTERFACE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * struct usb_driver - identifies USB driver to usbcore
@@ -558,7 +577,8 @@ struct usb_driver {
 
 	void (*disconnect) (struct usb_interface *intf);
 
-	int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
+	int (*ioctl) (struct usb_interface *intf, unsigned int code,
+			void *buf);
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
@@ -601,7 +621,7 @@ extern void usb_deregister_dev(struct usb_interface *intf,
 
 extern int usb_disabled(void);
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * URB support, for asynchronous request completions
@@ -611,12 +631,14 @@ extern int usb_disabled(void);
  * urb-&gt;transfer_flags:
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
+					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
-#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
-#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
+#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
+#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
+					 * needed */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
@@ -804,7 +826,8 @@ struct urb
 	u8 reject;			/* submissions will fail */
 
 	/* public, documented fields in the urb that can be used by drivers */
-	struct list_head urb_list;	/* list head for use by the urb owner */
+	struct list_head urb_list;	/* list head for use by the urb's
+					 * current owner */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
@@ -817,14 +840,16 @@ struct urb
 	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */
 	int start_frame;		/* (modify) start frame (ISO) */
 	int number_of_packets;		/* (in) number of ISO packets */
-	int interval;			/* (modify) transfer interval (INT/ISO) */
+	int interval;			/* (modify) transfer interval
+					 * (INT/ISO) */
 	int error_count;		/* (return) number of ISO errors */
 	void *context;			/* (in) context for completion */
 	usb_complete_t complete;	/* (in) completion routine */
-	struct usb_iso_packet_descriptor iso_frame_desc[0];	/* (in) ISO ONLY */
+	struct usb_iso_packet_descriptor iso_frame_desc[0];
+					/* (in) ISO ONLY */
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * usb_fill_control_urb - initializes a control urb
@@ -1049,7 +1074,7 @@ void usb_sg_cancel (struct usb_sg_request *io);
 void usb_sg_wait (struct usb_sg_request *io);
 
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * For various legacy reasons, Linux has a small cookie that's paired with
@@ -1090,23 +1115,34 @@ void usb_sg_wait (struct usb_sg_request *io);
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))
-#define usb_settoggle(dev, ep, out, bit) ((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | ((bit) &lt;&lt; (ep)))
+#define usb_settoggle(dev, ep, out, bit) \
+		((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | \
+		 ((bit) &lt;&lt; (ep)))
 
 
-static inline unsigned int __create_pipe(struct usb_device *dev, unsigned int endpoint)
+static inline unsigned int __create_pipe(struct usb_device *dev,
+		unsigned int endpoint)
 {
 	return (dev-&gt;devnum &lt;&lt; 8) | (endpoint &lt;&lt; 15);
 }
 
 /* Create various pipes... */
-#define usb_sndctrlpipe(dev,endpoint)	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvctrlpipe(dev,endpoint)	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndbulkpipe(dev,endpoint)	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvbulkpipe(dev,endpoint)	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndintpipe(dev,endpoint)	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvintpipe(dev,endpoint)	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndbulkpipe(dev,endpoint)	\
+	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvbulkpipe(dev,endpoint)	\
+	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
 
 /*-------------------------------------------------------------------------*/
 
@@ -1130,7 +1166,7 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 	return le16_to_cpu(ep-&gt;desc.wMaxPacketSize);
 }
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* Events from the usb core */
 #define USB_DEVICE_ADD		0x0001
@@ -1141,14 +1177,18 @@ extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
 
 #ifdef DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg)
+#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , \
+	__FILE__ , ## arg)
 #else
 #define dbg(format, arg...) do {} while (0)
 #endif
 
-#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , __FILE__ , ## arg)
-#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , __FILE__ , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , __FILE__ , ## arg)
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , \
+	__FILE__ , ## arg)
 
 
 #endif  /* __KERNEL__ */</pre><hr><pre>commit 0e6c8e8db508fcb292836b23d039649c5de29090
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:33:03 2005 -0400

    [PATCH] usbcore: endpoint attributes track altsetting changes
    
    This patch (as588) fixes the way endpoint attribute files are registered
    and unregistered.  Now they will correctly track along with altsetting
    changes.  This fixes bugzilla entry #5467.
    
    In a separate but related change, when a usb_reset_configuration call
    fails, the device state is not changed to USB_STATE_ADDRESS.  In the
    first place, failure means that we don't know what the state is, not
    that we know the device is unconfigured.  In the second place, doing
    this can potentially lead to a memory leak, since usbcore might not
    realize there still is a current configuration that needs to be
    destroyed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 574d0d4b3401..5ad0d5e28119 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1149,6 +1149,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
+	if (device_is_registered(&amp;iface-&gt;dev))
+		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
 	iface-&gt;cur_altsetting = alt;
@@ -1184,6 +1186,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
+	if (device_is_registered(&amp;iface-&gt;dev))
+		usb_create_sysfs_intf_files(iface);
 
 	return 0;
 }
@@ -1233,10 +1237,8 @@ int usb_reset_configuration(struct usb_device *dev)
 			USB_REQ_SET_CONFIGURATION, 0,
 			config-&gt;desc.bConfigurationValue, 0,
 			NULL, 0, USB_CTRL_SET_TIMEOUT);
-	if (retval &lt; 0) {
-		usb_set_device_state(dev, USB_STATE_ADDRESS);
+	if (retval &lt; 0)
 		return retval;
-	}
 
 	dev-&gt;toggle[0] = dev-&gt;toggle[1] = 0;
 
@@ -1245,6 +1247,8 @@ int usb_reset_configuration(struct usb_device *dev)
 		struct usb_interface *intf = config-&gt;interface[i];
 		struct usb_host_interface *alt;
 
+		if (device_is_registered(&amp;intf-&gt;dev))
+			usb_remove_sysfs_intf_files(intf);
 		alt = usb_altnum_to_altsetting(intf, 0);
 
 		/* No altsetting 0?  We'll assume the first altsetting.
@@ -1257,6 +1261,8 @@ int usb_reset_configuration(struct usb_device *dev)
 
 		intf-&gt;cur_altsetting = alt;
 		usb_enable_interface(dev, intf);
+		if (device_is_registered(&amp;intf-&gt;dev))
+			usb_create_sysfs_intf_files(intf);
 	}
 	return 0;
 }</pre><hr><pre>commit be69e5b1900a19a545becda822b18d6f09168ba5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 25 15:56:06 2005 -0400

    [PATCH] usbcore: Improve endpoint sysfs file handling
    
    This revised patch (as587b) improves the implementation of USB endpoint
    sysfs files.  Instead of storing a whole bunch of attributes for every
    single endpoint, each endpoint now gets its own kobject and they can
    share a static list of attributes.  The number of extra fields added to
    struct usb_host_endpoint has been reduced from 4 to 1.
    
    The bEndpointAddress field is retained even though it is redundant (it
    repeats the same information as the attributes' directory name).  The
    code avoids calling kobject_register, to prevent generating unwanted
    hotplug events.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4bdbc9df6e03..f18317fb49ee 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -23,43 +23,56 @@
 #include "usb.h"
 
 /* endpoint stuff */
-struct endpoint_attribute {
-	struct device_attribute dev_attr;
-	struct usb_endpoint_descriptor *endpoint;
+struct ep_object {
+	struct usb_endpoint_descriptor *desc;
 	struct usb_device *udev;
+	struct kobject kobj;
 };
-#define to_endpoint_attr(_dev_attr) \
-	container_of(_dev_attr, struct endpoint_attribute, dev_attr)
-
-#define usb_ep_attr(field, format_string)					\
-static ssize_t show_ep_##field(struct device *dev, struct device_attribute *attr,	\
-			    char *buf)						\
-{										\
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);	\
-										\
-	return sprintf(buf, format_string, endpoint_attr-&gt;endpoint-&gt;field);	\
-}
+#define to_ep_object(_kobj) \
+	container_of(_kobj, struct ep_object, kobj)
+
+struct ep_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct usb_device *,
+			struct usb_endpoint_descriptor *, char *);
+};
+#define to_ep_attribute(_attr) \
+	container_of(_attr, struct ep_attribute, attr)
+
+#define EP_ATTR(_name)						\
+struct ep_attribute ep_##_name = {				\
+	.attr = {.name = #_name, .owner = THIS_MODULE,		\
+			.mode = S_IRUGO},			\
+	.show = show_ep_##_name}
+
+#define usb_ep_attr(field, format_string)			\
+static ssize_t show_ep_##field(struct usb_device *udev,		\
+		struct usb_endpoint_descriptor *desc, 		\
+		char *buf)					\
+{								\
+	return sprintf(buf, format_string, desc-&gt;field);	\
+}								\
+static EP_ATTR(field);
+
 usb_ep_attr(bLength, "%02x\n")
-usb_ep_attr(bDescriptorType, "%02x\n")
 usb_ep_attr(bEndpointAddress, "%02x\n")
 usb_ep_attr(bmAttributes, "%02x\n")
 usb_ep_attr(bInterval, "%02x\n")
 
-static ssize_t show_ep_wMaxPacketSize(struct device *dev,
-				      struct device_attribute *attr, char *buf)
+static ssize_t show_ep_wMaxPacketSize(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
-
 	return sprintf(buf, "%04x\n",
-		      le16_to_cpu(endpoint_attr-&gt;endpoint-&gt;wMaxPacketSize) &amp; 0x07ff);
+			le16_to_cpu(desc-&gt;wMaxPacketSize) &amp; 0x07ff);
 }
+static EP_ATTR(wMaxPacketSize);
 
-static ssize_t show_ep_type(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_type(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
 	char *type = "unknown";
 
-	switch (endpoint_attr-&gt;endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		type = "Control";
 		break;
@@ -75,35 +88,34 @@ static ssize_t show_ep_type(struct device *dev, struct device_attribute *attr, c
 	}
 	return sprintf(buf, "%s\n", type);
 }
+static EP_ATTR(type);
 
-static ssize_t show_ep_interval(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_interval(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
-	struct usb_device *udev = endpoint_attr-&gt;udev;
-	struct usb_endpoint_descriptor *endpoint = endpoint_attr-&gt;endpoint;
 	char unit;
 	unsigned interval = 0;
 	unsigned in;
 
-	in = (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN);
+	in = (desc-&gt;bEndpointAddress &amp; USB_DIR_IN);
 
-	switch (endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		if (udev-&gt;speed == USB_SPEED_HIGH) 	/* uframes per NAK */
-			interval = endpoint-&gt;bInterval;
+			interval = desc-&gt;bInterval;
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
-		interval = 1 &lt;&lt; (endpoint-&gt;bInterval - 1);
+		interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
 		break;
 	case USB_ENDPOINT_XFER_BULK:
-		if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; !in)	/* uframes per NAK */
-			interval = endpoint-&gt;bInterval;
+		if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; !in) /* uframes per NAK */
+			interval = desc-&gt;bInterval;
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (udev-&gt;speed == USB_SPEED_HIGH) {
-			interval = 1 &lt;&lt; (endpoint-&gt;bInterval - 1);
-		} else
-			interval = endpoint-&gt;bInterval;
+		if (udev-&gt;speed == USB_SPEED_HIGH)
+			interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
+		else
+			interval = desc-&gt;bInterval;
 		break;
 	}
 	interval *= (udev-&gt;speed == USB_SPEED_HIGH) ? 125 : 1000;
@@ -116,78 +128,95 @@ static ssize_t show_ep_interval(struct device *dev, struct device_attribute *att
 
 	return sprintf(buf, "%d%cs\n", interval, unit);
 }
+static EP_ATTR(interval);
 
-static ssize_t show_ep_direction(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_direction(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
 	char *direction;
 
-	if ((endpoint_attr-&gt;endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
-	    USB_ENDPOINT_XFER_CONTROL)
+	if ((desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
+			USB_ENDPOINT_XFER_CONTROL)
 		direction = "both";
-	else if (endpoint_attr-&gt;endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN)
+	else if (desc-&gt;bEndpointAddress &amp; USB_DIR_IN)
 		direction = "in";
 	else
 		direction = "out";
 	return sprintf(buf, "%s\n", direction);
 }
+static EP_ATTR(direction);
+
+static struct attribute *ep_attrs[] = {
+	&amp;ep_bLength.attr,
+	&amp;ep_bEndpointAddress.attr,
+	&amp;ep_bmAttributes.attr,
+	&amp;ep_bInterval.attr,
+	&amp;ep_wMaxPacketSize.attr,
+	&amp;ep_type.attr,
+	&amp;ep_interval.attr,
+	&amp;ep_direction.attr,
+	NULL,
+};
 
-static struct endpoint_attribute *create_ep_attr(struct usb_endpoint_descriptor *endpoint,
-						 struct usb_device *udev, char *name,
-		ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf))
+static void ep_object_release(struct kobject *kobj)
 {
-	struct endpoint_attribute *ep_attr;
-
-	ep_attr = kzalloc(sizeof(*ep_attr), GFP_KERNEL);
-	if (ep_attr) {
-		ep_attr-&gt;endpoint = endpoint;
-		ep_attr-&gt;udev = udev;
-		ep_attr-&gt;dev_attr.attr.name = name;
-		ep_attr-&gt;dev_attr.attr.mode = 0444;
-		ep_attr-&gt;dev_attr.attr.owner = THIS_MODULE;
-		ep_attr-&gt;dev_attr.show = show;
-	}
-	return ep_attr;
+	kfree(to_ep_object(kobj));
 }
 
-static void usb_create_ep_files(struct kobject *kobj, struct usb_host_endpoint *endpoint, struct usb_device *udev)
+static ssize_t ep_object_show(struct kobject *kobj, struct attribute *attr,
+		char *buf)
 {
-	struct usb_endpoint_descriptor *ep;
-
-	ep = &amp;endpoint-&gt;desc;
-
-	endpoint-&gt;attrs = kzalloc(sizeof(struct attribute *) * 10, GFP_KERNEL);
-	endpoint-&gt;attrs[0] = &amp;(create_ep_attr(ep, udev, "direction", show_ep_direction)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[1] = &amp;(create_ep_attr(ep, udev, "type", show_ep_type)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[2] = &amp;(create_ep_attr(ep, udev, "bLength", show_ep_bLength)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[3] = &amp;(create_ep_attr(ep, udev, "bDescriptorType", show_ep_bDescriptorType)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[4] = &amp;(create_ep_attr(ep, udev, "bEndpointAddress", show_ep_bEndpointAddress)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[5] = &amp;(create_ep_attr(ep, udev, "bmAttributes", show_ep_bmAttributes)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[6] = &amp;(create_ep_attr(ep, udev, "wMaxPacketSize", show_ep_wMaxPacketSize)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[7] = &amp;(create_ep_attr(ep, udev, "bInterval", show_ep_bInterval)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[8] = &amp;(create_ep_attr(ep, udev, "interval", show_ep_interval)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[9] = NULL;
-	endpoint-&gt;num_attrs = 9;
-
-	endpoint-&gt;attr_group = kzalloc(sizeof(*endpoint-&gt;attr_group), GFP_KERNEL);
-	endpoint-&gt;attr_name = kzalloc(10, GFP_KERNEL);
-	sprintf(endpoint-&gt;attr_name, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
-
-	endpoint-&gt;attr_group-&gt;attrs = endpoint-&gt;attrs;
-	endpoint-&gt;attr_group-&gt;name = endpoint-&gt;attr_name;
-	sysfs_create_group(kobj, endpoint-&gt;attr_group);
+	struct ep_object *ep_obj = to_ep_object(kobj);
+	struct ep_attribute *ep_attr = to_ep_attribute(attr);
+
+	return (ep_attr-&gt;show)(ep_obj-&gt;udev, ep_obj-&gt;desc, buf);
 }
 
-static void usb_remove_ep_files(struct kobject *kobj, struct usb_host_endpoint *endpoint)
+static struct sysfs_ops ep_object_sysfs_ops = {
+	.show =			ep_object_show,
+};
+
+static struct kobj_type ep_object_ktype = {
+	.release =		ep_object_release,
+	.sysfs_ops =		&amp;ep_object_sysfs_ops,
+	.default_attrs =	ep_attrs,
+};
+
+static void usb_create_ep_files(struct kobject *parent,
+		struct usb_host_endpoint *endpoint,
+		struct usb_device *udev)
 {
-	int i;
+	struct ep_object *ep_obj;
+	struct kobject *kobj;
+
+	ep_obj = kzalloc(sizeof(struct ep_object), GFP_KERNEL);
+	if (!ep_obj)
+		return;
 
-	sysfs_remove_group(kobj, endpoint-&gt;attr_group);
-	kfree(endpoint-&gt;attr_group);
-	kfree(endpoint-&gt;attr_name);
-	for (i = 0; i &lt; endpoint-&gt;num_attrs; ++i)
-		kfree(endpoint-&gt;attrs[i]);
-	kfree(endpoint-&gt;attrs);
+	ep_obj-&gt;desc = &amp;endpoint-&gt;desc;
+	ep_obj-&gt;udev = udev;
+
+	kobj = &amp;ep_obj-&gt;kobj;
+	kobject_set_name(kobj, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
+	kobj-&gt;parent = parent;
+	kobj-&gt;ktype = &amp;ep_object_ktype;
+
+	/* Don't use kobject_register, because it generates a hotplug event */
+	kobject_init(kobj);
+	if (kobject_add(kobj) == 0)
+		endpoint-&gt;kobj = kobj;
+	else
+		kobject_put(kobj);
+}
+
+static void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
+{
+
+	if (endpoint-&gt;kobj) {
+		kobject_del(endpoint-&gt;kobj);
+		kobject_put(endpoint-&gt;kobj);
+		endpoint-&gt;kobj = NULL;
+	}
 }
 
 /* Active configuration fields */
@@ -411,7 +440,7 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 {
 	struct device *dev = &amp;udev-&gt;dev;
 
-	usb_remove_ep_files(&amp;dev-&gt;kobj, &amp;udev-&gt;ep0);
+	usb_remove_ep_files(&amp;udev-&gt;ep0);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 
 	if (udev-&gt;descriptor.iManufacturer)
@@ -496,7 +525,7 @@ static struct attribute_group intf_attr_grp = {
 	.attrs = intf_attrs,
 };
 
-static void usb_create_intf_ep_files(struct usb_interface *intf)
+static inline void usb_create_intf_ep_files(struct usb_interface *intf)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
@@ -504,17 +533,17 @@ static void usb_create_intf_ep_files(struct usb_interface *intf)
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
 		usb_create_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i],
-				    interface_to_usbdev(intf));
+				interface_to_usbdev(intf));
 }
 
-static void usb_remove_intf_ep_files(struct usb_interface *intf)
+static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
 
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
-		usb_remove_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i]);
+		usb_remove_ep_files(&amp;iface_desc-&gt;endpoint[i]);
 }
 
 void usb_create_sysfs_intf_files (struct usb_interface *intf)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a2d923fd54f9..465ff4585ca5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -57,10 +57,7 @@ struct usb_host_endpoint {
 	struct usb_endpoint_descriptor	desc;
 	struct list_head		urb_list;
 	void				*hcpriv;
-	char 				*attr_name;
-	struct attribute_group		*attr_group;
-	struct attribute 		**attrs;
-	int				num_attrs;
+	struct kobject			*kobj;	/* For sysfs info */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;</pre><hr><pre>commit 3f13e66e219238e025ff561d69826da9342c3f4a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:43:36 2005 -0700

    [PATCH] PATCH: usb-storage: use kthread API
    
    This patch is originally from Alan Stern (as569).  It has been rediffed
    against a current tree.
    
    This patch converts usb-storage to use the kthread API for creating its
    control and scanning threads.  The new code doesn't use kthread_stop
    because the threads need (or will need in the future) to exit
    asynchronously.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index c1a902691bc6..3847ebed2aa4 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -54,6 +54,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/kthread.h&gt;
 
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
@@ -310,22 +311,7 @@ static int usb_stor_control_thread(void * __us)
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us_to_host(us);
 
-	lock_kernel();
-
-	/*
-	 * This thread doesn't need any user-level access,
-	 * so get rid of all our resources.
-	 */
-	daemonize("usb-storage");
 	current-&gt;flags |= PF_NOFREEZE;
-	unlock_kernel();
-
-	/* acquire a reference to the host, so it won't be deallocated
-	 * until we're ready to exit */
-	scsi_host_get(host);
-
-	/* signal that we've started the thread */
-	complete(&amp;(us-&gt;notify));
 
 	for(;;) {
 		US_DEBUGP("*** thread sleeping.\n");
@@ -768,6 +754,7 @@ static int get_pipes(struct us_data *us)
 static int usb_stor_acquire_resources(struct us_data *us)
 {
 	int p;
+	struct task_struct *th;
 
 	us-&gt;current_urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!us-&gt;current_urb) {
@@ -784,17 +771,19 @@ static int usb_stor_acquire_resources(struct us_data *us)
 	}
 
 	/* Start up our control thread */
-	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
-	if (p &lt; 0) {
+	th = kthread_create(usb_stor_control_thread, us, "usb-storage");
+	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start control thread\n");
-		return p;
+		return PTR_ERR(th);
 	}
-	us-&gt;pid = p;
-	atomic_inc(&amp;total_threads);
 
-	/* Wait for the thread to start */
-	wait_for_completion(&amp;(us-&gt;notify));
+	/* Take a reference to the host for the control thread and
+	 * count it among all the threads we have launched.  Then
+	 * start it up. */
+	scsi_host_get(us_to_host(us));
+	atomic_inc(&amp;total_threads);
+	wake_up_process(th);
 
 	return 0;
 }
@@ -890,21 +879,6 @@ static int usb_stor_scan_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
 
-	/*
-	 * This thread doesn't need any user-level access,
-	 * so get rid of all our resources.
-	 */
-	lock_kernel();
-	daemonize("usb-stor-scan");
-	unlock_kernel();
-
-	/* Acquire a reference to the host, so it won't be deallocated
-	 * until we're ready to exit */
-	scsi_host_get(us_to_host(us));
-
-	/* Signal that we've started the thread */
-	complete(&amp;(us-&gt;notify));
-
 	printk(KERN_DEBUG
 		"usb-storage: device found at %d\n", us-&gt;pusb_dev-&gt;devnum);
 
@@ -949,6 +923,7 @@ static int storage_probe(struct usb_interface *intf,
 	struct us_data *us;
 	const int id_index = id - storage_usb_ids; 
 	int result;
+	struct task_struct *th;
 
 	US_DEBUGP("USB Mass Storage device detected\n");
 
@@ -1029,17 +1004,21 @@ static int storage_probe(struct usb_interface *intf,
 	}
 
 	/* Start up the thread for delayed SCSI-device scanning */
-	result = kernel_thread(usb_stor_scan_thread, us, CLONE_VM);
-	if (result &lt; 0) {
+	th = kthread_create(usb_stor_scan_thread, us, "usb-stor-scan");
+	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start the device-scanning thread\n");
 		quiesce_and_remove_host(us);
+		result = PTR_ERR(th);
 		goto BadDevice;
 	}
-	atomic_inc(&amp;total_threads);
 
-	/* Wait for the thread to start */
-	wait_for_completion(&amp;(us-&gt;notify));
+	/* Take a reference to the host for the scanning thread and
+	 * count it among all the threads we have launched.  Then
+	 * start it up. */
+	scsi_host_get(us_to_host(us));
+	atomic_inc(&amp;total_threads);
+	wake_up_process(th);
 
 	return 0;
 
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index dfa4dc71dd3e..98b09711a739 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -161,9 +161,6 @@ struct us_data {
 	struct scsi_cmnd	*srb;		 /* current srb		*/
 	unsigned int		tag;		 /* current dCBWTag	*/
 
-	/* thread information */
-	int			pid;		 /* control thread	 */
-
 	/* control and bulk communications data */
 	struct urb		*current_urb;	 /* USB requests	 */
 	struct usb_ctrlrequest	*cr;		 /* control requests	 */</pre><hr><pre>commit ce2596df79ddbac605a290f4c7cf011cb40524fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:41:39 2005 -0700

    [PATCH] PATCH: usb-storage: implement minimal PM
    
    This patch from Alan Stern started as as568.  It has been rediffed against
    a current tree.
    
    This patch adds minimal suspend/resume support to usb-storage.  Just enough
    for it to qualify as PM-aware.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index eb901817b7d2..c1a902691bc6 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -111,11 +111,6 @@ static atomic_t total_threads = ATOMIC_INIT(0);
 static DECLARE_COMPLETION(threads_gone);
 
 
-static int storage_probe(struct usb_interface *iface,
-			 const struct usb_device_id *id);
-
-static void storage_disconnect(struct usb_interface *iface);
-
 /* The entries in this table, except for final ones here
  * (USB_MASS_STORAGE_CLASS and the empty entry), correspond,
  * line for line with the entries of us_unsuaul_dev_list[].
@@ -233,13 +228,40 @@ static struct us_unusual_dev us_unusual_dev_list[] = {
 	{ NULL }
 };
 
-static struct usb_driver usb_storage_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"usb-storage",
-	.probe =	storage_probe,
-	.disconnect =	storage_disconnect,
-	.id_table =	storage_usb_ids,
-};
+
+#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
+
+static int storage_suspend(struct usb_interface *iface, pm_message_t message)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	/* Wait until no command is running */
+	down(&amp;us-&gt;dev_semaphore);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+	iface-&gt;dev.power.power_state.event = message.event;
+
+	/* When runtime PM is working, we'll set a flag to indicate
+	 * whether we should autoresume when a SCSI request arrives. */
+
+	up(&amp;us-&gt;dev_semaphore);
+	return 0;
+}
+
+static int storage_resume(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	down(&amp;us-&gt;dev_semaphore);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+	iface-&gt;dev.power.power_state.event = PM_EVENT_ON;
+
+	up(&amp;us-&gt;dev_semaphore);
+	return 0;
+}
+
+#endif /* CONFIG_PM */
 
 /*
  * fill_inquiry_response takes an unsigned char array (which must
@@ -1042,6 +1064,18 @@ static void storage_disconnect(struct usb_interface *intf)
  * Initialization and registration
  ***********************************************************************/
 
+static struct usb_driver usb_storage_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"usb-storage",
+	.probe =	storage_probe,
+	.disconnect =	storage_disconnect,
+#ifdef CONFIG_PM
+	.suspend =	storage_suspend,
+	.resume =	storage_resume,
+#endif
+	.id_table =	storage_usb_ids,
+};
+
 static int __init usb_stor_init(void)
 {
 	int retval;</pre><hr><pre>commit bbafa4668f37f5093a3ae2a8b0cbe327e24e12da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:40:22 2005 -0700

    [PATCH] PATCH: usb-storage: allocate separate sense buffer
    
    This patch is from Alan Stern (as560).  It has been rediffed against a
    current tree.
    
    This patch allocates a separate buffer for usb-storage to use when
    auto-sensing.  Up to now we have been using the sense buffer embedded in a
    scsi_cmnd struct, which is dangerous on hosts that (a) don't do
    cache-coherent DMA or (b) have DMA alignment restrictions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e89e945fc4a7..7ca896a342e3 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -636,11 +636,11 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 
 		/* use the new buffer we have */
 		old_request_buffer = srb-&gt;request_buffer;
-		srb-&gt;request_buffer = srb-&gt;sense_buffer;
+		srb-&gt;request_buffer = us-&gt;sensebuf;
 
 		/* set the buffer length for transfer */
 		old_request_bufflen = srb-&gt;request_bufflen;
-		srb-&gt;request_bufflen = 18;
+		srb-&gt;request_bufflen = US_SENSE_SIZE;
 
 		/* set up for no scatter-gather use */
 		old_sg = srb-&gt;use_sg;
@@ -652,6 +652,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		temp_result = us-&gt;transport(us-&gt;srb, us);
 
 		/* let's clean up right away */
+		memcpy(srb-&gt;sense_buffer, us-&gt;sensebuf, US_SENSE_SIZE);
 		srb-&gt;resid = old_resid;
 		srb-&gt;request_buffer = old_request_buffer;
 		srb-&gt;request_bufflen = old_request_bufflen;
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 92ee079d9172..eb901817b7d2 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -467,6 +467,12 @@ static int associate_dev(struct us_data *us, struct usb_interface *intf)
 		US_DEBUGP("I/O buffer allocation failed\n");
 		return -ENOMEM;
 	}
+
+	us-&gt;sensebuf = kmalloc(US_SENSE_SIZE, GFP_KERNEL);
+	if (!us-&gt;sensebuf) {
+		US_DEBUGP("Sense buffer allocation failed\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -800,6 +806,8 @@ static void dissociate_dev(struct us_data *us)
 {
 	US_DEBUGP("-- %s\n", __FUNCTION__);
 
+	kfree(us-&gt;sensebuf);
+
 	/* Free the device-related DMA-mapped buffers */
 	if (us-&gt;cr)
 		usb_buffer_free(us-&gt;pusb_dev, sizeof(*us-&gt;cr), us-&gt;cr,
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index a195adae57b6..dfa4dc71dd3e 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -117,6 +117,7 @@ enum { US_DO_ALL_FLAGS };
  */
 
 #define US_IOBUF_SIZE		64	/* Size of the DMA-mapped I/O buffer */
+#define US_SENSE_SIZE		18	/* Size of the autosense data buffer */
 
 typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data*);
 typedef int (*trans_reset)(struct us_data*);
@@ -168,6 +169,7 @@ struct us_data {
 	struct usb_ctrlrequest	*cr;		 /* control requests	 */
 	struct usb_sg_request	current_sg;	 /* scatter-gather req.  */
 	unsigned char		*iobuf;		 /* I/O buffer		 */
+	unsigned char		*sensebuf;	 /* sense data buffer	 */
 	dma_addr_t		cr_dma;		 /* buffer DMA addresses */
 	dma_addr_t		iobuf_dma;
 </pre><hr><pre>commit b876aef7f890d8c59a45b78858a36cf60fddf522
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:38:56 2005 -0700

    [PATCH] PATCH: usb-storage: move GetMaxLUN later in time
    
    This patch is originally from Alan Stern (as557).  It has been re-diffed
    against a current tree, and I also corrected a minor merging error.
    
    Some time ago we introduced a delay before device scanning, because many
    devices do not like to receive SCSI commands right after enumeration.
    Now it turns out there's a device that doesn't like to receive
    Get-Max-LUN right after enumeration either.  Accordingly this patch
    delays the Get-Max-LUN request until the beginning of the scanning
    procedure.  This fixes Bugzilla entry #5010.
    
    Three things are worth noting.  First, I removed the locking code from
    usb_stor_acquire_resources.  It's not needed, because the locking is to
    protect against disconnect events and acquire_resources is only called
    during probe (so the disconnect routine can't be called).  Second, I
    initialized to 0 the buffer used for the Get-Max-LUN response.  It's not
    really necessary, but it will prevent random values from showing up in
    the debugging log when the request fails.  Third, I added a test against
    the SINGLE_LUN flag.  This will allow us to use the flag to indicate
    Bulk-only devices that can't handle Get-Max-LUN.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index c1ba5301ebfc..e89e945fc4a7 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -923,6 +923,7 @@ int usb_stor_Bulk_max_lun(struct us_data *us)
 	int result;
 
 	/* issue the command */
+	us-&gt;iobuf[0] = 0;
 	result = usb_stor_control_msg(us, us-&gt;recv_ctrl_pipe,
 				 US_BULK_GET_MAX_LUN, 
 				 USB_DIR_IN | USB_TYPE_CLASS | 
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 5164900e40c1..92ee079d9172 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -747,25 +747,13 @@ static int usb_stor_acquire_resources(struct us_data *us)
 		return -ENOMEM;
 	}
 
-	/* Lock the device while we carry out the next two operations */
-	down(&amp;us-&gt;dev_semaphore);
-
-	/* For bulk-only devices, determine the max LUN value */
-	if (us-&gt;protocol == US_PR_BULK) {
-		p = usb_stor_Bulk_max_lun(us);
-		if (p &lt; 0) {
-			up(&amp;us-&gt;dev_semaphore);
-			return p;
-		}
-		us-&gt;max_lun = p;
-	}
-
 	/* Just before we start our control thread, initialize
 	 * the device if it needs initialization */
-	if (us-&gt;unusual_dev-&gt;initFunction)
-		us-&gt;unusual_dev-&gt;initFunction(us);
-
-	up(&amp;us-&gt;dev_semaphore);
+	if (us-&gt;unusual_dev-&gt;initFunction) {
+		p = us-&gt;unusual_dev-&gt;initFunction(us);
+		if (p)
+			return p;
+	}
 
 	/* Start up our control thread */
 	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
@@ -904,6 +892,14 @@ static int usb_stor_scan_thread(void * __us)
 
 	/* If the device is still connected, perform the scanning */
 	if (!test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+
+		/* For bulk-only devices, determine the max LUN value */
+		if (us-&gt;protocol == US_PR_BULK &amp;&amp;
+				!(us-&gt;flags &amp; US_FL_SINGLE_LUN)) {
+			down(&amp;us-&gt;dev_semaphore);
+			us-&gt;max_lun = usb_stor_Bulk_max_lun(us);
+			up(&amp;us-&gt;dev_semaphore);
+		}
 		scsi_scan_host(us_to_host(us));
 		printk(KERN_DEBUG "usb-storage: device scan complete\n");
 </pre><hr><pre>commit 423e489d704d05c6e8c2927fb1854db85914912a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 13:06:13 2005 -0400

    [PATCH] hid-core: Add Clear-Halt on the Interrupt-in endpoint
    
    This patch (as577) adds a Clear-Halt call on the Interrupt-in endpoint
    during input device configuration.  Without it my HP USB keyboard doesn't
    work.
    
    Vojtech says it's worth trying, since it might help with some recalcitrant
    devices.  On the other hand, it might interfere with others.  I'm
    submitting it so that it can get tested by a range of users.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index f7fcce731f54..79ddce4555ab 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1784,6 +1784,9 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 	hid-&gt;urbctrl-&gt;transfer_dma = hid-&gt;ctrlbuf_dma;
 	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
 
+	/* May be needed for some devices */
+	usb_clear_halt(hid-&gt;dev, hid-&gt;urbin-&gt;pipe);
+
 	return hid;
 
 fail:</pre><hr><pre>commit 478a3bab8c87a9ba4a4ba338314e32bb0c378e62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 12:52:02 2005 -0400

    [PATCH] USB: Always do usb-handoff
    
    This revised patch (as586b) makes usb-handoff permanently true and no
    longer a kernel boot parameter.  It also removes the piix3_usb quirk code;
    that was nothing more than an early version of the USB handoff code
    (written at a time when Intel's PIIX3 was about the only motherboard with
    USB support).  And it adds identifiers for the three PCI USB controller
    classes to pci_ids.h.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 971589a9752d..90766b75d1b7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1517,8 +1517,6 @@ running once the system is up.
 	uart6850=	[HW,OSS]
 			Format: &lt;io&gt;,&lt;irq&gt;
 
-	usb-handoff	[HW] Enable early USB BIOS -&gt; OS handoff
-
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index f7411ca48835..b7fd3f644e1e 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -23,33 +23,6 @@
 #include &lt;linux/acpi.h&gt;
 
 
-/*
- * PIIX3 USB: We have to disable USB interrupts that are
- * hardwired to PIRQD# and may be shared with an
- * external device.
- *
- * Legacy Support Register (LEGSUP):
- *     bit13:  USB PIRQ Enable (USBPIRQDEN),
- *     bit4:   Trap/SMI On IRQ Enable (USBSMIEN).
- *
- * We mask out all r/wc bits, too.
- */
-static void __devinit quirk_piix3_usb(struct pci_dev *dev)
-{
-	u16 legsup;
-
-	pci_read_config_word(dev, 0xc0, &amp;legsup);
-	legsup &amp;= 0x50ef;
-	pci_write_config_word(dev, 0xc0, legsup);
-}
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371SB_2,	quirk_piix3_usb );
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	quirk_piix3_usb );
-
-
-/* FIXME these should be the guts of hcd-&gt;reset() methods; resolve all
- * the differences between this version and the HCD's version.
- */
-
 #define UHCI_USBLEGSUP		0xc0		/* legacy support */
 #define UHCI_USBCMD		0		/* command register */
 #define UHCI_USBINTR		4		/* interrupt register */
@@ -83,13 +56,6 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	qui
 #define EHCI_USBLEGCTLSTS	4		/* legacy control/status */
 #define EHCI_USBLEGCTLSTS_SOOE	(1 &lt;&lt; 13)	/* SMI on ownership change */
 
-int usb_early_handoff __devinitdata = 0;
-static int __init usb_handoff_early(char *str)
-{
-	usb_early_handoff = 1;
-	return 0;
-}
-__setup("usb-handoff", usb_handoff_early);
 
 /*
  * Make sure the controller is completely inactive, unable to
@@ -320,17 +286,11 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 
 static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 {
-	if (!usb_early_handoff)
-		return;
-
-	if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x00)) { /* UHCI */
+	if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_UHCI)
 		quirk_usb_handoff_uhci(pdev);
-	} else if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x10)) { /* OHCI */
+	else if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_OHCI)
 		quirk_usb_handoff_ohci(pdev);
-	} else if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x20)) { /* EHCI */
+	else if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_EHCI)
 		quirk_usb_disable_ehci(pdev);
-	}
-
-	return;
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
diff --git a/include/asm-i386/mach-summit/mach_mpparse.h b/include/asm-i386/mach-summit/mach_mpparse.h
index 2b9e6d55bef1..1cce2b924a80 100644
--- a/include/asm-i386/mach-summit/mach_mpparse.h
+++ b/include/asm-i386/mach-summit/mach_mpparse.h
@@ -22,7 +22,6 @@ static inline void mpc_oem_pci_bus(struct mpc_config_bus *m,
 {
 }
 
-extern int usb_early_handoff;
 static inline int mps_oem_check(struct mp_config_table *mpc, char *oem, 
 		char *productid)
 {
@@ -32,7 +31,6 @@ static inline int mps_oem_check(struct mp_config_table *mpc, char *oem,
 			 || !strncmp(productid, "RUTHLESS SMP", 12))){
 		use_cyclone = 1; /*enable cyclone-timer*/
 		setup_summit();
-		usb_early_handoff = 1;
 		return 1;
 	}
 	return 0;
@@ -46,7 +44,6 @@ static inline int acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 	     || !strncmp(oem_table_id, "EXA", 3))){
 		use_cyclone = 1; /*enable cyclone-timer*/
 		setup_summit();
-		usb_early_handoff = 1;
 		return 1;
 	}
 	return 0;
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 7d300f7469e3..467a096c3b81 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -96,6 +96,9 @@
 #define PCI_CLASS_SERIAL_ACCESS		0x0c01
 #define PCI_CLASS_SERIAL_SSA		0x0c02
 #define PCI_CLASS_SERIAL_USB		0x0c03
+#define PCI_CLASS_SERIAL_USB_UHCI	0x0c0300
+#define PCI_CLASS_SERIAL_USB_OHCI	0x0c0310
+#define PCI_CLASS_SERIAL_USB_EHCI	0x0c0320
 #define PCI_CLASS_SERIAL_FIBER		0x0c04
 #define PCI_CLASS_SERIAL_SMBUS		0x0c05
 </pre>
    <div class="pagination">
        <a href='2_132.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><span>[133]</span><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_134.html'>Next&gt;&gt;</a>
    <div>
</body>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_48.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><span>[49]</span><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_50.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5cbe61c5aff0a8ada691eb8b07dbfb55c303f640
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 11:20:06 2012 -0400

    usb-serial: ftdi_sio: fix oops during autosuspend
    
    This patch (as1550) fixes a bug in the usb-serial core that affects
    the ftdi_sio driver and most likely others as well.  The core
    implements suspend and resume routines, but it doesn't store pointers
    to those routines in the usb_driver structures that it registers,
    even though it does set those drivers' supports_autosuspend flag.  The
    end result is that when one of these devices is autosuspended, we try
    to call through a NULL pointer.
    
    The patch fixes the problem by setting the suspend and resume method
    pointers to the appropriate routines in the USB serial core, along
    with the supports_autosuspend field, in each driver as it is
    registered.
    
    This should be back-ported to all the stable kernels that have the new
    usb_serial_register_drivers() interface.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Frank Sch√§fer &lt;schaefer.frank@gmx.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 906f06e97fde..f7b263e237ef 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1336,7 +1336,6 @@ static int usb_serial_register(struct usb_serial_driver *driver)
 				driver-&gt;description);
 		return -EINVAL;
 	}
-	driver-&gt;usb_driver-&gt;supports_autosuspend = 1;
 
 	/* Add this device to our list of devices */
 	mutex_lock(&amp;table_lock);
@@ -1371,7 +1370,7 @@ static void usb_serial_deregister(struct usb_serial_driver *device)
  * @serial_drivers: NULL-terminated array of pointers to drivers to be registered
  *
  * Registers @udriver and all the drivers in the @serial_drivers array.
- * Automatically fills in the .no_dynamic_id field in @udriver and
+ * Automatically fills in the .no_dynamic_id and PM fields in @udriver and
  * the .usb_driver field in each serial driver.
  */
 int usb_serial_register_drivers(struct usb_driver *udriver,
@@ -1390,11 +1389,17 @@ int usb_serial_register_drivers(struct usb_driver *udriver,
 	 * the serial drivers are registered, because the probe would
 	 * simply fail for lack of a matching serial driver.
 	 * Therefore save off udriver's id_table until we are all set.
+	 *
+	 * Suspend/resume support is implemented in the usb-serial core,
+	 * so fill in the PM-related fields in udriver.
 	 */
 	saved_id_table = udriver-&gt;id_table;
 	udriver-&gt;id_table = NULL;
 
 	udriver-&gt;no_dynamic_id = 1;
+	udriver-&gt;supports_autosuspend = 1;
+	udriver-&gt;suspend = usb_serial_suspend;
+	udriver-&gt;resume = usb_serial_resume;
 	rc = usb_register(udriver);
 	if (rc)
 		return rc;</pre><hr><pre>commit ebf20de453042c066a289b90dd14d59de03dba2f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 1 11:28:49 2012 -0400

    EHCI: update PM methods in ehci-tegra.c
    
    This patch (as1547) rearranges the Power Management parts of the
    ehci-tegra driver to match the conventions used in other EHCI platform
    drivers.  In particular, the controller should not be powered down by
    the root hub's suspend routine; the controller's power level should be
    managed by the controller's own PM methods.
    
    The end result of the patch is that the standard ehci_bus_suspend()
    and ehci_bus_resume() methods can be used instead of special-purpose
    routines.  The driver now uses the standard dev_pm_ops methods instead
    of legacy power management.  Since there is no supported wakeup
    mechanism for the controller, runtime suspend is forbidden by default
    (this can be overridden via sysfs, if desired).
    
    These adjustments are needed in order to make ehci-tegra compatible
    with recent changes to the USB core.  The core now checks the root
    hub's status following bus suspend; if the controller is automatically
    powered down during bus suspend then the check will fail and the root
    hub will be resumed immediately.  Doing the controller power-down in a
    separate method avoids this problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Tested-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 86183366647f..73f3525e6921 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -24,6 +24,7 @@
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_gpio.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;mach/usb_phy.h&gt;
 #include &lt;mach/iomap.h&gt;
@@ -37,9 +38,7 @@ struct tegra_ehci_hcd {
 	struct clk *emc_clk;
 	struct usb_phy *transceiver;
 	int host_resumed;
-	int bus_suspended;
 	int port_resuming;
-	int power_down_on_bus_suspend;
 	enum tegra_usb_phy_port_speed port_speed;
 };
 
@@ -273,120 +272,6 @@ static void tegra_ehci_restart(struct usb_hcd *hcd)
 	up_write(&amp;ehci_cf_port_reset_rwsem);
 }
 
-static int tegra_usb_suspend(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	struct ehci_regs __iomem *hw = tegra-&gt;ehci-&gt;regs;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;tegra-&gt;ehci-&gt;lock, flags);
-
-	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
-	ehci_halt(tegra-&gt;ehci);
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	spin_unlock_irqrestore(&amp;tegra-&gt;ehci-&gt;lock, flags);
-
-	tegra_ehci_power_down(hcd);
-	return 0;
-}
-
-static int tegra_usb_resume(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	struct ehci_regs __iomem *hw = ehci-&gt;regs;
-	unsigned long val;
-
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	tegra_ehci_power_up(hcd);
-
-	if (tegra-&gt;port_speed &gt; TEGRA_USB_PHY_PORT_SPEED_HIGH) {
-		/* Wait for the phy to detect new devices
-		 * before we restart the controller */
-		msleep(10);
-		goto restart;
-	}
-
-	/* Force the phy to keep data lines in suspend state */
-	tegra_ehci_phy_restore_start(tegra-&gt;phy, tegra-&gt;port_speed);
-
-	/* Enable host mode */
-	tdi_reset(ehci);
-
-	/* Enable Port Power */
-	val = readl(&amp;hw-&gt;port_status[0]);
-	val |= PORT_POWER;
-	writel(val, &amp;hw-&gt;port_status[0]);
-	udelay(10);
-
-	/* Check if the phy resume from LP0. When the phy resume from LP0
-	 * USB register will be reset. */
-	if (!readl(&amp;hw-&gt;async_next)) {
-		/* Program the field PTC based on the saved speed mode */
-		val = readl(&amp;hw-&gt;port_status[0]);
-		val &amp;= ~PORT_TEST(~0);
-		if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_HIGH)
-			val |= PORT_TEST_FORCE;
-		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_FULL)
-			val |= PORT_TEST(6);
-		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)
-			val |= PORT_TEST(7);
-		writel(val, &amp;hw-&gt;port_status[0]);
-		udelay(10);
-
-		/* Disable test mode by setting PTC field to NORMAL_OP */
-		val = readl(&amp;hw-&gt;port_status[0]);
-		val &amp;= ~PORT_TEST(~0);
-		writel(val, &amp;hw-&gt;port_status[0]);
-		udelay(10);
-	}
-
-	/* Poll until CCS is enabled */
-	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_CONNECT,
-						 PORT_CONNECT, 2000)) {
-		pr_err("%s: timeout waiting for PORT_CONNECT\n", __func__);
-		goto restart;
-	}
-
-	/* Poll until PE is enabled */
-	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_PE,
-						 PORT_PE, 2000)) {
-		pr_err("%s: timeout waiting for USB_PORTSC1_PE\n", __func__);
-		goto restart;
-	}
-
-	/* Clear the PCI status, to avoid an interrupt taken upon resume */
-	val = readl(&amp;hw-&gt;status);
-	val |= STS_PCD;
-	writel(val, &amp;hw-&gt;status);
-
-	/* Put controller in suspend mode by writing 1 to SUSP bit of PORTSC */
-	val = readl(&amp;hw-&gt;port_status[0]);
-	if ((val &amp; PORT_POWER) &amp;&amp; (val &amp; PORT_PE)) {
-		val |= PORT_SUSPEND;
-		writel(val, &amp;hw-&gt;port_status[0]);
-
-		/* Wait until port suspend completes */
-		if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_SUSPEND,
-							 PORT_SUSPEND, 1000)) {
-			pr_err("%s: timeout waiting for PORT_SUSPEND\n",
-								__func__);
-			goto restart;
-		}
-	}
-
-	tegra_ehci_phy_restore_end(tegra-&gt;phy);
-	return 0;
-
-restart:
-	if (tegra-&gt;port_speed &lt;= TEGRA_USB_PHY_PORT_SPEED_HIGH)
-		tegra_ehci_phy_restore_end(tegra-&gt;phy);
-
-	tegra_ehci_restart(hcd);
-	return 0;
-}
-
 static void tegra_ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
@@ -434,36 +319,6 @@ static int tegra_ehci_setup(struct usb_hcd *hcd)
 	return retval;
 }
 
-#ifdef CONFIG_PM
-static int tegra_ehci_bus_suspend(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	int error_status = 0;
-
-	error_status = ehci_bus_suspend(hcd);
-	if (!error_status &amp;&amp; tegra-&gt;power_down_on_bus_suspend) {
-		tegra_usb_suspend(hcd);
-		tegra-&gt;bus_suspended = 1;
-	}
-
-	return error_status;
-}
-
-static int tegra_ehci_bus_resume(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-
-	if (tegra-&gt;bus_suspended &amp;&amp; tegra-&gt;power_down_on_bus_suspend) {
-		tegra_usb_resume(hcd);
-		tegra-&gt;bus_suspended = 0;
-	}
-
-	tegra_usb_phy_preresume(tegra-&gt;phy);
-	tegra-&gt;port_resuming = 1;
-	return ehci_bus_resume(hcd);
-}
-#endif
-
 struct temp_buffer {
 	void *kmalloc_ptr;
 	void *old_xfer_buffer;
@@ -574,8 +429,8 @@ static const struct hc_driver tegra_ehci_hc_driver = {
 	.hub_control		= tegra_ehci_hub_control,
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 #ifdef CONFIG_PM
-	.bus_suspend		= tegra_ehci_bus_suspend,
-	.bus_resume		= tegra_ehci_bus_resume,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
 	.port_handed_over	= ehci_port_handed_over,
@@ -608,6 +463,183 @@ static int setup_vbus_gpio(struct platform_device *pdev)
 	return err;
 }
 
+#ifdef CONFIG_PM
+
+static int controller_suspend(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct ehci_hcd	*ehci = tegra-&gt;ehci;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct ehci_regs __iomem *hw = ehci-&gt;regs;
+	unsigned long flags;
+
+	if (time_before(jiffies, ehci-&gt;next_statechange))
+		msleep(10);
+
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
+	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
+	ehci_halt(ehci);
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+
+	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+
+	tegra_ehci_power_down(hcd);
+	return 0;
+}
+
+static int controller_resume(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct ehci_hcd	*ehci = tegra-&gt;ehci;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct ehci_regs __iomem *hw = ehci-&gt;regs;
+	unsigned long val;
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	tegra_ehci_power_up(hcd);
+
+	if (tegra-&gt;port_speed &gt; TEGRA_USB_PHY_PORT_SPEED_HIGH) {
+		/* Wait for the phy to detect new devices
+		 * before we restart the controller */
+		msleep(10);
+		goto restart;
+	}
+
+	/* Force the phy to keep data lines in suspend state */
+	tegra_ehci_phy_restore_start(tegra-&gt;phy, tegra-&gt;port_speed);
+
+	/* Enable host mode */
+	tdi_reset(ehci);
+
+	/* Enable Port Power */
+	val = readl(&amp;hw-&gt;port_status[0]);
+	val |= PORT_POWER;
+	writel(val, &amp;hw-&gt;port_status[0]);
+	udelay(10);
+
+	/* Check if the phy resume from LP0. When the phy resume from LP0
+	 * USB register will be reset. */
+	if (!readl(&amp;hw-&gt;async_next)) {
+		/* Program the field PTC based on the saved speed mode */
+		val = readl(&amp;hw-&gt;port_status[0]);
+		val &amp;= ~PORT_TEST(~0);
+		if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_HIGH)
+			val |= PORT_TEST_FORCE;
+		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_FULL)
+			val |= PORT_TEST(6);
+		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)
+			val |= PORT_TEST(7);
+		writel(val, &amp;hw-&gt;port_status[0]);
+		udelay(10);
+
+		/* Disable test mode by setting PTC field to NORMAL_OP */
+		val = readl(&amp;hw-&gt;port_status[0]);
+		val &amp;= ~PORT_TEST(~0);
+		writel(val, &amp;hw-&gt;port_status[0]);
+		udelay(10);
+	}
+
+	/* Poll until CCS is enabled */
+	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_CONNECT,
+						 PORT_CONNECT, 2000)) {
+		pr_err("%s: timeout waiting for PORT_CONNECT\n", __func__);
+		goto restart;
+	}
+
+	/* Poll until PE is enabled */
+	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_PE,
+						 PORT_PE, 2000)) {
+		pr_err("%s: timeout waiting for USB_PORTSC1_PE\n", __func__);
+		goto restart;
+	}
+
+	/* Clear the PCI status, to avoid an interrupt taken upon resume */
+	val = readl(&amp;hw-&gt;status);
+	val |= STS_PCD;
+	writel(val, &amp;hw-&gt;status);
+
+	/* Put controller in suspend mode by writing 1 to SUSP bit of PORTSC */
+	val = readl(&amp;hw-&gt;port_status[0]);
+	if ((val &amp; PORT_POWER) &amp;&amp; (val &amp; PORT_PE)) {
+		val |= PORT_SUSPEND;
+		writel(val, &amp;hw-&gt;port_status[0]);
+
+		/* Wait until port suspend completes */
+		if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_SUSPEND,
+							 PORT_SUSPEND, 1000)) {
+			pr_err("%s: timeout waiting for PORT_SUSPEND\n",
+								__func__);
+			goto restart;
+		}
+	}
+
+	tegra_ehci_phy_restore_end(tegra-&gt;phy);
+	goto done;
+
+ restart:
+	if (tegra-&gt;port_speed &lt;= TEGRA_USB_PHY_PORT_SPEED_HIGH)
+		tegra_ehci_phy_restore_end(tegra-&gt;phy);
+
+	tegra_ehci_restart(hcd);
+
+ done:
+	tegra_usb_phy_preresume(tegra-&gt;phy);
+	tegra-&gt;port_resuming = 1;
+	return 0;
+}
+
+static int tegra_ehci_suspend(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
+	int rc = 0;
+
+	/*
+	 * When system sleep is supported and USB controller wakeup is
+	 * implemented: If the controller is runtime-suspended and the
+	 * wakeup setting needs to be changed, call pm_runtime_resume().
+	 */
+	if (HCD_HW_ACCESSIBLE(hcd))
+		rc = controller_suspend(dev);
+	return rc;
+}
+
+static int tegra_ehci_resume(struct device *dev)
+{
+	int rc;
+
+	rc = controller_resume(dev);
+	if (rc == 0) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_active(dev);
+		pm_runtime_enable(dev);
+	}
+	return rc;
+}
+
+static int tegra_ehci_runtime_suspend(struct device *dev)
+{
+	return controller_suspend(dev);
+}
+
+static int tegra_ehci_runtime_resume(struct device *dev)
+{
+	return controller_resume(dev);
+}
+
+static const struct dev_pm_ops tegra_ehci_pm_ops = {
+	.suspend	= tegra_ehci_suspend,
+	.resume		= tegra_ehci_resume,
+	.runtime_suspend = tegra_ehci_runtime_suspend,
+	.runtime_resume	= tegra_ehci_runtime_resume,
+};
+
+#endif
+
 static u64 tegra_ehci_dma_mask = DMA_BIT_MASK(32);
 
 static int tegra_ehci_probe(struct platform_device *pdev)
@@ -722,7 +754,6 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 	}
 
 	tegra-&gt;host_resumed = 1;
-	tegra-&gt;power_down_on_bus_suspend = pdata-&gt;power_down_on_bus_suspend;
 	tegra-&gt;ehci = hcd_to_ehci(hcd);
 
 	irq = platform_get_irq(pdev, 0);
@@ -746,6 +777,14 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
+	pm_runtime_set_active(&amp;pdev-&gt;dev);
+	pm_runtime_get_noresume(&amp;pdev-&gt;dev);
+
+	/* Don't skip the pm_runtime_forbid call if wakeup isn't working */
+	/* if (!pdata-&gt;power_down_on_bus_suspend) */
+		pm_runtime_forbid(&amp;pdev-&gt;dev);
+	pm_runtime_enable(&amp;pdev-&gt;dev);
+	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 	return err;
 
 fail:
@@ -772,33 +811,6 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 	return err;
 }
 
-#ifdef CONFIG_PM
-static int tegra_ehci_resume(struct platform_device *pdev)
-{
-	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
-
-	if (tegra-&gt;bus_suspended)
-		return 0;
-
-	return tegra_usb_resume(hcd);
-}
-
-static int tegra_ehci_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
-
-	if (tegra-&gt;bus_suspended)
-		return 0;
-
-	if (time_before(jiffies, tegra-&gt;ehci-&gt;next_statechange))
-		msleep(10);
-
-	return tegra_usb_suspend(hcd);
-}
-#endif
-
 static int tegra_ehci_remove(struct platform_device *pdev)
 {
 	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
@@ -807,6 +819,10 @@ static int tegra_ehci_remove(struct platform_device *pdev)
 	if (tegra == NULL || hcd == NULL)
 		return -EINVAL;
 
+	pm_runtime_get_sync(&amp;pdev-&gt;dev);
+	pm_runtime_disable(&amp;pdev-&gt;dev);
+	pm_runtime_put_noidle(&amp;pdev-&gt;dev);
+
 #ifdef CONFIG_USB_OTG_UTILS
 	if (tegra-&gt;transceiver) {
 		otg_set_host(tegra-&gt;transceiver-&gt;otg, NULL);
@@ -847,13 +863,12 @@ static struct of_device_id tegra_ehci_of_match[] __devinitdata = {
 static struct platform_driver tegra_ehci_driver = {
 	.probe		= tegra_ehci_probe,
 	.remove		= tegra_ehci_remove,
-#ifdef CONFIG_PM
-	.suspend	= tegra_ehci_suspend,
-	.resume		= tegra_ehci_resume,
-#endif
 	.shutdown	= tegra_ehci_hcd_shutdown,
 	.driver		= {
 		.name	= "tegra-ehci",
 		.of_match_table = tegra_ehci_of_match,
+#ifdef CONFIG_PM
+		.pm	= &amp;tegra_ehci_pm_ops,
+#endif
 	}
 };</pre><hr><pre>commit 320cd1e750f1bf3e47eb41209dcb2be07264cb76
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 26 11:31:57 2012 -0400

    usb: gadget: udc-core: fix incompatibility with dummy-hcd
    
    This patch (as1548) fixes a recently-introduced incompatibility
    between the UDC core and the dummy-hcd driver.  Commit
    8ae8090c82eb407267001f75b3d256b3bd4ae691 (usb: gadget: udc-core: fix
    asymmetric calls in remove_driver) moved the usb_gadget_udc_stop()
    call in usb_gadget_remove_driver() below the usb_gadget_disconnect()
    call.
    
    As a result, usb_gadget_disconnect() gets called at a time when the
    gadget driver believes it has been unbound but dummy-hcd believes
    it has not.  A nasty error ensues when dummy-hcd calls the gadget
    driver's disconnect method a second time.
    
    To fix the problem, this patch moves the gadget driver's unbind
    notification after the usb_gadget_disconnect() call.  Now nothing
    happens between the two unbind notifications, so nothing goes wrong.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index df1bd87232dd..e5e44f8cde9a 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -263,8 +263,8 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 
 	if (udc_is_newstyle(udc)) {
 		udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
-		udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
 		usb_gadget_disconnect(udc-&gt;gadget);
+		udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
 		usb_gadget_udc_stop(udc-&gt;gadget, udc-&gt;driver);
 	} else {
 		usb_gadget_stop(udc-&gt;gadget, udc-&gt;driver);</pre><hr><pre>commit 151b61284776be2d6f02d48c23c3625678960b97
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 24 14:07:22 2012 -0400

    USB: EHCI: fix crash during suspend on ASUS computers
    
    This patch (as1545) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    This fixes Bugzilla #42728.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Steven Rostedt &lt;rostedt@goodmis.org&gt;
    Tested-by: Andrey Rahmatullin &lt;wrar@wrar.name&gt;
    Tested-by: Oleksij Rempel (fishor) &lt;bug-track@fisher-privat.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 622b4a48e732..57ed9e400c06 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -493,6 +493,15 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 
 	pci_save_state(pci_dev);
 
+	/*
+	 * Some systems crash if an EHCI controller is in D3 during
+	 * a sleep transition.  We have to leave such controllers in D0.
+	 */
+	if (hcd-&gt;broken_pci_sleep) {
+		dev_dbg(dev, "Staying in PCI D0\n");
+		return retval;
+	}
+
 	/* If the root hub is dead rather than suspended, disallow remote
 	 * wakeup.  usb_hc_died() should ensure that both hosts are marked as
 	 * dying, so we only need to check the primary roothub.
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 01bb7241d6ef..fe8dc069164e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -144,6 +144,14 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
+		if (pdev-&gt;subsystem_vendor == PCI_VENDOR_ID_ASUSTEK) {
+			/* EHCI #1 or #2 on 6 Series/C200 Series chipset */
+			if (pdev-&gt;device == 0x1c26 || pdev-&gt;device == 0x1c2d) {
+				ehci_info(ehci, "broken D3 during system sleep on ASUS\n");
+				hcd-&gt;broken_pci_sleep = 1;
+				device_set_wakeup_capable(&amp;pdev-&gt;dev, false);
+			}
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 5de415707c23..d28cc78a38e4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,6 +126,8 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
+	unsigned		broken_pci_sleep:1;	/* Don't put the
+			controller in PCI-D3 for system sleep */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */</pre><hr><pre>commit 3d9545cc375d117554a9b35dfddadf9189c62775
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 23 13:54:36 2012 -0400

    EHCI: maintain the ehci-&gt;command value properly
    
    The ehci-hcd driver is a little haphazard about keeping track of the
    state of the USBCMD register.  The ehci-&gt;command field is supposed to
    hold the register's value (apart from a few special bits) at all
    times, but it isn't maintained properly.
    
    This patch (as1543) cleans up the situation.  It keeps ehci-&gt;command
    up-to-date, and uses that value rather than reading the register from
    the hardware whenever possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 680e1a31fb87..7561966fbdc4 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -1025,10 +1025,8 @@ static ssize_t debug_lpm_write(struct file *file, const char __user *user_buf,
 		if (strict_strtoul(buf + 5, 16, &amp;hird))
 			return -EINVAL;
 		printk(KERN_INFO "setting hird %s %lu\n", buf + 6, hird);
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-		temp &amp;= ~CMD_HIRD;
-		temp |= hird &lt;&lt; 24;
-		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
+		ehci-&gt;command = (ehci-&gt;command &amp; ~CMD_HIRD) | (hird &lt;&lt; 24);
+		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	} else if (strncmp(buf, "disable", 7) == 0) {
 		if (strict_strtoul(buf + 8, 10, &amp;port))
 			return -EINVAL;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a87c0573c860..de1e689d3df0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -226,8 +226,13 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	if ((temp &amp; STS_HALT) != 0)
 		return 0;
 
+	/*
+	 * This routine gets called during probe before ehci-&gt;command
+	 * has been initialized, so we can't rely on its value.
+	 */
+	ehci-&gt;command &amp;= ~CMD_RUN;
 	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	temp &amp;= ~CMD_RUN;
+	temp &amp;= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
 	return handshake (ehci, &amp;ehci-&gt;regs-&gt;status,
 			  STS_HALT, STS_HALT, 16 * 125);
@@ -347,6 +352,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci-&gt;debug)
 		dbgp_external_startup();
 
+	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci-&gt;port_c_suspend = ehci-&gt;suspended_ports =
 			ehci-&gt;resuming_ports = 0;
 	return retval;
@@ -363,16 +369,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 #endif
 
 	/* wait for any schedule enables/disables to take effect */
-	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &lt;&lt; 10;
-	temp &amp;= STS_ASS | STS_PSS;
+	temp = (ehci-&gt;command &lt;&lt; 10) &amp; (STS_ASS | STS_PSS);
 	if (handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS | STS_PSS, temp, 16 * 125))
 		return;
 
 	/* then disable anything that's still active */
-	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	temp &amp;= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
-	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 402e766df2fe..fc9e7cc6ac9b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -233,7 +233,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	/* stop schedules, clean any completed work */
 	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
-	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci_work(ehci);
 
 	/* Unlike other USB host controller types, EHCI doesn't have
@@ -374,6 +373,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
+	ehci-&gt;command |= CMD_RUN;
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 36ca5077cdf7..13f4f980841a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -981,14 +981,12 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head = ehci-&gt;async;
 	timer_action_done (ehci, TIMER_ASYNC_OFF);
 	if (!head-&gt;qh_next.qh) {
-		u32	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		if (!(cmd &amp; CMD_ASE)) {
+		if (!(ehci-&gt;command &amp; CMD_ASE)) {
 			/* in case a clear of CMD_ASE didn't take yet */
 			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS, 0, 150);
-			cmd |= CMD_ASE;
-			ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+			ehci-&gt;command |= CMD_ASE;
+			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 			/* posted write need not be known to HC yet ... */
 		}
 	}
@@ -1204,7 +1202,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	int		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	struct ehci_qh	*prev;
 
 #ifdef DEBUG
@@ -1222,8 +1219,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		if (ehci-&gt;rh_state != EHCI_RH_HALTED
 				&amp;&amp; !ehci-&gt;reclaim) {
 			/* ... and CMD_IAAD clear */
-			ehci_writel(ehci, cmd &amp; ~CMD_ASE,
-				    &amp;ehci-&gt;regs-&gt;command);
+			ehci-&gt;command &amp;= ~CMD_ASE;
+			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 			wmb ();
 			// handshake later, if we need to
 			timer_action_done (ehci, TIMER_ASYNC_OFF);
@@ -1253,8 +1250,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		return;
 	}
 
-	cmd |= CMD_IAAD;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	iaa_watchdog_start(ehci);
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a60679cbbf85..ffe8fc3bc7ef 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -481,7 +481,6 @@ static int tt_no_collision (
 
 static int enable_periodic (struct ehci_hcd *ehci)
 {
-	u32	cmd;
 	int	status;
 
 	if (ehci-&gt;periodic_sched++)
@@ -497,8 +496,8 @@ static int enable_periodic (struct ehci_hcd *ehci)
 		return status;
 	}
 
-	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) | CMD_PSE;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command |= CMD_PSE;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... PSS happens later */
 
 	/* make sure ehci_work scans these */
@@ -511,7 +510,6 @@ static int enable_periodic (struct ehci_hcd *ehci)
 
 static int disable_periodic (struct ehci_hcd *ehci)
 {
-	u32	cmd;
 	int	status;
 
 	if (--ehci-&gt;periodic_sched)
@@ -537,8 +535,8 @@ static int disable_periodic (struct ehci_hcd *ehci)
 		return status;
 	}
 
-	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &amp; ~CMD_PSE;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command &amp;= ~CMD_PSE;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... */
 
 	free_cached_lists(ehci);</pre><hr><pre>commit 6feff1b92bedab133c5835e510d11f62e843b257
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 17 15:23:25 2012 -0400

    EHCI: don't try to clear the IAAD bit
    
    This patch (as1541) corrects a small mistake in ehci-hcd.  The IAAD
    (Interrupt on Async Advance Doorbell) bit in the USBCMD register is
    designed, as its name says, to act as a "doorbell".  That is, the
    driver activates the bit by setting it to 1, and the hardware
    deactivates it later by setting it back to 0.  The driver cannot clear
    the bit by writing a 0 to it; such writes are simply ignored.
    
    Therefore there is no reason for ehci-hcd to try to clear the bit.
    The patch removes the two instances where such attempts occur.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 057cdda7a489..343f40c23b5f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -415,9 +415,6 @@ static void ehci_iaa_watchdog(unsigned long param)
 		 * CMD_IAAD when it sets STS_IAA.)
 		 */
 		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-		if (cmd &amp; CMD_IAAD)
-			ehci_writel(ehci, cmd &amp; ~CMD_IAAD,
-					&amp;ehci-&gt;regs-&gt;command);
 
 		/* If IAA is set here it either legitimately triggered
 		 * before we cleared IAAD above (but _way_ late, so we'll
@@ -887,11 +884,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status &amp; STS_IAA) {
 		/* guard against (alleged) silicon errata */
-		if (cmd &amp; CMD_IAAD) {
-			ehci_writel(ehci, cmd &amp; ~CMD_IAAD,
-					&amp;ehci-&gt;regs-&gt;command);
+		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		}
 		if (ehci-&gt;reclaim) {
 			COUNT(ehci-&gt;stats.reclaim);
 			end_unlink_async(ehci);</pre><hr><pre>commit 2fbe2bf1fd37f9d99950bd8d8093623cf22cf08b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 18 11:33:00 2012 -0400

    EHCI: always clear the STS_FLR status bit
    
    This patch (as1544) fixes a problem affecting some EHCI controllers.
    They can generate interrupts whenever the STS_FLR status bit is turned
    on, even though that bit is masked out in the Interrupt Enable
    register.
    
    Since the driver doesn't use STS_FLR anyway, the patch changes the
    interrupt routine to clear that bit whenever it is set, rather than
    leaving it alone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Tomoya MORINAGA &lt;tomoya.rohm@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 95ca07a8e1b5..4a3bc5b7a06f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -858,8 +858,13 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		goto dead;
 	}
 
+	/*
+	 * We don't use STS_FLR, but some controllers don't like it to
+	 * remain on, so mask it out along with the other status bits.
+	 */
+	masked_status = status &amp; (INTR_MASK | STS_FLR);
+
 	/* Shared IRQ? */
-	masked_status = status &amp; INTR_MASK;
 	if (!masked_status || unlikely(ehci-&gt;rh_state == EHCI_RH_HALTED)) {
 		spin_unlock(&amp;ehci-&gt;lock);
 		return IRQ_NONE;</pre><hr><pre>commit dc75ce9d929aabeb0843a6b1a4ab320e58ba1597
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 17 15:24:15 2012 -0400

    EHCI: fix criterion for resuming the root hub
    
    This patch (as1542) changes the criterion ehci-hcd uses to tell when
    it needs to resume the controller's root hub.  A resume is needed when
    a port status change is detected, obviously, but only if the root hub
    is currently suspended.
    
    Right now the driver tests whether the root hub is running, and that
    is not the correct test.  In particular, if the controller has died
    then the root hub should not be restarted.  In addition, some buggy
    hardware occasionally requires the root hub to be running and
    sending out SOF packets even while it is nominally supposed to be
    suspended.
    
    In the end, the test needs to be changed.  Rather than checking whether
    the root hub is currently running, the driver will now check whether
    the root hub is currently suspended.  This will yield the correct
    behavior in all cases.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Peter Chen &lt;B29397@freescale.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 806cc95317aa..95ca07a8e1b5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -910,7 +910,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		pcd_status = status;
 
 		/* resume root hub? */
-		if (!(cmd &amp; CMD_RUN))
+		if (ehci-&gt;rh_state == EHCI_RH_SUSPENDED)
 			usb_hcd_resume_root_hub(hcd);
 
 		/* get per-port change detect bits */</pre><hr><pre>commit 8963c487a80b4688c9e68dcc504a90074aacc145
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 17 15:22:39 2012 -0400

    USB: fix deadlock in bConfigurationValue attribute method
    
    This patch (as154) fixes a self-deadlock that occurs when userspace
    writes to the bConfigurationValue sysfs attribute for a hub with
    children.  The task tries to lock the bandwidth_mutex at a time when
    it already owns the lock:
    
            The attribute's method calls usb_set_configuration(),
            which calls usb_disable_device() with the bandwidth_mutex
            held.
    
            usb_disable_device() unregisters the existing interfaces,
            which causes the hub driver to be unbound.
    
            The hub_disconnect() routine calls hub_quiesce(), which
            calls usb_disconnect() for each of the hub's children.
    
            usb_disconnect() attempts to acquire the bandwidth_mutex
            around a call to usb_disable_device().
    
    The solution is to make usb_disable_device() acquire the mutex for
    itself instead of requiring the caller to hold it.  Then the mutex can
    cover only the bandwidth deallocation operation and not the region
    where the interfaces are unregistered.
    
    This has the potential to change system behavior slightly when a
    config change races with another config or altsetting change.  Some of
    the bandwidth released from the old config might get claimed by the
    other config or altsetting, make it impossible to restore the old
    config in case of a failure.  But since we don't try to recover from
    config-change failures anyway, this doesn't matter.
    
    [This should be marked for stable kernels that contain the commit
    fccf4e86200b8f5edd9a65da26f150e32ba79808 "USB: Free bandwidth when
    usb_disable_device is called."
    That commit was marked for stable kernels as old as 2.6.32.]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a2aa9d652c67..ec6c97dadbe4 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1667,7 +1667,6 @@ void usb_disconnect(struct usb_device **pdev)
 {
 	struct usb_device	*udev = *pdev;
 	int			i;
-	struct usb_hcd		*hcd = bus_to_hcd(udev-&gt;bus);
 
 	/* mark the device as inactive, so any further urb submissions for
 	 * this device (and any of its children) will fail immediately.
@@ -1690,9 +1689,7 @@ void usb_disconnect(struct usb_device **pdev)
 	 * so that the hardware is now fully quiesced.
 	 */
 	dev_dbg (&amp;udev-&gt;dev, "unregistering device\n");
-	mutex_lock(hcd-&gt;bandwidth_mutex);
 	usb_disable_device(udev, 0);
-	mutex_unlock(hcd-&gt;bandwidth_mutex);
 	usb_hcd_synchronize_unlinks(udev);
 
 	usb_remove_ep_devs(&amp;udev-&gt;ep0);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index aed3e07942d4..ca717da3be95 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1136,8 +1136,6 @@ void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,
  * Deallocates hcd/hardware state for the endpoints (nuking all or most
  * pending urbs) and usbcore state for the interfaces, so that usbcore
  * must usb_set_configuration() before any interfaces could be used.
- *
- * Must be called with hcd-&gt;bandwidth_mutex held.
  */
 void usb_disable_device(struct usb_device *dev, int skip_ep0)
 {
@@ -1190,7 +1188,9 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 			usb_disable_endpoint(dev, i + USB_DIR_IN, false);
 		}
 		/* Remove endpoints from the host controller internal state */
+		mutex_lock(hcd-&gt;bandwidth_mutex);
 		usb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);
+		mutex_unlock(hcd-&gt;bandwidth_mutex);
 		/* Second pass: remove endpoint pointers */
 	}
 	for (i = skip_ep0; i &lt; 16; ++i) {
@@ -1750,7 +1750,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	/* if it's already configured, clear out old state first.
 	 * getting rid of old interfaces means unbinding their drivers.
 	 */
-	mutex_lock(hcd-&gt;bandwidth_mutex);
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device(dev, 1);	/* Skip ep0 */
 
@@ -1763,6 +1762,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	 * host controller will not allow submissions to dropped endpoints.  If
 	 * this call fails, the device state is unchanged.
 	 */
+	mutex_lock(hcd-&gt;bandwidth_mutex);
 	ret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);
 	if (ret &lt; 0) {
 		mutex_unlock(hcd-&gt;bandwidth_mutex);</pre><hr><pre>commit c85dcdac5852295cf6822f5c4331a6ddab72581f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 11 16:09:10 2012 -0400

    USB: gadget: storage gadgets send wrong error code for unknown commands
    
    This patch (as1539) fixes a minor bug in the mass-storage gadget
    drivers.  When an unknown command is received, the error code sent
    back is "Invalid Field in CDB" rather than "Invalid Command".  This is
    because the bitmask of CDB bytes allowed to be nonzero is incorrect.
    
    When handling an unknown command, we don't care which command bytes
    are nonzero.  All the bits in the mask should be set, not just eight
    of them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;Michal Nazarewicz &lt;mina86@mina86.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index a371e966425f..cb8c162cae5a 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -2189,7 +2189,7 @@ static int do_scsi_command(struct fsg_common *common)
 		common-&gt;data_size_from_cmnd = 0;
 		sprintf(unknown, "Unknown x%02x", common-&gt;cmnd[0]);
 		reply = check_command(common, common-&gt;cmnd_size,
-				      DATA_DIR_UNKNOWN, 0xff, 0, unknown);
+				      DATA_DIR_UNKNOWN, ~0, 0, unknown);
 		if (reply == 0) {
 			common-&gt;curlun-&gt;sense_data = SS_INVALID_COMMAND;
 			reply = -EINVAL;
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 4fac56927741..a896d73f7a93 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -2579,7 +2579,7 @@ static int do_scsi_command(struct fsg_dev *fsg)
 		fsg-&gt;data_size_from_cmnd = 0;
 		sprintf(unknown, "Unknown x%02x", fsg-&gt;cmnd[0]);
 		if ((reply = check_command(fsg, fsg-&gt;cmnd_size,
-				DATA_DIR_UNKNOWN, 0xff, 0, unknown)) == 0) {
+				DATA_DIR_UNKNOWN, ~0, 0, unknown)) == 0) {
 			fsg-&gt;curlun-&gt;sense_data = SS_INVALID_COMMAND;
 			reply = -EINVAL;
 		}</pre>
    <div class="pagination">
        <a href='2_48.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><span>[49]</span><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_50.html'>Next&gt;&gt;</a>
    <div>
</body>

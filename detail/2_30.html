<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_29.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><span>[30]</span><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_31.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1d10255c1c496557a5674e651c4ebbe0f61279f2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 18 10:39:05 2014 -0400

    USB: disable reset-resume when USB_QUIRK_RESET is set
    
    The USB_QUIRK_RESET flag indicates that a USB device changes its
    identity in some way when it is reset.  It may lose its firmware, its
    descriptors may change, or it may switch back to a default mode of
    operation.
    
    If a device does this, the kernel needs to avoid resetting it.  Resets
    are likely to fail, or worse, succeed while changing the device's
    state in a way the system can't detect.
    
    This means we should disable the reset-resume mechanism whenever this
    quirk flag is present.  An attempted reset-resume will fail, the
    device will be logically disconnected, and later on the hub driver
    will rediscover and re-enumerate the device.  This will cause the
    appropriate udev events to be generated, so that userspace will have a
    chance to switch the device into its normal operating mode, if
    necessary.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Reviewed-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2d74dfb9c989..d670aaf13a3d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3105,9 +3105,19 @@ static int finish_port_resume(struct usb_device *udev)
 	 * operation is carried out here, after the port has been
 	 * resumed.
 	 */
-	if (udev-&gt;reset_resume)
+	if (udev-&gt;reset_resume) {
+		/*
+		 * If the device morphs or switches modes when it is reset,
+		 * we don't want to perform a reset-resume.  We'll fail the
+		 * resume, which will cause a logical disconnect, and then
+		 * the device will be rediscovered.
+		 */
  retry_reset_resume:
-		status = usb_reset_and_verify_device(udev);
+		if (udev-&gt;quirks &amp; USB_QUIRK_RESET)
+			status = -ENODEV;
+		else
+			status = usb_reset_and_verify_device(udev);
+	}
 
 	/* 10.5.4.5 says be sure devices in the tree are still there.
 	 * For now let's assume the device didn't go crazy on resume,</pre><hr><pre>commit 6aec044cc2f5670cf3b143c151c8be846499bd15
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 12 11:30:38 2014 -0400

    USB: unbind all interfaces before rebinding any
    
    When a driver doesn't have pre_reset, post_reset, or reset_resume
    methods, the USB core unbinds that driver when its device undergoes a
    reset or a reset-resume, and then rebinds it afterward.
    
    The existing straightforward implementation can lead to problems,
    because each interface gets unbound and rebound before the next
    interface is handled.  If a driver claims additional interfaces, the
    claim may fail because the old binding instance may still own the
    additional interface when the new instance tries to claim it.
    
    This patch fixes the problem by first unbinding all the interfaces
    that are marked (i.e., their needs_binding flag is set) and then
    rebinding all of them.
    
    The patch also makes the helper functions in driver.c a little more
    uniform and adjusts some out-of-date comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: "Poulain, Loic" &lt;loic.poulain@intel.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 08283d40616c..888881e5f292 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1011,8 +1011,7 @@ EXPORT_SYMBOL_GPL(usb_deregister);
  * it doesn't support pre_reset/post_reset/reset_resume or
  * because it doesn't support suspend/resume.
  *
- * The caller must hold @intf's device's lock, but not its pm_mutex
- * and not @intf-&gt;dev.sem.
+ * The caller must hold @intf's device's lock, but not @intf's lock.
  */
 void usb_forced_unbind_intf(struct usb_interface *intf)
 {
@@ -1025,16 +1024,37 @@ void usb_forced_unbind_intf(struct usb_interface *intf)
 	intf-&gt;needs_binding = 1;
 }
 
+/*
+ * Unbind drivers for @udev's marked interfaces.  These interfaces have
+ * the needs_binding flag set, for example by usb_resume_interface().
+ *
+ * The caller must hold @udev's device lock.
+ */
+static void unbind_marked_interfaces(struct usb_device *udev)
+{
+	struct usb_host_config	*config;
+	int			i;
+	struct usb_interface	*intf;
+
+	config = udev-&gt;actconfig;
+	if (config) {
+		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
+			intf = config-&gt;interface[i];
+			if (intf-&gt;dev.driver &amp;&amp; intf-&gt;needs_binding)
+				usb_forced_unbind_intf(intf);
+		}
+	}
+}
+
 /* Delayed forced unbinding of a USB interface driver and scan
  * for rebinding.
  *
- * The caller must hold @intf's device's lock, but not its pm_mutex
- * and not @intf-&gt;dev.sem.
+ * The caller must hold @intf's device's lock, but not @intf's lock.
  *
  * Note: Rebinds will be skipped if a system sleep transition is in
  * progress and the PM "complete" callback hasn't occurred yet.
  */
-void usb_rebind_intf(struct usb_interface *intf)
+static void usb_rebind_intf(struct usb_interface *intf)
 {
 	int rc;
 
@@ -1051,68 +1071,66 @@ void usb_rebind_intf(struct usb_interface *intf)
 	}
 }
 
-#ifdef CONFIG_PM
-
-/* Unbind drivers for @udev's interfaces that don't support suspend/resume
- * There is no check for reset_resume here because it can be determined
- * only during resume whether reset_resume is needed.
+/*
+ * Rebind drivers to @udev's marked interfaces.  These interfaces have
+ * the needs_binding flag set.
  *
  * The caller must hold @udev's device lock.
  */
-static void unbind_no_pm_drivers_interfaces(struct usb_device *udev)
+static void rebind_marked_interfaces(struct usb_device *udev)
 {
 	struct usb_host_config	*config;
 	int			i;
 	struct usb_interface	*intf;
-	struct usb_driver	*drv;
 
 	config = udev-&gt;actconfig;
 	if (config) {
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
 			intf = config-&gt;interface[i];
-
-			if (intf-&gt;dev.driver) {
-				drv = to_usb_driver(intf-&gt;dev.driver);
-				if (!drv-&gt;suspend || !drv-&gt;resume)
-					usb_forced_unbind_intf(intf);
-			}
+			if (intf-&gt;needs_binding)
+				usb_rebind_intf(intf);
 		}
 	}
 }
 
-/* Unbind drivers for @udev's interfaces that failed to support reset-resume.
- * These interfaces have the needs_binding flag set by usb_resume_interface().
+/*
+ * Unbind all of @udev's marked interfaces and then rebind all of them.
+ * This ordering is necessary because some drivers claim several interfaces
+ * when they are first probed.
  *
  * The caller must hold @udev's device lock.
  */
-static void unbind_no_reset_resume_drivers_interfaces(struct usb_device *udev)
+void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev)
 {
-	struct usb_host_config	*config;
-	int			i;
-	struct usb_interface	*intf;
-
-	config = udev-&gt;actconfig;
-	if (config) {
-		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
-			intf = config-&gt;interface[i];
-			if (intf-&gt;dev.driver &amp;&amp; intf-&gt;needs_binding)
-				usb_forced_unbind_intf(intf);
-		}
-	}
+	unbind_marked_interfaces(udev);
+	rebind_marked_interfaces(udev);
 }
 
-static void do_rebind_interfaces(struct usb_device *udev)
+#ifdef CONFIG_PM
+
+/* Unbind drivers for @udev's interfaces that don't support suspend/resume
+ * There is no check for reset_resume here because it can be determined
+ * only during resume whether reset_resume is needed.
+ *
+ * The caller must hold @udev's device lock.
+ */
+static void unbind_no_pm_drivers_interfaces(struct usb_device *udev)
 {
 	struct usb_host_config	*config;
 	int			i;
 	struct usb_interface	*intf;
+	struct usb_driver	*drv;
 
 	config = udev-&gt;actconfig;
 	if (config) {
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
 			intf = config-&gt;interface[i];
-			if (intf-&gt;needs_binding)
-				usb_rebind_intf(intf);
+
+			if (intf-&gt;dev.driver) {
+				drv = to_usb_driver(intf-&gt;dev.driver);
+				if (!drv-&gt;suspend || !drv-&gt;resume)
+					usb_forced_unbind_intf(intf);
+			}
 		}
 	}
 }
@@ -1441,7 +1459,7 @@ int usb_resume_complete(struct device *dev)
 	 * whose needs_binding flag is set
 	 */
 	if (udev-&gt;state != USB_STATE_NOTATTACHED)
-		do_rebind_interfaces(udev);
+		rebind_marked_interfaces(udev);
 	return 0;
 }
 
@@ -1463,7 +1481,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 		pm_runtime_disable(dev);
 		pm_runtime_set_active(dev);
 		pm_runtime_enable(dev);
-		unbind_no_reset_resume_drivers_interfaces(udev);
+		unbind_marked_interfaces(udev);
 	}
 
 	/* Avoid PM error messages for devices disconnected while suspended
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5da5394127e9..2d74dfb9c989 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5380,10 +5380,11 @@ int usb_reset_device(struct usb_device *udev)
 				else if (cintf-&gt;condition ==
 						USB_INTERFACE_BOUND)
 					rebind = 1;
+				if (rebind)
+					cintf-&gt;needs_binding = 1;
 			}
-			if (ret == 0 &amp;&amp; rebind)
-				usb_rebind_intf(cintf);
 		}
+		usb_unbind_and_rebind_marked_interfaces(udev);
 	}
 
 	usb_autosuspend_device(udev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 823857767a16..0923add72b59 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -55,7 +55,7 @@ extern int usb_match_one_id_intf(struct usb_device *dev,
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
-extern void usb_rebind_intf(struct usb_interface *intf);
+extern void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev);
 
 extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
 		struct dev_state *owner);</pre><hr><pre>commit 7aae51347b21eb738dc1981df1365b57a6c5ee4e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 15 15:37:04 2014 -0500

    [SCSI] sd: don't fail if the device doesn't recognize SYNCHRONIZE CACHE
    
    Evidently some wacky USB-ATA bridges don't recognize the SYNCHRONIZE
    CACHE command, as shown in this email thread:
    
            http://marc.info/?t=138978356200002&amp;r=1&amp;w=2
    
    The fact that we can't tell them to drain their caches shouldn't
    prevent the system from going into suspend.  Therefore sd_sync_cache()
    shouldn't return an error if the device replies with an Invalid
    Command ASC.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Sven Neumann &lt;s.neumann@raumfeld.com&gt;
    Tested-by: Daniel Mack &lt;zonque@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 470954aba728..36d1a23f14be 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1463,8 +1463,8 @@ static int sd_sync_cache(struct scsi_disk *sdkp)
 			sd_print_sense_hdr(sdkp, &amp;sshdr);
 		/* we need to evaluate the error return  */
 		if (scsi_sense_valid(&amp;sshdr) &amp;&amp;
-			/* 0x3a is medium not present */
-			sshdr.asc == 0x3a)
+			(sshdr.asc == 0x3a ||	/* medium not present */
+			 sshdr.asc == 0x20))	/* invalid command */
 				/* this is no error here */
 				return 0;
 </pre><hr><pre>commit f080a51bef2caa9b0f647dc430bc608d5723ac29
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 20 10:49:30 2014 -0500

    USB: complain if userspace resets an active endpoint
    
    It is an error for a driver to call usb_clear_halt() or
    usb_reset_endpoint() while there are URBs queued for the endpoint,
    because the end result is not well defined.  At the time the endpoint
    gets reset, it may or may not be actively running.
    
    As far as I know, no kernel drivers do this.  But some userspace
    drivers do, and it seems like a good idea to bring this error to their
    attention.
    
    This patch adds a warning to the kernel log whenever a program invokes
    the USBDEVFS_CLEAR_HALT or USBDEVFS_RESETEP ioctls at an inappropriate
    time, and includes the name of the program.  This will make it clear
    that any subsequent errors are not due to the misbehavior of a kernel
    driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Suggested-by: Bj√∏rn Mork &lt;bjorn@mork.no&gt;
    CC: Stanislaw Gruszka &lt;sgruszka@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 90e18f6fa2bb..f3ba2e076ee3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1043,6 +1043,20 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	return ret;
 }
 
+static void check_reset_of_active_ep(struct usb_device *udev,
+		unsigned int epnum, char *ioctl_name)
+{
+	struct usb_host_endpoint **eps;
+	struct usb_host_endpoint *ep;
+
+	eps = (epnum &amp; USB_DIR_IN) ? udev-&gt;ep_in : udev-&gt;ep_out;
+	ep = eps[epnum &amp; 0x0f];
+	if (ep &amp;&amp; !list_empty(&amp;ep-&gt;urb_list))
+		dev_warn(&amp;udev-&gt;dev, "Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\n",
+				task_pid_nr(current), current-&gt;comm,
+				ioctl_name, epnum);
+}
+
 static int proc_resetep(struct dev_state *ps, void __user *arg)
 {
 	unsigned int ep;
@@ -1056,6 +1070,7 @@ static int proc_resetep(struct dev_state *ps, void __user *arg)
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
+	check_reset_of_active_ep(ps-&gt;dev, ep, "RESETEP");
 	usb_reset_endpoint(ps-&gt;dev, ep);
 	return 0;
 }
@@ -1074,6 +1089,7 @@ static int proc_clearhalt(struct dev_state *ps, void __user *arg)
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
+	check_reset_of_active_ep(ps-&gt;dev, ep, "CLEAR_HALT");
 	if (ep &amp; USB_DIR_IN)
 		pipe = usb_rcvbulkpipe(ps-&gt;dev, ep &amp; 0x7f);
 	else</pre><hr><pre>commit 3e8d6d85adedc59115a564c0a54b36e42087c4d9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 13 15:49:17 2014 -0500

    USB: EHCI: add delay during suspend to prevent erroneous wakeups
    
    High-speed USB connections revert back to full-speed signalling when
    the device goes into suspend.  This takes several milliseconds, and
    during that time it's not possible to tell reliably whether the device
    has been disconnected.
    
    On some platforms, the Wake-On-Disconnect circuitry gets confused
    during this intermediate state.  It generates a false wakeup signal,
    which can prevent the controller from going to sleep.
    
    To avoid this problem, this patch adds a 5-ms delay to the
    ehci_bus_suspend() routine if any ports have to switch over to
    full-speed signalling.  (Actually, the delay was already present for
    devices using a particular kind of PHY power management; the patch
    merely causes the delay to be used more widely.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Peter Chen &lt;Peter.Chen@freescale.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 47b858fc50b2..7ae0c4d51741 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -238,6 +238,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	int			port;
 	int			mask;
 	int			changed;
+	bool			fs_idle_delay;
 
 	ehci_dbg(ehci, "suspend root hub\n");
 
@@ -272,6 +273,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
 	changed = 0;
+	fs_idle_delay = false;
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
@@ -300,16 +302,32 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 
 		if (t1 != t2) {
+			/*
+			 * On some controllers, Wake-On-Disconnect will
+			 * generate false wakeup signals until the bus
+			 * switches over to full-speed idle.  For their
+			 * sake, add a delay if we need one.
+			 */
+			if ((t2 &amp; PORT_WKDISC_E) &amp;&amp;
+					ehci_port_speed(ehci, t2) ==
+						USB_PORT_STAT_HIGH_SPEED)
+				fs_idle_delay = true;
 			ehci_writel(ehci, t2, reg);
 			changed = 1;
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	if ((changed &amp;&amp; ehci-&gt;has_tdi_phy_lpm) || fs_idle_delay) {
+		/*
+		 * Wait for HCD to enter low-power mode or for the bus
+		 * to switch to full-speed idle.
+		 */
+		usleep_range(5000, 5500);
+	}
 
 	if (changed &amp;&amp; ehci-&gt;has_tdi_phy_lpm) {
-		spin_unlock_irq(&amp;ehci-&gt;lock);
-		msleep(5);	/* 5 ms for HCD to enter low-power mode */
 		spin_lock_irq(&amp;ehci-&gt;lock);
-
 		port = HCS_N_PORTS(ehci-&gt;hcs_params);
 		while (port--) {
 			u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[port];
@@ -322,8 +340,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 					port, (t3 &amp; HOSTPC_PHCD) ?
 					"succeeded" : "failed");
 		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 	}
-	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* Apparently some devices need a &gt;= 1-uframe delay here */
 	if (ehci-&gt;bus_suspended)</pre><hr><pre>commit adff52952ef52c4dbfb930727f6f8cfe14d9967c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 11 11:26:00 2014 -0500

    USB: ohci-platform: check for platform data misconfiguration
    
    The ohci-platform driver checks for misconfigurations in cases where
    the Device Tree data specifies big-endian registers or descriptors but
    the corresponding driver config settings have not been enabled.  As
    Jonas Gorski suggested, we may as well apply the same check to general
    platform data too.
    
    This requires moving the code that sets the big-endian quirk flags
    from the ohci_platform_reset() routine into ohci_platform_probe(), and
    moving the checks out of the DT-specific "if" statement clause.
    
    The patch also changes the text of the error messages in an attempt to
    make the nature of the error more clear.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Jonas Gorski &lt;jogo@openwrt.org&gt;
    Acked-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-platform.c b/drivers/usb/host/ohci-platform.c
index b6ca0b25259a..b6002c951c5c 100644
--- a/drivers/usb/host/ohci-platform.c
+++ b/drivers/usb/host/ohci-platform.c
@@ -47,10 +47,6 @@ static int ohci_platform_reset(struct usb_hcd *hcd)
 	struct usb_ohci_pdata *pdata = dev_get_platdata(&amp;pdev-&gt;dev);
 	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
 
-	if (pdata-&gt;big_endian_desc)
-		ohci-&gt;flags |= OHCI_QUIRK_BE_DESC;
-	if (pdata-&gt;big_endian_mmio)
-		ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO;
 	if (pdata-&gt;no_big_frame_no)
 		ohci-&gt;flags |= OHCI_QUIRK_FRAME_NO;
 	if (pdata-&gt;num_ports)
@@ -177,22 +173,6 @@ static int ohci_platform_probe(struct platform_device *dev)
 		if (of_property_read_bool(dev-&gt;dev.of_node, "big-endian"))
 			ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;
 
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
-		if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_MMIO) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-regs not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
-#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
-		if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_DESC) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-desc not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
 		priv-&gt;phy = devm_phy_get(&amp;dev-&gt;dev, "usb");
 		if (IS_ERR(priv-&gt;phy)) {
 			err = PTR_ERR(priv-&gt;phy);
@@ -213,6 +193,28 @@ static int ohci_platform_probe(struct platform_device *dev)
 		}
 	}
 
+	if (pdata-&gt;big_endian_desc)
+		ohci-&gt;flags |= OHCI_QUIRK_BE_DESC;
+	if (pdata-&gt;big_endian_mmio)
+		ohci-&gt;flags |= OHCI_QUIRK_BE_MMIO;
+
+#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
+	if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_MMIO) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_MMIO not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC
+	if (ohci-&gt;flags &amp; OHCI_QUIRK_BE_DESC) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_OHCI_BIG_ENDIAN_DESC not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+
 	if (pdata-&gt;power_on) {
 		err = pdata-&gt;power_on(dev);
 		if (err &lt; 0)</pre><hr><pre>commit 843d5e036419bddb4aaf21d60c7ffe437e963166
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 11 11:26:10 2014 -0500

    USB: ehci-platform: check for platform data misconfiguration
    
    The ehci-platform driver checks for misconfigurations in cases where
    the Device Tree data specifies big-endian registers or descriptors but
    the corresponding driver config settings have not been enabled.  As
    Jonas Gorski suggested, we may as well apply the same check to general
    platform data too.
    
    This requires moving the code that sets the big-endian quirk flags
    from the ehci_platform_reset() routine into ehci_platform_probe(), and
    moving the checks out of the DT-specific "if" statement clause.
    
    The patch also changes the text of the error messages in an attempt to
    make the nature of the error more clear.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Jonas Gorski &lt;jogo@openwrt.org&gt;
    Acked-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-platform.c b/drivers/usb/host/ehci-platform.c
index 117873033d00..b3a0e11073aa 100644
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@ -55,10 +55,6 @@ static int ehci_platform_reset(struct usb_hcd *hcd)
 
 	hcd-&gt;has_tt = pdata-&gt;has_tt;
 	ehci-&gt;has_synopsys_hc_bug = pdata-&gt;has_synopsys_hc_bug;
-	if (pdata-&gt;big_endian_desc)
-		ehci-&gt;big_endian_desc = 1;
-	if (pdata-&gt;big_endian_mmio)
-		ehci-&gt;big_endian_mmio = 1;
 
 	if (pdata-&gt;pre_setup) {
 		retval = pdata-&gt;pre_setup(hcd);
@@ -192,22 +188,6 @@ static int ehci_platform_probe(struct platform_device *dev)
 		if (of_property_read_bool(dev-&gt;dev.of_node, "big-endian"))
 			ehci-&gt;big_endian_mmio = ehci-&gt;big_endian_desc = 1;
 
-#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-		if (ehci-&gt;big_endian_mmio) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-regs not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
-#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
-		if (ehci-&gt;big_endian_desc) {
-			dev_err(&amp;dev-&gt;dev,
-				"Error big-endian-desc not compiled in\n");
-			err = -EINVAL;
-			goto err_put_hcd;
-		}
-#endif
 		priv-&gt;phy = devm_phy_get(&amp;dev-&gt;dev, "usb");
 		if (IS_ERR(priv-&gt;phy)) {
 			err = PTR_ERR(priv-&gt;phy);
@@ -228,6 +208,28 @@ static int ehci_platform_probe(struct platform_device *dev)
 		}
 	}
 
+	if (pdata-&gt;big_endian_desc)
+		ehci-&gt;big_endian_desc = 1;
+	if (pdata-&gt;big_endian_mmio)
+		ehci-&gt;big_endian_mmio = 1;
+
+#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+	if (ehci-&gt;big_endian_mmio) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_MMIO not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC
+	if (ehci-&gt;big_endian_desc) {
+		dev_err(&amp;dev-&gt;dev,
+			"Error: CONFIG_USB_EHCI_BIG_ENDIAN_DESC not set\n");
+		err = -EINVAL;
+		goto err_put_clks;
+	}
+#endif
+
 	if (pdata-&gt;power_on) {
 		err = pdata-&gt;power_on(dev);
 		if (err &lt; 0)</pre><hr><pre>commit 823d12c95c666fa7ab7dad208d735f6bc6afabdc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 30 10:43:22 2014 -0500

    usb-storage: enable multi-LUN scanning when needed
    
    People sometimes create their own custom-configured kernels and forget
    to enable CONFIG_SCSI_MULTI_LUN.  This causes problems when they plug
    in a USB storage device (such as a card reader) with more than one
    LUN.
    
    Fortunately, we can tell fairly easily when a storage device claims to
    have more than one LUN.  When that happens, this patch asks the SCSI
    layer to probe all the LUNs automatically, regardless of the config
    setting.
    
    The patch also updates the Kconfig help text for usb-storage,
    explaining that CONFIG_SCSI_MULTI_LUN may be necessary.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Thomas Raschbacher &lt;lordvan@lordvan.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    CC: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/Kconfig b/drivers/usb/storage/Kconfig
index 8470e1b114f2..1dd0604d1911 100644
--- a/drivers/usb/storage/Kconfig
+++ b/drivers/usb/storage/Kconfig
@@ -18,7 +18,9 @@ config USB_STORAGE
 
 	  This option depends on 'SCSI' support being enabled, but you
 	  probably also need 'SCSI device support: SCSI disk support'
-	  (BLK_DEV_SD) for most USB storage devices.
+	  (BLK_DEV_SD) for most USB storage devices.  Some devices also
+	  will require 'Probe all LUNs on each SCSI device'
+	  (SCSI_MULTI_LUN).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called usb-storage.
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 18509e6c21ab..9d38ddc8da49 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -78,6 +78,8 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
+	struct us_data *us = host_to_us(sdev-&gt;host);
+
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
@@ -102,6 +104,10 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
+	/* Tell the SCSI layer if we know there is more than one LUN */
+	if (us-&gt;protocol == USB_PR_BULK &amp;&amp; us-&gt;max_lun &gt; 0)
+		sdev-&gt;sdev_bflags |= BLIST_FORCELUN;
+
 	return 0;
 }
 </pre><hr><pre>commit c5637e5119c43452a00e27c274356b072263ecbb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 21 10:38:45 2014 -0500

    usb-storage: add unusual-devs entry for BlackBerry 9000
    
    This patch adds an unusual-devs entry for the BlackBerry 9000.  This
    fixes Bugzilla #22442.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Moritz Moeller-Herrmann &lt;moritz-kernel@moeller-herrmann.de&gt;
    Tested-by: Moritz Moeller-Herrmann &lt;moritz-kernel@moeller-herrmann.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index ad06255c2ade..adbeb255616a 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1455,6 +1455,13 @@ UNUSUAL_DEV( 0x0f88, 0x042e, 0x0100, 0x0100,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY ),
 
+/* Reported by Moritz Moeller-Herrmann &lt;moritz-kernel@moeller-herrmann.de&gt; */
+UNUSUAL_DEV(  0x0fca, 0x8004, 0x0201, 0x0201,
+		"Research In Motion",
+		"BlackBerry Bold 9000",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_MAX_SECTORS_64 ),
+
 /* Reported by Michael Stattmann &lt;michael@stattmann.com&gt; */
 UNUSUAL_DEV(  0x0fce, 0xd008, 0x0000, 0x0000,
 		"Sony Ericsson",</pre><hr><pre>commit a9c143c82608bee2a36410caa56d82cd86bdc7fa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 30 10:20:29 2014 -0500

    usb-storage: restrict bcdDevice range for Super Top in Cypress ATACB
    
    The Cypress ATACB unusual-devs entry for the Super Top SATA bridge
    causes problems.  Although it was originally reported only for
    bcdDevice = 0x160, its range was much larger.  This resulted in a bug
    report for bcdDevice 0x220, so the range was capped at 0x219.  Now
    Milan reports errors with bcdDevice 0x150.
    
    Therefore this patch restricts the range to just 0x160.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Milan Svoboda &lt;milan.svoboda@centrum.cz&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_cypress.h b/drivers/usb/storage/unusual_cypress.h
index 65a6a75066a8..82e8ed0324e3 100644
--- a/drivers/usb/storage/unusual_cypress.h
+++ b/drivers/usb/storage/unusual_cypress.h
@@ -31,7 +31,7 @@ UNUSUAL_DEV(  0x04b4, 0x6831, 0x0000, 0x9999,
 		"Cypress ISD-300LP",
 		USB_SC_CYP_ATACB, USB_PR_DEVICE, NULL, 0),
 
-UNUSUAL_DEV( 0x14cd, 0x6116, 0x0000, 0x0219,
+UNUSUAL_DEV( 0x14cd, 0x6116, 0x0160, 0x0160,
 		"Super Top",
 		"USB 2.0  SATA BRIDGE",
 		USB_SC_CYP_ATACB, USB_PR_DEVICE, NULL, 0),</pre>
    <div class="pagination">
        <a href='2_29.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><span>[30]</span><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_31.html'>Next&gt;&gt;</a>
    <div>
</body>

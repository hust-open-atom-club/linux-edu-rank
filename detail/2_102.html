<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_101.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><span>[102]</span><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_103.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 79a7d9ee1a2e8b8dc44dd217f07496911850ec0e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 17:10:11 2007 -0400

    USB: cleanups for g_file_storage
    
    This patch (as957) makes some minor cleanups to the g_file_storage
    driver:
    
            Update the copyright date and version string;
    
            Uniformize the logging macros for the gadget and the LUNs;
    
            Remove "inline" markers -- nowadays we rely on the compiler
            to decide which routines are best inlined;
    
            Use the print_hex_dump() library routines;
    
            Remove some unnecessary assignments within conditionals
            and fix some close-brace indenting levels;
    
            Fix some column-80 violations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 0019116ee411..9998cd7af418 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1,7 +1,7 @@
 /*
  * file_storage.c -- File-backed USB Storage Gadget, for USB development
  *
- * Copyright (C) 2003-2005 Alan Stern
+ * Copyright (C) 2003-2007 Alan Stern
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -218,7 +218,7 @@
 
 
 /* #define VERBOSE_DEBUG */
-#undef DUMP_MSGS
+/* #define DUMP_MSGS */
 
 
 #include &lt;linux/blkdev.h&gt;
@@ -249,7 +249,7 @@
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"28 November 2005"
+#define DRIVER_VERSION		"7 August 2007"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -275,12 +275,9 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 /*-------------------------------------------------------------------------*/
 
-#define yprintk(l,level,fmt,args...) \
-	dev_printk(level , &amp;(l)-&gt;dev , fmt , ## args)
-
 #ifdef DEBUG
 #define LDBG(lun,fmt,args...) \
-	yprintk(lun , KERN_DEBUG , fmt , ## args)
+	dev_dbg(&amp;(lun)-&gt;dev , fmt , ## args)
 #define MDBG(fmt,args...) \
 	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
 #else
@@ -300,11 +297,11 @@ MODULE_LICENSE("Dual BSD/GPL");
 #endif /* VERBOSE_DEBUG */
 
 #define LERROR(lun,fmt,args...) \
-	yprintk(lun , KERN_ERR , fmt , ## args)
+	dev_err(&amp;(lun)-&gt;dev , fmt , ## args)
 #define LWARN(lun,fmt,args...) \
-	yprintk(lun , KERN_WARNING , fmt , ## args)
+	dev_warn(&amp;(lun)-&gt;dev , fmt , ## args)
 #define LINFO(lun,fmt,args...) \
-	yprintk(lun , KERN_INFO , fmt , ## args)
+	dev_info(&amp;(lun)-&gt;dev , fmt , ## args)
 
 #define MINFO(fmt,args...) \
 	printk(KERN_INFO DRIVER_NAME ": " fmt , ## args)
@@ -558,7 +555,7 @@ struct lun {
 
 #define backing_file_is_open(curlun)	((curlun)-&gt;filp != NULL)
 
-static inline struct lun *dev_to_lun(struct device *dev)
+static struct lun *dev_to_lun(struct device *dev)
 {
 	return container_of(dev, struct lun, dev);
 }
@@ -691,13 +688,13 @@ struct fsg_dev {
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
 
-static int inline exception_in_progress(struct fsg_dev *fsg)
+static int exception_in_progress(struct fsg_dev *fsg)
 {
 	return (fsg-&gt;state &gt; FSG_STATE_IDLE);
 }
 
 /* Make bulk-out requests be divisible by the maxpacket size */
-static void inline set_bulk_out_req_length(struct fsg_dev *fsg,
+static void set_bulk_out_req_length(struct fsg_dev *fsg,
 		struct fsg_buffhd *bh, unsigned int length)
 {
 	unsigned int	rem;
@@ -723,50 +720,36 @@ static void	close_all_backing_files(struct fsg_dev *fsg);
 static void dump_msg(struct fsg_dev *fsg, const char *label,
 		const u8 *buf, unsigned int length)
 {
-	unsigned int	start, num, i;
-	char		line[52], *p;
-
-	if (length &gt;= 512)
-		return;
-	DBG(fsg, "%s, length %u:\n", label, length);
-
-	start = 0;
-	while (length &gt; 0) {
-		num = min(length, 16u);
-		p = line;
-		for (i = 0; i &lt; num; ++i) {
-			if (i == 8)
-				*p++ = ' ';
-			sprintf(p, " %02x", buf[i]);
-			p += 3;
-		}
-		*p = 0;
-		printk(KERN_DEBUG "%6x: %s\n", start, line);
-		buf += num;
-		start += num;
-		length -= num;
+	if (length &lt; 512) {
+		DBG(fsg, "%s, length %u:\n", label, length);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET,
+				16, 1, buf, length, 0);
 	}
 }
 
-static void inline dump_cdb(struct fsg_dev *fsg)
+static void dump_cdb(struct fsg_dev *fsg)
 {}
 
 #else
 
-static void inline dump_msg(struct fsg_dev *fsg, const char *label,
+static void dump_msg(struct fsg_dev *fsg, const char *label,
 		const u8 *buf, unsigned int length)
 {}
 
-static void inline dump_cdb(struct fsg_dev *fsg)
-{
-	int	i;
-	char	cmdbuf[3*MAX_COMMAND_SIZE + 1];
+#ifdef VERBOSE_DEBUG
 
-	for (i = 0; i &lt; fsg-&gt;cmnd_size; ++i)
-		sprintf(cmdbuf + i*3, " %02x", fsg-&gt;cmnd[i]);
-	VDBG(fsg, "SCSI CDB: %s\n", cmdbuf);
+static void dump_cdb(struct fsg_dev *fsg)
+{
+	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,
+			16, 1, fsg-&gt;cmnd, fsg-&gt;cmnd_size, 0);
 }
 
+#else
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#endif /* VERBOSE_DEBUG */
 #endif /* DUMP_MSGS */
 
 
@@ -789,24 +772,24 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 
 /* Routines for unaligned data access */
 
-static u16 inline get_be16(u8 *buf)
+static u16 get_be16(u8 *buf)
 {
 	return ((u16) buf[0] &lt;&lt; 8) | ((u16) buf[1]);
 }
 
-static u32 inline get_be32(u8 *buf)
+static u32 get_be32(u8 *buf)
 {
 	return ((u32) buf[0] &lt;&lt; 24) | ((u32) buf[1] &lt;&lt; 16) |
 			((u32) buf[2] &lt;&lt; 8) | ((u32) buf[3]);
 }
 
-static void inline put_be16(u8 *buf, u16 val)
+static void put_be16(u8 *buf, u16 val)
 {
 	buf[0] = val &gt;&gt; 8;
 	buf[1] = val;
 }
 
-static void inline put_be32(u8 *buf, u32 val)
+static void put_be32(u8 *buf, u32 val)
 {
 	buf[0] = val &gt;&gt; 24;
 	buf[1] = val &gt;&gt; 16;
@@ -992,7 +975,7 @@ static const struct usb_descriptor_header *hs_function[] = {
 #define HS_FUNCTION_PRE_EP_ENTRIES	2
 
 /* Maxpacket and other transfer characteristics vary by speed. */
-static inline struct usb_endpoint_descriptor *
+static struct usb_endpoint_descriptor *
 ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
 		struct usb_endpoint_descriptor *hs)
 {
@@ -1616,7 +1599,8 @@ static int do_read(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg-&gt;next_buffhd_to_fill;
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -1855,7 +1839,8 @@ static int do_write(struct fsg_dev *fsg)
 		}
 
 		/* Wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2339,7 +2324,8 @@ static int pad_with_zeros(struct fsg_dev *fsg)
 
 		/* Wait for the next buffer to be free */
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -2399,7 +2385,8 @@ static int throw_away_data(struct fsg_dev *fsg)
 		}
 
 		/* Otherwise wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 	return 0;
@@ -2521,7 +2508,8 @@ static int send_status(struct fsg_dev *fsg)
 	/* Wait for the next buffer to become available */
 	bh = fsg-&gt;next_buffhd_to_fill;
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2741,9 +2729,10 @@ static int do_scsi_command(struct fsg_dev *fsg)
 	/* Wait for the next buffer to become available for data or status */
 	bh = fsg-&gt;next_buffhd_to_drain = fsg-&gt;next_buffhd_to_fill;
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
-		}
+	}
 	fsg-&gt;phase_error = 0;
 	fsg-&gt;short_packet_received = 0;
 
@@ -3015,9 +3004,10 @@ static int get_next_command(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg-&gt;next_buffhd_to_fill;
 		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 
 		/* Queue a request to read a Bulk-only CBW */
 		set_bulk_out_req_length(fsg, bh, USB_BULK_CB_WRAP_LEN);
@@ -3031,9 +3021,10 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the CBW to arrive */
 		while (bh-&gt;state != BUF_STATE_FULL) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 		smp_rmb();
 		rc = received_cbw(fsg, bh);
 		bh-&gt;state = BUF_STATE_EMPTY;
@@ -3042,9 +3033,10 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the next command to arrive */
 		while (fsg-&gt;cbbuf_cmnd_size == 0) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
-			}
+		}
 
 		/* Is the previous status interrupt request still busy?
 		 * The host is allowed to skip reading the status,
@@ -3565,7 +3557,8 @@ static ssize_t show_ro(struct device *dev, struct device_attribute *attr, char *
 	return sprintf(buf, "%d\n", curlun-&gt;ro);
 }
 
-static ssize_t show_file(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_file(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);
@@ -3574,8 +3567,8 @@ static ssize_t show_file(struct device *dev, struct device_attribute *attr, char
 
 	down_read(&amp;fsg-&gt;filesem);
 	if (backing_file_is_open(curlun)) {	// Get the complete pathname
-		p = d_path(curlun-&gt;filp-&gt;f_path.dentry, curlun-&gt;filp-&gt;f_path.mnt,
-				buf, PAGE_SIZE - 1);
+		p = d_path(curlun-&gt;filp-&gt;f_path.dentry,
+				curlun-&gt;filp-&gt;f_path.mnt, buf, PAGE_SIZE - 1);
 		if (IS_ERR(p))
 			rc = PTR_ERR(p);
 		else {
@@ -3593,7 +3586,8 @@ static ssize_t show_file(struct device *dev, struct device_attribute *attr, char
 }
 
 
-static ssize_t store_ro(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t store_ro(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	ssize_t		rc = count;
 	struct lun	*curlun = dev_to_lun(dev);
@@ -3617,7 +3611,8 @@ static ssize_t store_ro(struct device *dev, struct device_attribute *attr, const
 	return rc;
 }
 
-static ssize_t store_file(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t store_file(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);</pre><hr><pre>commit d74d4a69dc1cc7ddc0eabb9c9f1e45005e2984eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 11:59:18 2007 -0400

    USB: don't touch sysfs stuff when altsetting is unchanged
    
    This patch (as955) prevents the interface-related sysfs files and
    endpoint pseudo-devices from being deleted and recreated when a call
    to usb_set_interface() specifies the current altsetting.  Since the
    altsetting doesn't get changed, there's no need to do anything.
    
    Furthermore, avoiding changes to the endpoint devices will be
    necessary in the future.  This code is called from usb_reset_device(),
    which gets invoked for reset-resume processing, but upcoming changes
    to the PM and driver cores will make it impossible to register devices
    while a suspend/resume transition is in progress.  Since we don't need
    to re-register those endpoint devices anyhow, it's best to skip the
    whole thing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index c905b35d4f85..d638375e22e7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1173,6 +1173,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	struct usb_host_interface *alt;
 	int ret;
 	int manual = 0;
+	int changed;
 
 	if (dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -1212,7 +1213,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	if (device_is_registered(&amp;iface-&gt;dev))
+	changed = (iface-&gt;cur_altsetting != alt);
+	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1249,7 +1251,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
-	if (device_is_registered(&amp;iface-&gt;dev))
+	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_create_sysfs_intf_files(iface);
 
 	return 0;</pre><hr><pre>commit e9df41c5c5899259541dc928872cad4d07b82076
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 11:48:02 2007 -0400

    USB: make HCDs responsible for managing endpoint queues
    
    This patch (as954) implements a suggestion of David Brownell's.  Now
    the host controller drivers are responsible for linking and unlinking
    URBs to/from their endpoint queues.  This eliminates the possiblity of
    strange situations where usbcore thinks an URB is linked but the HCD
    thinks it isn't.  It also means HCDs no longer have to check for URBs
    being dequeued before they were fully enqueued.
    
    In addition to the core changes, this requires changing every host
    controller driver and the root-hub URB handler.  For the most part the
    required changes are fairly small; drivers have to call
    usb_hcd_link_urb_to_ep() in their urb_enqueue method,
    usb_hcd_check_unlink_urb() in their urb_dequeue method, and
    usb_hcd_unlink_urb_from_ep() before giving URBs back.  A few HCDs make
    matters more complicated by the way they split up the flow of control.
    
    In addition some method interfaces get changed.  The endpoint argument
    for urb_enqueue is now redundant so it is removed.  The unlink status
    is required by usb_hcd_check_unlink_urb(), so it has been added to
    urb_dequeue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index a5a46a55376b..a853f63b9254 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -356,11 +356,17 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	const u8	*bufp = tbuf;
 	int		len = 0;
 	int		patch_wakeup = 0;
-	int		status = 0;
+	int		status;
 	int		n;
 
 	might_sleep();
 
+	spin_lock_irq(&amp;hcd_root_hub_lock);
+	status = usb_hcd_link_urb_to_ep(hcd, urb);
+	spin_unlock_irq(&amp;hcd_root_hub_lock);
+	if (status)
+		return status;
+
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
 	wValue   = le16_to_cpu (cmd-&gt;wValue);
@@ -525,10 +531,9 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	spin_unlock(&amp;urb-&gt;lock);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
 	 * Avoiding calls to local_irq_disable/enable makes the code
@@ -571,26 +576,21 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 		urb = hcd-&gt;status_urb;
 		if (urb) {
-			spin_lock(&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS) {
-				hcd-&gt;poll_pending = 0;
-				hcd-&gt;status_urb = NULL;
-				urb-&gt;status = 0;
-				urb-&gt;hcpriv = NULL;
-				urb-&gt;actual_length = length;
-				memcpy(urb-&gt;transfer_buffer, buffer, length);
-			} else		/* urb has been unlinked */
-				length = 0;
-			spin_unlock(&amp;urb-&gt;lock);
+			hcd-&gt;poll_pending = 0;
+			hcd-&gt;status_urb = NULL;
+			urb-&gt;status = 0;
+			urb-&gt;hcpriv = NULL;
+			urb-&gt;actual_length = length;
+			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			spin_unlock(&amp;hcd_root_hub_lock);
 			usb_hcd_giveback_urb(hcd, urb);
 			spin_lock(&amp;hcd_root_hub_lock);
-		} else
+		} else {
 			length = 0;
-
-		if (length &lt;= 0)
 			hcd-&gt;poll_pending = 1;
+		}
 		spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	}
 
@@ -619,24 +619,26 @@ static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 	int		len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
-	if (urb-&gt;status != -EINPROGRESS)	/* already unlinked */
-		retval = urb-&gt;status;
-	else if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
+	if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
 		dev_dbg (hcd-&gt;self.controller, "not queuing rh status urb\n");
 		retval = -EINVAL;
-	} else {
-		hcd-&gt;status_urb = urb;
-		urb-&gt;hcpriv = hcd;	/* indicate it's queued */
+		goto done;
+	}
 
-		if (!hcd-&gt;uses_new_polling)
-			mod_timer (&amp;hcd-&gt;rh_timer,
-				(jiffies/(HZ/4) + 1) * (HZ/4));
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
+		goto done;
 
-		/* If a status change has already occurred, report it ASAP */
-		else if (hcd-&gt;poll_pending)
-			mod_timer (&amp;hcd-&gt;rh_timer, jiffies);
-		retval = 0;
-	}
+	hcd-&gt;status_urb = urb;
+	urb-&gt;hcpriv = hcd;	/* indicate it's queued */
+	if (!hcd-&gt;uses_new_polling)
+		mod_timer(&amp;hcd-&gt;rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));
+
+	/* If a status change has already occurred, report it ASAP */
+	else if (hcd-&gt;poll_pending)
+		mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
+	retval = 0;
+ done:
 	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
 	return retval;
 }
@@ -655,11 +657,16 @@ static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 /* Unlinks of root-hub control URBs are legal, but they don't do anything
  * since these URBs always execute synchronously.
  */
-static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	unsigned long	flags;
+	int		rc;
 
 	spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
@@ -669,14 +676,16 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;hcpriv = NULL;
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
 			usb_hcd_giveback_urb(hcd, urb);
 			spin_lock(&amp;hcd_root_hub_lock);
 		}
 	}
+ done:
 	spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
-	return 0;
+	return rc;
 }
 
 
@@ -977,12 +986,26 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 
 /*-------------------------------------------------------------------------*/
 
-static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
+/**
+ * usb_hcd_link_urb_to_ep - add an URB to its endpoint queue
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being submitted
+ *
+ * Host controller drivers should call this routine in their enqueue()
+ * method.  The HCD's private spinlock must be held and interrupts must
+ * be disabled.  The actions carried out here are required for URB
+ * submission, as well as for endpoint shutdown and for usb_kill_urb.
+ *
+ * Returns 0 for no error, otherwise a negative error code (in which case
+ * the enqueue() method must fail).  If no error occurs but enqueue() fails
+ * anyway, it must call usb_hcd_unlink_urb_from_ep() before releasing
+ * the private spinlock and returning.
+ */
+int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long	flags;
 	int		rc = 0;
 
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
 
 	/* Check that the URB isn't being killed */
 	if (unlikely(urb-&gt;reject)) {
@@ -1009,48 +1032,48 @@ static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 	}
  done:
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	return rc;
 }
+EXPORT_SYMBOL_GPL(usb_hcd_link_urb_to_ep);
 
-static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+/**
+ * usb_hcd_check_unlink_urb - check whether an URB may be unlinked
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being checked for unlinkability
+ * @status: error code to store in @urb if the unlink succeeds
+ *
+ * Host controller drivers should call this routine in their dequeue()
+ * method.  The HCD's private spinlock must be held and interrupts must
+ * be disabled.  The actions carried out here are required for making
+ * sure than an unlink is valid.
+ *
+ * Returns 0 for no error, otherwise a negative error code (in which case
+ * the dequeue() method must fail).  The possible error codes are:
+ *
+ *	-EIDRM: @urb was not submitted or has already completed.
+ *		The completion function may not have been called yet.
+ *
+ *	-EBUSY: @urb has already been unlinked.
+ */
+int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status)
 {
-	unsigned long		flags;
 	struct list_head	*tmp;
-	int			rc = 0;
-
-	/*
-	 * we contend for urb-&gt;status with the hcd core,
-	 * which changes it while returning the urb.
-	 *
-	 * Caller guaranteed that the urb pointer hasn't been freed, and
-	 * that it was submitted.  But as a rule it can't know whether or
-	 * not it's already been unlinked ... so we respect the reversed
-	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
-	 * unlinking it.
-	 */
-	spin_lock_irqsave(&amp;urb-&gt;lock, flags);
-	spin_lock(&amp;hcd_urb_list_lock);
 
 	/* insist the urb is still queued */
 	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
 		if (tmp == &amp;urb-&gt;urb_list)
 			break;
 	}
-	if (tmp != &amp;urb-&gt;urb_list) {
-		rc = -EIDRM;
-		goto done;
-	}
+	if (tmp != &amp;urb-&gt;urb_list)
+		return -EIDRM;
 
 	/* Any status except -EINPROGRESS means something already started to
 	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	if (urb-&gt;status != -EINPROGRESS) {
-		rc = -EBUSY;
-		goto done;
-	}
+	if (urb-&gt;status != -EINPROGRESS)
+		return -EBUSY;
 	urb-&gt;status = status;
 
 	/* IRQ setup can easily be broken so that USB controllers
@@ -1065,21 +1088,28 @@ static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 	}
 
- done:
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-	return rc;
+	return 0;
 }
+EXPORT_SYMBOL_GPL(usb_hcd_check_unlink_urb);
 
-static void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
+/**
+ * usb_hcd_unlink_urb_from_ep - remove an URB from its endpoint queue
+ * @hcd: host controller to which @urb was submitted
+ * @urb: URB being unlinked
+ *
+ * Host controller drivers should call this routine before calling
+ * usb_hcd_giveback_urb().  The HCD's private spinlock must be held and
+ * interrupts must be disabled.  The actions carried out here are required
+ * for URB completion.
+ */
+void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long		flags;
-
 	/* clear all state linking urb to this dev (and hcd) */
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
 	list_del_init(&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+	spin_unlock(&amp;hcd_urb_list_lock);
 }
+EXPORT_SYMBOL_GPL(usb_hcd_unlink_urb_from_ep);
 
 static void map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
 {
@@ -1153,20 +1183,15 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	 * URBs must be submitted in process context with interrupts
 	 * enabled.
 	 */
-	status = usb_hcd_link_urb_to_ep(hcd, urb);
-	if (!status) {
-		map_urb_for_dma(hcd, urb);
-		if (is_root_hub(urb-&gt;dev))
-			status = rh_urb_enqueue(hcd, urb);
-		else
-			status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb-&gt;ep, urb,
-					mem_flags);
-	}
+	map_urb_for_dma(hcd, urb);
+	if (is_root_hub(urb-&gt;dev))
+		status = rh_urb_enqueue(hcd, urb);
+	else
+		status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb, mem_flags);
 
 	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
 		unmap_urb_for_dma(hcd, urb);
-		usb_hcd_unlink_urb_from_ep(hcd, urb);
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
 		if (urb-&gt;reject)
@@ -1183,24 +1208,19 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
  * soon as practical.  we've already set up the urb's return status,
  * but we can't know if the callback completed already.
  */
-static int
-unlink1 (struct usb_hcd *hcd, struct urb *urb)
+static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	int		value;
 
 	if (is_root_hub(urb-&gt;dev))
-		value = usb_rh_urb_dequeue (hcd, urb);
+		value = usb_rh_urb_dequeue(hcd, urb, status);
 	else {
 
 		/* The only reason an HCD might fail this call is if
 		 * it has not yet fully queued the urb to begin with.
 		 * Such failures should be harmless. */
-		value = hcd-&gt;driver-&gt;urb_dequeue (hcd, urb);
+		value = hcd-&gt;driver-&gt;urb_dequeue(hcd, urb, status);
 	}
-
-	if (value != 0)
-		dev_dbg (hcd-&gt;self.controller, "dequeue %p --&gt; %d\n",
-				urb, value);
 	return value;
 }
 
@@ -1216,14 +1236,11 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	int			retval;
 
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-
-	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
-	if (!retval)
-		retval = unlink1(hcd, urb);
+	retval = unlink1(hcd, urb, status);
 
 	if (retval == 0)
 		retval = -EINPROGRESS;
-	else if (retval != -EIDRM)
+	else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
 				urb, retval);
 	return retval;
@@ -1245,7 +1262,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	usb_hcd_unlink_urb_from_ep(hcd, urb);
 	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
@@ -1282,7 +1298,6 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 rescan:
 	spin_lock_irq(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
-		int	tmp;
 		int	is_in;
 
 		/* the urb may already have been unlinked */
@@ -1292,34 +1307,26 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		is_in = usb_urb_dir_in(urb);
 		spin_unlock(&amp;hcd_urb_list_lock);
 
-		spin_lock (&amp;urb-&gt;lock);
-		tmp = urb-&gt;status;
-		if (tmp == -EINPROGRESS)
-			urb-&gt;status = -ESHUTDOWN;
-		spin_unlock (&amp;urb-&gt;lock);
-
-		/* kick hcd unless it's already returning this */
-		if (tmp == -EINPROGRESS) {
-			unlink1 (hcd, urb);
-			dev_dbg (hcd-&gt;self.controller,
-				"shutdown urb %p ep%d%s%s\n",
-				urb, usb_endpoint_num(&amp;ep-&gt;desc),
-				is_in ? "in" : "out",
-				({	char *s;
-
-					switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
-					case USB_ENDPOINT_XFER_CONTROL:
-						s = ""; break;
-					case USB_ENDPOINT_XFER_BULK:
-						s = "-bulk"; break;
-					case USB_ENDPOINT_XFER_INT:
-						s = "-intr"; break;
-					default:
-				 		s = "-iso"; break;
-					};
-					s;
-				}));
-		}
+		/* kick hcd */
+		unlink1(hcd, urb, -ESHUTDOWN);
+		dev_dbg (hcd-&gt;self.controller,
+			"shutdown urb %p ep%d%s%s\n",
+			urb, usb_endpoint_num(&amp;ep-&gt;desc),
+			is_in ? "in" : "out",
+			({	char *s;
+
+				 switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
+				 case USB_ENDPOINT_XFER_CONTROL:
+					s = ""; break;
+				 case USB_ENDPOINT_XFER_BULK:
+					s = "-bulk"; break;
+				 case USB_ENDPOINT_XFER_INT:
+					s = "-intr"; break;
+				 default:
+			 		s = "-iso"; break;
+				};
+				s;
+			}));
 		usb_put_urb (urb);
 
 		/* list contents may have changed */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 8683142e70e1..745be2566f62 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -189,11 +189,10 @@ struct hc_driver {
 	int	(*get_frame_number) (struct usb_hcd *hcd);
 
 	/* manage i/o requests, device state */
-	int	(*urb_enqueue) (struct usb_hcd *hcd,
-					struct usb_host_endpoint *ep,
-					struct urb *urb,
-					gfp_t mem_flags);
-	int	(*urb_dequeue) (struct usb_hcd *hcd, struct urb *urb);
+	int	(*urb_enqueue)(struct usb_hcd *hcd,
+				struct urb *urb, gfp_t mem_flags);
+	int	(*urb_dequeue)(struct usb_hcd *hcd,
+				struct urb *urb, int status);
 
 	/* hw synch, freeing endpoint resources that urb_dequeue can't */
 	void 	(*endpoint_disable)(struct usb_hcd *hcd,
@@ -211,6 +210,11 @@ struct hc_driver {
 		/* Needed only if port-change IRQs are level-triggered */
 };
 
+extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
+extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
+extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb);
+
 extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb (struct urb *urb, int status);
 extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index d008d1360a7a..c441d10c087e 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -962,13 +962,13 @@ static struct platform_driver dummy_udc_driver = {
 
 static int dummy_urb_enqueue (
 	struct usb_hcd			*hcd,
-	struct usb_host_endpoint	*ep,
 	struct urb			*urb,
 	gfp_t				mem_flags
 ) {
 	struct dummy	*dum;
 	struct urbp	*urbp;
 	unsigned long	flags;
+	int		rc;
 
 	if (!urb-&gt;transfer_buffer &amp;&amp; urb-&gt;transfer_buffer_length)
 		return -EINVAL;
@@ -980,6 +980,11 @@ static int dummy_urb_enqueue (
 
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	rc = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (rc) {
+		kfree(urbp);
+		goto done;
+	}
 
 	if (!dum-&gt;udev) {
 		dum-&gt;udev = urb-&gt;dev;
@@ -997,22 +1002,28 @@ static int dummy_urb_enqueue (
 		mod_timer (&amp;dum-&gt;timer, jiffies + 1);
 
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
-	return 0;
+ done:
+	return rc;
 }
 
-static int dummy_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct dummy	*dum;
 	unsigned long	flags;
+	int		rc;
 
 	/* giveback happens automatically in timer callback,
 	 * so make sure the callback happens */
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	if (dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp; !list_empty(&amp;dum-&gt;urbp_list))
+
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (!rc &amp;&amp; dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp;
+			!list_empty(&amp;dum-&gt;urbp_list))
 		mod_timer (&amp;dum-&gt;timer, jiffies);
+
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void maybe_set_status (struct urb *urb, int status)
@@ -1511,6 +1522,7 @@ static void dummy_timer (unsigned long _dum)
 		if (ep)
 			ep-&gt;already_seen = ep-&gt;setup_stage = 0;
 
+		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
 		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
 		spin_lock (&amp;dum-&gt;lock);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 35cdba10411b..db00492588b6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -719,7 +719,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
  */
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -734,12 +733,12 @@ static int ehci_urb_enqueue (
 	default:
 		if (!qh_urb_transaction (ehci, urb, &amp;qtd_list, mem_flags))
 			return -ENOMEM;
-		return submit_async (ehci, ep, urb, &amp;qtd_list, mem_flags);
+		return submit_async(ehci, urb, &amp;qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
 		if (!qh_urb_transaction (ehci, urb, &amp;qtd_list, mem_flags))
 			return -ENOMEM;
-		return intr_submit (ehci, ep, urb, &amp;qtd_list, mem_flags);
+		return intr_submit(ehci, urb, &amp;qtd_list, mem_flags);
 
 	case PIPE_ISOCHRONOUS:
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH)
@@ -777,13 +776,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
  * completions normally happen asynchronously
  */
 
-static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	struct ehci_qh		*qh;
 	unsigned long		flags;
+	int			rc;
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	switch (usb_pipetype (urb-&gt;pipe)) {
 	// case PIPE_CONTROL:
 	// case PIPE_BULK:
@@ -838,7 +842,7 @@ static int ehci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 	}
 done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 140bfa423e07..1da2de4d34ed 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -262,6 +262,7 @@ __acquires(ehci-&gt;lock)
 #endif
 
 	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
 	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
 	spin_lock (&amp;ehci-&gt;lock);
@@ -913,7 +914,6 @@ static struct ehci_qh *qh_append_tds (
 static int
 submit_async (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -922,10 +922,10 @@ submit_async (
 	int			epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh = NULL;
-	int			rc = 0;
+	int			rc;
 
 	qtd = list_entry (qtd_list-&gt;next, struct ehci_qtd, qtd_list);
-	epnum = ep-&gt;desc.bEndpointAddress;
+	epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
@@ -933,7 +933,7 @@ submit_async (
 		__FUNCTION__, urb-&gt;dev-&gt;devpath, urb,
 		epnum &amp; 0x0f, (epnum &amp; USB_DIR_IN) ? "in" : "out",
 		urb-&gt;transfer_buffer_length,
-		qtd, ep-&gt;hcpriv);
+		qtd, urb-&gt;ep-&gt;hcpriv);
 #endif
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
@@ -942,9 +942,13 @@ submit_async (
 		rc = -ESHUTDOWN;
 		goto done;
 	}
+	rc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(rc))
+		goto done;
 
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	if (unlikely(qh == NULL)) {
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 		rc = -ENOMEM;
 		goto done;
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index e682f2342ef8..8b267b3fd2bb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -797,7 +797,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static int intr_submit (
 	struct ehci_hcd		*ehci,
-	struct usb_host_endpoint *ep,
 	struct urb		*urb,
 	struct list_head	*qtd_list,
 	gfp_t			mem_flags
@@ -805,23 +804,26 @@ static int intr_submit (
 	unsigned		epnum;
 	unsigned long		flags;
 	struct ehci_qh		*qh;
-	int			status = 0;
+	int			status;
 	struct list_head	empty;
 
 	/* get endpoint and transfer/schedule data */
-	epnum = ep-&gt;desc.bEndpointAddress;
+	epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
 			&amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-		goto done;
+		goto done_not_linked;
 	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
 
 	/* get qh and force any scheduling errors */
 	INIT_LIST_HEAD (&amp;empty);
-	qh = qh_append_tds (ehci, urb, &amp;empty, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, &amp;empty, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	if (qh == NULL) {
 		status = -ENOMEM;
 		goto done;
@@ -832,13 +834,16 @@ static int intr_submit (
 	}
 
 	/* then queue the urb's tds to the qh */
-	qh = qh_append_tds (ehci, urb, qtd_list, epnum, &amp;ep-&gt;hcpriv);
+	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	BUG_ON (qh == NULL);
 
 	/* ... update usbfs periodic stats */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_int_reqs++;
 
 done:
+	if (unlikely(status))
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	if (status)
 		qtd_list_free (ehci, urb, qtd_list);
@@ -1686,12 +1691,19 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags)))
+			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (likely (status == 0))
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 done:
@@ -2049,12 +2061,19 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags)))
+			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
 		status = -ESHUTDOWN;
-	else
-		status = iso_stream_schedule (ehci, urb, stream);
+		goto done_not_linked;
+	}
+	status = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);
+	if (unlikely(status))
+		goto done_not_linked;
+	status = iso_stream_schedule(ehci, urb, stream);
 	if (status == 0)
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
+	else
+		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 done:
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 5c851a36de72..d5027dc75a57 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -290,6 +290,7 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 
 	urb_dbg(urb, "Finish");
 
+	usb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);
 	spin_unlock(&amp;isp116x-&gt;lock);
 	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
 	spin_lock(&amp;isp116x-&gt;lock);
@@ -673,7 +674,7 @@ static int balance(struct isp116x *isp116x, u16 period, u16 load)
 /*-----------------------------------------------------------------*/
 
 static int isp116x_urb_enqueue(struct usb_hcd *hcd,
-			       struct usb_host_endpoint *hep, struct urb *urb,
+			       struct urb *urb,
 			       gfp_t mem_flags)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
@@ -682,6 +683,7 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	int is_out = !usb_pipein(pipe);
 	int type = usb_pipetype(pipe);
 	int epnum = usb_pipeendpoint(pipe);
+	struct usb_host_endpoint *hep = urb-&gt;ep;
 	struct isp116x_ep *ep = NULL;
 	unsigned long flags;
 	int i;
@@ -705,7 +707,12 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	if (!HC_IS_RUNNING(hcd-&gt;state)) {
 		kfree(ep);
 		ret = -ENODEV;
-		goto fail;
+		goto fail_not_linked;
+	}
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep-&gt;hcpriv)
@@ -818,6 +825,9 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	start_atl_transfers(isp116x);
 
       fail:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+      fail_not_linked:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 	return ret;
 }
@@ -825,20 +835,21 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 /*
    Dequeue URBs.
 */
-static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	struct usb_host_endpoint *hep;
 	struct isp116x_ep *ep, *ep_act;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&amp;isp116x-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	hep = urb-&gt;hcpriv;
-	/* URB already unlinked (or never linked)? */
-	if (!hep) {
-		spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-		return 0;
-	}
 	ep = hep-&gt;hcpriv;
 	WARN_ON(hep != ep-&gt;hep);
 
@@ -856,9 +867,9 @@ static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 
 	if (urb)
 		finish_request(isp116x, ep, urb);
-
+ done:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void isp116x_endpoint_disable(struct usb_hcd *hcd,
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index d673cb9c36b1..6b06ab69938f 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -117,7 +117,6 @@ MODULE_PARM_DESC (no_handshake, "true (not default) disables BIOS handshake");
  */
 static int ohci_urb_enqueue (
 	struct usb_hcd	*hcd,
-	struct usb_host_endpoint *ep,
 	struct urb	*urb,
 	gfp_t		mem_flags
 ) {
@@ -134,7 +133,7 @@ static int ohci_urb_enqueue (
 #endif
 
 	/* every endpoint has a ed, locate and maybe (re)initialize it */
-	if (! (ed = ed_get (ohci, ep, urb-&gt;dev, pipe, urb-&gt;interval)))
+	if (! (ed = ed_get (ohci, urb-&gt;ep, urb-&gt;dev, pipe, urb-&gt;interval)))
 		return -ENOMEM;
 
 	/* for the private part of the URB we need the number of TDs (size) */
@@ -199,22 +198,17 @@ static int ohci_urb_enqueue (
 		retval = -ENODEV;
 		goto fail;
 	}
-
-	/* in case of unlink-during-submit */
-	spin_lock (&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock (&amp;urb-&gt;lock);
-		urb-&gt;hcpriv = urb_priv;
-		finish_urb (ohci, urb);
-		retval = 0;
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval)
 		goto fail;
-	}
 
 	/* schedule the ed if needed */
 	if (ed-&gt;state == ED_IDLE) {
 		retval = ed_schedule (ohci, ed);
-		if (retval &lt; 0)
-			goto fail0;
+		if (retval &lt; 0) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			goto fail;
+		}
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 			u16	frame = ohci_frame_no(ohci);
 
@@ -238,8 +232,6 @@ static int ohci_urb_enqueue (
 	urb-&gt;hcpriv = urb_priv;
 	td_submit_urb (ohci, urb);
 
-fail0:
-	spin_unlock (&amp;urb-&gt;lock);
 fail:
 	if (retval)
 		urb_free_priv (ohci, urb_priv);
@@ -253,17 +245,21 @@ static int ohci_urb_enqueue (
  * asynchronously, and we might be dealing with an urb that's
  * partially transferred, or an ED with other urbs being unlinked.
  */
-static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
+static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	unsigned long		flags;
+	int			rc;
 
 #ifdef OHCI_VERBOSE_DEBUG
 	urb_print (urb, "UNLINK", 1);
 #endif
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	if (HC_IS_RUNNING(hcd-&gt;state)) {
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc) {
+		;	/* Do nothing */
+	} else if (HC_IS_RUNNING(hcd-&gt;state)) {
 		urb_priv_t  *urb_priv;
 
 		/* Unless an IRQ completed the unlink while it was being
@@ -284,7 +280,7 @@ static int ohci_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 			finish_urb (ohci, urb);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 547d39be3eb9..889c0720743b 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -74,6 +74,7 @@ __acquires(ohci-&gt;lock)
 #endif
 
 	/* urb-&gt;complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
 	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
 	spin_lock (&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 40a1de4c256e..94bb229df3bc 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -784,6 +784,9 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 		if (urb) {
 			urb-&gt;status = -ENODEV;
 			urb-&gt;hcpriv = NULL;
+			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
+					urb);
+
 			spin_unlock(&amp;r8a66597-&gt;lock);
 			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
 			spin_lock(&amp;r8a66597-&gt;lock);
@@ -1131,6 +1134,8 @@ static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
 		urb-&gt;hcpriv = NULL;
+		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
+
 		spin_unlock(&amp;r8a66597-&gt;lock);
 		usb_hcd_giveback_urb(hcd, urb);
 		spin_lock(&amp;r8a66597-&gt;lock);
@@ -1722,21 +1727,25 @@ static struct r8a66597_td *r8a66597_make_td(struct r8a66597 *r8a66597,
 }
 
 static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
-				struct usb_host_endpoint *hep,
 				struct urb *urb,
 				gfp_t mem_flags)
 {
+	struct usb_host_endpoint *hep = urb-&gt;ep;
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td = NULL;
-	int ret = 0, request = 0;
+	int ret, request = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;r8a66597-&gt;lock, flags);
 	if (!get_urb_to_r8a66597_dev(r8a66597, urb)) {
 		ret = -ENODEV;
-		goto error;
+		goto error_not_linked;
 	}
 
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto error_not_linked;
+
 	if (!hep-&gt;hcpriv) {
 		hep-&gt;hcpriv = kzalloc(sizeof(struct r8a66597_pipe),
 				GFP_ATOMIC);
@@ -1761,15 +1770,7 @@ static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
 	if (list_empty(&amp;r8a66597-&gt;pipe_queue[td-&gt;pipenum]))
 		request = 1;
 	list_add_tail(&amp;td-&gt;queue, &amp;r8a66597-&gt;pipe_queue[td-&gt;pipenum]);
-
-	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
-		ret = -EPIPE;
-		goto error;
-	}
 	urb-&gt;hcpriv = td;
-	spin_unlock(&amp;urb-&gt;lock);
 
 	if (request) {
 		ret = start_transfer(r8a66597, td);
@@ -1781,17 +1782,26 @@ static int r8a66597_urb_enqueue(struct usb_hcd *hcd,
 		set_td_timer(r8a66597, td);
 
 error:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+error_not_linked:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
 	return ret;
 }
 
-static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
 {
 	struct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);
 	struct r8a66597_td *td;
 	unsigned long flags;
+	int rc;
 
 	spin_lock_irqsave(&amp;r8a66597-&gt;lock, flags);
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
+		goto done;
+
 	if (urb-&gt;hcpriv) {
 		td = urb-&gt;hcpriv;
 		pipe_stop(r8a66597, td-&gt;pipe);
@@ -1799,8 +1809,9 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
 		done(r8a66597, td, td-&gt;pipenum, urb);
 	}
+ done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 4cfa3ff2c993..3d3a63d002c5 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -441,6 +441,7 @@ static void finish_request(
 	urb-&gt;hcpriv = NULL;
 	spin_unlock(&amp;urb-&gt;lock);
 
+	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
 	spin_unlock(&amp;sl811-&gt;lock);
 	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
 	spin_lock(&amp;sl811-&gt;lock);
@@ -807,7 +808,6 @@ static int balance(struct sl811 *sl811, u16 period, u16 load)
 
 static int sl811h_urb_enqueue(
 	struct usb_hcd		*hcd,
-	struct usb_host_endpoint *hep,
 	struct urb		*urb,
 	gfp_t			mem_flags
 ) {
@@ -820,7 +820,8 @@ static int sl811h_urb_enqueue(
 	struct sl811h_ep	*ep = NULL;
 	unsigned long		flags;
 	int			i;
-	int			retval = 0;
+	int			retval;
+	struct usb_host_endpoint	*hep = urb-&gt;ep;
 
 #ifdef	DISABLE_ISO
 	if (type == PIPE_ISOCHRONOUS)
@@ -838,7 +839,12 @@ static int sl811h_urb_enqueue(
 			|| !HC_IS_RUNNING(hcd-&gt;state)) {
 		retval = -ENODEV;
 		kfree(ep);
-		goto fail;
+		goto fail_not_linked;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		kfree(ep);
+		goto fail_not_linked;
 	}
 
 	if (hep-&gt;hcpriv) {
@@ -965,23 +971,27 @@ static int sl811h_urb_enqueue(
 	start_transfer(sl811);
 	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811-&gt;irq_enable);
 fail:
+	if (retval)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+fail_not_linked:
 	spin_unlock_irqrestore(&amp;sl811-&gt;lock, flags);
 	return retval;
 }
 
-static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct sl811		*sl811 = hcd_to_sl811(hcd);
 	struct usb_host_endpoint *hep;
 	unsigned long		flags;
 	struct sl811h_ep	*ep;
-	int			retval = 0;
+	int			retval;
 
 	spin_lock_irqsave(&amp;sl811-&gt;lock, flags);
-	hep = urb-&gt;hcpriv;
-	if (!hep)
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
 		goto fail;
 
+	hep = urb-&gt;hcpriv;
 	ep = hep-&gt;hcpriv;
 	if (ep) {
 		/* finish right away if this urb can't be active ...
@@ -1029,8 +1039,8 @@ static int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 			VDBG("dequeue, urb %p active %s; wait4irq\n", urb,
 				(sl811-&gt;active_a == ep) ? "A" : "B");
 	} else
-fail:
 		retval = -EINVAL;
+ fail:
 	spin_unlock_irqrestore(&amp;sl811-&gt;lock, flags);
 	return retval;
 }
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 598ad098aeeb..c87660b5edc3 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -521,6 +521,7 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         urb-&gt;status = status;
         urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
         if (ENDP_QUEUE_SIZE &gt; --endp-&gt;queue_size) {
                 endp-&gt;active = 0;
@@ -561,6 +562,7 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         urb-&gt;status = status;
         urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
         if (ENDP_QUEUE_SIZE &gt; --endp-&gt;queue_size) {
                 endp-&gt;active = 0;
@@ -1876,20 +1878,32 @@ static int u132_hcd_reset(struct usb_hcd *hcd)
 }
 
 static int create_endpoint_and_queue_int(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
         gfp_t mem_flags)
 {
         struct u132_ring *ring;
         unsigned long irqs;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         ring = endp-&gt;ring = &amp;u132-&gt;ring[0];
         if (ring-&gt;curr_endp) {
@@ -1905,7 +1919,7 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         endp-&gt;pipetype = usb_pipetype(urb-&gt;pipe);
         u132_endp_init_kref(u132, endp);
         if (usb_pipein(urb-&gt;pipe)) {
@@ -1924,7 +1938,6 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
                 u132_udev_get_kref(u132, udev);
         }
         urb-&gt;hcpriv = u132;
-        spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
         endp-&gt;delayed = 1;
         endp-&gt;jiffies = jiffies + msecs_to_jiffies(urb-&gt;interval);
         endp-&gt;udev_number = address;
@@ -1939,8 +1952,8 @@ static int create_endpoint_and_queue_int(struct u132 *u132,
         return 0;
 }
 
-static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-        struct usb_host_endpoint *hep, struct urb *urb,
+static int queue_int_on_old_endpoint(struct u132 *u132,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp, u8 address)
 {
@@ -1964,21 +1977,33 @@ static int queue_int_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
 }
 
 static int create_endpoint_and_queue_bulk(struct u132 *u132,
-        struct u132_udev *udev, struct usb_host_endpoint *hep, struct urb *urb,
+	struct u132_udev *udev, struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,
         gfp_t mem_flags)
 {
         int ring_number;
         struct u132_ring *ring;
         unsigned long irqs;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         endp-&gt;dequeueing = 0;
         endp-&gt;edset_flush = 0;
@@ -1986,7 +2011,7 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         endp-&gt;pipetype = usb_pipetype(urb-&gt;pipe);
         u132_endp_init_kref(u132, endp);
         if (usb_pipein(urb-&gt;pipe)) {
@@ -2015,7 +2040,6 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
         }
         ring-&gt;length += 1;
         urb-&gt;hcpriv = u132;
-        spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
         endp-&gt;udev_number = address;
         endp-&gt;usb_addr = usb_addr;
         endp-&gt;usb_endp = usb_endp;
@@ -2029,7 +2053,7 @@ static int create_endpoint_and_queue_bulk(struct u132 *u132,
 }
 
 static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
-         struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp, u8 address)
 {
@@ -2051,19 +2075,32 @@ static int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,
 }
 
 static int create_endpoint_and_queue_control(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,
         gfp_t mem_flags)
 {
         struct u132_ring *ring;
-        u8 endp_number = ++u132-&gt;num_endpoints;
-        struct u132_endp *endp = hep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] =
-                kmalloc(sizeof(struct u132_endp), mem_flags);
+	unsigned long irqs;
+	int rc;
+	u8 endp_number;
+	struct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);
+
         if (!endp) {
                 return -ENOMEM;
         }
+
+	spin_lock_init(&amp;endp-&gt;queue_lock.slock);
+	spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		kfree(endp);
+		return rc;
+	}
+
+	endp_number = ++u132-&gt;num_endpoints;
+	urb-&gt;ep-&gt;hcpriv = u132-&gt;endp[endp_number - 1] = endp;
         INIT_DELAYED_WORK(&amp;endp-&gt;scheduler, u132_hcd_endp_work_scheduler);
-        spin_lock_init(&amp;endp-&gt;queue_lock.slock);
         INIT_LIST_HEAD(&amp;endp-&gt;urb_more);
         ring = endp-&gt;ring = &amp;u132-&gt;ring[0];
         if (ring-&gt;curr_endp) {
@@ -2079,11 +2116,10 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
         endp-&gt;delayed = 0;
         endp-&gt;endp_number = endp_number;
         endp-&gt;u132 = u132;
-        endp-&gt;hep = hep;
+	endp-&gt;hep = urb-&gt;ep;
         u132_endp_init_kref(u132, endp);
         u132_endp_get_kref(u132, endp);
         if (usb_addr == 0) {
-                unsigned long irqs;
                 u8 address = u132-&gt;addr[usb_addr].address;
                 struct u132_udev *udev = &amp;u132-&gt;udev[address];
                 endp-&gt;udev_number = address;
@@ -2097,7 +2133,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 udev-&gt;endp_number_in[usb_endp] = endp_number;
                 udev-&gt;endp_number_out[usb_endp] = endp_number;
                 urb-&gt;hcpriv = u132;
-                spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
                 endp-&gt;queue_size = 1;
                 endp-&gt;queue_last = 0;
                 endp-&gt;queue_next = 0;
@@ -2106,7 +2141,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 u132_endp_queue_work(u132, endp, 0);
                 return 0;
         } else {                /*(usb_addr &gt; 0) */
-                unsigned long irqs;
                 u8 address = u132-&gt;addr[usb_addr].address;
                 struct u132_udev *udev = &amp;u132-&gt;udev[address];
                 endp-&gt;udev_number = address;
@@ -2120,7 +2154,6 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
                 udev-&gt;endp_number_in[usb_endp] = endp_number;
                 udev-&gt;endp_number_out[usb_endp] = endp_number;
                 urb-&gt;hcpriv = u132;
-                spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
                 endp-&gt;queue_size = 1;
                 endp-&gt;queue_last = 0;
                 endp-&gt;queue_next = 0;
@@ -2132,7 +2165,7 @@ static int create_endpoint_and_queue_control(struct u132 *u132,
 }
 
 static int queue_control_on_old_endpoint(struct u132 *u132,
-        struct usb_host_endpoint *hep, struct urb *urb,
+	struct urb *urb,
         struct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,
         u8 usb_endp)
 {
@@ -2232,8 +2265,8 @@ static int queue_control_on_old_endpoint(struct u132 *u132,
         }
 }
 
-static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
-        struct urb *urb, gfp_t mem_flags)
+static int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
 {
         struct u132 *u132 = hcd_to_u132(hcd);
         if (irqs_disabled()) {
@@ -2258,16 +2291,24 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                 if (usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT) {
                         u8 address = u132-&gt;addr[usb_addr].address;
                         struct u132_udev *udev = &amp;u132-&gt;udev[address];
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         urb-&gt;actual_length = 0;
                         if (endp) {
                                 unsigned long irqs;
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_int_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_int_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2282,8 +2323,8 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else {        /*(endp == NULL) */
                                 return create_endpoint_and_queue_int(u132, udev,
-                                         hep, urb, usb_dev, usb_addr, usb_endp,
-                                        address, mem_flags);
+						urb, usb_dev, usb_addr,
+						usb_endp, address, mem_flags);
                         }
                 } else if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
                         dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "the hardware does no"
@@ -2292,16 +2333,24 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                 } else if (usb_pipetype(urb-&gt;pipe) == PIPE_BULK) {
                         u8 address = u132-&gt;addr[usb_addr].address;
                         struct u132_udev *udev = &amp;u132-&gt;udev[address];
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         urb-&gt;actual_length = 0;
                         if (endp) {
                                 unsigned long irqs;
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_bulk_on_old_endpoint(u132, udev,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp, address);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_bulk_on_old_endpoint(
+							u132, udev, urb,
+							usb_dev, endp,
+							usb_addr, usb_endp,
+							address);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2314,10 +2363,10 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else
                                 return create_endpoint_and_queue_bulk(u132,
-                                        udev, hep, urb, usb_dev, usb_addr,
+					udev, urb, usb_dev, usb_addr,
                                         usb_endp, address, mem_flags);
                 } else {
-                        struct u132_endp *endp = hep-&gt;hcpriv;
+                        struct u132_endp *endp = urb-&gt;ep-&gt;hcpriv;
                         u16 urb_size = 8;
                         u8 *b = urb-&gt;setup_packet;
                         int i = 0;
@@ -2340,9 +2389,16 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 int retval;
                                 spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
-                                retval = queue_control_on_old_endpoint(u132,
-                                        hep, urb, usb_dev, endp, usb_addr,
-                                        usb_endp);
+				retval = usb_hcd_link_urb_to_ep(hcd, urb);
+				if (retval == 0) {
+					retval = queue_control_on_old_endpoint(
+							u132, urb, usb_dev,
+							endp, usb_addr,
+							usb_endp);
+					if (retval)
+						usb_hcd_unlink_urb_from_ep(
+								hcd, urb);
+				}
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
                                         irqs);
                                 if (retval) {
@@ -2355,7 +2411,7 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct usb_host_endpoint *hep,
                                 return -EINVAL;
                         } else
                                 return create_endpoint_and_queue_control(u132,
-                                        hep, urb, usb_dev, usb_addr, usb_endp,
+					urb, usb_dev, usb_addr, usb_endp,
                                         mem_flags);
                 }
         }
@@ -2390,10 +2446,17 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
 }
 
 static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
-        struct urb *urb)
+		struct urb *urb, int status)
 {
         unsigned long irqs;
+	int rc;
+
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
+	rc = usb_hcd_check_unlink_urb(u132_to_hcd(u132), urb, status);
+	if (rc) {
+		spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
+		return rc;
+	}
         if (endp-&gt;queue_size == 0) {
                 dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "urb=%p not found in endp[%d]"
                         "=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,
@@ -2438,6 +2501,8 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                 }
                 if (urb_slot) {
                         struct usb_hcd *hcd = u132_to_hcd(u132);
+
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
                         endp-&gt;queue_size -= 1;
                         if (list_empty(&amp;endp-&gt;urb_more)) {
                                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock,
@@ -2467,7 +2532,10 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                         return -EINVAL;
                 } else {
-                        int retval = dequeue_from_overflow_chain(u132, endp,
+			int retval;
+
+			usb_hcd_unlink_urb_from_ep(u132_to_hcd(u132), urb);
+			retval = dequeue_from_overflow_chain(u132, endp,
                                 urb);
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                         return retval;
@@ -2475,7 +2543,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
         }
 }
 
-static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
         struct u132 *u132 = hcd_to_u132(hcd);
         if (u132-&gt;going &gt; 2) {
@@ -2490,11 +2558,11 @@ static int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
                 if (usb_pipein(urb-&gt;pipe)) {
                         u8 endp_number = udev-&gt;endp_number_in[usb_endp];
                         struct u132_endp *endp = u132-&gt;endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
+                        return u132_endp_urb_dequeue(u132, endp, urb, status);
                 } else {
                         u8 endp_number = udev-&gt;endp_number_out[usb_endp];
                         struct u132_endp *endp = u132-&gt;endp[endp_number - 1];
-                        return u132_endp_urb_dequeue(u132, endp, urb);
+                        return u132_endp_urb_dequeue(u132, endp, urb, status);
                 }
         }
 }
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 3bb908ca38e9..bff200cb3d2e 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1376,7 +1376,6 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
-		struct usb_host_endpoint *hep,
 		struct urb *urb, gfp_t mem_flags)
 {
 	int ret;
@@ -1387,19 +1386,19 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
-	ret = urb-&gt;status;
-	if (ret != -EINPROGRESS)		/* URB already unlinked! */
-		goto done;
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (ret)
+		goto done_not_linked;
 
 	ret = -ENOMEM;
 	urbp = uhci_alloc_urb_priv(uhci, urb);
 	if (!urbp)
 		goto done;
 
-	if (hep-&gt;hcpriv)
-		qh = (struct uhci_qh *) hep-&gt;hcpriv;
+	if (urb-&gt;ep-&gt;hcpriv)
+		qh = urb-&gt;ep-&gt;hcpriv;
 	else {
-		qh = uhci_alloc_qh(uhci, urb-&gt;dev, hep);
+		qh = uhci_alloc_qh(uhci, urb-&gt;dev, urb-&gt;ep);
 		if (!qh)
 			goto err_no_qh;
 	}
@@ -1440,27 +1439,29 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 err_submit_failed:
 	if (qh-&gt;state == QH_STATE_IDLE)
 		uhci_make_qh_idle(uhci, qh);	/* Reclaim unused QH */
-
 err_no_qh:
 	uhci_free_urb_priv(uhci, urbp);
-
 done:
+	if (ret)
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+done_not_linked:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 	return ret;
 }
 
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	struct urb_priv *urbp;
 	struct uhci_qh *qh;
+	int rc;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	urbp = urb-&gt;hcpriv;
-	if (!urbp)			/* URB was never linked! */
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc)
 		goto done;
-	qh = urbp-&gt;qh;
+
+	qh = ((struct urb_priv *) urb-&gt;hcpriv)-&gt;qh;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
@@ -1477,7 +1478,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 
 done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-	return 0;
+	return rc;
 }
 
 /*
@@ -1529,6 +1530,7 @@ __acquires(uhci-&gt;lock)
 	}
 
 	uhci_free_urb_priv(uhci, urbp);
+	usb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);
 
 	spin_unlock(&amp;uhci-&gt;lock);
 	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);</pre><hr><pre>commit 9a9bf406df3ce238089d14f4cb41157ca56d8ad3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:06:54 2007 -0400

    USB: separate out endpoint queue management and DMA mapping routines
    
    This patch (as953) separates out three key portions from
    usb_hcd_submit_urb(), usb_hcd_unlink_urb(), and usb_hcd_giveback_urb()
    and puts them in separate functions of their own.  In the next patch,
    these functions will be called directly by host controller drivers
    while holding their private spinlocks, which will remove the
    possibility of some unpleasant races.
    
    The code responsible for mapping and unmapping DMA buffers is also
    placed into a couple of separate subroutines, for the sake of
    cleanliness and consistency.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index f8e7deb03ee9..eb2121788264 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -914,99 +914,117 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 
 /*-------------------------------------------------------------------------*/
 
-static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
+static int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long		flags;
+	unsigned long	flags;
+	int		rc = 0;
 
-	/* clear all state linking urb to this dev (and hcd) */
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	list_del_init (&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
-	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
-		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
-			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
-					sizeof (struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
-		if (urb-&gt;transfer_buffer_length != 0
-			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
-			dma_unmap_single (hcd-&gt;self.controller,
-					urb-&gt;transfer_dma,
-					urb-&gt;transfer_buffer_length,
-					usb_urb_dir_in(urb)
-					    ? DMA_FROM_DEVICE
-					    : DMA_TO_DEVICE);
+	/* Check that the URB isn't being killed */
+	if (unlikely(urb-&gt;reject)) {
+		rc = -EPERM;
+		goto done;
 	}
-}
-
-/* may be called in any context with a valid urb-&gt;dev usecount
- * caller surrenders "ownership" of urb
- * expects usb_submit_urb() to have sanity checked and conditioned all
- * inputs in the urb
- */
-int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
-{
-	int			status;
-	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	unsigned long		flags;
-
-	if (!hcd)
-		return -ENODEV;
 
-	usbmon_urb_submit(&amp;hcd-&gt;self, urb);
+	if (unlikely(!urb-&gt;ep-&gt;enabled)) {
+		rc = -ENOENT;
+		goto done;
+	}
 
 	/*
-	 * Atomically queue the urb,  first to our records, then to the HCD.
-	 * Access to urb-&gt;status is controlled by urb-&gt;lock ... changes on
-	 * i/o completion (normal or fault) or unlinking.
+	 * Check the host controller's state and add the URB to the
+	 * endpoint's queue.
 	 */
-
-	// FIXME:  verify that quiescing hc works right (RH cleans up)
-
-	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	if (unlikely(!urb-&gt;ep-&gt;enabled))
-		status = -ENOENT;
-	else if (unlikely (urb-&gt;reject))
-		status = -EPERM;
-	else switch (hcd-&gt;state) {
+	switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
-		list_add_tail (&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
-		status = 0;
+		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		break;
 	default:
-		status = -ESHUTDOWN;
-		break;
+		rc = -ESHUTDOWN;
+		goto done;
 	}
+ done:
 	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
-	if (status) {
-		INIT_LIST_HEAD (&amp;urb-&gt;urb_list);
-		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		return status;
+	return rc;
+}
+
+static int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status)
+{
+	unsigned long		flags;
+	struct list_head	*tmp;
+	int			rc = 0;
+
+	/*
+	 * we contend for urb-&gt;status with the hcd core,
+	 * which changes it while returning the urb.
+	 *
+	 * Caller guaranteed that the urb pointer hasn't been freed, and
+	 * that it was submitted.  But as a rule it can't know whether or
+	 * not it's already been unlinked ... so we respect the reversed
+	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
+	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
+	 * unlinking it.
+	 */
+	spin_lock_irqsave(&amp;urb-&gt;lock, flags);
+	spin_lock(&amp;hcd_urb_list_lock);
+
+	/* insist the urb is still queued */
+	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
+		if (tmp == &amp;urb-&gt;urb_list)
+			break;
+	}
+	if (tmp != &amp;urb-&gt;urb_list) {
+		rc = -EIDRM;
+		goto done;
 	}
 
-	/* increment urb's reference count as part of giving it to the HCD
-	 * (which now controls it).  HCD guarantees that it either returns
-	 * an error or calls giveback(), but not both.
+	/* Any status except -EINPROGRESS means something already started to
+	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	urb = usb_get_urb (urb);
-	atomic_inc (&amp;urb-&gt;use_count);
-
-	if (is_root_hub(urb-&gt;dev)) {
-		/* NOTE:  requirement on hub callers (usbfs and the hub
-		 * driver, for now) that URBs' urb-&gt;transfer_buffer be
-		 * valid and usb_buffer_{sync,unmap}() not be needed, since
-		 * they could clobber root hub response data.
-		 */
-		status = rh_urb_enqueue (hcd, urb);
+	if (urb-&gt;status != -EINPROGRESS) {
+		rc = -EBUSY;
 		goto done;
 	}
+	urb-&gt;status = status;
+
+	/* IRQ setup can easily be broken so that USB controllers
+	 * never get completion IRQs ... maybe even the ones we need to
+	 * finish unlinking the initial failed usb_set_address()
+	 * or device descriptor fetch.
+	 */
+	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
+			!is_root_hub(urb-&gt;dev)) {
+		dev_warn(hcd-&gt;self.controller, "Unlink after no-IRQ?  "
+			"Controller is probably using the wrong IRQ.\n");
+		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
+	}
+
+ done:
+	spin_unlock(&amp;hcd_urb_list_lock);
+	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
+	return rc;
+}
+
+static void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)
+{
+	unsigned long		flags;
 
-	/* lower level hcd code should use *_dma exclusively,
+	/* clear all state linking urb to this dev (and hcd) */
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
+	list_del_init(&amp;urb-&gt;urb_list);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
+}
+
+static void map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	/* Map the URB's buffers for DMA access.
+	 * Lower level HCD code should use *_dma exclusively,
 	 * unless it uses pio or talks to another transport.
 	 */
-	if (hcd-&gt;self.uses_dma) {
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
 		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
@@ -1024,16 +1042,73 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
+}
 
-	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, urb-&gt;ep, urb, mem_flags);
-done:
-	if (unlikely (status)) {
-		urb_unlink(hcd, urb);
-		atomic_dec (&amp;urb-&gt;use_count);
-		if (urb-&gt;reject)
-			wake_up (&amp;usb_kill_urb_queue);
+static void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
+			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
+			dma_unmap_single(hcd-&gt;self.controller, urb-&gt;setup_dma,
+					sizeof(struct usb_ctrlrequest),
+					DMA_TO_DEVICE);
+		if (urb-&gt;transfer_buffer_length != 0
+			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
+			dma_unmap_single(hcd-&gt;self.controller,
+					urb-&gt;transfer_dma,
+					urb-&gt;transfer_buffer_length,
+					usb_urb_dir_in(urb)
+					    ? DMA_FROM_DEVICE
+					    : DMA_TO_DEVICE);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* may be called in any context with a valid urb-&gt;dev usecount
+ * caller surrenders "ownership" of urb
+ * expects usb_submit_urb() to have sanity checked and conditioned all
+ * inputs in the urb
+ */
+int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
+{
+	int			status;
+	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
+
+	/* increment urb's reference count as part of giving it to the HCD
+	 * (which will control it).  HCD guarantees that it either returns
+	 * an error or calls giveback(), but not both.
+	 */
+	usb_get_urb(urb);
+	atomic_inc(&amp;urb-&gt;use_count);
+	usbmon_urb_submit(&amp;hcd-&gt;self, urb);
+
+	/* NOTE requirements on root-hub callers (usbfs and the hub
+	 * driver, for now):  URBs' urb-&gt;transfer_buffer must be
+	 * valid and usb_buffer_{sync,unmap}() not be needed, since
+	 * they could clobber root hub response data.  Also, control
+	 * URBs must be submitted in process context with interrupts
+	 * enabled.
+	 */
+	status = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (!status) {
+		map_urb_for_dma(hcd, urb);
+		if (is_root_hub(urb-&gt;dev))
+			status = rh_urb_enqueue(hcd, urb);
+		else
+			status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb-&gt;ep, urb,
+					mem_flags);
+	}
+
+	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		usb_put_urb (urb);
+		unmap_urb_for_dma(hcd, urb);
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
+		atomic_dec(&amp;urb-&gt;use_count);
+		if (urb-&gt;reject)
+			wake_up(&amp;usb_kill_urb_queue);
+		usb_put_urb(urb);
 	}
 	return status;
 }
@@ -1074,78 +1149,20 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  */
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
-	struct usb_hcd			*hcd = NULL;
-	struct device			*sys = NULL;
-	unsigned long			flags;
-	struct list_head		*tmp;
-	int				retval;
-
-	/*
-	 * we contend for urb-&gt;status with the hcd core,
-	 * which changes it while returning the urb.
-	 *
-	 * Caller guaranteed that the urb pointer hasn't been freed, and
-	 * that it was submitted.  But as a rule it can't know whether or
-	 * not it's already been unlinked ... so we respect the reversed
-	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
-	 * unlinking it.
-	 */
-	spin_lock_irqsave (&amp;urb-&gt;lock, flags);
-	spin_lock(&amp;hcd_urb_list_lock);
+	struct usb_hcd		*hcd;
+	int			retval;
 
-	sys = &amp;urb-&gt;dev-&gt;dev;
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	if (hcd == NULL) {
-		retval = -ENODEV;
-		goto done;
-	}
-
-	/* insist the urb is still queued */
-	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
-		if (tmp == &amp;urb-&gt;urb_list)
-			break;
-	}
-	if (tmp != &amp;urb-&gt;urb_list) {
-		retval = -EIDRM;
-		goto done;
-	}
 
-	/* Any status except -EINPROGRESS means something already started to
-	 * unlink this URB from the hardware.  So there's no more work to do.
-	 */
-	if (urb-&gt;status != -EINPROGRESS) {
-		retval = -EBUSY;
-		goto done;
-	}
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (!retval)
+		retval = unlink1(hcd, urb);
 
-	/* IRQ setup can easily be broken so that USB controllers
-	 * never get completion IRQs ... maybe even the ones we need to
-	 * finish unlinking the initial failed usb_set_address()
-	 * or device descriptor fetch.
-	 */
-	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
-			!is_root_hub(urb-&gt;dev)) {
-		dev_warn (hcd-&gt;self.controller, "Unlink after no-IRQ?  "
-			"Controller is probably using the wrong IRQ.\n");
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-	}
-
-	urb-&gt;status = status;
-
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-
-	retval = unlink1 (hcd, urb);
 	if (retval == 0)
 		retval = -EINPROGRESS;
-	return retval;
-
-done:
-	spin_unlock(&amp;hcd_urb_list_lock);
-	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
-	if (retval != -EIDRM &amp;&amp; sys &amp;&amp; sys-&gt;driver)
-		dev_dbg (sys, "hcd_unlink_urb %p fail %d\n", urb, retval);
+	else if (retval != -EIDRM)
+		dev_dbg(&amp;urb-&gt;dev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
+				urb, retval);
 	return retval;
 }
 
@@ -1165,7 +1182,8 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	urb_unlink(hcd, urb);
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
 
@@ -1194,12 +1212,12 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
 
+	might_sleep();
 	hcd = bus_to_hcd(udev-&gt;bus);
-	local_irq_disable ();
 
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
-	spin_lock(&amp;hcd_urb_list_lock);
+	spin_lock_irq(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 		int	is_in;
@@ -1244,13 +1262,11 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		/* list contents may have changed */
 		goto rescan;
 	}
-	spin_unlock(&amp;hcd_urb_list_lock);
-	local_irq_enable ();
+	spin_unlock_irq(&amp;hcd_urb_list_lock);
 
 	/* synchronize with the hardware, so old configuration state
 	 * clears out immediately (and will be freed).
 	 */
-	might_sleep ();
 	if (hcd-&gt;driver-&gt;endpoint_disable)
 		hcd-&gt;driver-&gt;endpoint_disable (hcd, ep);
 </pre><hr><pre>commit 9439eb94b5c374d5b02699f8897fc43aa3603701
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:05:45 2007 -0400

    USB: update spinlock usage for root-hub URBs
    
    This patch (as952) adjusts the spinlock usage in the root-hub
    emulation part of usbcore, to make it match more closely the pattern
    used by regular host controller drivers.  To wit: The private lock
    (usb_hcd_root_hub_lock) is held throughout the important parts, and it
    is dropped temporarily without re-enabling interrupts around the call
    to usb_hcd_giveback_urb().
    
    A nice side effect is that the code now avoids calling
    local_irq_save(), thereby becoming more RT-friendly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 47a055a2acf5..f8e7deb03ee9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -356,10 +356,11 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	const u8	*bufp = tbuf;
 	int		len = 0;
 	int		patch_wakeup = 0;
-	unsigned long	flags;
 	int		status = 0;
 	int		n;
 
+	might_sleep();
+
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
 	wValue   = le16_to_cpu (cmd-&gt;wValue);
@@ -523,13 +524,21 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	}
 
 	/* any errors get returned through the urb completion */
-	local_irq_save (flags);
-	spin_lock (&amp;urb-&gt;lock);
+	spin_lock_irq(&amp;hcd_root_hub_lock);
+	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	spin_unlock (&amp;urb-&gt;lock);
-	usb_hcd_giveback_urb (hcd, urb);
-	local_irq_restore (flags);
+	spin_unlock(&amp;urb-&gt;lock);
+
+	/* This peculiar use of spinlocks echoes what real HC drivers do.
+	 * Avoiding calls to local_irq_disable/enable makes the code
+	 * RT-friendly.
+	 */
+	spin_unlock(&amp;hcd_root_hub_lock);
+	usb_hcd_giveback_urb(hcd, urb);
+	spin_lock(&amp;hcd_root_hub_lock);
+
+	spin_unlock_irq(&amp;hcd_root_hub_lock);
 	return 0;
 }
 
@@ -559,8 +568,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 	if (length &gt; 0) {
 
 		/* try to complete the status urb */
-		local_irq_save (flags);
-		spin_lock(&amp;hcd_root_hub_lock);
+		spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 		urb = hcd-&gt;status_urb;
 		if (urb) {
 			spin_lock(&amp;urb-&gt;lock);
@@ -574,16 +582,16 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 			} else		/* urb has been unlinked */
 				length = 0;
 			spin_unlock(&amp;urb-&gt;lock);
+
+			spin_unlock(&amp;hcd_root_hub_lock);
+			usb_hcd_giveback_urb(hcd, urb);
+			spin_lock(&amp;hcd_root_hub_lock);
 		} else
 			length = 0;
-		spin_unlock(&amp;hcd_root_hub_lock);
 
-		/* local irqs are always blocked in completions */
-		if (length &gt; 0)
-			usb_hcd_giveback_urb (hcd, urb);
-		else
+		if (length &lt;= 0)
 			hcd-&gt;poll_pending = 1;
-		local_irq_restore (flags);
+		spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	}
 
 	/* The USB 2.0 spec says 256 ms.  This is close enough and won't
@@ -651,25 +659,23 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long	flags;
 
+	spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
 	} else {				/* Status URB */
 		if (!hcd-&gt;uses_new_polling)
 			del_timer (&amp;hcd-&gt;rh_timer);
-		local_irq_save (flags);
-		spin_lock (&amp;hcd_root_hub_lock);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;hcpriv = NULL;
-		} else
-			urb = NULL;		/* wasn't fully queued */
-		spin_unlock (&amp;hcd_root_hub_lock);
-		if (urb)
-			usb_hcd_giveback_urb (hcd, urb);
-		local_irq_restore (flags);
-	}
 
+			spin_unlock(&amp;hcd_root_hub_lock);
+			usb_hcd_giveback_urb(hcd, urb);
+			spin_lock(&amp;hcd_root_hub_lock);
+		}
+	}
+	spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	return 0;
 }
 </pre><hr><pre>commit d617bc83ff48ebf0df253605529d8b3bef15773a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 15:04:52 2007 -0400

    USB: cleanup for previous patches
    
    This patch (as951) cleans up a few loose ends from earlier patches.
    Redundant checks for non-NULL urb-&gt;dev are removed, as are checks of
    urb-&gt;dev-&gt;bus (which can never be NULL).  Conversely, a check for
    non-NULL urb-&gt;ep is added to the unlink paths.
    
    A homegrown round-down-to-power-of-2 loop is simplified by using the
    ilog2 routine.  The comparison in usb_urb_dir_in() is made more
    transparent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 739c5e0aa3b8..47a055a2acf5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1074,11 +1074,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	struct list_head		*tmp;
 	int				retval;
 
-	if (!urb)
-		return -EINVAL;
-	if (!urb-&gt;dev || !urb-&gt;dev-&gt;bus)
-		return -ENODEV;
-
 	/*
 	 * we contend for urb-&gt;status with the hcd core,
 	 * which changes it while returning the urb.
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1acca8696bcd..19f5f66c2733 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -3,6 +3,7 @@
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/init.h&gt;
+#include &lt;linux/log2.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/wait.h&gt;
 #include "hcd.h"
@@ -441,10 +442,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		default:
 			return -EINVAL;
 		}
-		/* power of two? */
-		while (max &gt; urb-&gt;interval)
-			max &gt;&gt;= 1;
-		urb-&gt;interval = max;
+		/* Round down to a power of 2, no more than max */
+		urb-&gt;interval = min(max, 1 &lt;&lt; ilog2(urb-&gt;interval));
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);
@@ -513,8 +512,10 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
+	if (!urb-&gt;dev)
 		return -ENODEV;
+	if (!urb-&gt;ep)
+		return -EIDRM;
 	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
@@ -541,7 +542,7 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
+	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;ep))
 		return;
 	spin_lock_irq(&amp;urb-&gt;lock);
 	++urb-&gt;reject;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 019ae963a9fe..a51f34e80572 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1395,7 +1395,7 @@ extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
  */
 static inline int usb_urb_dir_in(struct urb *urb)
 {
-	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) != URB_DIR_OUT;
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN;
 }
 
 /**</pre><hr><pre>commit 18ea5d00d05fa6300606f0711748016c95fb26dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:10:36 2007 -0400

    USB: avoid urb-&gt;pipe in usbmon
    
    This patch (as949) changes the usbmon driver to use the new urb-&gt;ep
    field rather than urb-&gt;pipe.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index c03dfd7a9d36..0b0d77c669da 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -354,7 +354,7 @@ static inline char mon_bin_get_setup(unsigned char *setupb,
     const struct urb *urb, char ev_type)
 {
 
-	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
+	if (!usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc) || ev_type != 'S')
 		return '-';
 
 	if (urb-&gt;dev-&gt;bus-&gt;uses_dma &amp;&amp;
@@ -410,7 +410,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	if (length &gt;= rp-&gt;b_size/5)
 		length = rp-&gt;b_size/5;
 
-	if (usb_pipein(urb-&gt;pipe)) {
+	if (usb_urb_dir_in(urb)) {
 		if (ev_type == 'S') {
 			length = 0;
 			data_tag = '&lt;';
@@ -440,10 +440,22 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	 */
 	memset(ep, 0, PKT_SIZE);
 	ep-&gt;type = ev_type;
-	ep-&gt;xfer_type = usb_pipetype(urb-&gt;pipe);
-	/* We use the fact that usb_pipein() returns 0x80 */
-	ep-&gt;epnum = usb_pipeendpoint(urb-&gt;pipe) | usb_pipein(urb-&gt;pipe);
-	ep-&gt;devnum = usb_pipedevice(urb-&gt;pipe);
+	switch (usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc)) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ep-&gt;xfer_type = PIPE_CONTROL;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ep-&gt;xfer_type = PIPE_BULK;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ep-&gt;xfer_type = PIPE_INTERRUPT;
+		break;
+	default:
+		ep-&gt;xfer_type = PIPE_ISOCHRONOUS;
+		break;
+	}
+	ep-&gt;epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;ts_sec = ts.tv_sec;
@@ -500,10 +512,22 @@ static void mon_bin_error(void *data, struct urb *urb, int error)
 
 	memset(ep, 0, PKT_SIZE);
 	ep-&gt;type = 'E';
-	ep-&gt;xfer_type = usb_pipetype(urb-&gt;pipe);
-	/* We use the fact that usb_pipein() returns 0x80 */
-	ep-&gt;epnum = usb_pipeendpoint(urb-&gt;pipe) | usb_pipein(urb-&gt;pipe);
-	ep-&gt;devnum = usb_pipedevice(urb-&gt;pipe);
+	switch (usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc)) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ep-&gt;xfer_type = PIPE_CONTROL;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ep-&gt;xfer_type = PIPE_BULK;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ep-&gt;xfer_type = PIPE_INTERRUPT;
+		break;
+	default:
+		ep-&gt;xfer_type = PIPE_ISOCHRONOUS;
+		break;
+	}
+	ep-&gt;epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;status = error;
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index ce61d8b0fd86..e58f761d060f 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -154,8 +154,8 @@ static void mon_complete(struct usb_bus *ubus, struct urb *urb)
 		 * This should not happen.
 		 * At this point we do not even know the bus number...
 		 */
-		printk(KERN_ERR TAG ": Null mon bus in URB, pipe 0x%x\n",
-		    urb-&gt;pipe);
+		printk(KERN_ERR TAG ": Null mon bus in URB, address %p\n",
+		    urb);
 		return;
 	}
 
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 8f27a9e1c36b..9d0070ceef52 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -50,10 +50,12 @@ struct mon_iso_desc {
 struct mon_event_text {
 	struct list_head e_link;
 	int type;		/* submit, complete, etc. */
-	unsigned int pipe;	/* Pipe */
 	unsigned long id;	/* From pointer, most of the time */
 	unsigned int tstamp;
+	int xfertype;
 	int busnum;
+	int devnum;
+	int epnum;
 	int length;		/* Depends on type: xfer length or act length */
 	int status;
 	int interval;
@@ -61,6 +63,7 @@ struct mon_event_text {
 	int error_count;
 	char setup_flag;
 	char data_flag;
+	char is_in;
 	int numdesc;		/* Full number */
 	struct mon_iso_desc isodesc[ISODESC_MAX];
 	unsigned char setup[SETUP_MAX];
@@ -121,7 +124,7 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
     struct urb *urb, char ev_type, struct mon_bus *mbus)
 {
 
-	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
+	if (ep-&gt;xfertype != USB_ENDPOINT_XFER_CONTROL || ev_type != 'S')
 		return '-';
 
 	if (urb-&gt;dev-&gt;bus-&gt;uses_dma &amp;&amp;
@@ -138,14 +141,12 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
 static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
     int len, char ev_type, struct mon_bus *mbus)
 {
-	int pipe = urb-&gt;pipe;
-
 	if (len &lt;= 0)
 		return 'L';
 	if (len &gt;= DATA_MAX)
 		len = DATA_MAX;
 
-	if (usb_pipein(pipe)) {
+	if (ep-&gt;is_in) {
 		if (ev_type != 'C')
 			return '&lt;';
 	} else {
@@ -203,24 +204,28 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	}
 
 	ep-&gt;type = ev_type;
-	ep-&gt;pipe = urb-&gt;pipe;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
+	ep-&gt;epnum = usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;xfertype = usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;is_in = usb_urb_dir_in(urb);
 	ep-&gt;tstamp = stamp;
 	ep-&gt;length = (ev_type == 'S') ?
 	    urb-&gt;transfer_buffer_length : urb-&gt;actual_length;
 	/* Collecting status makes debugging sense for submits, too */
 	ep-&gt;status = urb-&gt;status;
 
-	if (usb_pipeint(urb-&gt;pipe)) {
+	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		ep-&gt;interval = urb-&gt;interval;
-	} else if (usb_pipeisoc(urb-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC) {
 		ep-&gt;interval = urb-&gt;interval;
 		ep-&gt;start_frame = urb-&gt;start_frame;
 		ep-&gt;error_count = urb-&gt;error_count;
 	}
 	ep-&gt;numdesc = urb-&gt;number_of_packets;
-	if (usb_pipeisoc(urb-&gt;pipe) &amp;&amp; urb-&gt;number_of_packets &gt; 0) {
+	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+			urb-&gt;number_of_packets &gt; 0) {
 		if ((ndesc = urb-&gt;number_of_packets) &gt; ISODESC_MAX)
 			ndesc = ISODESC_MAX;
 		fp = urb-&gt;iso_frame_desc;
@@ -268,9 +273,12 @@ static void mon_text_error(void *data, struct urb *urb, int error)
 	}
 
 	ep-&gt;type = 'E';
-	ep-&gt;pipe = urb-&gt;pipe;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;busnum = 0;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
+	ep-&gt;epnum = usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;xfertype = usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;is_in = usb_urb_dir_in(urb);
 	ep-&gt;tstamp = 0;
 	ep-&gt;length = 0;
 	ep-&gt;status = error;
@@ -413,10 +421,10 @@ static ssize_t mon_text_read_u(struct file *file, char __user *buf,
 	mon_text_read_head_u(rp, &amp;ptr, ep);
 	if (ep-&gt;type == 'E') {
 		mon_text_read_statset(rp, &amp;ptr, ep);
-	} else if (usb_pipeisoc(ep-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC) {
 		mon_text_read_isostat(rp, &amp;ptr, ep);
 		mon_text_read_isodesc(rp, &amp;ptr, ep);
-	} else if (usb_pipeint(ep-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		mon_text_read_intstat(rp, &amp;ptr, ep);
 	} else {
 		mon_text_read_statset(rp, &amp;ptr, ep);
@@ -468,18 +476,17 @@ static void mon_text_read_head_t(struct mon_reader_text *rp,
 {
 	char udir, utype;
 
-	udir = usb_pipein(ep-&gt;pipe) ? 'i' : 'o';
-	switch (usb_pipetype(ep-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:	utype = 'Z'; break;
-	case PIPE_INTERRUPT:	utype = 'I'; break;
-	case PIPE_CONTROL:	utype = 'C'; break;
+	udir = (ep-&gt;is_in ? 'i' : 'o');
+	switch (ep-&gt;xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:	utype = 'Z'; break;
+	case USB_ENDPOINT_XFER_INT:	utype = 'I'; break;
+	case USB_ENDPOINT_XFER_CONTROL:	utype = 'C'; break;
 	default: /* PIPE_BULK */  utype = 'B';
 	}
 	p-&gt;cnt += snprintf(p-&gt;pbuf + p-&gt;cnt, p-&gt;limit - p-&gt;cnt,
 	    "%lx %u %c %c%c:%03u:%02u",
 	    ep-&gt;id, ep-&gt;tstamp, ep-&gt;type,
-	    utype, udir,
-	    usb_pipedevice(ep-&gt;pipe), usb_pipeendpoint(ep-&gt;pipe));
+	    utype, udir, ep-&gt;devnum, ep-&gt;epnum);
 }
 
 static void mon_text_read_head_u(struct mon_reader_text *rp,
@@ -487,18 +494,17 @@ static void mon_text_read_head_u(struct mon_reader_text *rp,
 {
 	char udir, utype;
 
-	udir = usb_pipein(ep-&gt;pipe) ? 'i' : 'o';
-	switch (usb_pipetype(ep-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:	utype = 'Z'; break;
-	case PIPE_INTERRUPT:	utype = 'I'; break;
-	case PIPE_CONTROL:	utype = 'C'; break;
+	udir = (ep-&gt;is_in ? 'i' : 'o');
+	switch (ep-&gt;xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:	utype = 'Z'; break;
+	case USB_ENDPOINT_XFER_INT:	utype = 'I'; break;
+	case USB_ENDPOINT_XFER_CONTROL:	utype = 'C'; break;
 	default: /* PIPE_BULK */  utype = 'B';
 	}
 	p-&gt;cnt += snprintf(p-&gt;pbuf + p-&gt;cnt, p-&gt;limit - p-&gt;cnt,
 	    "%lx %u %c %c%c:%d:%03u:%u",
 	    ep-&gt;id, ep-&gt;tstamp, ep-&gt;type,
-	    utype, udir,
-	    ep-&gt;busnum, usb_pipedevice(ep-&gt;pipe), usb_pipeendpoint(ep-&gt;pipe));
+	    utype, udir, ep-&gt;busnum, ep-&gt;devnum, ep-&gt;epnum);
 }
 
 static void mon_text_read_statset(struct mon_reader_text *rp,</pre><hr><pre>commit 93cf9b909efb773f74b5d87659d41f957ccbce7e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:09:28 2007 -0400

    USB: avoid urb-&gt;pipe in usbfs
    
    This patch (as948) removes most of the references to urb-&gt;pipe from
    the usbfs routines in devio.c.  The one tricky aspect is in
    snoop_urb(), which can be called before the URB is submitted and which
    uses usb_urb_dir_in().  For this to work properly, the URB's direction
    flag must be set manually in proc_do_submiturb().
    
    The patch also fixes a minor bug; the wValue, wIndex, and wLength
    fields were snooped in proc_do_submiturb() without conversion from
    le16 to CPU-byte-ordering.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 927a181120a9..b9f1edd6af53 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -289,10 +289,8 @@ static void snoop_urb(struct urb *urb, void __user *userurb)
 	if (!usbfs_snoop)
 		return;
 
-	if (urb-&gt;pipe &amp; USB_DIR_IN)
-		dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=IN\n");
-	else
-		dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=OUT\n");
+	dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=%s\n",
+			usb_urb_dir_in(urb) ? "IN" : "OUT");
 	dev_info(&amp;urb-&gt;dev-&gt;dev, "userurb=%p\n", userurb);
 	dev_info(&amp;urb-&gt;dev-&gt;dev, "transfer_buffer_length=%d\n",
 		 urb-&gt;transfer_buffer_length);
@@ -910,6 +908,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
 	int ret, ifnum = -1;
+	int is_in;
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP|USBDEVFS_URB_SHORT_NOT_OK|
 			   URB_NO_FSBR|URB_ZERO_PACKET))
@@ -924,16 +923,18 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ret = checkintf(ps, ifnum)))
 			return ret;
 	}
-	if ((uurb-&gt;endpoint &amp; USB_ENDPOINT_DIR_MASK) != 0)
-		ep = ps-&gt;dev-&gt;ep_in [uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
-	else
-		ep = ps-&gt;dev-&gt;ep_out [uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	if ((uurb-&gt;endpoint &amp; USB_ENDPOINT_DIR_MASK) != 0) {
+		is_in = 1;
+		ep = ps-&gt;dev-&gt;ep_in[uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	} else {
+		is_in = 0;
+		ep = ps-&gt;dev-&gt;ep_out[uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	}
 	if (!ep)
 		return -ENOENT;
 	switch(uurb-&gt;type) {
 	case USBDEVFS_URB_TYPE_CONTROL:
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_CONTROL)
+		if (!usb_endpoint_xfer_control(&amp;ep-&gt;desc))
 			return -EINVAL;
 		/* min 8 byte setup packet, max 8 byte setup plus an arbitrary data stage */
 		if (uurb-&gt;buffer_length &lt; 8 || uurb-&gt;buffer_length &gt; (8 + MAX_USBFS_BUFFER_SIZE))
@@ -952,23 +953,32 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			kfree(dr);
 			return ret;
 		}
-		uurb-&gt;endpoint = (uurb-&gt;endpoint &amp; ~USB_ENDPOINT_DIR_MASK) | (dr-&gt;bRequestType &amp; USB_ENDPOINT_DIR_MASK);
 		uurb-&gt;number_of_packets = 0;
 		uurb-&gt;buffer_length = le16_to_cpup(&amp;dr-&gt;wLength);
 		uurb-&gt;buffer += 8;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ?  VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length)) {
+		if ((dr-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; uurb-&gt;buffer_length) {
+			is_in = 1;
+			uurb-&gt;endpoint |= USB_DIR_IN;
+		} else {
+			is_in = 0;
+			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
+		}
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
 			kfree(dr);
 			return -EFAULT;
 		}
 		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequest=%02x "
 			"bRrequestType=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",
-			dr-&gt;bRequest, dr-&gt;bRequestType, dr-&gt;wValue,
-			dr-&gt;wIndex, dr-&gt;wLength);
+			dr-&gt;bRequest, dr-&gt;bRequestType,
+			__le16_to_cpup(&amp;dr-&gt;wValue),
+			__le16_to_cpup(&amp;dr-&gt;wIndex),
+			__le16_to_cpup(&amp;dr-&gt;wLength));
 		break;
 
 	case USBDEVFS_URB_TYPE_BULK:
-		switch (ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+		switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
 		case USB_ENDPOINT_XFER_CONTROL:
 		case USB_ENDPOINT_XFER_ISOC:
 			return -EINVAL;
@@ -977,7 +987,8 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length))
 			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "bulk urb\n");
 		break;
@@ -986,8 +997,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		/* arbitrary limit */
 		if (uurb-&gt;number_of_packets &lt; 1 || uurb-&gt;number_of_packets &gt; 128)
 			return -EINVAL;
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_ISOC)
+		if (!usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 			return -EINVAL;
 		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) * uurb-&gt;number_of_packets;
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
@@ -1014,12 +1024,12 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 
 	case USBDEVFS_URB_TYPE_INTERRUPT:
 		uurb-&gt;number_of_packets = 0;
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_INT)
+		if (!usb_endpoint_xfer_int(&amp;ep-&gt;desc))
 			return -EINVAL;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length))
 			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "interrupt urb\n");
 		break;
@@ -1039,8 +1049,11 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		return -ENOMEM;
 	}
         as-&gt;urb-&gt;dev = ps-&gt;dev;
-        as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) | __create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) | (uurb-&gt;endpoint &amp; USB_DIR_IN);
-        as-&gt;urb-&gt;transfer_flags = uurb-&gt;flags;
+        as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) |
+			__create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) |
+			(uurb-&gt;endpoint &amp; USB_DIR_IN);
+        as-&gt;urb-&gt;transfer_flags = uurb-&gt;flags |
+			(is_in ? URB_DIR_IN : URB_DIR_OUT);
 	as-&gt;urb-&gt;transfer_buffer_length = uurb-&gt;buffer_length;
 	as-&gt;urb-&gt;setup_packet = (unsigned char*)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
@@ -1070,13 +1083,13 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;uid = current-&gt;uid;
 	as-&gt;euid = current-&gt;euid;
 	security_task_getsecid(current, &amp;as-&gt;secid);
-	if (!(uurb-&gt;endpoint &amp; USB_DIR_IN)) {
-		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer, as-&gt;urb-&gt;transfer_buffer_length)) {
+	if (!is_in) {
+		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer,
+				as-&gt;urb-&gt;transfer_buffer_length)) {
 			free_async(as);
 			return -EFAULT;
 		}
 	}
-	snoop(&amp;as-&gt;urb-&gt;dev-&gt;dev, "submit urb\n");
 	snoop_urb(as-&gt;urb, as-&gt;userurb);
         async_newpending(as);
         if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
@@ -1126,7 +1139,7 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	if (put_user(urb-&gt;error_count, &amp;userurb-&gt;error_count))
 		return -EFAULT;
 
-	if (usb_pipeisoc(urb-&gt;pipe)) {
+	if (usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)) {
 		for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 			if (put_user(urb-&gt;iso_frame_desc[i].actual_length,
 				     &amp;userurb-&gt;iso_frame_desc[i].actual_length))
@@ -1240,7 +1253,7 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 	if (put_user(urb-&gt;error_count, &amp;userurb-&gt;error_count))
 		return -EFAULT;
 
-	if (usb_pipeisoc(urb-&gt;pipe)) {
+	if (usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)) {
 		for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 			if (put_user(urb-&gt;iso_frame_desc[i].actual_length,
 				     &amp;userurb-&gt;iso_frame_desc[i].actual_length))</pre><hr><pre>commit 4326ed0be93574dac5b5e475713015159108bd88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:08:43 2007 -0400

    USB: address-0 handling during device initialization
    
    This patch (as947) changes the device initialization and enumeration
    code in hub.c; now udev-&gt;devnum will be set to 0 while the device is
    being accessed at address 0.  Until now this wasn't needed because the
    address value was passed as part of urb-&gt;pipe; without that field the
    device address must be stored elsewhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c8a01f66df70..34be27a6cbb4 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1481,6 +1481,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		case 0:
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
+		  	udev-&gt;devnum = 0;	/* Device now at address 0 */
 			/* FALL THROUGH */
 		case -ENOTCONN:
 		case -ENODEV:
@@ -2005,20 +2006,21 @@ static void ep0_reinit(struct usb_device *udev)
 #define usb_sndaddr0pipe()	(PIPE_CONTROL &lt;&lt; 30)
 #define usb_rcvaddr0pipe()	((PIPE_CONTROL &lt;&lt; 30) | USB_DIR_IN)
 
-static int hub_set_address(struct usb_device *udev)
+static int hub_set_address(struct usb_device *udev, int devnum)
 {
 	int retval;
 
-	if (udev-&gt;devnum == 0)
+	if (devnum &lt;= 1)
 		return -EINVAL;
 	if (udev-&gt;state == USB_STATE_ADDRESS)
 		return 0;
 	if (udev-&gt;state != USB_STATE_DEFAULT)
 		return -EINVAL;
 	retval = usb_control_msg(udev, usb_sndaddr0pipe(),
-		USB_REQ_SET_ADDRESS, 0, udev-&gt;devnum, 0,
+		USB_REQ_SET_ADDRESS, 0, devnum, 0,
 		NULL, 0, USB_CTRL_SET_TIMEOUT);
 	if (retval == 0) {
+		udev-&gt;devnum = devnum;	/* Device now using proper address */
 		usb_set_device_state(udev, USB_STATE_ADDRESS);
 		ep0_reinit(udev);
 	}
@@ -2045,6 +2047,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	unsigned		delay = HUB_SHORT_RESET_TIME;
 	enum usb_device_speed	oldspeed = udev-&gt;speed;
 	char 			*speed, *type;
+	int			devnum = udev-&gt;devnum;
 
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -2074,7 +2077,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		goto fail;
 	}
 	oldspeed = udev-&gt;speed;
-  
+
 	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
 	 * it's fixed size except for full speed devices.
 	 * For Wireless USB devices, ep0 max packet is always 512 (tho
@@ -2115,7 +2118,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	dev_info (&amp;udev-&gt;dev,
 		  "%s %s speed %sUSB device using %s and address %d\n",
 		  (udev-&gt;config) ? "reset" : "new", speed, type,
-		  udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, udev-&gt;devnum);
+		  udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
 
 	/* Set up TT records, if needed  */
 	if (hdev-&gt;tt) {
@@ -2202,7 +2205,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		}
 
 		for (j = 0; j &lt; SET_ADDRESS_TRIES; ++j) {
-			retval = hub_set_address(udev);
+			retval = hub_set_address(udev, devnum);
 			if (retval &gt;= 0)
 				break;
 			msleep(200);
@@ -2210,7 +2213,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		if (retval &lt; 0) {
 			dev_err(&amp;udev-&gt;dev,
 				"device not accepting address %d, error %d\n",
-				udev-&gt;devnum, retval);
+				devnum, retval);
 			goto fail;
 		}
  
@@ -2263,8 +2266,10 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	retval = 0;
 
 fail:
-	if (retval)
+	if (retval) {
 		hub_port_disable(hub, port1, 0);
+		udev-&gt;devnum = devnum;	/* for disconnect processing */
+	}
 	mutex_unlock(&amp;usb_address0_mutex);
 	return retval;
 }
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1a64a6a850f3..1acca8696bcd 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -284,9 +284,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
 		return -EINVAL;
-	if (!(dev = urb-&gt;dev) ||
-	    (dev-&gt;state &lt; USB_STATE_DEFAULT) ||
-	    (!dev-&gt;bus) || (dev-&gt;devnum &lt;= 0))
+	if (!(dev = urb-&gt;dev) || dev-&gt;state &lt; USB_STATE_DEFAULT)
 		return -ENODEV;
 	if (dev-&gt;bus-&gt;controller-&gt;power.power_state.event != PM_EVENT_ON
 			|| dev-&gt;state == USB_STATE_SUSPENDED)</pre><hr><pre>commit 5e60a16139c2a48b9876b0ff910671eee5fb32ec
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:07:21 2007 -0400

    USB: avoid using urb-&gt;pipe in usbcore
    
    This patch (as946) eliminates many of the uses of urb-&gt;pipe in
    usbcore.  Unfortunately there will have to be a significant API
    change, affecting all USB drivers, before we can remove it entirely.
    This patch contents itself with changing only the interface to
    usb_buffer_map_sg() and friends: The pipe argument is replaced with a
    direction flag.  That can be done easily because those routines get
    used in only one place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index bcbaedc897d5..739c5e0aa3b8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -635,9 +635,9 @@ static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 
 static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeint (urb-&gt;pipe))
+	if (usb_endpoint_xfer_int(&amp;urb-&gt;ep-&gt;desc))
 		return rh_queue_status (hcd, urb);
-	if (usb_pipecontrol (urb-&gt;pipe))
+	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc))
 		return rh_call_control (hcd, urb);
 	return -EINVAL;
 }
@@ -651,7 +651,7 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long	flags;
 
-	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
 	} else {				/* Status URB */
@@ -918,7 +918,7 @@ static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
 	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
-		if (usb_pipecontrol (urb-&gt;pipe)
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
 					sizeof (struct usb_ctrlrequest),
@@ -1001,7 +1001,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	 * unless it uses pio or talks to another transport.
 	 */
 	if (hcd-&gt;self.uses_dma) {
-		if (usb_pipecontrol (urb-&gt;pipe)
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
 					hcd-&gt;self.controller,
@@ -1201,11 +1201,13 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	spin_lock(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
+		int	is_in;
 
 		/* the urb may already have been unlinked */
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
+		is_in = usb_urb_dir_in(urb);
 		spin_unlock(&amp;hcd_urb_list_lock);
 
 		spin_lock (&amp;urb-&gt;lock);
@@ -1216,19 +1218,25 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 		/* kick hcd unless it's already returning this */
 		if (tmp == -EINPROGRESS) {
-			tmp = urb-&gt;pipe;
 			unlink1 (hcd, urb);
 			dev_dbg (hcd-&gt;self.controller,
-				"shutdown urb %p pipe %08x ep%d%s%s\n",
-				urb, tmp, usb_pipeendpoint (tmp),
-				(tmp &amp; USB_DIR_IN) ? "in" : "out",
-				({ char *s; \
-				 switch (usb_pipetype (tmp)) { \
-				 case PIPE_CONTROL:	s = ""; break; \
-				 case PIPE_BULK:	s = "-bulk"; break; \
-				 case PIPE_INTERRUPT:	s = "-intr"; break; \
-				 default: 		s = "-iso"; break; \
-				}; s;}));
+				"shutdown urb %p ep%d%s%s\n",
+				urb, usb_endpoint_num(&amp;ep-&gt;desc),
+				is_in ? "in" : "out",
+				({	char *s;
+
+					switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
+					case USB_ENDPOINT_XFER_CONTROL:
+						s = ""; break;
+					case USB_ENDPOINT_XFER_BULK:
+						s = "-bulk"; break;
+					case USB_ENDPOINT_XFER_INT:
+						s = "-intr"; break;
+					default:
+				 		s = "-iso"; break;
+					};
+					s;
+				}));
 		}
 		usb_put_urb (urb);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 0d618647758e..a26a7292b61a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -59,8 +59,8 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev,
 			"%s timed out on ep%d%s len=%d/%d\n",
 			current-&gt;comm,
-			usb_pipeendpoint(urb-&gt;pipe),
-			usb_pipein(urb-&gt;pipe) ? "in" : "out",
+			usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc),
+			usb_urb_dir_in(urb) ? "in" : "out",
 			urb-&gt;actual_length,
 			urb-&gt;transfer_buffer_length);
 	} else
@@ -250,7 +250,8 @@ static void sg_clean (struct usb_sg_request *io)
 		io-&gt;urbs = NULL;
 	}
 	if (io-&gt;dev-&gt;dev.dma_mask != NULL)
-		usb_buffer_unmap_sg (io-&gt;dev, io-&gt;pipe, io-&gt;sg, io-&gt;nents);
+		usb_buffer_unmap_sg (io-&gt;dev, usb_pipein(io-&gt;pipe),
+				io-&gt;sg, io-&gt;nents);
 	io-&gt;dev = NULL;
 }
 
@@ -278,8 +279,8 @@ static void sg_complete (struct urb *urb)
 		dev_err (io-&gt;dev-&gt;bus-&gt;controller,
 			"dev %s ep%d%s scatterlist error %d/%d\n",
 			io-&gt;dev-&gt;devpath,
-			usb_pipeendpoint (urb-&gt;pipe),
-			usb_pipein (urb-&gt;pipe) ? "in" : "out",
+			usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc),
+			usb_urb_dir_in(urb) ? "in" : "out",
 			status, io-&gt;status);
 		// BUG ();
 	}
@@ -379,7 +380,8 @@ int usb_sg_init (
 	 */
 	dma = (dev-&gt;dev.dma_mask != NULL);
 	if (dma)
-		io-&gt;entries = usb_buffer_map_sg (dev, pipe, sg, nents);
+		io-&gt;entries = usb_buffer_map_sg(dev, usb_pipein(pipe),
+				sg, nents);
 	else
 		io-&gt;entries = nents;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index d3c68d8eafb2..67e2e582e463 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -748,7 +748,7 @@ void usb_buffer_unmap(struct urb *urb)
 /**
  * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to map
  * @nents: the number of entries in the scatterlist
  *
@@ -771,14 +771,13 @@ void usb_buffer_unmap(struct urb *urb)
  *
  * Reverse the effect of this call with usb_buffer_unmap_sg().
  */
-int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 		      struct scatterlist *sg, int nents)
 {
 	struct usb_bus		*bus;
 	struct device		*controller;
 
 	if (!dev
-			|| usb_pipecontrol(pipe)
 			|| !(bus = dev-&gt;bus)
 			|| !(controller = bus-&gt;controller)
 			|| !controller-&gt;dma_mask)
@@ -786,7 +785,7 @@ int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
 
 	// FIXME generic api broken like pci, can't report errors
 	return dma_map_sg(controller, sg, nents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
 /* XXX DISABLED, no users currently.  If you wish to re-enable this
@@ -799,14 +798,14 @@ int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
 /**
  * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to synchronize
  * @n_hw_ents: the positive return value from usb_buffer_map_sg
  *
  * Use this when you are re-using a scatterlist's data buffers for
  * another USB request.
  */
-void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 			   struct scatterlist *sg, int n_hw_ents)
 {
 	struct usb_bus		*bus;
@@ -819,20 +818,20 @@ void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
 		return;
 
 	dma_sync_sg(controller, sg, n_hw_ents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 #endif
 
 /**
  * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to unmap
  * @n_hw_ents: the positive return value from usb_buffer_map_sg
  *
  * Reverses the effect of usb_buffer_map_sg().
  */
-void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			 struct scatterlist *sg, int n_hw_ents)
 {
 	struct usb_bus		*bus;
@@ -845,7 +844,7 @@ void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
 		return;
 
 	dma_unmap_sg(controller, sg, n_hw_ents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
 /* format to disable USB on kernel command line is: nousb */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9d08f5a5ba76..019ae963a9fe 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1422,13 +1422,13 @@ void usb_buffer_unmap (struct urb *urb);
 #endif
 
 struct scatterlist;
-int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 		      struct scatterlist *sg, int nents);
 #if 0
-void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 			   struct scatterlist *sg, int n_hw_ents);
 #endif
-void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			 struct scatterlist *sg, int n_hw_ents);
 
 /*-------------------------------------------------------------------*</pre>
    <div class="pagination">
        <a href='2_101.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><span>[102]</span><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_103.html'>Next&gt;&gt;</a>
    <div>
</body>

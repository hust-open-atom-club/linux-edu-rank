<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_67.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><span>[68]</span><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_69.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fcf7d2141f4a363a4a8454c4a0f26bb69e766c5f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 20 10:37:57 2010 -0400

    USB: OHCI: don't look at the root hub to get the number of ports
    
    This patch (as1371) fixes a small bug in ohci-hcd.  The HCD already
    knows how many ports the controller has; there's no need to go looking
    at the root hub's usb_device structure to find out.  Especially since
    the root hub's maxchild value is set correctly only while the root hub
    is bound to the hub driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 32bbce9718f0..65cac8cc8921 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -697,7 +697,7 @@ static int ohci_hub_control (
 	u16		wLength
 ) {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ports = hcd_to_bus (hcd)-&gt;root_hub-&gt;maxchild;
+	int		ports = ohci-&gt;num_ports;
 	u32		temp;
 	int		retval = 0;
 </pre><hr><pre>commit 62f9cfa3ece58268b3e92ca59c23b175f86205aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 20 10:40:59 2010 -0400

    USB: don't choose configs with no interfaces
    
    This patch (as1372) fixes a bug in the routine that chooses the
    default configuration to install when a new USB device is detected.
    The algorithm is supposed to look for a config whose first interface
    is for a non-vendor-specific class.  But the way it's currently
    written, it will also accept a config with no interfaces at all, which
    is not very useful.  (Believe it or not, such things do exist.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andrew Victor &lt;avictor.za@gmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index bdf87a8414a1..2c95153c0f24 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -120,7 +120,7 @@ int usb_choose_configuration(struct usb_device *udev)
 		 * than a vendor-specific driver. */
 		else if (udev-&gt;descriptor.bDeviceClass !=
 						USB_CLASS_VENDOR_SPEC &amp;&amp;
-				(!desc || desc-&gt;bInterfaceClass !=
+				(desc &amp;&amp; desc-&gt;bInterfaceClass !=
 						USB_CLASS_VENDOR_SPEC)) {
 			best = c;
 			break;</pre><hr><pre>commit eef6a7d5c2f38adadab8240fabf43730fe796482
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 17:39:21 2010 +0900

    workqueue: warn about flush_scheduled_work()
    
    This patch (as1319) adds kerneldoc and a pointed warning to
    flush_scheduled_work().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Tejun Heo &lt;tj@kernel.org&gt;

diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 5bfb213984b2..0225fea89340 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -845,6 +845,30 @@ int schedule_on_each_cpu(work_func_t func)
 	return 0;
 }
 
+/**
+ * flush_scheduled_work - ensure that any scheduled work has run to completion.
+ *
+ * Forces execution of the kernel-global workqueue and blocks until its
+ * completion.
+ *
+ * Think twice before calling this function!  It's very easy to get into
+ * trouble if you don't take great care.  Either of the following situations
+ * will lead to deadlock:
+ *
+ *	One of the work items currently on the workqueue needs to acquire
+ *	a lock held by your code or its caller.
+ *
+ *	Your code is running in the context of a work routine.
+ *
+ * They will be detected by lockdep when they occur, but the first might not
+ * occur very often.  It depends on what work items are on the workqueue and
+ * what locks they need, which you have no control over.
+ *
+ * In most situations flushing the entire workqueue is overkill; you merely
+ * need to know that a particular work item isn't queued and isn't running.
+ * In such cases you should use cancel_delayed_work_sync() or
+ * cancel_work_sync() instead.
+ */
 void flush_scheduled_work(void)
 {
 	flush_workqueue(keventd_wq);</pre><hr><pre>commit 571dc79d62a163fd043de47d7d39bae58831e81e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 9 16:03:43 2010 -0400

    USB: put claimed interfaces in the "suspended" state
    
    This patch (as1370) fixes a bug in the USB runtime power management
    code.  When a driver claims an interface, it doesn't expect to need to
    call usb_autopm_get_interface() or usb_autopm_put_interface() for
    runtime PM to work.  Runtime PM can be controlled by the driver's
    primary interface; the additional interfaces it claims shouldn't
    interfere.  As things stand, the claimed interfaces will prevent the
    device from autosuspending.
    
    To fix this problem, the patch sets interfaces to the suspended state
    when they are claimed.
    
    Also, although in theory this shouldn't matter, the patch changes the
    suspend code so that interfaces are suspended in reverse order from
    detection and resuming.  This is how the PM core works, and we ought
    to use the same approach.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Debugged-and-tested-by: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 64b91d6c5a5d..2f3dc4cdf79b 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -301,7 +301,7 @@ static int usb_probe_interface(struct device *dev)
 
 	intf-&gt;condition = USB_INTERFACE_BINDING;
 
-	/* Bound interfaces are initially active.  They are
+	/* Probed interfaces are initially active.  They are
 	 * runtime-PM-enabled only if the driver has autosuspend support.
 	 * They are sensitive to their children's power states.
 	 */
@@ -437,11 +437,11 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Bound interfaces are initially active.  They are
+	/* Claimed interfaces are initially inactive (suspended).  They are
 	 * runtime-PM-enabled only if the driver has autosuspend support.
 	 * They are sensitive to their children's power states.
 	 */
-	pm_runtime_set_active(dev);
+	pm_runtime_set_suspended(dev);
 	pm_suspend_ignore_children(dev, false);
 	if (driver-&gt;supports_autosuspend)
 		pm_runtime_enable(dev);
@@ -1170,7 +1170,7 @@ static int usb_resume_interface(struct usb_device *udev,
 static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 {
 	int			status = 0;
-	int			i = 0;
+	int			i = 0, n = 0;
 	struct usb_interface	*intf;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
@@ -1179,7 +1179,8 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
-		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+		n = udev-&gt;actconfig-&gt;desc.bNumInterfaces;
+		for (i = n - 1; i &gt;= 0; --i) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			status = usb_suspend_interface(udev, intf, msg);
 			if (status != 0)
@@ -1192,7 +1193,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
 		msg.event ^= (PM_EVENT_SUSPEND | PM_EVENT_RESUME);
-		while (--i &gt;= 0) {
+		while (++i &lt; n) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			usb_resume_interface(udev, intf, msg, 0);
 		}</pre><hr><pre>commit 0e5f231bc16ff9910882fa5b9d64d80e7691cfab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 8 16:56:37 2010 -0400

    USB: EHCI: defer reclamation of siTDs
    
    This patch (as1369) fixes a problem in ehci-hcd.  Some controllers
    occasionally run into trouble when the driver reclaims siTDs too
    quickly.  This can happen while streaming audio; it causes the
    controller to crash.
    
    The patch changes siTD reclamation to work the same way as iTD
    reclamation: Completed siTDs are stored on a list and not reused until
    at least one frame has passed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Nate Case &lt;ncase@xes-inc.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 207e7a85aeb0..13ead00aecd5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -543,6 +543,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
+	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) &lt; 0)
 		return retval;
 
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index aeda96e0af67..1f3f01eacaf0 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -136,7 +136,7 @@ static inline void qh_put (struct ehci_qh *qh)
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
-	free_cached_itd_list(ehci);
+	free_cached_lists(ehci);
 	if (ehci-&gt;async)
 		qh_put (ehci-&gt;async);
 	ehci-&gt;async = NULL;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a0aaaaff2560..805ec633a652 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -510,7 +510,7 @@ static int disable_periodic (struct ehci_hcd *ehci)
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... */
 
-	free_cached_itd_list(ehci);
+	free_cached_lists(ehci);
 
 	ehci-&gt;next_uframe = -1;
 	return 0;
@@ -2139,13 +2139,27 @@ sitd_complete (
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
 	iso_stream_put (ehci, stream);
-	/* OK to recycle this SITD now that its completion callback ran. */
+
 done:
 	sitd-&gt;urb = NULL;
-	sitd-&gt;stream = NULL;
-	list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-	iso_stream_put(ehci, stream);
-
+	if (ehci-&gt;clock_frame != sitd-&gt;frame) {
+		/* OK to recycle this SITD now. */
+		sitd-&gt;stream = NULL;
+		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+		iso_stream_put(ehci, stream);
+	} else {
+		/* HW might remember this SITD, so we can't recycle it yet.
+		 * Move it to a safe place until a new frame starts.
+		 */
+		list_move(&amp;sitd-&gt;sitd_list, &amp;ehci-&gt;cached_sitd_list);
+		if (stream-&gt;refcount == 2) {
+			/* If iso_stream_put() were called here, stream
+			 * would be freed.  Instead, just prevent reuse.
+			 */
+			stream-&gt;ep-&gt;hcpriv = NULL;
+			stream-&gt;ep = NULL;
+		}
+	}
 	return retval;
 }
 
@@ -2211,9 +2225,10 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void free_cached_itd_list(struct ehci_hcd *ehci)
+static void free_cached_lists(struct ehci_hcd *ehci)
 {
 	struct ehci_itd *itd, *n;
+	struct ehci_sitd *sitd, *sn;
 
 	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
 		struct ehci_iso_stream	*stream = itd-&gt;stream;
@@ -2221,6 +2236,13 @@ static void free_cached_itd_list(struct ehci_hcd *ehci)
 		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
 		iso_stream_put(ehci, stream);
 	}
+
+	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
+		struct ehci_iso_stream	*stream = sitd-&gt;stream;
+		sitd-&gt;stream = NULL;
+		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+		iso_stream_put(ehci, stream);
+	}
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2247,7 +2269,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		clock_frame = -1;
 	}
 	if (ehci-&gt;clock_frame != clock_frame) {
-		free_cached_itd_list(ehci);
+		free_cached_lists(ehci);
 		ehci-&gt;clock_frame = clock_frame;
 	}
 	clock %= mod;
@@ -2414,7 +2436,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
 			if (ehci-&gt;clock_frame != clock_frame) {
-				free_cached_itd_list(ehci);
+				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
 			}
 		} else {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index b1dce96dd621..556c0b48f3ab 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -87,8 +87,9 @@ struct ehci_hcd {			/* one per controller */
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_sched;	/* periodic activity count */
 
-	/* list of itds completed while clock_frame was still active */
+	/* list of itds &amp; sitds completed while clock_frame was still active */
 	struct list_head	cached_itd_list;
+	struct list_head	cached_sitd_list;
 	unsigned		clock_frame;
 
 	/* per root hub port */
@@ -195,7 +196,7 @@ timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	clear_bit (action, &amp;ehci-&gt;actions);
 }
 
-static void free_cached_itd_list(struct ehci_hcd *ehci);
+static void free_cached_lists(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 </pre><hr><pre>commit 5f677f1d45b2bf08085bbba7394392dfa586fa8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:20:11 2010 -0400

    USB: fix remote wakeup settings during system sleep
    
    This patch (as1363) changes the way USB remote wakeup is handled
    during system sleeps.  It won't be enabled unless an interface driver
    specifically needs it.  Also, it won't be enabled during the FREEZE or
    QUIESCE phases of hibernation, when the system doesn't respond to
    wakeup events anyway.  Finally, if the device is already
    runtime-suspended with remote wakeup enabled, but wakeup is supposed
    to be disabled for the system sleep, the device gets woken up so that
    it can be suspended again with the proper wakeup setting.
    
    This will fix problems people have reported with certain USB webcams
    that generate wakeup requests when they shouldn't, and as a result
    cause system suspends to fail.  See
    
            https://bugs.launchpad.net/ubuntu/+source/linux/+bug/515109
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Erik Andr√©n &lt;erik.andren@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 6a3b5cae3a6e..64b91d6c5a5d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1263,13 +1263,47 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
+static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
+{
+	int			w, i;
+	struct usb_interface	*intf;
+
+	/* Remote wakeup is needed only when we actually go to sleep.
+	 * For things like FREEZE and QUIESCE, if the device is already
+	 * autosuspended then its current wakeup setting is okay.
+	 */
+	if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_QUIESCE) {
+		if (udev-&gt;state != USB_STATE_SUSPENDED)
+			udev-&gt;do_remote_wakeup = 0;
+		return;
+	}
+
+	/* If remote wakeup is permitted, see whether any interface drivers
+	 * actually want it.
+	 */
+	w = 0;
+	if (device_may_wakeup(&amp;udev-&gt;dev) &amp;&amp; udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			w |= intf-&gt;needs_remote_wakeup;
+		}
+	}
+
+	/* If the device is autosuspended with the wrong wakeup setting,
+	 * autoresume now so the setting can be changed.
+	 */
+	if (udev-&gt;state == USB_STATE_SUSPENDED &amp;&amp; w != udev-&gt;do_remote_wakeup)
+		pm_runtime_resume(&amp;udev-&gt;dev);
+	udev-&gt;do_remote_wakeup = w;
+}
+
 /* The device lock is held by the PM core */
 int usb_suspend(struct device *dev, pm_message_t msg)
 {
 	struct usb_device	*udev = to_usb_device(dev);
 
 	do_unbind_rebind(udev, DO_UNBIND);
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	choose_wakeup(udev, msg);
 	return usb_suspend_both(udev, msg);
 }
 </pre><hr><pre>commit 12fb8c1574d7d0c262d2f4c667047889c4f27ebe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 18 15:41:22 2010 -0400

    [SCSI] don't kfree an initialized struct device
    
    This patch (as1359) fixes a bug in scsi_alloc_target().  After a
    device structure has been initialized (and especially after its name
    has been set), it must not be freed directly.  One has to call
    put_device() instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 38518b088073..c992ecf4e372 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -459,8 +459,7 @@ static struct scsi_target *scsi_alloc_target(struct device *parent,
 	found_target-&gt;reap_ref++;
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 	if (found_target-&gt;state != STARGET_DEL) {
-		put_device(parent);
-		kfree(starget);
+		put_device(dev);
 		return found_target;
 	}
 	/* Unfortunately, we found a dying target; need to</pre><hr><pre>commit 1821438a9b6a8454281ec2e151014709f641d2d5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 18 15:41:11 2010 -0400

    [SCSI] don't reap targets upon device_add failure
    
    This patch (as1358) fixes a bug in the error pathway of
    scsi_target_add().  If registration fails, the target should not be
    reaped.  The reaping occurs later, when scanning is finished and all
    the child devices are removed.  The current code leaves an unbalanced
    value in starget-&gt;reap_ref.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 429c9b73e3e4..838a0db8ea1f 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -853,9 +853,6 @@ static int scsi_target_add(struct scsi_target *starget)
 	error = device_add(&amp;starget-&gt;dev);
 	if (error) {
 		dev_err(&amp;starget-&gt;dev, "target device_add failed, error %d\n", error);
-		get_device(&amp;starget-&gt;dev);
-		scsi_target_reap(starget);
-		put_device(&amp;starget-&gt;dev);
 		return error;
 	}
 	transport_add_device(&amp;starget-&gt;dev);</pre><hr><pre>commit 3d61510f4ecacfe47c75c0eb51c0659dfa77fb1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:21:58 2010 -0400

    HID: usbhid: enable remote wakeup for keyboards
    
    This patch (as1365) enables remote wakeup by default for USB keyboard
    devices.  Keyboards in general are supposed to be wakeup devices, but
    the correct place to enable it depends on the device's bus; no single
    approach will work for all keyboard devices.  In particular, this
    covers only USB keyboards (and then only those supporting the boot
    protocol).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 56d06cd8075b..9cd61a52e9e3 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1026,12 +1026,15 @@ static int usbhid_start(struct hid_device *hid)
 	/* Some keyboards don't work until their LEDs have been set.
 	 * Since BIOSes do set the LEDs, it must be safe for any device
 	 * that supports the keyboard boot protocol.
+	 * In addition, enable remote wakeup by default for all keyboard
+	 * devices supporting the boot protocol.
 	 */
 	if (interface-&gt;desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &amp;&amp;
 			interface-&gt;desc.bInterfaceProtocol ==
-				USB_INTERFACE_PROTOCOL_KEYBOARD)
+				USB_INTERFACE_PROTOCOL_KEYBOARD) {
 		usbhid_set_leds(hid);
-
+		device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
+	}
 	return 0;
 
 fail:
diff --git a/drivers/hid/usbhid/usbkbd.c b/drivers/hid/usbhid/usbkbd.c
index f843443ba5c3..b2fd0b00de92 100644
--- a/drivers/hid/usbhid/usbkbd.c
+++ b/drivers/hid/usbhid/usbkbd.c
@@ -313,6 +313,7 @@ static int usb_kbd_probe(struct usb_interface *iface,
 		goto fail2;
 
 	usb_set_intfdata(iface, kbd);
+	device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 	return 0;
 
 fail2:	</pre><hr><pre>commit 7152b592593b9d48b33f8997b1dfd6df9143f7ec
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Mar 6 15:04:03 2010 -0500

    USB: fix usbfs regression
    
    This patch (as1352) fixes a bug in the way isochronous input data is
    returned to userspace for usbfs transfers.  The entire buffer must be
    copied, not just the first actual_length bytes, because the individual
    packets will be discontiguous if any of them are short.
    
    Reported-by: Markus Rechberger &lt;mrechberger@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e909ff7b9094..3466fdc5bb11 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1207,6 +1207,13 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			free_async(as);
 			return -ENOMEM;
 		}
+		/* Isochronous input data may end up being discontiguous
+		 * if some of the packets are short.  Clear the buffer so
+		 * that the gaps don't leak kernel data to userspace.
+		 */
+		if (is_in &amp;&amp; uurb-&gt;type == USBDEVFS_URB_TYPE_ISO)
+			memset(as-&gt;urb-&gt;transfer_buffer, 0,
+					uurb-&gt;buffer_length);
 	}
 	as-&gt;urb-&gt;dev = ps-&gt;dev;
 	as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) |
@@ -1345,10 +1352,14 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	void __user *addr = as-&gt;userurb;
 	unsigned int i;
 
-	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length)
-		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer,
-				 urb-&gt;actual_length))
+	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length) {
+		if (urb-&gt;number_of_packets &gt; 0)		/* Isochronous */
+			i = urb-&gt;transfer_buffer_length;
+		else					/* Non-Isoc */
+			i = urb-&gt;actual_length;
+		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer, i))
 			goto err_out;
+	}
 	if (put_user(as-&gt;status, &amp;userurb-&gt;status))
 		goto err_out;
 	if (put_user(urb-&gt;actual_length, &amp;userurb-&gt;actual_length))</pre>
    <div class="pagination">
        <a href='2_67.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><span>[68]</span><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_69.html'>Next&gt;&gt;</a>
    <div>
</body>

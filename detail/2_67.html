<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_66.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><span>[67]</span><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_68.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7aba8d014341341590ecb64050b7a026642a62eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:21:33 2010 -0400

    USB: don't enable remote wakeup by default
    
    This patch (as1364) avoids enabling remote wakeup by default on all
    non-root-hub USB devices.  Individual drivers or userspace will have
    to enable it wherever it is needed, such as for keyboards or network
    interfaces.  Note: This affects only system sleep, not autosuspend.
    
    External hubs will continue to relay wakeup requests received from
    downstream through their upstream port, even when remote wakeup is not
    enabled for the hub itself.  Disabling remote wakeup on a hub merely
    prevents it from generating wakeup requests in response to connect,
    disconnect, and overcurrent events.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 497dbb29744d..2a767b3143a4 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1783,7 +1783,6 @@ int usb_new_device(struct usb_device *udev)
 		 * sysfs power/wakeup controls wakeup enabled/disabled
 		 */
 		device_init_wakeup(&amp;udev-&gt;dev, 0);
-		device_set_wakeup_enable(&amp;udev-&gt;dev, 1);
 	}
 
 	/* Tell the runtime-PM framework the device is active */</pre><hr><pre>commit 7560d32ec70508a71f537a88e40f7717f15389ac
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:18:50 2010 -0400

    USB: improve runtime remote wakeup settings
    
    This patch (as1362) adjusts the way the USB autosuspend routines
    handle remote-wakeup settings.  They aren't supposed to use
    device_may_wakeup(); that test is intended only for system sleep, not
    runtime power management.  Instead the code checks to see if any
    interface drivers need remote wakeup; if they do then it is enabled,
    provided the device is capable of it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index edff55a32575..271e857be0fa 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1486,9 +1486,6 @@ int usb_autoresume_device(struct usb_device *udev)
  * 0, a delayed autosuspend request for @intf's device is attempted.  The
  * attempt may fail (see autosuspend_check()).
  *
- * If the driver has set @intf-&gt;needs_remote_wakeup then autosuspend will
- * take place only if the device's remote-wakeup facility is enabled.
- *
  * This routine can run only in process context.
  */
 void usb_autopm_put_interface(struct usb_interface *intf)
@@ -1673,14 +1670,14 @@ EXPORT_SYMBOL_GPL(usb_autopm_get_interface_no_resume);
 /* Internal routine to check whether we may autosuspend a device. */
 static int autosuspend_check(struct usb_device *udev)
 {
-	int			i;
+	int			w, i;
 	struct usb_interface	*intf;
 	unsigned long		suspend_time, j;
 
 	/* Fail if autosuspend is disabled, or any interfaces are in use, or
 	 * any interface drivers require remote wakeup but it isn't available.
 	 */
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	w = 0;
 	if (udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -1694,12 +1691,7 @@ static int autosuspend_check(struct usb_device *udev)
 				continue;
 			if (atomic_read(&amp;intf-&gt;dev.power.usage_count) &gt; 0)
 				return -EBUSY;
-			if (intf-&gt;needs_remote_wakeup &amp;&amp;
-					!udev-&gt;do_remote_wakeup) {
-				dev_dbg(&amp;udev-&gt;dev, "remote wakeup needed "
-						"for autosuspend\n");
-				return -EOPNOTSUPP;
-			}
+			w |= intf-&gt;needs_remote_wakeup;
 
 			/* Don't allow autosuspend if the device will need
 			 * a reset-resume and any of its interface drivers
@@ -1715,6 +1707,11 @@ static int autosuspend_check(struct usb_device *udev)
 			}
 		}
 	}
+	if (w &amp;&amp; !device_can_wakeup(&amp;udev-&gt;dev)) {
+		dev_dbg(&amp;udev-&gt;dev, "remote wakeup needed for autosuspend\n");
+		return -EOPNOTSUPP;
+	}
+	udev-&gt;do_remote_wakeup = w;
 
 	/* If everything is okay but the device hasn't been idle for long
 	 * enough, queue a delayed autosuspend request.</pre><hr><pre>commit ff9c895f07d36193c75533bda8193bde8ca99d02
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:27:28 2010 -0400

    USB: fix usbmon and DMA mapping for scatter-gather URBs
    
    This patch (as1368) fixes a rather obscure bug in usbmon: When tracing
    URBs sent by the scatter-gather library, it accesses the data buffers
    while they are still mapped for DMA.
    
    The solution is to move the mapping and unmapping out of the s-g
    library and into the usual place in hcd.c.  This requires the addition
    of new URB flag bits to describe the kind of mapping needed, since we
    have to call dma_map_sg() if the HCD supports native scatter-gather
    operation and dma_map_page() if it doesn't.  The nice thing about
    having the new flags is that they simplify the testing for unmapping.
    
    The patch removes the only caller of usb_buffer_[un]map_sg(), so those
    functions are #if'ed out.  A later patch will remove them entirely.
    
    As a result of this change, urb-&gt;sg will be set in situations where
    it wasn't set previously.  Hence the xhci and whci drivers are
    adjusted to test urb-&gt;num_sgs instead, which retains its original
    meaning and is nonzero only when the HCD has to handle a scatterlist.
    
    Finally, even when a submission error occurs we don't want to hand
    URBs to usbmon before they are unmapped.  The submission path is
    rearranged so that map_urb_for_dma() is called only for non-root-hub
    URBs and unmap_urb_for_dma() is called immediately after a submission
    error.  This simplifies the error handling.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 38d4700926f7..6a05e6934455 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1259,6 +1259,51 @@ static void hcd_free_coherent(struct usb_bus *bus, dma_addr_t *dma_handle,
 	*dma_handle = 0;
 }
 
+static void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	enum dma_data_direction dir;
+
+	if (urb-&gt;transfer_flags &amp; URB_SETUP_MAP_SINGLE)
+		dma_unmap_single(hcd-&gt;self.controller,
+				urb-&gt;setup_dma,
+				sizeof(struct usb_ctrlrequest),
+				DMA_TO_DEVICE);
+	else if (urb-&gt;transfer_flags &amp; URB_SETUP_MAP_LOCAL)
+		hcd_free_coherent(urb-&gt;dev-&gt;bus,
+				&amp;urb-&gt;setup_dma,
+				(void **) &amp;urb-&gt;setup_packet,
+				sizeof(struct usb_ctrlrequest),
+				DMA_TO_DEVICE);
+
+	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+	if (urb-&gt;transfer_flags &amp; URB_DMA_MAP_SG)
+		dma_unmap_sg(hcd-&gt;self.controller,
+				urb-&gt;sg-&gt;sg,
+				urb-&gt;num_sgs,
+				dir);
+	else if (urb-&gt;transfer_flags &amp; URB_DMA_MAP_PAGE)
+		dma_unmap_page(hcd-&gt;self.controller,
+				urb-&gt;transfer_dma,
+				urb-&gt;transfer_buffer_length,
+				dir);
+	else if (urb-&gt;transfer_flags &amp; URB_DMA_MAP_SINGLE)
+		dma_unmap_single(hcd-&gt;self.controller,
+				urb-&gt;transfer_dma,
+				urb-&gt;transfer_buffer_length,
+				dir);
+	else if (urb-&gt;transfer_flags &amp; URB_MAP_LOCAL)
+		hcd_free_coherent(urb-&gt;dev-&gt;bus,
+				&amp;urb-&gt;transfer_dma,
+				&amp;urb-&gt;transfer_buffer,
+				urb-&gt;transfer_buffer_length,
+				dir);
+
+	/* Make it safe to call this routine more than once */
+	urb-&gt;transfer_flags &amp;= ~(URB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL |
+			URB_DMA_MAP_SG | URB_DMA_MAP_PAGE |
+			URB_DMA_MAP_SINGLE | URB_MAP_LOCAL);
+}
+
 static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 			   gfp_t mem_flags)
 {
@@ -1270,8 +1315,6 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 	 * unless it uses pio or talks to another transport,
 	 * or uses the provided scatter gather list for bulk.
 	 */
-	if (is_root_hub(urb-&gt;dev))
-		return 0;
 
 	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)) {
@@ -1284,6 +1327,7 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 			if (dma_mapping_error(hcd-&gt;self.controller,
 						urb-&gt;setup_dma))
 				return -EAGAIN;
+			urb-&gt;transfer_flags |= URB_SETUP_MAP_SINGLE;
 		} else if (hcd-&gt;driver-&gt;flags &amp; HCD_LOCAL_MEM)
 			ret = hcd_alloc_coherent(
 					urb-&gt;dev-&gt;bus, mem_flags,
@@ -1291,20 +1335,57 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 					(void **)&amp;urb-&gt;setup_packet,
 					sizeof(struct usb_ctrlrequest),
 					DMA_TO_DEVICE);
+			if (ret)
+				return ret;
+			urb-&gt;transfer_flags |= URB_SETUP_MAP_LOCAL;
 	}
 
 	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
-	if (ret == 0 &amp;&amp; urb-&gt;transfer_buffer_length != 0
+	if (urb-&gt;transfer_buffer_length != 0
 	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)) {
 		if (hcd-&gt;self.uses_dma) {
-			urb-&gt;transfer_dma = dma_map_single (
-					hcd-&gt;self.controller,
-					urb-&gt;transfer_buffer,
-					urb-&gt;transfer_buffer_length,
-					dir);
-			if (dma_mapping_error(hcd-&gt;self.controller,
+			if (urb-&gt;num_sgs) {
+				int n = dma_map_sg(
+						hcd-&gt;self.controller,
+						urb-&gt;sg-&gt;sg,
+						urb-&gt;num_sgs,
+						dir);
+				if (n &lt;= 0)
+					ret = -EAGAIN;
+				else
+					urb-&gt;transfer_flags |= URB_DMA_MAP_SG;
+				if (n != urb-&gt;num_sgs) {
+					urb-&gt;num_sgs = n;
+					urb-&gt;transfer_flags |=
+							URB_DMA_SG_COMBINED;
+				}
+			} else if (urb-&gt;sg) {
+				struct scatterlist *sg;
+
+				sg = (struct scatterlist *) urb-&gt;sg;
+				urb-&gt;transfer_dma = dma_map_page(
+						hcd-&gt;self.controller,
+						sg_page(sg),
+						sg-&gt;offset,
+						urb-&gt;transfer_buffer_length,
+						dir);
+				if (dma_mapping_error(hcd-&gt;self.controller,
 						urb-&gt;transfer_dma))
-				return -EAGAIN;
+					ret = -EAGAIN;
+				else
+					urb-&gt;transfer_flags |= URB_DMA_MAP_PAGE;
+			} else {
+				urb-&gt;transfer_dma = dma_map_single(
+						hcd-&gt;self.controller,
+						urb-&gt;transfer_buffer,
+						urb-&gt;transfer_buffer_length,
+						dir);
+				if (dma_mapping_error(hcd-&gt;self.controller,
+						urb-&gt;transfer_dma))
+					ret = -EAGAIN;
+				else
+					urb-&gt;transfer_flags |= URB_DMA_MAP_SINGLE;
+			}
 		} else if (hcd-&gt;driver-&gt;flags &amp; HCD_LOCAL_MEM) {
 			ret = hcd_alloc_coherent(
 					urb-&gt;dev-&gt;bus, mem_flags,
@@ -1312,55 +1393,16 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 					&amp;urb-&gt;transfer_buffer,
 					urb-&gt;transfer_buffer_length,
 					dir);
-
-			if (ret &amp;&amp; usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-			    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
-				hcd_free_coherent(urb-&gt;dev-&gt;bus,
-					&amp;urb-&gt;setup_dma,
-					(void **)&amp;urb-&gt;setup_packet,
-					sizeof(struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
+			if (ret == 0)
+				urb-&gt;transfer_flags |= URB_MAP_LOCAL;
 		}
+		if (ret &amp;&amp; (urb-&gt;transfer_flags &amp; (URB_SETUP_MAP_SINGLE |
+				URB_SETUP_MAP_LOCAL)))
+			unmap_urb_for_dma(hcd, urb);
 	}
 	return ret;
 }
 
-static void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
-{
-	enum dma_data_direction dir;
-
-	if (is_root_hub(urb-&gt;dev))
-		return;
-
-	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)) {
-		if (hcd-&gt;self.uses_dma)
-			dma_unmap_single(hcd-&gt;self.controller, urb-&gt;setup_dma,
-					sizeof(struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
-		else if (hcd-&gt;driver-&gt;flags &amp; HCD_LOCAL_MEM)
-			hcd_free_coherent(urb-&gt;dev-&gt;bus, &amp;urb-&gt;setup_dma,
-					(void **)&amp;urb-&gt;setup_packet,
-					sizeof(struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
-	}
-
-	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
-	if (urb-&gt;transfer_buffer_length != 0
-	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)) {
-		if (hcd-&gt;self.uses_dma)
-			dma_unmap_single(hcd-&gt;self.controller,
-					urb-&gt;transfer_dma,
-					urb-&gt;transfer_buffer_length,
-					dir);
-		else if (hcd-&gt;driver-&gt;flags &amp; HCD_LOCAL_MEM)
-			hcd_free_coherent(urb-&gt;dev-&gt;bus, &amp;urb-&gt;transfer_dma,
-					&amp;urb-&gt;transfer_buffer,
-					urb-&gt;transfer_buffer_length,
-					dir);
-	}
-}
-
 /*-------------------------------------------------------------------------*/
 
 /* may be called in any context with a valid urb-&gt;dev usecount
@@ -1389,21 +1431,20 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	 * URBs must be submitted in process context with interrupts
 	 * enabled.
 	 */
-	status = map_urb_for_dma(hcd, urb, mem_flags);
-	if (unlikely(status)) {
-		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		goto error;
-	}
 
-	if (is_root_hub(urb-&gt;dev))
+	if (is_root_hub(urb-&gt;dev)) {
 		status = rh_urb_enqueue(hcd, urb);
-	else
-		status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb, mem_flags);
+	} else {
+		status = map_urb_for_dma(hcd, urb, mem_flags);
+		if (likely(status == 0)) {
+			status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb, mem_flags);
+			if (unlikely(status))
+				unmap_urb_for_dma(hcd, urb);
+		}
+	}
 
 	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
-		unmap_urb_for_dma(hcd, urb);
- error:
 		urb-&gt;hcpriv = NULL;
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 619c44fb8a96..79d1cdf4a635 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -259,9 +259,6 @@ static void sg_clean(struct usb_sg_request *io)
 		kfree(io-&gt;urbs);
 		io-&gt;urbs = NULL;
 	}
-	if (io-&gt;dev-&gt;dev.dma_mask != NULL)
-		usb_buffer_unmap_sg(io-&gt;dev, usb_pipein(io-&gt;pipe),
-				    io-&gt;sg, io-&gt;nents);
 	io-&gt;dev = NULL;
 }
 
@@ -364,7 +361,6 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 {
 	int i;
 	int urb_flags;
-	int dma;
 	int use_sg;
 
 	if (!io || !dev || !sg
@@ -378,21 +374,9 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	io-&gt;pipe = pipe;
 	io-&gt;sg = sg;
 	io-&gt;nents = nents;
-
-	/* not all host controllers use DMA (like the mainstream pci ones);
-	 * they can use PIO (sl811) or be software over another transport.
-	 */
-	dma = (dev-&gt;dev.dma_mask != NULL);
-	if (dma)
-		io-&gt;entries = usb_buffer_map_sg(dev, usb_pipein(pipe),
-						sg, nents);
-	else
-		io-&gt;entries = nents;
+	io-&gt;entries = nents;
 
 	/* initialize all the urbs we'll use */
-	if (io-&gt;entries &lt;= 0)
-		return io-&gt;entries;
-
 	if (dev-&gt;bus-&gt;sg_tablesize &gt; 0) {
 		io-&gt;urbs = kmalloc(sizeof *io-&gt;urbs, mem_flags);
 		use_sg = true;
@@ -404,8 +388,6 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 		goto nomem;
 
 	urb_flags = 0;
-	if (dma)
-		urb_flags |= URB_NO_TRANSFER_DMA_MAP;
 	if (usb_pipein(pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
@@ -423,12 +405,13 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 
 		io-&gt;urbs[0]-&gt;complete = sg_complete;
 		io-&gt;urbs[0]-&gt;context = io;
+
 		/* A length of zero means transfer the whole sg list */
 		io-&gt;urbs[0]-&gt;transfer_buffer_length = length;
 		if (length == 0) {
 			for_each_sg(sg, sg, io-&gt;entries, i) {
 				io-&gt;urbs[0]-&gt;transfer_buffer_length +=
-					sg_dma_len(sg);
+					sg-&gt;length;
 			}
 		}
 		io-&gt;urbs[0]-&gt;sg = io;
@@ -454,26 +437,16 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 			io-&gt;urbs[i]-&gt;context = io;
 
 			/*
-			 * Some systems need to revert to PIO when DMA is temporarily
-			 * unavailable.  For their sakes, both transfer_buffer and
-			 * transfer_dma are set when possible.
-			 *
-			 * Note that if IOMMU coalescing occurred, we cannot
-			 * trust sg_page anymore, so check if S/G list shrunk.
+			 * Some systems can't use DMA; they use PIO instead.
+			 * For their sakes, transfer_buffer is set whenever
+			 * possible.
 			 */
-			if (io-&gt;nents == io-&gt;entries &amp;&amp; !PageHighMem(sg_page(sg)))
+			if (!PageHighMem(sg_page(sg)))
 				io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(sg);
 			else
 				io-&gt;urbs[i]-&gt;transfer_buffer = NULL;
 
-			if (dma) {
-				io-&gt;urbs[i]-&gt;transfer_dma = sg_dma_address(sg);
-				len = sg_dma_len(sg);
-			} else {
-				/* hc may use _only_ transfer_buffer */
-				len = sg-&gt;length;
-			}
-
+			len = sg-&gt;length;
 			if (length) {
 				len = min_t(unsigned, len, length);
 				length -= len;
@@ -481,6 +454,8 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 					io-&gt;entries = i + 1;
 			}
 			io-&gt;urbs[i]-&gt;transfer_buffer_length = len;
+
+			io-&gt;urbs[i]-&gt;sg = (struct usb_sg_request *) sg;
 		}
 		io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 2532a0917f8c..a760e46871c5 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -333,9 +333,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	}
 
-	/* Cache the direction for later use */
-	urb-&gt;transfer_flags = (urb-&gt;transfer_flags &amp; ~URB_DIR_MASK) |
-			(is_out ? URB_DIR_OUT : URB_DIR_IN);
+	/* Clear the internal flags and cache the direction for later use */
+	urb-&gt;transfer_flags &amp;= ~(URB_DIR_MASK | URB_DMA_MAP_SINGLE |
+			URB_DMA_MAP_PAGE | URB_DMA_MAP_SG | URB_MAP_LOCAL |
+			URB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL |
+			URB_DMA_SG_COMBINED);
+	urb-&gt;transfer_flags |= (is_out ? URB_DIR_OUT : URB_DIR_IN);
 
 	if (xfertype != USB_ENDPOINT_XFER_CONTROL &amp;&amp;
 			dev-&gt;state &lt; USB_STATE_CONFIGURED)
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 097172e2ba06..8180ce533ebf 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -881,6 +881,7 @@ void usb_buffer_unmap(struct urb *urb)
 EXPORT_SYMBOL_GPL(usb_buffer_unmap);
 #endif  /*  0  */
 
+#if 0
 /**
  * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint
  * @dev: device to which the scatterlist will be mapped
@@ -924,6 +925,7 @@ int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE) ? : -ENOMEM;
 }
 EXPORT_SYMBOL_GPL(usb_buffer_map_sg);
+#endif
 
 /* XXX DISABLED, no users currently.  If you wish to re-enable this
  * XXX please determine whether the sync is to transfer ownership of
@@ -960,6 +962,7 @@ void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 EXPORT_SYMBOL_GPL(usb_buffer_dmasync_sg);
 #endif
 
+#if 0
 /**
  * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist
  * @dev: device to which the scatterlist will be mapped
@@ -985,6 +988,7 @@ void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 EXPORT_SYMBOL_GPL(usb_buffer_unmap_sg);
+#endif
 
 /* To disable USB, kernel command line is 'nousb' not 'usbcore.nousb' */
 #ifdef MODULE
diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c
index 141d049beb3e..b388dd1fb4c4 100644
--- a/drivers/usb/host/whci/qset.c
+++ b/drivers/usb/host/whci/qset.c
@@ -646,7 +646,7 @@ int qset_add_urb(struct whc *whc, struct whc_qset *qset, struct urb *urb,
 	wurb-&gt;urb = urb;
 	INIT_WORK(&amp;wurb-&gt;dequeue_work, urb_dequeue_work);
 
-	if (urb-&gt;sg) {
+	if (urb-&gt;num_sgs) {
 		ret = qset_add_urb_sg(whc, qset, urb, mem_flags);
 		if (ret == -EINVAL) {
 			qset_free_stds(qset, urb);
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 407d33fb5e84..c1359ed310b5 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -1962,7 +1962,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	int running_total, trb_buff_len, ret;
 	u64 addr;
 
-	if (urb-&gt;sg)
+	if (urb-&gt;num_sgs)
 		return queue_bulk_sg_tx(xhci, mem_flags, urb, slot_id, ep_index);
 
 	ep_ring = xhci-&gt;devs[slot_id]-&gt;eps[ep_index].ring;
diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index ddf7f9a1b336..8a7968df278f 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -416,7 +416,7 @@ static unsigned int mon_bin_get_data(const struct mon_reader_bin *rp,
 
 	} else {
 		/* If IOMMU coalescing occurred, we cannot trust sg_page */
-		if (urb-&gt;sg-&gt;nents != urb-&gt;num_sgs) {
+		if (urb-&gt;transfer_flags &amp; URB_DMA_SG_COMBINED) {
 			*flag = 'D';
 			return length;
 		}
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 4d0be130f49b..d56260280f54 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -161,9 +161,7 @@ static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
 	} else {
 		struct scatterlist *sg = urb-&gt;sg-&gt;sg;
 
-		/* If IOMMU coalescing occurred, we cannot trust sg_page */
-		if (urb-&gt;sg-&gt;nents != urb-&gt;num_sgs ||
-				PageHighMem(sg_page(sg)))
+		if (PageHighMem(sg_page(sg)))
 			return 'D';
 
 		/* For the text interface we copy only the first sg buffer */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 739f1fd1cc15..99833029e5a8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -965,10 +965,19 @@ extern int usb_disabled(void);
 					 * needed */
 #define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
+/* The following flags are used internally by usbcore and HCDs */
 #define URB_DIR_IN		0x0200	/* Transfer from device to host */
 #define URB_DIR_OUT		0
 #define URB_DIR_MASK		URB_DIR_IN
 
+#define URB_DMA_MAP_SINGLE	0x00010000	/* Non-scatter-gather mapping */
+#define URB_DMA_MAP_PAGE	0x00020000	/* HCD-unsupported S-G */
+#define URB_DMA_MAP_SG		0x00040000	/* HCD-supported S-G */
+#define URB_MAP_LOCAL		0x00080000	/* HCD-local-memory mapping */
+#define URB_SETUP_MAP_SINGLE	0x00100000	/* Setup packet DMA mapped */
+#define URB_SETUP_MAP_LOCAL	0x00200000	/* HCD-local setup packet */
+#define URB_DMA_SG_COMBINED	0x00400000	/* S-G entries were combined */
+
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */</pre><hr><pre>commit 0ede76fcec5415ef82a423a95120286895822e2d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 5 15:10:17 2010 -0500

    USB: remove uses of URB_NO_SETUP_DMA_MAP
    
    This patch (as1350) removes all usages of coherent buffers for USB
    control-request setup-packet buffers.  There's no good reason to
    reserve coherent memory for these things; control requests are hardly
    ever used in large quantity (the major exception is firmware
    transfers, and they aren't time-critical).  Furthermore, only seven
    drivers used it.  We might as well always use streaming DMA mappings
    for setup-packet buffers, and remove some extra complexity from
    usbcore.
    
    The DMA-mapping portion of hcd.c is currently in flux.  A separate
    patch will be submitted to remove support for URB_NO_SETUP_DMA_MAP
    after everything else settles down.  The removal should go smoothly,
    as by then nobody will be using it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 7b85b696fdab..6a510c9675fc 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -787,8 +787,7 @@ static int hid_alloc_buffers(struct usb_device *dev, struct hid_device *hid)
 			&amp;usbhid-&gt;inbuf_dma);
 	usbhid-&gt;outbuf = usb_buffer_alloc(dev, usbhid-&gt;bufsize, GFP_KERNEL,
 			&amp;usbhid-&gt;outbuf_dma);
-	usbhid-&gt;cr = usb_buffer_alloc(dev, sizeof(*usbhid-&gt;cr), GFP_KERNEL,
-			&amp;usbhid-&gt;cr_dma);
+	usbhid-&gt;cr = kmalloc(sizeof(*usbhid-&gt;cr), GFP_KERNEL);
 	usbhid-&gt;ctrlbuf = usb_buffer_alloc(dev, usbhid-&gt;bufsize, GFP_KERNEL,
 			&amp;usbhid-&gt;ctrlbuf_dma);
 	if (!usbhid-&gt;inbuf || !usbhid-&gt;outbuf || !usbhid-&gt;cr ||
@@ -846,7 +845,7 @@ static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
 
 	usb_buffer_free(dev, usbhid-&gt;bufsize, usbhid-&gt;inbuf, usbhid-&gt;inbuf_dma);
 	usb_buffer_free(dev, usbhid-&gt;bufsize, usbhid-&gt;outbuf, usbhid-&gt;outbuf_dma);
-	usb_buffer_free(dev, sizeof(*(usbhid-&gt;cr)), usbhid-&gt;cr, usbhid-&gt;cr_dma);
+	kfree(usbhid-&gt;cr);
 	usb_buffer_free(dev, usbhid-&gt;bufsize, usbhid-&gt;ctrlbuf, usbhid-&gt;ctrlbuf_dma);
 }
 
@@ -1007,9 +1006,8 @@ static int usbhid_start(struct hid_device *hid)
 
 	usb_fill_control_urb(usbhid-&gt;urbctrl, dev, 0, (void *) usbhid-&gt;cr,
 			     usbhid-&gt;ctrlbuf, 1, hid_ctrl, hid);
-	usbhid-&gt;urbctrl-&gt;setup_dma = usbhid-&gt;cr_dma;
 	usbhid-&gt;urbctrl-&gt;transfer_dma = usbhid-&gt;ctrlbuf_dma;
-	usbhid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
+	usbhid-&gt;urbctrl-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	if (!(hid-&gt;quirks &amp; HID_QUIRK_NO_INIT_REPORTS))
 		usbhid_init_reports(hid);
diff --git a/drivers/hid/usbhid/usbhid.h b/drivers/hid/usbhid/usbhid.h
index ec20400c7f29..693fd3e720df 100644
--- a/drivers/hid/usbhid/usbhid.h
+++ b/drivers/hid/usbhid/usbhid.h
@@ -75,7 +75,6 @@ struct usbhid_device {
 
 	struct urb *urbctrl;                                            /* Control URB */
 	struct usb_ctrlrequest *cr;                                     /* Control request struct */
-	dma_addr_t cr_dma;                                              /* Control request struct dma */
 	struct hid_control_fifo ctrl[HID_CONTROL_FIFO_SIZE];  		/* Control fifo */
 	unsigned char ctrlhead, ctrltail;                               /* Control fifo head &amp; tail */
 	char *ctrlbuf;                                                  /* Control buffer */
diff --git a/drivers/hid/usbhid/usbkbd.c b/drivers/hid/usbhid/usbkbd.c
index f843443ba5c3..bdc7b09e8670 100644
--- a/drivers/hid/usbhid/usbkbd.c
+++ b/drivers/hid/usbhid/usbkbd.c
@@ -74,7 +74,6 @@ struct usb_kbd {
 	unsigned char *new;
 	struct usb_ctrlrequest *cr;
 	unsigned char *leds;
-	dma_addr_t cr_dma;
 	dma_addr_t new_dma;
 	dma_addr_t leds_dma;
 };
@@ -199,7 +198,7 @@ static int usb_kbd_alloc_mem(struct usb_device *dev, struct usb_kbd *kbd)
 		return -1;
 	if (!(kbd-&gt;new = usb_buffer_alloc(dev, 8, GFP_ATOMIC, &amp;kbd-&gt;new_dma)))
 		return -1;
-	if (!(kbd-&gt;cr = usb_buffer_alloc(dev, sizeof(struct usb_ctrlrequest), GFP_ATOMIC, &amp;kbd-&gt;cr_dma)))
+	if (!(kbd-&gt;cr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL)))
 		return -1;
 	if (!(kbd-&gt;leds = usb_buffer_alloc(dev, 1, GFP_ATOMIC, &amp;kbd-&gt;leds_dma)))
 		return -1;
@@ -212,7 +211,7 @@ static void usb_kbd_free_mem(struct usb_device *dev, struct usb_kbd *kbd)
 	usb_free_urb(kbd-&gt;irq);
 	usb_free_urb(kbd-&gt;led);
 	usb_buffer_free(dev, 8, kbd-&gt;new, kbd-&gt;new_dma);
-	usb_buffer_free(dev, sizeof(struct usb_ctrlrequest), kbd-&gt;cr, kbd-&gt;cr_dma);
+	kfree(kbd-&gt;cr);
 	usb_buffer_free(dev, 1, kbd-&gt;leds, kbd-&gt;leds_dma);
 }
 
@@ -304,9 +303,8 @@ static int usb_kbd_probe(struct usb_interface *iface,
 	usb_fill_control_urb(kbd-&gt;led, dev, usb_sndctrlpipe(dev, 0),
 			     (void *) kbd-&gt;cr, kbd-&gt;leds, 1,
 			     usb_kbd_led, kbd);
-	kbd-&gt;led-&gt;setup_dma = kbd-&gt;cr_dma;
 	kbd-&gt;led-&gt;transfer_dma = kbd-&gt;leds_dma;
-	kbd-&gt;led-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
+	kbd-&gt;led-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	error = input_register_device(kbd-&gt;dev);
 	if (error)
diff --git a/drivers/input/misc/cm109.c b/drivers/input/misc/cm109.c
index 86457feccfc4..8d2d291ee508 100644
--- a/drivers/input/misc/cm109.c
+++ b/drivers/input/misc/cm109.c
@@ -102,7 +102,6 @@ struct cm109_dev {
 	struct cm109_ctl_packet *ctl_data;
 	dma_addr_t ctl_dma;
 	struct usb_ctrlrequest *ctl_req;
-	dma_addr_t ctl_req_dma;
 	struct urb *urb_ctl;
 	/*
 	 * The 3 bitfields below are protected by ctl_submit_lock.
@@ -629,9 +628,7 @@ static const struct usb_device_id cm109_usb_table[] = {
 
 static void cm109_usb_cleanup(struct cm109_dev *dev)
 {
-	if (dev-&gt;ctl_req)
-		usb_buffer_free(dev-&gt;udev, sizeof(*(dev-&gt;ctl_req)),
-				dev-&gt;ctl_req, dev-&gt;ctl_req_dma);
+	kfree(dev-&gt;ctl_req);
 	if (dev-&gt;ctl_data)
 		usb_buffer_free(dev-&gt;udev, USB_PKT_LEN,
 				dev-&gt;ctl_data, dev-&gt;ctl_dma);
@@ -696,8 +693,7 @@ static int cm109_usb_probe(struct usb_interface *intf,
 	if (!dev-&gt;ctl_data)
 		goto err_out;
 
-	dev-&gt;ctl_req = usb_buffer_alloc(udev, sizeof(*(dev-&gt;ctl_req)),
-					GFP_KERNEL, &amp;dev-&gt;ctl_req_dma);
+	dev-&gt;ctl_req = kmalloc(sizeof(*(dev-&gt;ctl_req)), GFP_KERNEL);
 	if (!dev-&gt;ctl_req)
 		goto err_out;
 
@@ -735,10 +731,8 @@ static int cm109_usb_probe(struct usb_interface *intf,
 	usb_fill_control_urb(dev-&gt;urb_ctl, udev, usb_sndctrlpipe(udev, 0),
 			     (void *)dev-&gt;ctl_req, dev-&gt;ctl_data, USB_PKT_LEN,
 			     cm109_urb_ctl_callback, dev);
-	dev-&gt;urb_ctl-&gt;setup_dma = dev-&gt;ctl_req_dma;
 	dev-&gt;urb_ctl-&gt;transfer_dma = dev-&gt;ctl_dma;
-	dev-&gt;urb_ctl-&gt;transfer_flags |= URB_NO_SETUP_DMA_MAP |
-					URB_NO_TRANSFER_DMA_MAP;
+	dev-&gt;urb_ctl-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	dev-&gt;urb_ctl-&gt;dev = udev;
 
 	/* find out the physical bus location */
diff --git a/drivers/input/misc/powermate.c b/drivers/input/misc/powermate.c
index 668913d12044..7ba4b5f53fc2 100644
--- a/drivers/input/misc/powermate.c
+++ b/drivers/input/misc/powermate.c
@@ -64,7 +64,6 @@ struct powermate_device {
 	dma_addr_t data_dma;
 	struct urb *irq, *config;
 	struct usb_ctrlrequest *configcr;
-	dma_addr_t configcr_dma;
 	struct usb_device *udev;
 	struct input_dev *input;
 	spinlock_t lock;
@@ -182,8 +181,6 @@ static void powermate_sync_state(struct powermate_device *pm)
 	usb_fill_control_urb(pm-&gt;config, pm-&gt;udev, usb_sndctrlpipe(pm-&gt;udev, 0),
 			     (void *) pm-&gt;configcr, NULL, 0,
 			     powermate_config_complete, pm);
-	pm-&gt;config-&gt;setup_dma = pm-&gt;configcr_dma;
-	pm-&gt;config-&gt;transfer_flags |= URB_NO_SETUP_DMA_MAP;
 
 	if (usb_submit_urb(pm-&gt;config, GFP_ATOMIC))
 		printk(KERN_ERR "powermate: usb_submit_urb(config) failed");
@@ -281,8 +278,7 @@ static int powermate_alloc_buffers(struct usb_device *udev, struct powermate_dev
 	if (!pm-&gt;data)
 		return -1;
 
-	pm-&gt;configcr = usb_buffer_alloc(udev, sizeof(*(pm-&gt;configcr)),
-					GFP_ATOMIC, &amp;pm-&gt;configcr_dma);
+	pm-&gt;configcr = kmalloc(sizeof(*(pm-&gt;configcr)), GFP_KERNEL);
 	if (!pm-&gt;configcr)
 		return -1;
 
@@ -293,8 +289,7 @@ static void powermate_free_buffers(struct usb_device *udev, struct powermate_dev
 {
 	usb_buffer_free(udev, POWERMATE_PAYLOAD_SIZE_MAX,
 			pm-&gt;data, pm-&gt;data_dma);
-	usb_buffer_free(udev, sizeof(*(pm-&gt;configcr)),
-			pm-&gt;configcr, pm-&gt;configcr_dma);
+	kfree(pm-&gt;configcr);
 }
 
 /* Called whenever a USB device matching one in our supported devices table is connected */
diff --git a/drivers/input/misc/yealink.c b/drivers/input/misc/yealink.c
index 93a22ac0f88c..2828328e9dd0 100644
--- a/drivers/input/misc/yealink.c
+++ b/drivers/input/misc/yealink.c
@@ -111,7 +111,6 @@ struct yealink_dev {
 	struct yld_ctl_packet	*ctl_data;
 	dma_addr_t		ctl_dma;
 	struct usb_ctrlrequest	*ctl_req;
-	dma_addr_t		ctl_req_dma;
 	struct urb		*urb_ctl;
 
 	char phys[64];			/* physical device path */
@@ -836,8 +835,7 @@ static int usb_cleanup(struct yealink_dev *yld, int err)
 	usb_free_urb(yld-&gt;urb_irq);
 	usb_free_urb(yld-&gt;urb_ctl);
 
-	usb_buffer_free(yld-&gt;udev, sizeof(*(yld-&gt;ctl_req)),
-			yld-&gt;ctl_req, yld-&gt;ctl_req_dma);
+	kfree(yld-&gt;ctl_req);
 	usb_buffer_free(yld-&gt;udev, USB_PKT_LEN,
 			yld-&gt;ctl_data, yld-&gt;ctl_dma);
 	usb_buffer_free(yld-&gt;udev, USB_PKT_LEN,
@@ -896,8 +894,7 @@ static int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	if (!yld-&gt;ctl_data)
 		return usb_cleanup(yld, -ENOMEM);
 
-	yld-&gt;ctl_req = usb_buffer_alloc(udev, sizeof(*(yld-&gt;ctl_req)),
-					GFP_ATOMIC, &amp;yld-&gt;ctl_req_dma);
+	yld-&gt;ctl_req = kmalloc(sizeof(*(yld-&gt;ctl_req)), GFP_KERNEL);
 	if (yld-&gt;ctl_req == NULL)
 		return usb_cleanup(yld, -ENOMEM);
 
@@ -936,10 +933,8 @@ static int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	usb_fill_control_urb(yld-&gt;urb_ctl, udev, usb_sndctrlpipe(udev, 0),
 			(void *)yld-&gt;ctl_req, yld-&gt;ctl_data, USB_PKT_LEN,
 			urb_ctl_callback, yld);
-	yld-&gt;urb_ctl-&gt;setup_dma	= yld-&gt;ctl_req_dma;
 	yld-&gt;urb_ctl-&gt;transfer_dma	= yld-&gt;ctl_dma;
-	yld-&gt;urb_ctl-&gt;transfer_flags	|= URB_NO_SETUP_DMA_MAP |
-					URB_NO_TRANSFER_DMA_MAP;
+	yld-&gt;urb_ctl-&gt;transfer_flags	|= URB_NO_TRANSFER_DMA_MAP;
 	yld-&gt;urb_ctl-&gt;dev = udev;
 
 	/* find out the physical bus location */
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 09301f4b7225..2532a0917f8c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -396,8 +396,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		return -EPIPE;		/* The most suitable error code :-) */
 
 	/* enforce simple/standard policy */
-	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT | URB_DIR_MASK | URB_FREE_BUFFER);
+	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
+			URB_FREE_BUFFER);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 1088abb4416c..097172e2ba06 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -775,7 +775,7 @@ EXPORT_SYMBOL_GPL(usb_free_coherent);
  * @urb: urb whose transfer_buffer/setup_packet will be mapped
  *
  * Return value is either null (indicating no buffer could be mapped), or
- * the parameter.  URB_NO_TRANSFER_DMA_MAP and URB_NO_SETUP_DMA_MAP are
+ * the parameter.  URB_NO_TRANSFER_DMA_MAP is
  * added to urb-&gt;transfer_flags if the operation succeeds.  If the device
  * is connected to this system through a non-DMA controller, this operation
  * always succeeds.
@@ -803,17 +803,11 @@ struct urb *usb_buffer_map(struct urb *urb)
 			urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length,
 			usb_pipein(urb-&gt;pipe)
 				? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-		if (usb_pipecontrol(urb-&gt;pipe))
-			urb-&gt;setup_dma = dma_map_single(controller,
-					urb-&gt;setup_packet,
-					sizeof(struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
 	/* FIXME generic api broken like pci, can't report errors */
 	/* if (urb-&gt;transfer_dma == DMA_ADDR_INVALID) return 0; */
 	} else
 		urb-&gt;transfer_dma = ~0;
-	urb-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP
-				| URB_NO_SETUP_DMA_MAP);
+	urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	return urb;
 }
 EXPORT_SYMBOL_GPL(usb_buffer_map);
@@ -881,14 +875,8 @@ void usb_buffer_unmap(struct urb *urb)
 			urb-&gt;transfer_dma, urb-&gt;transfer_buffer_length,
 			usb_pipein(urb-&gt;pipe)
 				? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-		if (usb_pipecontrol(urb-&gt;pipe))
-			dma_unmap_single(controller,
-					urb-&gt;setup_dma,
-					sizeof(struct usb_ctrlrequest),
-					DMA_TO_DEVICE);
 	}
-	urb-&gt;transfer_flags &amp;= ~(URB_NO_TRANSFER_DMA_MAP
-				| URB_NO_SETUP_DMA_MAP);
+	urb-&gt;transfer_flags &amp;= ~URB_NO_TRANSFER_DMA_MAP;
 }
 EXPORT_SYMBOL_GPL(usb_buffer_unmap);
 #endif  /*  0  */
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index a21cce6f7403..9dcc82337ced 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -977,15 +977,13 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!u)
 			goto cleanup;
 
-		reqp = usb_buffer_alloc (udev, sizeof *reqp, GFP_KERNEL,
-				&amp;u-&gt;setup_dma);
+		reqp = kmalloc(sizeof *reqp, GFP_KERNEL);
 		if (!reqp)
 			goto cleanup;
 		reqp-&gt;setup = req;
 		reqp-&gt;number = i % NUM_SUBCASES;
 		reqp-&gt;expected = expected;
 		u-&gt;setup_packet = (char *) &amp;reqp-&gt;setup;
-		u-&gt;transfer_flags |= URB_NO_SETUP_DMA_MAP;
 
 		u-&gt;context = &amp;context;
 		u-&gt;complete = ctrl_complete;
@@ -1017,10 +1015,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		if (!urb [i])
 			continue;
 		urb [i]-&gt;dev = udev;
-		if (urb [i]-&gt;setup_packet)
-			usb_buffer_free (udev, sizeof (struct usb_ctrlrequest),
-					urb [i]-&gt;setup_packet,
-					urb [i]-&gt;setup_dma);
+		kfree(urb[i]-&gt;setup_packet);
 		simple_free_urb (urb [i]);
 	}
 	kfree (urb);
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index f253edec3bb8..44716427c51c 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -147,11 +147,9 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	 * hasn't been mapped for DMA.  Yes, this is clunky, but it's
 	 * easier than always having the caller tell us whether the
 	 * transfer buffer has already been mapped. */
-	us-&gt;current_urb-&gt;transfer_flags = URB_NO_SETUP_DMA_MAP;
 	if (us-&gt;current_urb-&gt;transfer_buffer == us-&gt;iobuf)
 		us-&gt;current_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	us-&gt;current_urb-&gt;transfer_dma = us-&gt;iobuf_dma;
-	us-&gt;current_urb-&gt;setup_dma = us-&gt;cr_dma;
 
 	/* submit the URB */
 	status = usb_submit_urb(us-&gt;current_urb, GFP_NOIO);
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index bbeeb92a2131..c54a370c76c5 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -407,9 +407,8 @@ static int associate_dev(struct us_data *us, struct usb_interface *intf)
 	/* Store our private data in the interface */
 	usb_set_intfdata(intf, us);
 
-	/* Allocate the device-related DMA-mapped buffers */
-	us-&gt;cr = usb_buffer_alloc(us-&gt;pusb_dev, sizeof(*us-&gt;cr),
-			GFP_KERNEL, &amp;us-&gt;cr_dma);
+	/* Allocate the control/setup and DMA-mapped buffers */
+	us-&gt;cr = kmalloc(sizeof(*us-&gt;cr), GFP_KERNEL);
 	if (!us-&gt;cr) {
 		US_DEBUGP("usb_ctrlrequest allocation failed\n");
 		return -ENOMEM;
@@ -757,13 +756,9 @@ static void dissociate_dev(struct us_data *us)
 {
 	US_DEBUGP("-- %s\n", __func__);
 
-	/* Free the device-related DMA-mapped buffers */
-	if (us-&gt;cr)
-		usb_buffer_free(us-&gt;pusb_dev, sizeof(*us-&gt;cr), us-&gt;cr,
-				us-&gt;cr_dma);
-	if (us-&gt;iobuf)
-		usb_buffer_free(us-&gt;pusb_dev, US_IOBUF_SIZE, us-&gt;iobuf,
-				us-&gt;iobuf_dma);
+	/* Free the buffers */
+	kfree(us-&gt;cr);
+	usb_buffer_free(us-&gt;pusb_dev, US_IOBUF_SIZE, us-&gt;iobuf, us-&gt;iobuf_dma);
 
 	/* Remove our private data from the interface */
 	usb_set_intfdata(us-&gt;pusb_intf, NULL);
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 69717134231b..89d3bfff98df 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -139,8 +139,7 @@ struct us_data {
 	struct usb_ctrlrequest	*cr;		 /* control requests	 */
 	struct usb_sg_request	current_sg;	 /* scatter-gather req.  */
 	unsigned char		*iobuf;		 /* I/O buffer		 */
-	dma_addr_t		cr_dma;		 /* buffer DMA addresses */
-	dma_addr_t		iobuf_dma;
+	dma_addr_t		iobuf_dma;	 /* buffer DMA addresses */
 	struct task_struct	*ctl_thread;	 /* the control thread   */
 
 	/* mutual exclusion and synchronization structures */
diff --git a/drivers/usb/wusbcore/wa-xfer.c b/drivers/usb/wusbcore/wa-xfer.c
index 112ef7e26f6b..2ce6b7eccc6a 100644
--- a/drivers/usb/wusbcore/wa-xfer.c
+++ b/drivers/usb/wusbcore/wa-xfer.c
@@ -474,8 +474,6 @@ static void __wa_xfer_setup_hdr0(struct wa_xfer *xfer,
 		struct wa_xfer_ctl *xfer_ctl =
 			container_of(xfer_hdr0, struct wa_xfer_ctl, hdr);
 		xfer_ctl-&gt;bmAttribute = xfer-&gt;is_inbound ? 1 : 0;
-		BUG_ON(xfer-&gt;urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP
-		       &amp;&amp; xfer-&gt;urb-&gt;setup_packet == NULL);
 		memcpy(&amp;xfer_ctl-&gt;baSetupData, xfer-&gt;urb-&gt;setup_packet,
 		       sizeof(xfer_ctl-&gt;baSetupData));
 		break;</pre><hr><pre>commit 749da5f82fe33ff68dd4aa1a5e35cd9aa6246dab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 4 17:05:08 2010 -0500

    USB: straighten out port feature vs. port status usage
    
    This patch (as1349b) clears up the confusion in many USB host
    controller drivers between port features and port statuses.  In mosty
    cases it's true that the status bit is in the position given by the
    corresponding feature value, but that's not always true and it's not
    guaranteed in the USB spec.
    
    There's no functional change, just replacing expressions of the form
    (1 &lt;&lt; USB_PORT_FEAT_x) with USB_PORT_STAT_x, which has the same value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5ac27ed0c635..497dbb29744d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3037,7 +3037,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 		/* maybe switch power back on (e.g. root hub was reset) */
 		if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2
-				&amp;&amp; !(portstatus &amp; (1 &lt;&lt; USB_PORT_FEAT_POWER)))
+				&amp;&amp; !(portstatus &amp; USB_PORT_STAT_POWER))
 			set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);
 
 		if (portstatus &amp; USB_PORT_STAT_ENABLE)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index c7178bcde67a..c44018109a13 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -659,7 +659,7 @@ static int ehci_hub_control (
 		 * Even if OWNER is set, so the port is owned by the
 		 * companion controller, khubd needs to be able to clear
 		 * the port-change status bits (especially
-		 * USB_PORT_FEAT_C_CONNECTION).
+		 * USB_PORT_STAT_C_CONNECTION).
 		 */
 
 		switch (wValue) {
@@ -729,12 +729,12 @@ static int ehci_hub_control (
 
 		// wPortChange bits
 		if (temp &amp; PORT_CSC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+			status |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 		if (temp &amp; PORT_PEC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_ENABLE;
+			status |= USB_PORT_STAT_C_ENABLE &lt;&lt; 16;
 
 		if ((temp &amp; PORT_OCC) &amp;&amp; !ignore_oc){
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT;
+			status |= USB_PORT_STAT_C_OVERCURRENT &lt;&lt; 16;
 
 			/*
 			 * Hubs should disable port power on over-current.
@@ -791,7 +791,7 @@ static int ehci_hub_control (
 		if ((temp &amp; PORT_RESET)
 				&amp;&amp; time_after_eq(jiffies,
 					ehci-&gt;reset_done[wIndex])) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_RESET;
+			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
 
 			/* force reset to complete */
@@ -833,7 +833,7 @@ static int ehci_hub_control (
 		 */
 
 		if (temp &amp; PORT_CONNECT) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			status |= USB_PORT_STAT_CONNECTION;
 			// status may be from integrated TT
 			if (ehci-&gt;has_hostpc) {
 				temp1 = ehci_readl(ehci, hostpc_reg);
@@ -842,11 +842,11 @@ static int ehci_hub_control (
 				status |= ehci_port_speed(ehci, temp);
 		}
 		if (temp &amp; PORT_PE)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+			status |= USB_PORT_STAT_ENABLE;
 
 		/* maybe the port was unsuspended without our knowledge */
 		if (temp &amp; (PORT_SUSPEND|PORT_RESUME)) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+			status |= USB_PORT_STAT_SUSPEND;
 		} else if (test_bit(wIndex, &amp;ehci-&gt;suspended_ports)) {
 			clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
 			ehci-&gt;reset_done[wIndex] = 0;
@@ -855,13 +855,13 @@ static int ehci_hub_control (
 		}
 
 		if (temp &amp; PORT_OC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
+			status |= USB_PORT_STAT_OVERCURRENT;
 		if (temp &amp; PORT_RESET)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+			status |= USB_PORT_STAT_RESET;
 		if (temp &amp; PORT_POWER)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+			status |= USB_PORT_STAT_POWER;
 		if (test_bit(wIndex, &amp;ehci-&gt;port_c_suspend))
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+			status |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 
 #ifndef	VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */
diff --git a/drivers/usb/host/isp1362-hcd.c b/drivers/usb/host/isp1362-hcd.c
index acc157da7275..6a6a50849bfe 100644
--- a/drivers/usb/host/isp1362-hcd.c
+++ b/drivers/usb/host/isp1362-hcd.c
@@ -1265,7 +1265,7 @@ static int isp1362_urb_enqueue(struct usb_hcd *hcd,
 
 	/* don't submit to a dead or disabled port */
 	if (!((isp1362_hcd-&gt;rhport[0] | isp1362_hcd-&gt;rhport[1]) &amp;
-	      (1 &lt;&lt; USB_PORT_FEAT_ENABLE)) ||
+	      USB_PORT_STAT_ENABLE) ||
 	    !HC_IS_RUNNING(hcd-&gt;state)) {
 		kfree(ep);
 		retval = -ENODEV;
diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c
index cfdac6da9556..13f7d1200bc0 100644
--- a/drivers/usb/host/isp1760-hcd.c
+++ b/drivers/usb/host/isp1760-hcd.c
@@ -1923,7 +1923,7 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 		 * Even if OWNER is set, so the port is owned by the
 		 * companion controller, khubd needs to be able to clear
 		 * the port-change status bits (especially
-		 * USB_PORT_FEAT_C_CONNECTION).
+		 * USB_PORT_STAT_C_CONNECTION).
 		 */
 
 		switch (wValue) {
@@ -1987,7 +1987,7 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 
 		/* wPortChange bits */
 		if (temp &amp; PORT_CSC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+			status |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 
 
 		/* whoever resumes must GetPortStatus to complete it!! */
@@ -2007,7 +2007,7 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					priv-&gt;reset_done)) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				status |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 				priv-&gt;reset_done = 0;
 
 				/* stop resume signaling */
@@ -2031,7 +2031,7 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 		if ((temp &amp; PORT_RESET)
 				&amp;&amp; time_after_eq(jiffies,
 					priv-&gt;reset_done)) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_RESET;
+			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			priv-&gt;reset_done = 0;
 
 			/* force reset to complete */
@@ -2062,18 +2062,18 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 			printk(KERN_ERR "Warning: PORT_OWNER is set\n");
 
 		if (temp &amp; PORT_CONNECT) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			status |= USB_PORT_STAT_CONNECTION;
 			/* status may be from integrated TT */
 			status |= ehci_port_speed(priv, temp);
 		}
 		if (temp &amp; PORT_PE)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+			status |= USB_PORT_STAT_ENABLE;
 		if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
-			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+			status |= USB_PORT_STAT_SUSPEND;
 		if (temp &amp; PORT_RESET)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+			status |= USB_PORT_STAT_RESET;
 		if (temp &amp; PORT_POWER)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+			status |= USB_PORT_STAT_POWER;
 
 		put_unaligned(cpu_to_le32(status), (__le32 *) buf);
 		break;
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 8f04c0afa59f..f608dfd09a8a 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -3201,7 +3201,7 @@ static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
 		 * Even if OWNER is set, so the port is owned by the
 		 * companion controller, khubd needs to be able to clear
 		 * the port-change status bits (especially
-		 * USB_PORT_FEAT_C_CONNECTION).
+		 * USB_PORT_STAT_C_CONNECTION).
 		 */
 
 		switch (wValue) {
@@ -3263,11 +3263,11 @@ static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
 
 		/* wPortChange bits */
 		if (temp &amp; PORT_CSC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+			status |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 		if (temp &amp; PORT_PEC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_ENABLE;
+			status |= USB_PORT_STAT_C_ENABLE &lt;&lt; 16;
 		if ((temp &amp; PORT_OCC) &amp;&amp; !ignore_oc)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT;
+			status |= USB_PORT_STAT_C_OVERCURRENT &lt;&lt; 16;
 
 		/* whoever resumes must GetPortStatus to complete it!! */
 		if (temp &amp; PORT_RESUME) {
@@ -3285,7 +3285,7 @@ static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					oxu-&gt;reset_done[wIndex])) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				status |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 				oxu-&gt;reset_done[wIndex] = 0;
 
 				/* stop resume signaling */
@@ -3308,7 +3308,7 @@ static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
 		if ((temp &amp; PORT_RESET)
 				&amp;&amp; time_after_eq(jiffies,
 					oxu-&gt;reset_done[wIndex])) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_RESET;
+			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			oxu-&gt;reset_done[wIndex] = 0;
 
 			/* force reset to complete */
@@ -3347,20 +3347,20 @@ static int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,
 		 */
 
 		if (temp &amp; PORT_CONNECT) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			status |= USB_PORT_STAT_CONNECTION;
 			/* status may be from integrated TT */
 			status |= oxu_port_speed(oxu, temp);
 		}
 		if (temp &amp; PORT_PE)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+			status |= USB_PORT_STAT_ENABLE;
 		if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
-			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+			status |= USB_PORT_STAT_SUSPEND;
 		if (temp &amp; PORT_OC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
+			status |= USB_PORT_STAT_OVERCURRENT;
 		if (temp &amp; PORT_RESET)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+			status |= USB_PORT_STAT_RESET;
 		if (temp &amp; PORT_POWER)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+			status |= USB_PORT_STAT_POWER;
 
 #ifndef	OXU_VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index a004a1220848..6db57ab6079d 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1018,10 +1018,10 @@ static void start_root_hub_sampling(struct r8a66597 *r8a66597, int port,
 	rh-&gt;old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) &amp; LNST;
 	rh-&gt;scount = R8A66597_MAX_SAMPLING;
 	if (connect)
-		rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+		rh-&gt;port |= USB_PORT_STAT_CONNECTION;
 	else
-		rh-&gt;port &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_CONNECTION);
-	rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+		rh-&gt;port &amp;= ~USB_PORT_STAT_CONNECTION;
+	rh-&gt;port |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 
 	r8a66597_root_hub_start_polling(r8a66597);
 }
@@ -1065,8 +1065,8 @@ static void r8a66597_usb_connect(struct r8a66597 *r8a66597, int port)
 	else if (speed == LSMODE)
 		rh-&gt;port |= USB_PORT_STAT_LOW_SPEED;
 
-	rh-&gt;port &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_RESET);
-	rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+	rh-&gt;port &amp;= USB_PORT_STAT_RESET;
+	rh-&gt;port |= USB_PORT_STAT_ENABLE;
 }
 
 /* this function must be called with interrupt disabled */
@@ -1705,7 +1705,7 @@ static void r8a66597_root_hub_control(struct r8a66597 *r8a66597, int port)
 	u16 tmp;
 	struct r8a66597_root_hub *rh = &amp;r8a66597-&gt;root_hub[port];
 
-	if (rh-&gt;port &amp; (1 &lt;&lt; USB_PORT_FEAT_RESET)) {
+	if (rh-&gt;port &amp; USB_PORT_STAT_RESET) {
 		unsigned long dvstctr_reg = get_dvstctr_reg(port);
 
 		tmp = r8a66597_read(r8a66597, dvstctr_reg);
@@ -1717,7 +1717,7 @@ static void r8a66597_root_hub_control(struct r8a66597 *r8a66597, int port)
 			r8a66597_usb_connect(r8a66597, port);
 	}
 
-	if (!(rh-&gt;port &amp; (1 &lt;&lt; USB_PORT_FEAT_CONNECTION))) {
+	if (!(rh-&gt;port &amp; USB_PORT_STAT_CONNECTION)) {
 		r8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));
 		r8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));
 	}
@@ -2185,7 +2185,7 @@ static int r8a66597_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			rh-&gt;port &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_POWER);
+			rh-&gt;port &amp;= ~USB_PORT_STAT_POWER;
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			break;
@@ -2226,12 +2226,12 @@ static int r8a66597_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			break;
 		case USB_PORT_FEAT_POWER:
 			r8a66597_port_power(r8a66597, port, 1);
-			rh-&gt;port |= (1 &lt;&lt; USB_PORT_FEAT_POWER);
+			rh-&gt;port |= USB_PORT_STAT_POWER;
 			break;
 		case USB_PORT_FEAT_RESET: {
 			struct r8a66597_device *dev = rh-&gt;dev;
 
-			rh-&gt;port |= (1 &lt;&lt; USB_PORT_FEAT_RESET);
+			rh-&gt;port |= USB_PORT_STAT_RESET;
 
 			disable_r8a66597_pipe_all(r8a66597, dev);
 			free_usb_address(r8a66597, dev, 1);
@@ -2269,12 +2269,12 @@ static int r8a66597_bus_suspend(struct usb_hcd *hcd)
 		struct r8a66597_root_hub *rh = &amp;r8a66597-&gt;root_hub[port];
 		unsigned long dvstctr_reg = get_dvstctr_reg(port);
 
-		if (!(rh-&gt;port &amp; (1 &lt;&lt; USB_PORT_FEAT_ENABLE)))
+		if (!(rh-&gt;port &amp; USB_PORT_STAT_ENABLE))
 			continue;
 
 		dbg("suspend port = %d", port);
 		r8a66597_bclr(r8a66597, UACT, dvstctr_reg);	/* suspend */
-		rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+		rh-&gt;port |= USB_PORT_STAT_SUSPEND;
 
 		if (rh-&gt;dev-&gt;udev-&gt;do_remote_wakeup) {
 			msleep(3);	/* waiting last SOF */
@@ -2300,12 +2300,12 @@ static int r8a66597_bus_resume(struct usb_hcd *hcd)
 		struct r8a66597_root_hub *rh = &amp;r8a66597-&gt;root_hub[port];
 		unsigned long dvstctr_reg = get_dvstctr_reg(port);
 
-		if (!(rh-&gt;port &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)))
+		if (!(rh-&gt;port &amp; USB_PORT_STAT_SUSPEND))
 			continue;
 
 		dbg("resume port = %d", port);
-		rh-&gt;port &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
-		rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
+		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
 		msleep(50);
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index dcd7fab7179c..bcf9f0e809de 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -90,10 +90,10 @@ static void port_power(struct sl811 *sl811, int is_on)
 
 	/* hub is inactive unless the port is powered */
 	if (is_on) {
-		if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_POWER))
+		if (sl811-&gt;port1 &amp; USB_PORT_STAT_POWER)
 			return;
 
-		sl811-&gt;port1 = (1 &lt;&lt; USB_PORT_FEAT_POWER);
+		sl811-&gt;port1 = USB_PORT_STAT_POWER;
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV;
 	} else {
 		sl811-&gt;port1 = 0;
@@ -407,7 +407,7 @@ static struct sl811h_ep	*start(struct sl811 *sl811, u8 bank)
 
 static inline void start_transfer(struct sl811 *sl811)
 {
-	if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+	if (sl811-&gt;port1 &amp; USB_PORT_STAT_SUSPEND)
 		return;
 	if (sl811-&gt;active_a == NULL) {
 		sl811-&gt;active_a = start(sl811, SL811_EP_A(SL811_HOST_BUF));
@@ -721,23 +721,23 @@ static irqreturn_t sl811h_irq(struct usb_hcd *hcd)
 		 * force the reset and make khubd clean up later.
 		 */
 		if (irqstat &amp; SL11H_INTMASK_RD)
-			sl811-&gt;port1 &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_CONNECTION);
+			sl811-&gt;port1 &amp;= ~USB_PORT_STAT_CONNECTION;
 		else
-			sl811-&gt;port1 |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			sl811-&gt;port1 |= USB_PORT_STAT_CONNECTION;
 
-		sl811-&gt;port1 |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+		sl811-&gt;port1 |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 
 	} else if (irqstat &amp; SL11H_INTMASK_RD) {
-		if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)) {
+		if (sl811-&gt;port1 &amp; USB_PORT_STAT_SUSPEND) {
 			DBG("wakeup\n");
-			sl811-&gt;port1 |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+			sl811-&gt;port1 |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 			sl811-&gt;stat_wake++;
 		} else
 			irqstat &amp;= ~SL11H_INTMASK_RD;
 	}
 
 	if (irqstat) {
-		if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_ENABLE))
+		if (sl811-&gt;port1 &amp; USB_PORT_STAT_ENABLE)
 			start_transfer(sl811);
 		ret = IRQ_HANDLED;
 		if (retries--)
@@ -819,7 +819,7 @@ static int sl811h_urb_enqueue(
 	spin_lock_irqsave(&amp;sl811-&gt;lock, flags);
 
 	/* don't submit to a dead or disabled port */
-	if (!(sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_ENABLE))
+	if (!(sl811-&gt;port1 &amp; USB_PORT_STAT_ENABLE)
 			|| !HC_IS_RUNNING(hcd-&gt;state)) {
 		retval = -ENODEV;
 		kfree(ep);
@@ -1119,8 +1119,8 @@ sl811h_timer(unsigned long _sl811)
 	unsigned long	flags;
 	u8		irqstat;
 	u8		signaling = sl811-&gt;ctrl1 &amp; SL11H_CTL1MASK_FORCE;
-	const u32	mask = (1 &lt;&lt; USB_PORT_FEAT_CONNECTION)
-				| (1 &lt;&lt; USB_PORT_FEAT_ENABLE)
+	const u32	mask = USB_PORT_STAT_CONNECTION
+				| USB_PORT_STAT_ENABLE
 				| USB_PORT_STAT_LOW_SPEED;
 
 	spin_lock_irqsave(&amp;sl811-&gt;lock, flags);
@@ -1135,8 +1135,8 @@ sl811h_timer(unsigned long _sl811)
 	switch (signaling) {
 	case SL11H_CTL1MASK_SE0:
 		DBG("end reset\n");
-		sl811-&gt;port1 = (1 &lt;&lt; USB_PORT_FEAT_C_RESET)
-				| (1 &lt;&lt; USB_PORT_FEAT_POWER);
+		sl811-&gt;port1 = (USB_PORT_STAT_C_RESET &lt;&lt; 16)
+				 | USB_PORT_STAT_POWER;
 		sl811-&gt;ctrl1 = 0;
 		/* don't wrongly ack RD */
 		if (irqstat &amp; SL11H_INTMASK_INSRMV)
@@ -1144,7 +1144,7 @@ sl811h_timer(unsigned long _sl811)
 		break;
 	case SL11H_CTL1MASK_K:
 		DBG("end resume\n");
-		sl811-&gt;port1 &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
+		sl811-&gt;port1 &amp;= ~USB_PORT_STAT_SUSPEND;
 		break;
 	default:
 		DBG("odd timer signaling: %02x\n", signaling);
@@ -1154,9 +1154,9 @@ sl811h_timer(unsigned long _sl811)
 
 	if (irqstat &amp; SL11H_INTMASK_RD) {
 		/* usbcore nukes all pending transactions on disconnect */
-		if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_CONNECTION))
-			sl811-&gt;port1 |= (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION)
-					| (1 &lt;&lt; USB_PORT_FEAT_C_ENABLE);
+		if (sl811-&gt;port1 &amp; USB_PORT_STAT_CONNECTION)
+			sl811-&gt;port1 |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16)
+					| (USB_PORT_STAT_C_ENABLE &lt;&lt; 16);
 		sl811-&gt;port1 &amp;= ~mask;
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV;
 	} else {
@@ -1166,7 +1166,7 @@ sl811h_timer(unsigned long _sl811)
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV | SL11H_INTMASK_RD;
 	}
 
-	if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_CONNECTION)) {
+	if (sl811-&gt;port1 &amp; USB_PORT_STAT_CONNECTION) {
 		u8	ctrl2 = SL811HS_CTL2_INIT;
 
 		sl811-&gt;irq_enable |= SL11H_INTMASK_DONE_A;
@@ -1233,7 +1233,7 @@ sl811h_hub_control(
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			sl811-&gt;port1 &amp;= (1 &lt;&lt; USB_PORT_FEAT_POWER);
+			sl811-&gt;port1 &amp;= USB_PORT_STAT_POWER;
 			sl811-&gt;ctrl1 = 0;
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 			sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV;
@@ -1241,7 +1241,7 @@ sl811h_hub_control(
 						sl811-&gt;irq_enable);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
-			if (!(sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)))
+			if (!(sl811-&gt;port1 &amp; USB_PORT_STAT_SUSPEND))
 				break;
 
 			/* 20 msec of resume/K signaling, other irqs blocked */
@@ -1290,9 +1290,9 @@ sl811h_hub_control(
 			goto error;
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_RESET))
+			if (sl811-&gt;port1 &amp; USB_PORT_STAT_RESET)
 				goto error;
-			if (!(sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_ENABLE)))
+			if (!(sl811-&gt;port1 &amp; USB_PORT_STAT_ENABLE))
 				goto error;
 
 			DBG("suspend...\n");
@@ -1303,9 +1303,9 @@ sl811h_hub_control(
 			port_power(sl811, 1);
 			break;
 		case USB_PORT_FEAT_RESET:
-			if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+			if (sl811-&gt;port1 &amp; USB_PORT_STAT_SUSPEND)
 				goto error;
-			if (!(sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_POWER)))
+			if (!(sl811-&gt;port1 &amp; USB_PORT_STAT_POWER))
 				break;
 
 			/* 50 msec of reset/SE0 signaling, irqs blocked */
@@ -1314,7 +1314,7 @@ sl811h_hub_control(
 						sl811-&gt;irq_enable);
 			sl811-&gt;ctrl1 = SL11H_CTL1MASK_SE0;
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
-			sl811-&gt;port1 |= (1 &lt;&lt; USB_PORT_FEAT_RESET);
+			sl811-&gt;port1 |= USB_PORT_STAT_RESET;
 			mod_timer(&amp;sl811-&gt;timer, jiffies
 					+ msecs_to_jiffies(50));
 			break;
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index dd69df1e4558..325b47a267b9 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -205,27 +205,27 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 		/* wPortChange bits */
 		if (temp &amp; PORT_CSC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION;
+			status |= USB_PORT_STAT_C_CONNECTION &lt;&lt; 16;
 		if (temp &amp; PORT_PEC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_ENABLE;
+			status |= USB_PORT_STAT_C_ENABLE &lt;&lt; 16;
 		if ((temp &amp; PORT_OCC))
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT;
+			status |= USB_PORT_STAT_C_OVERCURRENT &lt;&lt; 16;
 		/*
 		 * FIXME ignoring suspend, reset, and USB 2.1/3.0 specific
 		 * changes
 		 */
 		if (temp &amp; PORT_CONNECT) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			status |= USB_PORT_STAT_CONNECTION;
 			status |= xhci_port_speed(temp);
 		}
 		if (temp &amp; PORT_PE)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+			status |= USB_PORT_STAT_ENABLE;
 		if (temp &amp; PORT_OC)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
+			status |= USB_PORT_STAT_OVERCURRENT;
 		if (temp &amp; PORT_RESET)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+			status |= USB_PORT_STAT_RESET;
 		if (temp &amp; PORT_POWER)
-			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+			status |= USB_PORT_STAT_POWER;
 		xhci_dbg(xhci, "Get port status returned 0x%x\n", status);
 		put_unaligned(cpu_to_le32(status), (__le32 *) buf);
 		break;
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 705cc4ad8737..ced6d9ea9af3 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -353,8 +353,7 @@ void musb_hnp_stop(struct musb *musb)
 	 * which cause occasional OPT A "Did not receive reset after connect"
 	 * errors.
 	 */
-	musb-&gt;port1_status &amp;=
-		~(1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+	musb-&gt;port1_status &amp;= ~(USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 }
 
 #endif
@@ -530,8 +529,8 @@ static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
 				musb_writeb(mbase, MUSB_DEVCTL, devctl);
 			} else {
 				musb-&gt;port1_status |=
-					  (1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT)
-					| (1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT);
+					  USB_PORT_STAT_OVERCURRENT
+					| (USB_PORT_STAT_C_OVERCURRENT &lt;&lt; 16);
 			}
 			break;
 		default:
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 7775e1c0a215..92e85e027cfb 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -183,8 +183,8 @@ static void musb_port_reset(struct musb *musb, bool do_reset)
 
 void musb_root_disconnect(struct musb *musb)
 {
-	musb-&gt;port1_status = (1 &lt;&lt; USB_PORT_FEAT_POWER)
-			| (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+	musb-&gt;port1_status = USB_PORT_STAT_POWER
+			| (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 
 	usb_hcd_poll_rh_status(musb_to_hcd(musb));
 	musb-&gt;is_active = 0;</pre><hr><pre>commit 288ead45fa6637e959015d055304f521cbbc0575
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 4 11:32:30 2010 -0500

    USB: remove bogus USB_PORT_FEAT_*_SPEED symbols
    
    This patch (as1348) removes the bogus
    USB_PORT_FEAT_{HIGHSPEED,SUPERSPEED} symbols from ch11.h.  No such
    features are defined by the USB spec.  (There is a PORT_LOWSPEED
    feature, but the spec doesn't mention it except to say that host
    software should never use it.)  The speed indicators are port
    statuses, not port features.
    
    As a temporary workaround for the xhci-hcd driver, a fictional
    USB_PORT_STAT_SUPER_SPEED symbol is added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 1883c3c7b69b..5ac27ed0c635 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -153,11 +153,11 @@ static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(int portstatus)
 {
-	if (portstatus &amp; (1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED))
+	if (portstatus &amp; USB_PORT_STAT_HIGH_SPEED)
     		return "480 Mb/s";
-	else if (portstatus &amp; (1 &lt;&lt; USB_PORT_FEAT_LOWSPEED))
+	else if (portstatus &amp; USB_PORT_STAT_LOW_SPEED)
 		return "1.5 Mb/s";
-	else if (portstatus &amp; (1 &lt;&lt; USB_PORT_FEAT_SUPERSPEED))
+	else if (portstatus &amp; USB_PORT_STAT_SUPER_SPEED)
 		return "5.0 Gb/s";
 	else
 		return "12 Mb/s";
@@ -3075,7 +3075,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if (!(hcd-&gt;driver-&gt;flags &amp; HCD_USB3))
 			udev-&gt;speed = USB_SPEED_UNKNOWN;
 		else if ((hdev-&gt;parent == NULL) &amp;&amp;
-				(portstatus &amp; (1 &lt;&lt; USB_PORT_FEAT_SUPERSPEED)))
+				(portstatus &amp; USB_PORT_STAT_SUPER_SPEED))
 			udev-&gt;speed = USB_SPEED_SUPER;
 		else
 			udev-&gt;speed = USB_SPEED_UNKNOWN;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 556c0b48f3ab..4ebe9ad209e4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -556,20 +556,20 @@ ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
 		case 0:
 			return 0;
 		case 1:
-			return (1&lt;&lt;USB_PORT_FEAT_LOWSPEED);
+			return USB_PORT_STAT_LOW_SPEED;
 		case 2:
 		default:
-			return (1&lt;&lt;USB_PORT_FEAT_HIGHSPEED);
+			return USB_PORT_STAT_HIGH_SPEED;
 		}
 	}
-	return (1&lt;&lt;USB_PORT_FEAT_HIGHSPEED);
+	return USB_PORT_STAT_HIGH_SPEED;
 }
 
 #else
 
 #define	ehci_is_TDI(e)			(0)
 
-#define	ehci_port_speed(ehci, portsc)	(1&lt;&lt;USB_PORT_FEAT_HIGHSPEED)
+#define	ehci_port_speed(ehci, portsc)	USB_PORT_STAT_HIGH_SPEED
 #endif
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c
index c7ac1d97d176..cfdac6da9556 100644
--- a/drivers/usb/host/isp1760-hcd.c
+++ b/drivers/usb/host/isp1760-hcd.c
@@ -111,7 +111,7 @@ struct isp1760_qh {
 	u32 ping;
 };
 
-#define ehci_port_speed(priv, portsc) (1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED)
+#define ehci_port_speed(priv, portsc) USB_PORT_STAT_HIGH_SPEED
 
 static unsigned int isp1760_readl(__u32 __iomem *regs)
 {
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 2891203200ce..8f04c0afa59f 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -3153,10 +3153,10 @@ static inline unsigned int oxu_port_speed(struct oxu_hcd *oxu,
 	case 0:
 		return 0;
 	case 1:
-		return 1 &lt;&lt; USB_PORT_FEAT_LOWSPEED;
+		return USB_PORT_STAT_LOW_SPEED;
 	case 2:
 	default:
-		return 1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED;
+		return USB_PORT_STAT_HIGH_SPEED;
 	}
 }
 
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 1398de140ead..a004a1220848 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1059,12 +1059,11 @@ static void r8a66597_usb_connect(struct r8a66597 *r8a66597, int port)
 	u16 speed = get_rh_usb_speed(r8a66597, port);
 	struct r8a66597_root_hub *rh = &amp;r8a66597-&gt;root_hub[port];
 
-	rh-&gt;port &amp;= ~((1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED) |
-		      (1 &lt;&lt; USB_PORT_FEAT_LOWSPEED));
+	rh-&gt;port &amp;= ~(USB_PORT_STAT_HIGH_SPEED | USB_PORT_STAT_LOW_SPEED);
 	if (speed == HSMODE)
-		rh-&gt;port |= (1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED);
+		rh-&gt;port |= USB_PORT_STAT_HIGH_SPEED;
 	else if (speed == LSMODE)
-		rh-&gt;port |= (1 &lt;&lt; USB_PORT_FEAT_LOWSPEED);
+		rh-&gt;port |= USB_PORT_STAT_LOW_SPEED;
 
 	rh-&gt;port &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_RESET);
 	rh-&gt;port |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 8f2f477890c4..dcd7fab7179c 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1121,7 +1121,7 @@ sl811h_timer(unsigned long _sl811)
 	u8		signaling = sl811-&gt;ctrl1 &amp; SL11H_CTL1MASK_FORCE;
 	const u32	mask = (1 &lt;&lt; USB_PORT_FEAT_CONNECTION)
 				| (1 &lt;&lt; USB_PORT_FEAT_ENABLE)
-				| (1 &lt;&lt; USB_PORT_FEAT_LOWSPEED);
+				| USB_PORT_STAT_LOW_SPEED;
 
 	spin_lock_irqsave(&amp;sl811-&gt;lock, flags);
 
@@ -1162,7 +1162,7 @@ sl811h_timer(unsigned long _sl811)
 	} else {
 		sl811-&gt;port1 |= mask;
 		if (irqstat &amp; SL11H_INTMASK_DP)
-			sl811-&gt;port1 &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_LOWSPEED);
+			sl811-&gt;port1 &amp;= ~USB_PORT_STAT_LOW_SPEED;
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV | SL11H_INTMASK_RD;
 	}
 
@@ -1173,7 +1173,7 @@ sl811h_timer(unsigned long _sl811)
 #ifdef USE_B
 		sl811-&gt;irq_enable |= SL11H_INTMASK_DONE_B;
 #endif
-		if (sl811-&gt;port1 &amp; (1 &lt;&lt; USB_PORT_FEAT_LOWSPEED)) {
+		if (sl811-&gt;port1 &amp; USB_PORT_STAT_LOW_SPEED) {
 			sl811-&gt;ctrl1 |= SL11H_CTL1MASK_LSPD;
 			ctrl2 |= SL811HS_CTL2MASK_DSWAP;
 		}
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index 208b805b80eb..dd69df1e4558 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -64,15 +64,15 @@ static void xhci_hub_descriptor(struct xhci_hcd *xhci,
 static unsigned int xhci_port_speed(unsigned int port_status)
 {
 	if (DEV_LOWSPEED(port_status))
-		return 1 &lt;&lt; USB_PORT_FEAT_LOWSPEED;
+		return USB_PORT_STAT_LOW_SPEED;
 	if (DEV_HIGHSPEED(port_status))
-		return 1 &lt;&lt; USB_PORT_FEAT_HIGHSPEED;
+		return USB_PORT_STAT_HIGH_SPEED;
 	if (DEV_SUPERSPEED(port_status))
-		return 1 &lt;&lt; USB_PORT_FEAT_SUPERSPEED;
+		return USB_PORT_STAT_SUPER_SPEED;
 	/*
 	 * FIXME: Yes, we should check for full speed, but the core uses that as
 	 * a default in portspeed() in usb/core/hub.c (which is the only place
-	 * USB_PORT_FEAT_*SPEED is used).
+	 * USB_PORT_STAT_*_SPEED is used).
 	 */
 	return 0;
 }
diff --git a/include/linux/usb/ch11.h b/include/linux/usb/ch11.h
index 35cb7357ff72..bd3185aba4ee 100644
--- a/include/linux/usb/ch11.h
+++ b/include/linux/usb/ch11.h
@@ -47,11 +47,7 @@
 #define USB_PORT_FEAT_RESET		4
 #define USB_PORT_FEAT_L1		5	/* L1 suspend */
 #define USB_PORT_FEAT_POWER		8
-#define USB_PORT_FEAT_LOWSPEED		9
-/* This value was never in Table 11-17 */
-#define USB_PORT_FEAT_HIGHSPEED		10
-/* This value is also fake */
-#define USB_PORT_FEAT_SUPERSPEED	11
+#define USB_PORT_FEAT_LOWSPEED		9	/* Should never be used */
 #define USB_PORT_FEAT_C_CONNECTION	16
 #define USB_PORT_FEAT_C_ENABLE		17
 #define USB_PORT_FEAT_C_SUSPEND		18
@@ -87,6 +83,7 @@ struct usb_port_status {
 #define USB_PORT_STAT_TEST              0x0800
 #define USB_PORT_STAT_INDICATOR         0x1000
 /* bits 13 to 15 are reserved */
+#define USB_PORT_STAT_SUPER_SPEED	0x8000	/* Linux-internal */
 
 /*
  * wPortChange bit field</pre><hr><pre>commit 52b265a12768b9a72679bec825eb82c784116464
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 8 16:48:49 2010 -0500

    PCI: clearing wakeup flags not needed
    
    This patch (as1353) removes a couple of unnecessary assignments from
    the PCI core.  The should_wakeup flag is naturally initialized to 0;
    there's no need to clear it.
    
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 37499127c801..60fcb6f02c91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1631,7 +1631,6 @@ void pci_pm_init(struct pci_dev *dev)
 		 * let the user space enable it to wake up the system as needed.
 		 */
 		device_set_wakeup_capable(&amp;dev-&gt;dev, true);
-		device_set_wakeup_enable(&amp;dev-&gt;dev, false);
 		/* Disable the PME# generation functionality */
 		pci_pme_active(dev, false);
 	} else {
@@ -1655,7 +1654,6 @@ void platform_pci_wakeup_init(struct pci_dev *dev)
 		return;
 
 	device_set_wakeup_capable(&amp;dev-&gt;dev, true);
-	device_set_wakeup_enable(&amp;dev-&gt;dev, false);
 	platform_pci_sleep_wake(dev, false);
 }
 </pre><hr><pre>commit d6f9cda1fd241bc7a1d896da94950fd972eca9b7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 26 23:53:55 2010 +0100

    PM: Improve device power management document
    
    Improve the device power management document after it's been
    updated by the previous patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/devices.txt b/Documentation/power/devices.txt
index 10018d19e0bf..57080cd74575 100644
--- a/Documentation/power/devices.txt
+++ b/Documentation/power/devices.txt
@@ -1,11 +1,13 @@
 Device Power Management
 
-(C) 2010 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;, Novell Inc.
+Copyright (c) 2010 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;, Novell Inc.
+Copyright (c) 2010 Alan Stern &lt;stern@rowland.harvard.edu&gt;
+
 
 Most of the code in Linux is device drivers, so most of the Linux power
-management code is also driver-specific.  Most drivers will do very little;
-others, especially for platforms with small batteries (like cell phones),
-will do a lot.
+management (PM) code is also driver-specific.  Most drivers will do very
+little; others, especially for platforms with small batteries (like cell
+phones), will do a lot.
 
 This writeup gives an overview of how drivers interact with system-wide
 power management goals, emphasizing the models and interfaces that are
@@ -19,9 +21,10 @@ Drivers will use one or both of these models to put devices into low-power
 states:
 
     System Sleep model:
-	Drivers can enter low power states as part of entering system-wide
-	low-power states like "suspend-to-ram", or (mostly for systems with
-	disks) "hibernate" (suspend-to-disk).
+	Drivers can enter low-power states as part of entering system-wide
+	low-power states like "suspend" (also known as "suspend-to-RAM"), or
+	(mostly for systems with disks) "hibernation" (also known as
+	"suspend-to-disk").
 
 	This is something that device, bus, and class drivers collaborate on
 	by implementing various role-specific suspend and resume methods to
@@ -29,41 +32,41 @@ states:
 	them without loss of data.
 
 	Some drivers can manage hardware wakeup events, which make the system
-	leave that low-power state.  This feature may be enabled or disabled
+	leave the low-power state.  This feature may be enabled or disabled
 	using the relevant /sys/devices/.../power/wakeup file (for Ethernet
 	drivers the ioctl interface used by ethtool may also be used for this
 	purpose); enabling it may cost some power usage, but let the whole
-	system enter low power states more often.
+	system enter low-power states more often.
 
     Runtime Power Management model:
-	Devices may also be put into low power states while the system is
+	Devices may also be put into low-power states while the system is
 	running, independently of other power management activity in principle.
 	However, devices are not generally independent of each other (for
-	example, parent device cannot be suspended unless all of its child
-	devices have been suspended).  Moreover,  depending on the bus type the
+	example, a parent device cannot be suspended unless all of its child
+	devices have been suspended).  Moreover, depending on the bus type the
 	device is on, it may be necessary to carry out some bus-specific
-	operations on the device for this purpose.  Also, devices put into low
-	power states at run time may require special handling during system-wide
-	power transitions, like suspend to RAM.
+	operations on the device for this purpose.  Devices put into low power
+	states at run time may require special handling during system-wide power
+	transitions (suspend or hibernation).
 
 	For these reasons not only the device driver itself, but also the
-	appropriate subsystem (bus type, device type or device class) driver
-	and the PM core are involved in the runtime power management of devices.
-	Like in the system sleep power management case, they need to collaborate
-	by implementing various role-specific suspend and resume methods, so
-	that the hardware is cleanly powered down and reactivated without data
-	or service loss.
-
-There's not a lot to be said about those low power states except that they
-are very system-specific, and often device-specific.  Also, that if enough
-devices have been put into low power states (at "run time"), the effect may be
-very similar to entering some system-wide low-power state (system sleep) ... and
-that synergies exist, so that several drivers using runtime PM might put the
-system into a state where even deeper power saving options are available.
-
-Most suspended devices will have quiesced all I/O:  no more DMA or IRQs, no
-more data read or written, and requests from upstream drivers are no longer
-accepted.  A given bus or platform may have different requirements though.
+	appropriate subsystem (bus type, device type or device class) driver and
+	the PM core are involved in runtime power management.  As in the system
+	sleep power management case, they need to collaborate by implementing
+	various role-specific suspend and resume methods, so that the hardware
+	is cleanly powered down and reactivated without data or service loss.
+
+There's not a lot to be said about those low-power states except that they are
+very system-specific, and often device-specific.  Also, that if enough devices
+have been put into low-power states (at runtime), the effect may be very similar
+to entering some system-wide low-power state (system sleep) ... and that
+synergies exist, so that several drivers using runtime PM might put the system
+into a state where even deeper power saving options are available.
+
+Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
+for wakeup events), no more data read or written, and requests from upstream
+drivers are no longer accepted.  A given bus or platform may have different
+requirements though.
 
 Examples of hardware wakeup events include an alarm from a real time clock,
 network wake-on-LAN packets, keyboard or mouse activity, and media insertion
@@ -72,10 +75,10 @@ or removal (for PCMCIA, MMC/SD, USB, and so on).
 
 Interfaces for Entering System Sleep States
 ===========================================
-There are programming interfaces provided for subsystem (bus type, device type,
-device class) and device drivers in order to allow them to participate in the
-power management of devices they are concerned with.  They cover the system
-sleep power management as well as the runtime power management of devices.
+There are programming interfaces provided for subsystems (bus type, device type,
+device class) and device drivers to allow them to participate in the power
+management of devices they are concerned with.  These interfaces cover both
+system sleep and runtime power management.
 
 
 Device Power Management Operations
@@ -106,16 +109,15 @@ struct dev_pm_ops {
 
 This structure is defined in include/linux/pm.h and the methods included in it
 are also described in that file.  Their roles will be explained in what follows.
-For now, it should be sufficient to remember that the last three of them are
-specific to runtime power management, while the remaining ones are used during
+For now, it should be sufficient to remember that the last three methods are
+specific to runtime power management while the remaining ones are used during
 system-wide power transitions.
 
-There also is an "old" or "legacy", deprecated way of implementing power
-management operations available at least for some subsystems.  This approach
-does not use struct dev_pm_ops objects and it only is suitable for implementing
-system sleep power management methods.  Therefore it is not described in this
-document, so please refer directly to the source code for more information about
-it.
+There also is a deprecated "old" or "legacy" interface for power management
+operations available at least for some subsystems.  This approach does not use
+struct dev_pm_ops objects and it is suitable only for implementing system sleep
+power management methods.  Therefore it is not described in this document, so
+please refer directly to the source code for more information about it.
 
 
 Subsystem-Level Methods
@@ -125,10 +127,10 @@ pointed to by the pm member of struct bus_type, struct device_type and
 struct class.  They are mostly of interest to the people writing infrastructure
 for buses, like PCI or USB, or device type and device class drivers.
 
-Bus drivers implement these methods as appropriate for the hardware and
-the drivers using it; PCI works differently from USB, and so on.  Not many
-people write subsystem-level drivers; most driver code is a "device driver" that
-builds on top of bus-specific framework code.
+Bus drivers implement these methods as appropriate for the hardware and the
+drivers using it; PCI works differently from USB, and so on.  Not many people
+write subsystem-level drivers; most driver code is a "device driver" that builds
+on top of bus-specific framework code.
 
 For more information on these driver calls, see the description later;
 they are called in phases for every device, respecting the parent-child
@@ -137,66 +139,78 @@ sequencing in the driver model tree.
 
 /sys/devices/.../power/wakeup files
 -----------------------------------
-All devices in the driver model have two flags to control handling of
-wakeup events, which are hardware signals that can force the device and/or
-system out of a low power state.  These are initialized by bus or device
-driver code using device_init_wakeup().
+All devices in the driver model have two flags to control handling of wakeup
+events (hardware signals that can force the device and/or system out of a low
+power state).  These flags are initialized by bus or device driver code using
+device_set_wakeup_capable() and device_set_wakeup_enable(), defined in
+include/linux/pm_wakeup.h.
 
 The "can_wakeup" flag just records whether the device (and its driver) can
-physically support wakeup events.  When that flag is clear, the sysfs
-"wakeup" file is empty, and device_may_wakeup() returns false.
-
-For devices that can issue wakeup events, a separate flag controls whether
-that device should try to use its wakeup mechanism.  The initial value of
-device_may_wakeup() will be false for the majority of devices, except for
-power buttons, keyboards, and Ethernet adapters whose WoL (wake-on-LAN) feature
-has been set up with ethtool.  Thus in the majority of cases the device's
-"wakeup" file will initially hold the value "disabled".  Userspace can change
-that to "enabled", so that device_may_wakeup() returns true, or change it back
-to "disabled", so that it returns false again.
+physically support wakeup events.  The device_set_wakeup_capable() routine
+affects this flag.  The "should_wakeup" flag controls whether the device should
+try to use its wakeup mechanism.  device_set_wakeup_enable() affects this flag;
+for the most part drivers should not change its value.  The initial value of
+should_wakeup is supposed to be false for the majority of devices; the major
+exceptions are power buttons, keyboards, and Ethernet adapters whose WoL
+(wake-on-LAN) feature has been set up with ethtool.
+
+Whether or not a device is capable of issuing wakeup events is a hardware
+matter, and the kernel is responsible for keeping track of it.  By contrast,
+whether or not a wakeup-capable device should issue wakeup events is a policy
+decision, and it is managed by user space through a sysfs attribute: the
+power/wakeup file.  User space can write the strings "enabled" or "disabled" to
+set or clear the should_wakeup flag, respectively.  Reads from the file will
+return the corresponding string if can_wakeup is true, but if can_wakeup is
+false then reads will return an empty string, to indicate that the device
+doesn't support wakeup events.  (But even though the file appears empty, writes
+will still affect the should_wakeup flag.)
+
+The device_may_wakeup() routine returns true only if both flags are set.
+Drivers should check this routine when putting devices in a low-power state
+during a system sleep transition, to see whether or not to enable the devices'
+wakeup mechanisms.  However for runtime power management, wakeup events should
+be enabled whenever the device and driver both support them, regardless of the
+should_wakeup flag.
 
 
 /sys/devices/.../power/control files
 ------------------------------------
-All devices in the driver model have a flag to control the desired behavior of
-its driver with respect to runtime power management.  This flag, called
-runtime_auto, is initialized by the bus type (or generally subsystem) code using
-pm_runtime_allow() or pm_runtime_forbid(), depending on whether or not the
-driver is supposed to power manage the device at run time by default,
-respectively.
-
-This setting may be adjusted by user space by writing either "on" or "auto" to
-the device's "control" file.  If "auto" is written, the device's runtime_auto
-flag will be set and the driver will be allowed to power manage the device if
-capable of doing that.  If "on" is written, the driver is not allowed to power
-manage the device which in turn is supposed to remain in the full power state at
-run time.  User space can check the current value of the runtime_auto flag by
-reading from the device's "control" file.
+Each device in the driver model has a flag to control whether it is subject to
+runtime power management.  This flag, called runtime_auto, is initialized by the
+bus type (or generally subsystem) code using pm_runtime_allow() or
+pm_runtime_forbid(); the default is to allow runtime power management.
+
+The setting can be adjusted by user space by writing either "on" or "auto" to
+the device's power/control sysfs file.  Writing "auto" calls pm_runtime_allow(),
+setting the flag and allowing the device to be runtime power-managed by its
+driver.  Writing "on" calls pm_runtime_forbid(), clearing the flag, returning
+the device to full power if it was in a low-power state, and preventing the
+device from being runtime power-managed.  User space can check the current value
+of the runtime_auto flag by reading the file.
 
 The device's runtime_auto flag has no effect on the handling of system-wide
-power transitions by its driver.  In particular, the device can (and in the
-majority of cases should and will) be put into a low power state during a
-system-wide transition to a sleep state (like "suspend-to-RAM") even though its
-runtime_auto flag is unset (in which case its "control" file contains "on").
+power transitions.  In particular, the device can (and in the majority of cases
+should and will) be put into a low-power state during a system-wide transition
+to a sleep state even though its runtime_auto flag is clear.
 
-For more information about the runtime power management framework for devices
-refer to Documentation/power/runtime_pm.txt.
+For more information about the runtime power management framework, refer to
+Documentation/power/runtime_pm.txt.
 
 
-Calling Drivers to Enter System Sleep States
-============================================
-When the system goes into a sleep state, each device's driver is asked
-to suspend the device by putting it into state compatible with the target
+Calling Drivers to Enter and Leave System Sleep States
+======================================================
+When the system goes into a sleep state, each device's driver is asked to
+suspend the device by putting it into a state compatible with the target
 system state.  That's usually some version of "off", but the details are
 system-specific.  Also, wakeup-enabled devices will usually stay partly
 functional in order to wake the system.
 
-When the system leaves that low power state, the device's driver is asked
-to resume it.  The suspend and resume operations always go together, and
-both are multi-phase operations.
+When the system leaves that low-power state, the device's driver is asked to
+resume it by returning it to full power.  The suspend and resume operations
+always go together, and both are multi-phase operations.
 
-For simple drivers, suspend might quiesce the device using the class code
-and then turn its hardware as "off" as possible with late_suspend.  The
+For simple drivers, suspend might quiesce the device using class code
+and then turn its hardware as "off" as possible during suspend_noirq.  The
 matching resume calls would then completely reinitialize the hardware
 before reactivating its class I/O queues.
 
@@ -224,269 +238,129 @@ devices have been suspended.  Device drivers must be prepared to cope with such
 situations.
 
 
-Suspending Devices
-------------------
-Suspending a given device is done in several phases.  Suspending the
-system always includes every phase, executing calls for every device
-before the next phase begins.  Not all busses or classes support all
-these callbacks; and not all drivers use all the callbacks.
-
-Generally, different callbacks are used depending on whether the system is
-going to the standby or memory sleep state ("suspend-to-RAM") or it is going to
-be hibernated ("suspend-to-disk").
+System Power Management Phases
+------------------------------
+Suspending or resuming the system is done in several phases.  Different phases
+are used for standby or memory sleep states ("suspend-to-RAM") and the
+hibernation state ("suspend-to-disk").  Each phase involves executing callbacks
+for every device before the next phase begins.  Not all busses or classes
+support all these callbacks and not all drivers use all the callbacks.  The
+various phases always run after tasks have been frozen and before they are
+unfrozen.  Furthermore, the *_noirq phases run at a time when IRQ handlers have
+been disabled (except for those marked with the IRQ_WAKEUP flag).
 
-If the system goes to the standby or memory sleep state the phases are seen by
-driver notifications issued in this order:
+Most phases use bus, type, and class callbacks (that is, methods defined in
+dev-&gt;bus-&gt;pm, dev-&gt;type-&gt;pm, and dev-&gt;class-&gt;pm).  The prepare and complete
+phases are exceptions; they use only bus callbacks.  When multiple callbacks
+are used in a phase, they are invoked in the order: &lt;class, type, bus&gt; during
+power-down transitions and in the opposite order during power-up transitions.
+For example, during the suspend phase the PM core invokes
 
-   1	bus-&gt;pm.prepare(dev) is called after tasks are frozen and it is supposed
-	to call the device driver's -&gt;pm.prepare() method.
+	dev-&gt;class-&gt;pm.suspend(dev);
+	dev-&gt;type-&gt;pm.suspend(dev);
+	dev-&gt;bus-&gt;pm.suspend(dev);
 
-	The purpose of this method is mainly to prevent new children of the
-	device from being registered after it has returned.  It also may be used
-	to generally prepare the device for the upcoming system transition, but
-	it should not put the device into a low power state.
+before moving on to the next device, whereas during the resume phase the core
+invokes
 
-   2	class-&gt;pm.suspend(dev) is called if dev is associated with a class that
-	has such a method.  It may invoke the device driver's -&gt;pm.suspend()
-	method, unless type-&gt;pm.suspend(dev) or bus-&gt;pm.suspend() does that.
+	dev-&gt;bus-&gt;pm.resume(dev);
+	dev-&gt;type-&gt;pm.resume(dev);
+	dev-&gt;class-&gt;pm.resume(dev);
 
-   3	type-&gt;pm.suspend(dev) is called if dev is associated with a device type
-	that has such a method.  It may invoke the device driver's
-	-&gt;pm.suspend() method, unless class-&gt;pm.suspend(dev) or
-	bus-&gt;pm.suspend() does that.
+These callbacks may in turn invoke device- or driver-specific methods stored in
+dev-&gt;driver-&gt;pm, but they don't have to.
 
-   4	bus-&gt;pm.suspend(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.suspend() method.
 
-	This call should generally quiesce the device so that it doesn't do any
-	I/O after the call has returned.  It also may save the device registers
-	and put it into the appropriate low power state, depending on the bus
-	type the device is on.
-
-   5	bus-&gt;pm.suspend_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.suspend_noirq() method, depending on the bus type
-	in question.
-
-	This method is invoked after device interrupts have been suspended,
-	which means that the driver's interrupt handler will not be called
-	while it is running.  It should save the values of the device's
-	registers that weren't saved previously and finally put the device into
-	the appropriate low power state.
+Entering System Suspend
+-----------------------
+When the system goes into the standby or memory sleep state, the phases are:
+
+		prepare, suspend, suspend_noirq.
+
+    1.	The prepare phase is meant to prevent races by preventing new devices
+	from being registered; the PM core would never know that all the
+	children of a device had been suspended if new children could be
+	registered at will.  (By contrast, devices may be unregistered at any
+	time.)  Unlike the other suspend-related phases, during the prepare
+	phase the device tree is traversed top-down.
+
+	The prepare phase uses only a bus callback.  After the callback method
+	returns, no new children may be registered below the device.  The method
+	may also prepare the device or driver in some way for the upcoming
+	system power transition, but it should not put the device into a
+	low-power state.
+
+    2.	The suspend methods should quiesce the device to stop it from performing
+	I/O.  They also may save the device registers and put it into the
+	appropriate low-power state, depending on the bus type the device is on,
+	and they may enable wakeup events.
+
+    3.	The suspend_noirq phase occurs after IRQ handlers have been disabled,
+	which means that the driver's interrupt handler will not be called while
+	the callback method is running.  The methods should save the values of
+	the device's registers that weren't saved previously and finally put the
+	device into the appropriate low-power state.
 
 	The majority of subsystems and device drivers need not implement this
-	method.  However, bus types allowing devices to share interrupt vectors,
-	like PCI, generally need to use it to prevent interrupt handling issues
-	from happening during suspend.
-
-At the end of those phases, drivers should normally have stopped all I/O
-transactions (DMA, IRQs), saved enough state that they can re-initialize
-or restore previous state (as needed by the hardware), and placed the
-device into a low-power state.  On many platforms they will also use
-gate off one or more clock sources; sometimes they will also switch off power
-supplies, or reduce voltages.  [Drivers supporting runtime PM may already have
-performed some or all of the steps needed to prepare for the upcoming system
-state transition.]
+	callback.  However, bus types allowing devices to share interrupt
+	vectors, like PCI, generally need it; otherwise a driver might encounter
+	an error during the suspend phase by fielding a shared interrupt
+	generated by some other device after its own device had been set to low
+	power.
+
+At the end of these phases, drivers should have stopped all I/O transactions
+(DMA, IRQs), saved enough state that they can re-initialize or restore previous
+state (as needed by the hardware), and placed the device into a low-power state.
+On many platforms they will gate off one or more clock sources; sometimes they
+will also switch off power supplies or reduce voltages.  (Drivers supporting
+runtime PM may already have performed some or all of these steps.)
 
 If device_may_wakeup(dev) returns true, the device should be prepared for
-generating hardware wakeup signals when the system is in the sleep state to
-trigger a system wakeup event.  For example, enable_irq_wake() might identify
+generating hardware wakeup signals to trigger a system wakeup event when the
+system is in the sleep state.  For example, enable_irq_wake() might identify
 GPIO signals hooked up to a switch or other external hardware, and
 pci_enable_wake() does something similar for the PCI PME signal.
 
-If a driver (or subsystem) fails it suspend method, the system won't enter the
-desired low power state; it will resume all the devices it's suspended so far.
-
-
-Hibernation Phases
-------------------
-Hibernating the system is more complicated than putting it into the standby or
-memory sleep state, because it involves creating a system image and saving it.
-Therefore there are more phases of hibernation and special device PM methods are
-used in this case.
-
-First, it is necessary to prepare the system for creating a hibernation image.
-This is similar to putting the system into the standby or memory sleep state,
-although it generally doesn't require that devices be put into low power states
-(that is even not desirable at this point).  Driver notifications are then
-issued in the following order:
-
-   1	bus-&gt;pm.prepare(dev) is called after tasks have been frozen and enough
-	memory has been freed.
-
-   2	class-&gt;pm.freeze(dev) is called if implemented.  It may invoke the
-        device driver's -&gt;pm.freeze() method, unless type-&gt;pm.freeze(dev) or
-        bus-&gt;pm.freeze() does that.
-
-   3	type-&gt;pm.freeze(dev) is called if implemented.  It may invoke the device
-	driver's -&gt;pm.suspend() method, unless class-&gt;pm.freeze(dev) or
-	bus-&gt;pm.freeze() does that.
-
-   4	bus-&gt;pm.freeze(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.freeze() method.
-
-   5	bus-&gt;pm.freeze_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.freeze_noirq() method, depending on the bus type
-	in question.
-
-The difference between -&gt;pm.freeze() and the corresponding -&gt;pm.suspend() (and
-similarly for the "noirq" variants) is that the former should avoid preparing
-devices to trigger system wakeup events and putting devices into low power
-states, although they generally have to save the values of device registers
-so that it's possible to restore them during system resume.
-
-Second, after the system image has been created, the functionality of devices
-has to be restored so that the image can be saved.  That is similar to resuming
-devices after the system has been woken up from the standby or memory sleep
-state, which is described below, and causes the following device notifications
-to be issued:
-
-   1	bus-&gt;pm.thaw_noirq(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw_noirq() method, depending on the bus type in question.
-
-   2	bus-&gt;pm.thaw(dev), if implemented; usually calls the device driver's
-	-&gt;pm.thaw() method.
-
-   3	type-&gt;pm.thaw(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw() method if not called by the bus type or class.
-
-   4	class-&gt;pm.thaw(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw() method if not called by the bus type or device type.
-
-   5	bus-&gt;pm.complete(dev), if implemented; may call the device driver's
-	-&gt;pm.complete() method.
-
-Generally, the role of the -&gt;pm.thaw() methods (including the "noirq" variants)
-is to bring the device back to the fully functional state, so that it may be
-used for saving the image, if necessary.  The role of bus-&gt;pm.complete() is to
-reverse whatever bus-&gt;pm.prepare() did (likewise for the analogous device driver
-callbacks).
-
-After the image has been saved, the devices need to be prepared for putting the
-system into the low power state.  That is analogous to suspending them before
-putting the system into the standby or memory sleep state and involves the
-following device notifications:
-
-   1	bus-&gt;pm.prepare(dev).
-
-   2	class-&gt;pm.poweroff(dev), if implemented; may invoke the device driver's
-   	-&gt;pm.poweroff() method if not called by the bus type or device type.
-
-   3	type-&gt;pm.poweroff(dev), if implemented; may invoke the device driver's
-   	-&gt;pm.poweroff() method if not called by the bus type or device class.
-
-   4	bus-&gt;pm.poweroff(dev), if implemented; usually calls the device driver's
-   	-&gt;pm.poweroff() method (if not called by the device class or type).
-
-   5	bus-&gt;pm.poweroff_noirq(dev), if implemented; may call the device
-	driver's -&gt;pm.poweroff_noirq() method, depending on the bus type
-	in question.
-
-The difference between -&gt;pm.poweroff() and the corresponding -&gt;pm.suspend() (and
-analogously for the "noirq" variants) is that the former need not save the
-device's registers.  Still, they should prepare the device for triggering
-system wakeup events if necessary and finally put it into the appropriate low
-power state.
-
-
-Device Low Power (suspend) States
----------------------------------
-Device low-power states aren't standard.  One device might only handle
-"on" and "off, while another might support a dozen different versions of
-"on" (how many engines are active?), plus a state that gets back to "on"
-faster than from a full "off".
-
-Some busses define rules about what different suspend states mean.  PCI
-gives one example:  after the suspend sequence completes, a non-legacy
-PCI device may not perform DMA or issue IRQs, and any wakeup events it
-issues would be issued through the PME# bus signal.  Plus, there are
-several PCI-standard device states, some of which are optional.
-
-In contrast, integrated system-on-chip processors often use IRQs as the
-wakeup event sources (so drivers would call enable_irq_wake) and might
-be able to treat DMA completion as a wakeup event (sometimes DMA can stay
-active too, it'd only be the CPU and some peripherals that sleep).
-
-Some details here may be platform-specific.  Systems may have devices that
-can be fully active in certain sleep states, such as an LCD display that's
-refreshed using DMA while most of the system is sleeping lightly ... and
-its frame buffer might even be updated by a DSP or other non-Linux CPU while
-the Linux control processor stays idle.
-
-Moreover, the specific actions taken may depend on the target system state.
-One target system state might allow a given device to be very operational;
-another might require a hard shut down with re-initialization on resume.
-And two different target systems might use the same device in different
-ways; the aforementioned LCD might be active in one product's "standby",
-but a different product using the same SOC might work differently.
+If any of these callbacks returns an error, the system won't enter the desired
+low-power state.  Instead the PM core will unwind its actions by resuming all
+the devices that were suspended.
 
 
-Resuming Devices
-----------------
-Resuming is done in multiple phases, much like suspending, with all
-devices processing each phase's calls before the next phase begins.
+Leaving System Suspend
+----------------------
+When resuming from standby or memory sleep, the phases are:
 
-Again, however, different callbacks are used depending on whether the system is
-waking up from the standby or memory sleep state ("suspend-to-RAM") or from
-hibernation ("suspend-to-disk").
+		resume_noirq, resume, complete.
 
-If the system is waking up from the standby or memory sleep state, the phases
-are seen by driver notifications issued in this order:
-
-   1	bus-&gt;pm.resume_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.resume_noirq() method, depending on the bus type in
-	question.
-
-	The role of this method is to perform actions that need to be performed
-	before device drivers' interrupt handlers are allowed to be invoked.  If
-	the given bus type permits devices to share interrupt vectors, like PCI,
-	this method should bring the device and its driver into a state in which
-	the driver can recognize if the device is the source of incoming
-	interrupts, if any, and handle them correctly.
+    1.	The resume_noirq callback methods should perform any actions needed
+	before the driver's interrupt handlers are invoked.  This generally
+	means undoing the actions of the suspend_noirq phase.  If the bus type
+	permits devices to share interrupt vectors, like PCI, the method should
+	bring the device and its driver into a state in which the driver can
+	recognize if the device is the source of incoming interrupts, if any,
+	and handle them correctly.
 
 	For example, the PCI bus type's -&gt;pm.resume_noirq() puts the device into
-	the full power state (D0 in the PCI terminology) and restores the
-	standard configuration registers of the device.  Then, it calls the
+	the full-power state (D0 in the PCI terminology) and restores the
+	standard configuration registers of the device.  Then it calls the
 	device driver's -&gt;pm.resume_noirq() method to perform device-specific
-	actions needed at this stage of resume.
-
-   2	bus-&gt;pm.resume(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.resume() method.
-
-	This call should generally bring the the device back to the working
-	state, so that it can do I/O as requested after the call has returned.
-	However, it may be more convenient to use the device class or device
-	type -&gt;pm.resume() for this purpose, in which case the bus type's
-	-&gt;pm.resume() method need not be implemented at all.
-
-   3	type-&gt;pm.resume(dev) is called, if implemented.  It may invoke the
-	device driver's -&gt;pm.resume() method, unless class-&gt;pm.resume(dev) or
-	bus-&gt;pm.resume() does that.
-
-	For devices that are not associated with any bus type or device class
-	this method plays the role of bus-&gt;pm.resume().
-
-   4	class-&gt;pm.resume(dev) is called, if implemented.  It may invoke the
-	device driver's -&gt;pm.resume() method, unless bus-&gt;pm.resume(dev) or
-	type-&gt;pm.resume() does that.
-
-	For devices that are not associated with any bus type or device type
-	this method plays the role of bus-&gt;pm.resume().
+	actions.
 
-   5	bus-&gt;pm.complete(dev) is called, if implemented.  It is supposed to
-	invoke the device driver's -&gt;pm.complete() method.
+    2.	The resume methods should bring the the device back to its operating
+	state, so that it can perform normal I/O.  This generally involves
+	undoing the actions of the suspend phase.
 
-	The role of this method is to reverse whatever bus-&gt;pm.prepare(dev)
-	(or the driver's -&gt;pm.prepare()) did during suspend, if necessary.
+    3.	The complete phase uses only a bus callback.  The method should undo the
+	actions of the prepare phase.  Note, however, that new children may be
+	registered below the device as soon as the resume callbacks occur; it's
+	not necessary to wait until the complete phase.
 
-At the end of those phases, drivers should normally be as functional as
-they were before suspending:  I/O can be performed using DMA and IRQs, and
-the relevant clocks are gated on.  In principle the device need not be
-"fully on"; it might be in a runtime lowpower/suspend state during suspend and
-the resume callbacks may try to restore that state, but that need not be
-desirable from the user's point of view.  In fact, there are multiple reasons
-why it's better to always put devices into the "fully working" state in the
-system sleep resume callbacks and they are discussed in more detail in
-Documentation/power/runtime_pm.txt.
+At the end of these phases, drivers should be as functional as they were before
+suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
+gated on.  Even if the device was in a low-power state before the system sleep
+because of runtime power management, afterwards it should be back in its
+full-power state.  There are multiple reasons why it's best to do this; they are
+discussed in more detail in Documentation/power/runtime_pm.txt.
 
 However, the details here may again be platform-specific.  For example,
 some systems support multiple "run" states, and the mode in effect at
@@ -502,103 +376,156 @@ the suspend was carried out, but that can't be guaranteed (in fact, it ususally
 is not the case).
 
 Drivers must also be prepared to notice that the device has been removed
-while the system was powered off, whenever that's physically possible.
+while the system was powered down, whenever that's physically possible.
 PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
 where common Linux platforms will see such removal.  Details of how drivers
 will notice and handle such removals are currently bus-specific, and often
 involve a separate thread.
 
+These callbacks may return an error value, but the PM core will ignore such
+errors since there's nothing it can do about them other than printing them in
+the system log.
 
-Resume From Hibernation
------------------------
+
+Entering Hibernation
+--------------------
+Hibernating the system is more complicated than putting it into the standby or
+memory sleep state, because it involves creating and saving a system image.
+Therefore there are more phases for hibernation, with a different set of
+callbacks.  These phases always run after tasks have been frozen and memory has
+been freed.
+
+The general procedure for hibernation is to quiesce all devices (freeze), create
+an image of the system memory while everything is stable, reactivate all
+devices (thaw), write the image to permanent storage, and finally shut down the
+system (poweroff).  The phases used to accomplish this are:
+
+	prepare, freeze, freeze_noirq, thaw_noirq, thaw, complete,
+	prepare, poweroff, poweroff_noirq
+
+    1.	The prepare phase is discussed in the "Entering System Suspend" section
+	above.
+
+    2.	The freeze methods should quiesce the device so that it doesn't generate
+	IRQs or DMA, and they may need to save the values of device registers.
+	However the device does not have to be put in a low-power state, and to
+	save time it's best not to do so.  Also, the device should not be
+	prepared to generate wakeup events.
+
+    3.	The freeze_noirq phase is analogous to the suspend_noirq phase discussed
+	above, except again that the device should not be put in a low-power
+	state and should not be allowed to generate wakeup events.
+
+At this point the system image is created.  All devices should be inactive and
+the contents of memory should remain undisturbed while this happens, so that the
+image forms an atomic snapshot of the system state.
+
+    4.	The thaw_noirq phase is analogous to the resume_noirq phase discussed
+	above.  The main difference is that its methods can assume the device is
+	in the same state as at the end of the freeze_noirq phase.
+
+    5.	The thaw phase is analogous to the resume phase discussed above.  Its
+	methods should bring the device back to an operating state, so that it
+	can be used for saving the image if necessary.
+
+    6.	The complete phase is discussed in the "Leaving System Suspend" section
+	above.
+
+At this point the system image is saved, and the devices then need to be
+prepared for the upcoming system shutdown.  This is much like suspending them
+before putting the system into the standby or memory sleep state, and the phases
+are similar.
+
+    7.	The prepare phase is discussed above.
+
+    8.	The poweroff phase is analogous to the suspend phase.
+
+    9.	The poweroff_noirq phase is analogous to the suspend_noirq phase.
+
+The poweroff and poweroff_noirq callbacks should do essentially the same things
+as the suspend and suspend_noirq callbacks.  The only notable difference is that
+they need not store the device register values, because the registers should
+already have been stored during the freeze or freeze_noirq phases.
+
+
+Leaving Hibernation
+-------------------
 Resuming from hibernation is, again, more complicated than resuming from a sleep
 state in which the contents of main memory are preserved, because it requires
 a system image to be loaded into memory and the pre-hibernation memory contents
 to be restored before control can be passed back to the image kernel.
 
-In principle, the image might be loaded into memory and the pre-hibernation
-memory contents might be restored by the boot loader.  For this purpose,
-however, the boot loader would need to know the image kernel's entry point and
-there's no protocol defined for passing that information to boot loaders.  As
-a workaround, the boot loader loads a fresh instance of the kernel, called the
-boot kernel, into memory and passes control to it in a usual way.  Then, the
-boot kernel reads the hibernation image, restores the pre-hibernation memory
-contents and passes control to the image kernel.  Thus, in fact, two different
-kernels are involved in resuming from hibernation and in general they are not
-only different because they play different roles in this operation.  Actually,
-the boot kernel may be completely different from the image kernel.  Not only
-the configuration of it, but also the version of it may be different.
-The consequences of this are important to device drivers and their subsystems
-(bus types, device classes and device types) too.
-
-Namely, to be able to load the hibernation image into memory, the boot kernel
-needs to include at least the subset of device drivers allowing it to access the
-storage medium containing the image, although it generally doesn't need to
-include all of the drivers included into the image kernel.  After the image has
-been loaded the devices handled by those drivers need to be prepared for passing
-control back to the image kernel.  This is very similar to the preparation of
-devices for creating a hibernation image described above.  In fact, it is done
-in the same way, with the help of the -&gt;pm.prepare(), -&gt;pm.freeze() and
--&gt;pm.freeze_noirq() callbacks, but only for device drivers included in the boot
-kernel (whose versions may generally be different from the versions of the
-analogous drivers from the image kernel).
+Although in principle, the image might be loaded into memory and the
+pre-hibernation memory contents restored by the boot loader, in practice this
+can't be done because boot loaders aren't smart enough and there is no
+established protocol for passing the necessary information.  So instead, the
+boot loader loads a fresh instance of the kernel, called the boot kernel, into
+memory and passes control to it in the usual way.  Then the boot kernel reads
+the system image, restores the pre-hibernation memory contents, and passes
+control to the image kernel.  Thus two different kernels are involved in
+resuming from hibernation.  In fact, the boot kernel may be completely different
+from the image kernel: a different configuration and even a different version.
+This has important consequences for device drivers and their subsystems.
+
+To be able to load the system image into memory, the boot kernel needs to
+include at least a subset of device drivers allowing it to access the storage
+medium containing the image, although it doesn't need to include all of the
+drivers present in the image kernel.  After the image has been loaded, the
+devices managed by the boot kernel need to be prepared for passing control back
+to the image kernel.  This is very similar to the initial steps involved in
+creating a system image, and it is accomplished in the same way, using prepare,
+freeze, and freeze_noirq phases.  However the devices affected by these phases
+are only those having drivers in the boot kernel; other devices will still be in
+whatever state the boot loader left them.
 
 Should the restoration of the pre-hibernation memory contents fail, the boot
-kernel would carry out the procedure of "thawing" devices described above, using
-the -&gt;pm.thaw_noirq(), -&gt;pm.thaw(), and -&gt;pm.complete() callbacks provided by
-subsystems and device drivers.  This, however, is a very rare condition.  Most
-often the pre-hibernation memory contents are restored successfully and control
-is passed to the image kernel that is now responsible for bringing the system
-back to the working state.
+kernel would go through the "thawing" procedure described above, using the
+thaw_noirq, thaw, and complete phases, and then continue running normally.  This
+happens only rarely.  Most often the pre-hibernation memory contents are
+restored successfully and control is passed to the image kernel, which then
+becomes responsible for bringing the system back to the working state.
 
-To achieve this goal, among other things, the image kernel restores the
-pre-hibernation functionality of devices.  This operation is analogous to the
-resuming of devices after waking up from the memory sleep state, although it
-involves different device notifications which are the following:
+To achieve this, the image kernel must restore the devices' pre-hibernation
+functionality.  The operation is much like waking up from the memory sleep
+state, although it involves different phases:
 
-   1	bus-&gt;pm.restore_noirq(dev), if implemented; may call the device driver's
-	-&gt;pm.restore_noirq() method, depending on the bus type in question.
+	restore_noirq, restore, complete
 
-   2	bus-&gt;pm.restore(dev), if implemented; usually calls the device driver's
-	-&gt;pm.restore() method.
+    1.	The restore_noirq phase is analogous to the resume_noirq phase.
 
-   3	type-&gt;pm.restore(dev), if implemented; may call the device driver's
-	-&gt;pm.restore() method if not called by the bus type or class.
+    2.	The restore phase is analogous to the resume phase.
 
-   4	class-&gt;pm.restore(dev), if implemented; may call the device driver's
-	-&gt;pm.restore() method if not called by the bus type or device type.
+    3.	The complete phase is discussed above.
 
-   5	bus-&gt;pm.complete(dev), if implemented; may call the device driver's
-	-&gt;pm.complete() method.
-
-The roles of the -&gt;pm.restore_noirq() and -&gt;pm.restore() callbacks are analogous
-to the roles of the corresponding resume callbacks, but they must assume that
-the device may have been accessed before by the boot kernel.  Consequently, the
-state of the device before they are called may be different from the state of it
-right prior to calling the resume callbacks.  That difference usually doesn't
-matter, so the majority of device drivers can set their resume and restore
-callback pointers to the same routine.  Nevertheless, different callback
-pointers are used in case there is a situation where it actually matters.
+The main difference from resume[_noirq] is that restore[_noirq] must assume the
+device has been accessed and reconfigured by the boot loader or the boot kernel.
+Consequently the state of the device may be different from the state remembered
+from the freeze and freeze_noirq phases.  The device may even need to be reset
+and completely re-initialized.  In many cases this difference doesn't matter, so
+the resume[_noirq] and restore[_norq] method pointers can be set to the same
+routines.  Nevertheless, different callback pointers are used in case there is a
+situation where it actually matters.
 
 
 System Devices
 --------------
-System devices follow a slightly different API, which can be found in
+System devices (sysdevs) follow a slightly different API, which can be found in
 
 	include/linux/sysdev.h
 	drivers/base/sys.c
 
-System devices will only be suspended with interrupts disabled, and after
-all other devices have been suspended.  On resume, they will be resumed
-before any other devices, and also with interrupts disabled.
+System devices will be suspended with interrupts disabled, and after all other
+devices have been suspended.  On resume, they will be resumed before any other
+devices, and also with interrupts disabled.  These things occur in special
+"sysdev_driver" phases, which affect only system devices.
 
-That is, when the non-boot CPUs are all offline and IRQs are disabled on the
-remaining online CPU, then the sysdev_driver.suspend() phase is carried out, and
-the system enters a sleep state (or hibernation image is created).  During
-resume (or after the image has been created) the sysdev_driver.resume() phase
-is carried out, IRQs are enabled on the only online CPU, the non-boot CPUs are
-enabled and that is followed by the "early resume" phase (in which the "noirq"
-callbacks provided by subsystems and device drivers are invoked).
+Thus, after the suspend_noirq (or freeze_noirq or poweroff_noirq) phase, when
+the non-boot CPUs are all offline and IRQs are disabled on the remaining online
+CPU, then a sysdev_driver.suspend phase is carried out, and the system enters a
+sleep state (or a system image is created).  During resume (or after the image
+has been created or loaded) a sysdev_driver.resume phase is carried out, IRQs
+are enabled on the only online CPU, the non-boot CPUs are enabled, and the
+resume_noirq (or thaw_noirq or restore_noirq) phase begins.
 
 Code to actually enter and exit the system-wide low power state sometimes
 involves hardware details that are only known to the boot firmware, and
@@ -606,18 +533,47 @@ may leave a CPU running software (from SRAM or flash memory) that monitors
 the system and manages its wakeup sequence.
 
 
+Device Low Power (suspend) States
+---------------------------------
+Device low-power states aren't standard.  One device might only handle
+"on" and "off, while another might support a dozen different versions of
+"on" (how many engines are active?), plus a state that gets back to "on"
+faster than from a full "off".
+
+Some busses define rules about what different suspend states mean.  PCI
+gives one example:  after the suspend sequence completes, a non-legacy
+PCI device may not perform DMA or issue IRQs, and any wakeup events it
+issues would be issued through the PME# bus signal.  Plus, there are
+several PCI-standard device states, some of which are optional.
+
+In contrast, integrated system-on-chip processors often use IRQs as the
+wakeup event sources (so drivers would call enable_irq_wake) and might
+be able to treat DMA completion as a wakeup event (sometimes DMA can stay
+active too, it'd only be the CPU and some peripherals that sleep).
+
+Some details here may be platform-specific.  Systems may have devices that
+can be fully active in certain sleep states, such as an LCD display that's
+refreshed using DMA while most of the system is sleeping lightly ... and
+its frame buffer might even be updated by a DSP or other non-Linux CPU while
+the Linux control processor stays idle.
+
+Moreover, the specific actions taken may depend on the target system state.
+One target system state might allow a given device to be very operational;
+another might require a hard shut down with re-initialization on resume.
+And two different target systems might use the same device in different
+ways; the aforementioned LCD might be active in one product's "standby",
+but a different product using the same SOC might work differently.
+
+
 Power Management Notifiers
 --------------------------
-As stated in Documentation/power/notifiers.txt, there are some operations that
-cannot be carried out by the power management callbacks discussed above, because
-carrying them out at these points would be too late or too early.  To handle
-these cases subsystems and device drivers may register power management
-notifiers that are called before tasks are frozen and after they have been
-thawed.
-
-Generally speaking, the PM notifiers are suitable for performing actions that
-either require user space to be available, or at least won't interfere with user
-space in a wrong way.
+There are some operations that cannot be carried out by the power management
+callbacks discussed above, because the callbacks occur too late or too early.
+To handle these cases, subsystems and device drivers may register power
+management notifiers that are called before tasks are frozen and after they have
+been thawed.  Generally speaking, the PM notifiers are suitable for performing
+actions that either require user space to be available, or at least won't
+interfere with user space.
 
 For details refer to Documentation/power/notifiers.txt.
 
@@ -629,24 +585,23 @@ running. This feature is useful for devices that are not being used, and
 can offer significant power savings on a running system.  These devices
 often support a range of runtime power states, which might use names such
 as "off", "sleep", "idle", "active", and so on.  Those states will in some
-cases (like PCI) be partially constrained by a bus the device uses, and will
+cases (like PCI) be partially constrained by the bus the device uses, and will
 usually include hardware states that are also used in system sleep states.
 
-Note, however, that a system-wide power transition can be started while some
-devices are in low power states due to the runtime power management.  The system
-sleep PM callbacks should generally recognize such situations and react to them
-appropriately, but the recommended actions to be taken in that cases are
-subsystem-specific.
-
-In some cases the decision may be made at the subsystem level while in some
-other cases the device driver may be left to decide.  In some cases it may be
-desirable to leave a suspended device in that state during system-wide power
-transition, but in some other cases the device ought to be put back into the
-full power state, for example to be configured for system wakeup or so that its
-system wakeup capability can be disabled.  That all depends on the hardware
-and the design of the subsystem and device driver in question.
-
-During system-wide resume from a sleep state it's better to put devices into
-the full power state, as explained in Documentation/power/runtime_pm.txt.  Refer
-to that document for more information regarding this particular issue as well as
+A system-wide power transition can be started while some devices are in low
+power states due to runtime power management.  The system sleep PM callbacks
+should recognize such situations and react to them appropriately, but the
+necessary actions are subsystem-specific.
+
+In some cases the decision may be made at the subsystem level while in other
+cases the device driver may be left to decide.  In some cases it may be
+desirable to leave a suspended device in that state during a system-wide power
+transition, but in other cases the device must be put back into the full-power
+state temporarily, for example so that its system wakeup capability can be
+disabled.  This all depends on the hardware and the design of the subsystem and
+device driver in question.
+
+During system-wide resume from a sleep state it's best to put devices into the
+full-power state, as explained in Documentation/power/runtime_pm.txt.  Refer to
+that document for more information regarding this particular issue as well as
 for information on the device runtime power management framework in general.</pre><hr><pre>commit 240c7337a4cd3d91b196c5ef97ad461b3a22fa09
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 23 00:50:07 2010 +0100

    PM: Allow runtime_suspend methods to call pm_schedule_suspend()
    
    This patch (as1361) changes the runtime PM interface slightly; it
    allows suspend requests to be scheduled while the runtime_suspend
    method is running.  If the method succeeds then the scheduled request
    is cancelled, whereas if the method fails then an idle notification is
    sent only if no request was scheduled.
    
    Being able to schedule suspend requests from within a runtime_suspend
    method is useful for drivers that need to test for idleness and
    suspend the device all while holding a single spinlock, or for drivers
    that want to check for idleness by polling.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 626dd147b75f..b0ec0e9f27e9 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -229,14 +229,16 @@ int __pm_runtime_suspend(struct device *dev, bool from_wq)
 
 	if (retval) {
 		dev-&gt;power.runtime_status = RPM_ACTIVE;
-		pm_runtime_cancel_pending(dev);
-
 		if (retval == -EAGAIN || retval == -EBUSY) {
-			notify = true;
+			if (dev-&gt;power.timer_expires == 0)
+				notify = true;
 			dev-&gt;power.runtime_error = 0;
+		} else {
+			pm_runtime_cancel_pending(dev);
 		}
 	} else {
 		dev-&gt;power.runtime_status = RPM_SUSPENDED;
+		pm_runtime_deactivate_timer(dev);
 
 		if (dev-&gt;parent) {
 			parent = dev-&gt;parent;
@@ -659,8 +661,6 @@ int pm_schedule_suspend(struct device *dev, unsigned int delay)
 
 	if (dev-&gt;power.runtime_status == RPM_SUSPENDED)
 		retval = 1;
-	else if (dev-&gt;power.runtime_status == RPM_SUSPENDING)
-		retval = -EINPROGRESS;
 	else if (atomic_read(&amp;dev-&gt;power.usage_count) &gt; 0
 	    || dev-&gt;power.disable_depth &gt; 0)
 		retval = -EAGAIN;</pre><hr><pre>commit fde4e2f73208b8f34f123791e39c0cb6bc74b32a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 7 10:41:10 2010 -0400

    HID: fix suspend crash by moving initializations earlier
    
    Although the usbhid driver allocates its usbhid structure in the probe
    routine, several critical fields in that structure don't get
    initialized until usbhid_start().  However if report descriptor
    parsing fails then usbhid_start() is never called.  This leads to
    problems during system suspend -- the system will freeze.
    
    This patch (as1378) fixes the bug by moving the initialization
    statements up into usbhid_probe().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Bruno Prmont &lt;bonbons@linux-vserver.org&gt;
    Tested-By: Bruno Prmont &lt;bonbons@linux-vserver.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 56d06cd8075b..7b85b696fdab 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -999,13 +999,6 @@ static int usbhid_start(struct hid_device *hid)
 		}
 	}
 
-	init_waitqueue_head(&amp;usbhid-&gt;wait);
-	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
-	INIT_WORK(&amp;usbhid-&gt;restart_work, __usbhid_restart_queues);
-	setup_timer(&amp;usbhid-&gt;io_retry, hid_retry_timeout, (unsigned long) hid);
-
-	spin_lock_init(&amp;usbhid-&gt;lock);
-
 	usbhid-&gt;urbctrl = usb_alloc_urb(0, GFP_KERNEL);
 	if (!usbhid-&gt;urbctrl) {
 		ret = -ENOMEM;
@@ -1179,6 +1172,12 @@ static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *
 	usbhid-&gt;intf = intf;
 	usbhid-&gt;ifnum = interface-&gt;desc.bInterfaceNumber;
 
+	init_waitqueue_head(&amp;usbhid-&gt;wait);
+	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
+	INIT_WORK(&amp;usbhid-&gt;restart_work, __usbhid_restart_queues);
+	setup_timer(&amp;usbhid-&gt;io_retry, hid_retry_timeout, (unsigned long) hid);
+	spin_lock_init(&amp;usbhid-&gt;lock);
+
 	ret = hid_add_device(hid);
 	if (ret) {
 		if (ret != -ENODEV)</pre>
    <div class="pagination">
        <a href='2_66.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><span>[67]</span><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_68.html'>Next&gt;&gt;</a>
    <div>
</body>

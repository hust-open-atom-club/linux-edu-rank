<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_128.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><span>[129]</span><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_130.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8d402e1ae03656c1ad215514f8885ef4793f0948
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Dec 17 18:03:37 2005 -0500

    [PATCH] UHCI: improve debugging code
    
    This patch (as626) makes some improvements to the debugging code in
    uhci-hcd.  The main change is that now the code won't get compiled if
    CONFIG_USB_DEBUG isn't set.  But there are other changes too, like
    adding a missing .owner field and printing a debugging dump if the
    controller dies.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index f2f5f8ce1715..e1239319655c 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -17,10 +17,13 @@
 
 #include "uhci-hcd.h"
 
-static struct dentry *uhci_debugfs_root = NULL;
+#define uhci_debug_operations (* (struct file_operations *) NULL)
+static struct dentry *uhci_debugfs_root;
+
+#ifdef DEBUG
 
 /* Handle REALLY large printks so we don't overflow buffers */
-static inline void lprintk(char *buf)
+static void lprintk(char *buf)
 {
 	char *p;
 
@@ -196,7 +199,6 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	return out - buf;
 }
 
-#ifdef CONFIG_PROC_FS
 static const char * const qh_names[] = {
   "skel_unlink_qh", "skel_iso_qh",
   "skel_int128_qh", "skel_int64_qh",
@@ -393,12 +395,13 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	return out - buf;
 }
 
+#ifdef CONFIG_DEBUG_FS
+
 #define MAX_OUTPUT	(64 * 1024)
 
 struct uhci_debug {
 	int size;
 	char *data;
-	struct uhci_hcd *uhci;
 };
 
 static int uhci_debug_open(struct inode *inode, struct file *file)
@@ -419,8 +422,10 @@ static int uhci_debug_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
+	up-&gt;size = 0;
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	up-&gt;size = uhci_sprint_schedule(uhci, up-&gt;data, MAX_OUTPUT);
+	if (uhci-&gt;is_initialized)
+		up-&gt;size = uhci_sprint_schedule(uhci, up-&gt;data, MAX_OUTPUT);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 
 	file-&gt;private_data = up;
@@ -472,15 +477,32 @@ static int uhci_debug_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
+#undef uhci_debug_operations
 static struct file_operations uhci_debug_operations = {
+	.owner =	THIS_MODULE,
 	.open =		uhci_debug_open,
 	.llseek =	uhci_debug_lseek,
 	.read =		uhci_debug_read,
 	.release =	uhci_debug_release,
 };
 
-#else	/* CONFIG_DEBUG_FS */
+#endif	/* CONFIG_DEBUG_FS */
 
-#define uhci_debug_operations (* (struct file_operations *) NULL)
+#else	/* DEBUG */
+
+static inline void lprintk(char *buf)
+{}
+
+static inline int uhci_show_qh(struct uhci_qh *qh, char *buf,
+		int len, int space)
+{
+	return 0;
+}
+
+static inline int uhci_sprint_schedule(struct uhci_hcd *uhci,
+		char *buf, int len)
+{
+	return 0;
+}
 
 #endif
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 9865f303d3fc..4edb8330c440 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -68,12 +68,16 @@ Alan Stern"
  * debug = 3, show all TDs in URBs when dumping
  */
 #ifdef DEBUG
+#define DEBUG_CONFIGURED	1
 static int debug = 1;
-#else
-static int debug = 0;
-#endif
 module_param(debug, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Debug level");
+
+#else
+#define DEBUG_CONFIGURED	0
+#define debug			0
+#endif
+
 static char *errbuf;
 #define ERRBUF_LEN    (32 * 1024)
 
@@ -338,6 +342,12 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 				dev_err(uhci_dev(uhci),
 					"host controller halted, "
 					"very bad!\n");
+				if (debug &gt; 1 &amp;&amp; errbuf) {
+					/* Print the schedule for debugging */
+					uhci_sprint_schedule(uhci,
+							errbuf, ERRBUF_LEN);
+					lprintk(errbuf);
+				}
 				hc_died(uhci);
 
 				/* Force a callback in case there are
@@ -376,6 +386,14 @@ static void release_uhci(struct uhci_hcd *uhci)
 {
 	int i;
 
+	if (DEBUG_CONFIGURED) {
+		spin_lock_irq(&amp;uhci-&gt;lock);
+		uhci-&gt;is_initialized = 0;
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+
+		debugfs_remove(uhci-&gt;dentry);
+	}
+
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
 		uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
 
@@ -390,8 +408,6 @@ static void release_uhci(struct uhci_hcd *uhci)
 	dma_free_coherent(uhci_dev(uhci),
 			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
 			uhci-&gt;frame, uhci-&gt;frame_dma_handle);
-
-	debugfs_remove(uhci-&gt;dentry);
 }
 
 static int uhci_reset(struct usb_hcd *hcd)
@@ -474,17 +490,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	hcd-&gt;uses_new_polling = 1;
 
-	dentry = debugfs_create_file(hcd-&gt;self.bus_name,
-			S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root, uhci,
-			&amp;uhci_debug_operations);
-	if (!dentry) {
-		dev_err(uhci_dev(uhci),
-				"couldn't create uhci debugfs entry\n");
-		retval = -ENOMEM;
-		goto err_create_debug_entry;
-	}
-	uhci-&gt;dentry = dentry;
-
 	uhci-&gt;fsbr = 0;
 	uhci-&gt;fsbrtimeout = 0;
 
@@ -495,6 +500,19 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
+	if (DEBUG_CONFIGURED) {
+		dentry = debugfs_create_file(hcd-&gt;self.bus_name,
+				S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,
+				uhci, &amp;uhci_debug_operations);
+		if (!dentry) {
+			dev_err(uhci_dev(uhci), "couldn't create uhci "
+					"debugfs entry\n");
+			retval = -ENOMEM;
+			goto err_create_debug_entry;
+		}
+		uhci-&gt;dentry = dentry;
+	}
+
 	uhci-&gt;frame = dma_alloc_coherent(uhci_dev(uhci),
 			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
 			&amp;uhci-&gt;frame_dma_handle, 0);
@@ -609,6 +627,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	mb();
 
 	configure_hc(uhci);
+	uhci-&gt;is_initialized = 1;
 	start_rh(uhci);
 	return 0;
 
@@ -872,16 +891,15 @@ static int __init uhci_hcd_init(void)
 	if (usb_disabled())
 		return -ENODEV;
 
-	if (debug) {
+	if (DEBUG_CONFIGURED) {
 		errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
 		if (!errbuf)
 			goto errbuf_failed;
+		uhci_debugfs_root = debugfs_create_dir("uhci", NULL);
+		if (!uhci_debugfs_root)
+			goto debug_failed;
 	}
 
-	uhci_debugfs_root = debugfs_create_dir("uhci", NULL);
-	if (!uhci_debugfs_root)
-		goto debug_failed;
-
 	uhci_up_cachep = kmem_cache_create("uhci_urb_priv",
 		sizeof(struct urb_priv), 0, 0, NULL, NULL);
 	if (!uhci_up_cachep)
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 7e96bef2e88f..4a69c7eb09bd 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -411,6 +411,7 @@ struct uhci_hcd {
 	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
 	unsigned int working_RD:1;		/* Suspended root hub doesn't
 						   need to be polled */
+	unsigned int is_initialized:1;		/* Data structure is usable */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 44bba9a6d196..5d6c4f75d0d8 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -736,7 +736,6 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 		if (errbuf) {
 			/* Print the chain for debugging purposes */
 			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-
 			lprintk(errbuf);
 		}
 	}
@@ -924,26 +923,17 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
 
 err:
-	/* 
-	 * Enable this chunk of code if you want to see some more debugging.
-	 * But be careful, it has the tendancy to starve out khubd and prevent
-	 * disconnects from happening successfully if you have a slow debug
-	 * log interface (like a serial console.
-	 */
-#if 0
 	if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
 		/* Some debugging code */
 		dev_dbg(uhci_dev(uhci), "%s: failed with status %x\n",
 				__FUNCTION__, status);
 
-		if (errbuf) {
+		if (debug &gt; 1 &amp;&amp; errbuf) {
 			/* Print the chain for debugging purposes */
 			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-
 			lprintk(errbuf);
 		}
 	}
-#endif
 
 	/* Note that the queue has stopped and save the next toggle value */
 	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;</pre><hr><pre>commit 0ed8fee1c1d38a62e981025ba40b5eba30c4ce2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Dec 17 18:02:38 2005 -0500

    [PATCH] UHCI: remove main list of URBs
    
    As part of reorienting uhci-hcd away from URBs and toward endpoint
    queues, this patch (as625) eliminates the driver's main list of URBs.
    The list wsa used mainly in checking for URB completions; now the driver
    goes through the list of active endpoints and checks the members of the
    queues.
    
    As a side effect, I had to remove the code that looks for FSBR timeouts.
    For now, FSBR will remain on so long as any URBs on a full-speed control
    or bulk queue request it, even if the queue isn't advancing.  A later
    patch can add more intelligent handling.  This isn't a huge drawback;
    it's pretty rare for an URB to get stuck for more than a fraction of a
    second.  (And it will help the people trying to use those insane HP USB
    devices.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 6814783adf91..f2f5f8ce1715 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -114,7 +114,6 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	}
 
 	out += sprintf(out, "%s", (urbp-&gt;fsbr ? " FSBR" : ""));
-	out += sprintf(out, "%s", (urbp-&gt;fsbr_timeout ? " FSBR_TO" : ""));
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 1ff4b8806372..9865f303d3fc 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -491,8 +491,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	spin_lock_init(&amp;uhci-&gt;lock);
 
 	INIT_LIST_HEAD(&amp;uhci-&gt;td_remove_list);
-	INIT_LIST_HEAD(&amp;uhci-&gt;urb_list);
-	INIT_LIST_HEAD(&amp;uhci-&gt;complete_list);
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index c057956667b5..7e96bef2e88f 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -132,6 +132,10 @@ struct uhci_qh {
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
+
+	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
+	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
+	unsigned int is_stopped:1;	/* Queue was stopped by an error */
 } __attribute__((aligned(16)));
 
 /*
@@ -384,6 +388,7 @@ struct uhci_hcd {
 
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
 	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QHs */
+	struct uhci_qh *next_qh;	/* Next QH to scan */
 
 	spinlock_t lock;
 
@@ -413,16 +418,10 @@ struct uhci_hcd {
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
-	/* Main list of URBs currently controlled by this HC */
-	struct list_head urb_list;
-
 	/* List of TDs that are done, but waiting to be freed (race) */
 	struct list_head td_remove_list;
 	unsigned int td_remove_age;		/* Age in frames */
 
-	/* List of URBs awaiting completion callback */
-	struct list_head complete_list;
-
 	struct list_head idle_qh_list;		/* Where the idle QHs live */
 
 	int rh_numports;			/* Number of root-hub ports */
@@ -448,7 +447,6 @@ static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
  *	Private per-URB data
  */
 struct urb_priv {
-	struct list_head urb_list;
 	struct list_head node;		/* Node in the QH's urbp list */
 
 	struct urb *urb;
@@ -456,10 +454,7 @@ struct urb_priv {
 	struct uhci_qh *qh;		/* QH for this URB */
 	struct list_head td_list;
 
-	unsigned long fsbrtime;		/* In jiffies */
-
 	unsigned fsbr : 1;		/* URB turned on FSBR */
-	unsigned fsbr_timeout : 1;	/* URB timed out on FSBR */
 	unsigned short_transfer : 1;	/* URB got a short transfer, no
 					 * need to rescan */
 };
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index c4194182dcc4..44bba9a6d196 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -151,53 +151,6 @@ static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
 	wmb();
 }
 
-/*
- * Remove an URB's TDs from the hardware schedule
- */
-static void uhci_remove_tds_from_schedule(struct uhci_hcd *uhci,
-		struct urb *urb, int status)
-{
-	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
-
-	/* Isochronous TDs get unlinked directly from the frame list */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
-		uhci_unlink_isochronous_tds(uhci, urb);
-		return;
-	}
-
-	/* If the URB isn't first on its queue, adjust the link pointer
-	 * of the last TD in the previous URB. */
-	if (urbp-&gt;node.prev != &amp;urbp-&gt;qh-&gt;queue) {
-		struct urb_priv *purbp;
-		struct uhci_td *ptd, *ltd;
-
-		if (status == -EINPROGRESS)
-			status = 0;
-		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
-		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ptd-&gt;link = ltd-&gt;link;
-	}
-
-	/* If the URB completed with an error, then the QH element certainly
-	 * points to one of the URB's TDs.  If it completed normally then
-	 * the QH element has certainly moved on to the next URB.  And if
-	 * the URB is still in progress then it must have been dequeued.
-	 * The QH element either hasn't reached it yet or is somewhere in
-	 * the middle.  If the URB wasn't first we can assume that it
-	 * hasn't started yet (see above): Otherwise all the preceding URBs
-	 * would have completed and been removed from the queue, so this one
-	 * _would_ be first.
-	 *
-	 * If the QH element is inside this URB, clear it.  It will be
-	 * set properly when the QH is activated.
-	 */
-	if (status &lt; 0)
-		urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
-}
-
 static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 		struct usb_device *udev, struct usb_host_endpoint *hep)
 {
@@ -250,6 +203,90 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
 
+/*
+ * When the currently executing URB is dequeued, save its current toggle value
+ */
+static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
+{
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
+	struct uhci_td *td;
+
+	/* If the QH element pointer is UHCI_PTR_TERM then then currently
+	 * executing URB has already been unlinked, so this one isn't it. */
+	if (qh_element(qh) == UHCI_PTR_TERM ||
+				qh-&gt;queue.next != &amp;urbp-&gt;node)
+		return;
+	qh-&gt;element = UHCI_PTR_TERM;
+
+	/* Only bulk and interrupt pipes have to worry about toggles */
+	if (!(usb_pipetype(urb-&gt;pipe) == PIPE_BULK ||
+			usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT))
+		return;
+
+	/* Find the first active TD; that's the device's toggle state */
+	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
+		if (td_status(td) &amp; TD_CTRL_ACTIVE) {
+			qh-&gt;needs_fixup = 1;
+			qh-&gt;initial_toggle = uhci_toggle(td_token(td));
+			return;
+		}
+	}
+
+	WARN_ON(1);
+}
+
+/*
+ * Fix up the data toggles for URBs in a queue, when one of them
+ * terminates early (short transfer, error, or dequeued).
+ */
+static void uhci_fixup_toggles(struct uhci_qh *qh, int skip_first)
+{
+	struct urb_priv *urbp = NULL;
+	struct uhci_td *td;
+	unsigned int toggle = qh-&gt;initial_toggle;
+	unsigned int pipe;
+
+	/* Fixups for a short transfer start with the second URB in the
+	 * queue (the short URB is the first). */
+	if (skip_first)
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+
+	/* When starting with the first URB, if the QH element pointer is
+	 * still valid then we know the URB's toggles are okay. */
+	else if (qh_element(qh) != UHCI_PTR_TERM)
+		toggle = 2;
+
+	/* Fix up the toggle for the URBs in the queue.  Normally this
+	 * loop won't run more than once: When an error or short transfer
+	 * occurs, the queue usually gets emptied. */
+	list_prepare_entry(urbp, &amp;qh-&gt;queue, node);
+	list_for_each_entry_continue(urbp, &amp;qh-&gt;queue, node) {
+
+		/* If the first TD has the right toggle value, we don't
+		 * need to change any toggles in this URB */
+		td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
+		if (toggle &gt; 1 || uhci_toggle(td_token(td)) == toggle) {
+			td = list_entry(urbp-&gt;td_list.next, struct uhci_td,
+					list);
+			toggle = uhci_toggle(td_token(td)) ^ 1;
+
+		/* Otherwise all the toggles in the URB have to be switched */
+		} else {
+			list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
+				td-&gt;token ^= __constant_cpu_to_le32(
+							TD_TOKEN_TOGGLE);
+				toggle ^= 1;
+			}
+		}
+	}
+
+	wmb();
+	pipe = list_entry(qh-&gt;queue.next, struct urb_priv, node)-&gt;urb-&gt;pipe;
+	usb_settoggle(qh-&gt;udev, usb_pipeendpoint(pipe),
+			usb_pipeout(pipe), toggle);
+	qh-&gt;needs_fixup = 0;
+}
+
 /*
  * Put a QH on the schedule in both hardware and software
  */
@@ -276,6 +313,9 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 
 	/* Move the QH from its old list to the end of the appropriate
 	 * skeleton's list */
+	if (qh == uhci-&gt;next_qh)
+		uhci-&gt;next_qh = list_entry(qh-&gt;node.next, struct uhci_qh,
+				node);
 	list_move_tail(&amp;qh-&gt;node, &amp;qh-&gt;skel-&gt;node);
 
 	/* Link it into the schedule */
@@ -310,6 +350,9 @@ static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		uhci_set_next_interrupt(uhci);
 
 	/* Move the QH from its old list to the end of the unlinking list */
+	if (qh == uhci-&gt;next_qh)
+		uhci-&gt;next_qh = list_entry(qh-&gt;node.next, struct uhci_qh,
+				node);
 	list_move_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skel_unlink_qh-&gt;node);
 }
 
@@ -323,6 +366,9 @@ static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	WARN_ON(qh-&gt;state == QH_STATE_ACTIVE);
 
+	if (qh == uhci-&gt;next_qh)
+		uhci-&gt;next_qh = list_entry(qh-&gt;node.next, struct uhci_qh,
+				node);
 	list_move(&amp;qh-&gt;node, &amp;uhci-&gt;idle_qh_list);
 	qh-&gt;state = QH_STATE_IDLE;
 
@@ -344,11 +390,9 @@ static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
 
 	urbp-&gt;urb = urb;
 	urb-&gt;hcpriv = urbp;
-	urbp-&gt;fsbrtime = jiffies;
 	
 	INIT_LIST_HEAD(&amp;urbp-&gt;node);
 	INIT_LIST_HEAD(&amp;urbp-&gt;td_list);
-	INIT_LIST_HEAD(&amp;urbp-&gt;urb_list);
 
 	return urbp;
 }
@@ -373,9 +417,6 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 {
 	struct uhci_td *td, *tmp;
 
-	if (!list_empty(&amp;urbp-&gt;urb_list))
-		dev_warn(uhci_dev(uhci), "urb %p still on uhci-&gt;urb_list!\n",
-				urbp-&gt;urb);
 	if (!list_empty(&amp;urbp-&gt;node))
 		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
 				urbp-&gt;urb);
@@ -452,71 +493,6 @@ static int uhci_map_status(int status, int dir_out)
 	return 0;
 }
 
-/*
- * Fix up the data toggles for URBs in a queue, when one of them
- * terminates early (short transfer, error, or dequeued).
- */
-static void uhci_fixup_toggles(struct urb *urb)
-{
-	struct list_head *head;
-	struct uhci_td *td;
-	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
-	int prevactive = 0;
-	unsigned int toggle = 0;
-	struct urb_priv *turbp, *list_end;
-
-	/*
-	 * We need to find out what the last successful toggle was so
-	 * we can update the data toggles for the following transfers.
-	 *
-	 * There are 2 ways the last successful completed TD is found:
-	 *
-	 * 1) The TD is NOT active and the actual length &lt; expected length
-	 * 2) The TD is NOT active and it's the last TD in the chain
-	 *
-	 * and a third way the first uncompleted TD is found:
-	 *
-	 * 3) The TD is active and the previous TD is NOT active
-	 */
-	head = &amp;urbp-&gt;td_list;
-	list_for_each_entry(td, head, list) {
-		unsigned int ctrlstat = td_status(td);
-
-		if (!(ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp;
-				(uhci_actual_length(ctrlstat) &lt;
-				 uhci_expected_length(td_token(td)) ||
-				td-&gt;list.next == head))
-			toggle = uhci_toggle(td_token(td)) ^ 1;
-		else if ((ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp; !prevactive)
-			toggle = uhci_toggle(td_token(td));
-
-		prevactive = ctrlstat &amp; TD_CTRL_ACTIVE;
-	}
-
-	/*
-	 * Fix up the toggle for the following URBs in the queue.
-	 *
-	 * We can stop as soon as we find an URB with toggles set correctly,
-	 * because then all the following URBs will be correct also.
-	 */
-	list_end = list_entry(&amp;urbp-&gt;qh-&gt;queue, struct urb_priv, node);
-	turbp = urbp;
-	while ((turbp = list_entry(turbp-&gt;node.next, struct urb_priv, node))
-			!= list_end) {
-		td = list_entry(turbp-&gt;td_list.next, struct uhci_td, list);
-		if (uhci_toggle(td_token(td)) == toggle)
-			return;
-
-		list_for_each_entry(td, &amp;turbp-&gt;td_list, list) {
-			td-&gt;token ^= __constant_cpu_to_le32(TD_TOKEN_TOGGLE);
-			toggle ^= 1;
-		}
-	}
-
-	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-			usb_pipeout(urb-&gt;pipe), toggle);
-}
-
 /*
  * Control transfers
  */
@@ -765,6 +741,9 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 		}
 	}
 
+	/* Note that the queue has stopped */
+	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
+	urbp-&gt;qh-&gt;is_stopped = 1;
 	return ret;
 }
 
@@ -927,7 +906,10 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 			 */
 			if (!urbp-&gt;short_transfer) {
 				urbp-&gt;short_transfer = 1;
-				uhci_fixup_toggles(urb);
+				urbp-&gt;qh-&gt;initial_toggle =
+						uhci_toggle(td_token(td)) ^ 1;
+				uhci_fixup_toggles(urbp-&gt;qh, 1);
+
 				td = list_entry(urbp-&gt;td_list.prev,
 						struct uhci_td, list);
 				urbp-&gt;qh-&gt;element = td-&gt;link;
@@ -962,6 +944,13 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 		}
 	}
 #endif
+
+	/* Note that the queue has stopped and save the next toggle value */
+	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
+	urbp-&gt;qh-&gt;is_stopped = 1;
+	urbp-&gt;qh-&gt;needs_fixup = 1;
+	urbp-&gt;qh-&gt;initial_toggle = uhci_toggle(td_token(td)) ^
+			(ret == -EREMOTEIO);
 	return ret;
 }
 
@@ -995,76 +984,39 @@ static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 /*
  * Isochronous transfers
  */
-static int isochronous_find_limits(struct uhci_hcd *uhci, struct urb *urb, unsigned int *start, unsigned int *end)
-{
-	struct urb *last_urb = NULL;
-	struct urb_priv *up;
-	int ret = 0;
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		/* look for pending URBs with identical pipe handle */
-		if ((urb-&gt;pipe == u-&gt;pipe) &amp;&amp; (urb-&gt;dev == u-&gt;dev) &amp;&amp;
-		    (u-&gt;status == -EINPROGRESS) &amp;&amp; (u != urb)) {
-			if (!last_urb)
-				*start = u-&gt;start_frame;
-			last_urb = u;
-		}
-	}
-
-	if (last_urb) {
-		*end = (last_urb-&gt;start_frame + last_urb-&gt;number_of_packets *
-				last_urb-&gt;interval) &amp; (UHCI_NUMFRAMES-1);
-		ret = 0;
-	} else
-		ret = -1;	/* no previous urb found */
-
-	return ret;
-}
-
-static int isochronous_find_start(struct uhci_hcd *uhci, struct urb *urb)
+static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
-	int limits;
-	unsigned int start = 0, end = 0;
+	struct uhci_td *td = NULL;	/* Since urb-&gt;number_of_packets &gt; 0 */
+	int i, frame;
+	unsigned long destination, status;
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	if (urb-&gt;number_of_packets &gt; 900)	/* 900? Why? */
 		return -EFBIG;
 
-	limits = isochronous_find_limits(uhci, urb, &amp;start, &amp;end);
+	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
+	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
 
+	/* Figure out the starting frame number */
 	if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
-		if (limits) {
+		if (list_empty(&amp;qh-&gt;queue)) {
 			uhci_get_current_frame_number(uhci);
-			urb-&gt;start_frame = (uhci-&gt;frame_number + 10)
-					&amp; (UHCI_NUMFRAMES - 1);
-		} else
-			urb-&gt;start_frame = end;
+			urb-&gt;start_frame = (uhci-&gt;frame_number + 10);
+
+		} else {		/* Go right after the last one */
+			struct urb *last_urb;
+
+			last_urb = list_entry(qh-&gt;queue.prev,
+					struct urb_priv, node)-&gt;urb;
+			urb-&gt;start_frame = (last_urb-&gt;start_frame +
+					last_urb-&gt;number_of_packets *
+					last_urb-&gt;interval);
+		}
 	} else {
-		urb-&gt;start_frame &amp;= (UHCI_NUMFRAMES - 1);
 		/* FIXME: Sanity check */
 	}
-
-	return 0;
-}
-
-/*
- * Isochronous transfers
- */
-static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
-		struct uhci_qh *qh)
-{
-	struct uhci_td *td = NULL;	/* Since urb-&gt;number_of_packets &gt; 0 */
-	int i, ret, frame;
-	unsigned long destination, status;
-	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
-
-	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
-	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
-
-	ret = isochronous_find_start(uhci, urb);
-	if (ret)
-		return ret;
+	urb-&gt;start_frame &amp;= (UHCI_NUMFRAMES - 1);
 
 	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
@@ -1203,7 +1155,6 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	/* Add this URB to the QH */
 	urbp-&gt;qh = qh;
 	list_add_tail(&amp;urbp-&gt;node, &amp;qh-&gt;queue);
-	list_add_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;urb_list);
 
 	/* If the new URB is the first and only one on this QH then either
 	 * the QH is new and idle or else it's unlinked and waiting to
@@ -1224,49 +1175,66 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	return ret;
 }
 
+static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long flags;
+	struct urb_priv *urbp;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	urbp = urb-&gt;hcpriv;
+	if (!urbp)			/* URB was never linked! */
+		goto done;
+
+	/* Remove Isochronous TDs from the frame list ASAP */
+	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+		uhci_unlink_isochronous_tds(uhci, urb);
+	uhci_unlink_qh(uhci, urbp-&gt;qh);
+
+done:
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	return 0;
+}
+
 /*
- * Return the result of a transfer
+ * Finish unlinking an URB and give it back
  */
-static void uhci_transfer_result(struct uhci_hcd *uhci, struct urb *urb)
+static void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,
+		struct urb *urb, struct pt_regs *regs)
+__releases(uhci-&gt;lock)
+__acquires(uhci-&gt;lock)
 {
-	int status;
-	int okay_to_giveback = 0;
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_CONTROL:
-		status = uhci_result_control(uhci, urb);
-		break;
-	case PIPE_ISOCHRONOUS:
-		status = uhci_result_isochronous(uhci, urb);
-		break;
-	default:	/* PIPE_BULK or PIPE_INTERRUPT */
-		status = uhci_result_common(uhci, urb);
-		break;
-	}
+	/* Isochronous TDs get unlinked directly from the frame list */
+	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+		uhci_unlink_isochronous_tds(uhci, urb);
 
-	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status == -EINPROGRESS) {	/* Not yet dequeued */
-		if (status != -EINPROGRESS) {	/* URB has completed */
-			urb-&gt;status = status;
+	/* If the URB isn't first on its queue, adjust the link pointer
+	 * of the last TD in the previous URB. */
+	else if (qh-&gt;queue.next != &amp;urbp-&gt;node) {
+		struct urb_priv *purbp;
+		struct uhci_td *ptd, *ltd;
 
-			/* If the URB got a real error (as opposed to
-			 * simply being dequeued), we don't have to
-			 * unlink the QH.  Fix this later... */
-			if (status &lt; 0)
-				uhci_unlink_qh(uhci, urbp-&gt;qh);
-			else
-				okay_to_giveback = 1;
-		}
-	} else {				/* Already dequeued */
-		if (urbp-&gt;qh-&gt;state == QH_STATE_UNLINKING &amp;&amp;
-				uhci-&gt;frame_number + uhci-&gt;is_stopped !=
-				urbp-&gt;qh-&gt;unlink_frame)
-			okay_to_giveback = 1;
+		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ptd-&gt;link = ltd-&gt;link;
 	}
-	spin_unlock(&amp;urb-&gt;lock);
-	if (!okay_to_giveback)
-		return;
+
+	/* Take the URB off the QH's queue.  If the queue is now empty,
+	 * this is a perfect time for a toggle fixup. */
+	list_del_init(&amp;urbp-&gt;node);
+	if (list_empty(&amp;qh-&gt;queue) &amp;&amp; qh-&gt;needs_fixup) {
+		usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
+				usb_pipeout(urb-&gt;pipe), qh-&gt;initial_toggle);
+		qh-&gt;needs_fixup = 0;
+	}
+
+	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
+	uhci_free_urb_priv(uhci, urbp);
 
 	switch (usb_pipetype(urb-&gt;pipe)) {
 	case PIPE_ISOCHRONOUS:
@@ -1277,122 +1245,107 @@ static void uhci_transfer_result(struct uhci_hcd *uhci, struct urb *urb)
 	case PIPE_INTERRUPT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
-		if (list_empty(&amp;urbp-&gt;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
+		if (list_empty(&amp;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
 			usb_release_bandwidth(urb-&gt;dev, urb, 0);
 		else
 			/* bandwidth was passed on to queued URB, */
 			/* so don't let usb_unlink_urb() release it */
 			urb-&gt;bandwidth = 0;
-		/* Falls through */
-	case PIPE_BULK:
-		if (status &lt; 0)
-			uhci_fixup_toggles(urb);
-		break;
-	default:	/* PIPE_CONTROL */
 		break;
 	}
 
-	/* Take the URB's TDs off the hardware schedule */
-	uhci_remove_tds_from_schedule(uhci, urb, status);
-
-	/* Take the URB off the QH's queue and see if the QH is now unused */
-	list_del_init(&amp;urbp-&gt;node);
-	if (list_empty(&amp;urbp-&gt;qh-&gt;queue))
-		uhci_unlink_qh(uhci, urbp-&gt;qh);
+	spin_unlock(&amp;uhci-&gt;lock);
+	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, regs);
+	spin_lock(&amp;uhci-&gt;lock);
 
-	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
+	/* If the queue is now empty, we can unlink the QH and give up its
+	 * reserved bandwidth. */
+	if (list_empty(&amp;qh-&gt;queue)) {
+		uhci_unlink_qh(uhci, qh);
 
-	/* Queue it for giving back */
-	list_move_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;complete_list);
+		/* Bandwidth stuff not yet implemented */
+	}
 }
 
 /*
- * Check out the QHs waiting to be fully unlinked
+ * Scan the URBs in a QH's queue
  */
-static void uhci_scan_unlinking_qhs(struct uhci_hcd *uhci)
-{
-	struct uhci_qh *qh, *tmp;
+#define QH_FINISHED_UNLINKING(qh)			\
+		(qh-&gt;state == QH_STATE_UNLINKING &amp;&amp;	\
+		uhci-&gt;frame_number + uhci-&gt;is_stopped != qh-&gt;unlink_frame)
 
-	list_for_each_entry_safe(qh, tmp, &amp;uhci-&gt;skel_unlink_qh-&gt;node, node) {
-
-		/* If the queue is empty and the QH is fully unlinked then
-		 * it can become IDLE. */
-		if (list_empty(&amp;qh-&gt;queue)) {
-			if (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
-					qh-&gt;unlink_frame)
-				uhci_make_qh_idle(uhci, qh);
-
-		/* If none of the QH's URBs have been dequeued then the QH
-		 * should be re-activated. */
-		} else {
-			struct urb_priv *urbp;
-			int any_dequeued = 0;
-
-			list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
-				if (urbp-&gt;urb-&gt;status != -EINPROGRESS) {
-					any_dequeued = 1;
-					break;
-				}
-			}
-			if (!any_dequeued)
-				uhci_activate_qh(uhci, qh);
-		}
-	}
-}
-
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
+		struct pt_regs *regs)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
 	struct urb_priv *urbp;
+	struct urb *urb;
+	int status;
 
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	urbp = urb-&gt;hcpriv;
-	if (!urbp)			/* URB was never linked! */
-		goto done;
+	while (!list_empty(&amp;qh-&gt;queue)) {
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+		urb = urbp-&gt;urb;
 
-	/* Remove Isochronous TDs from the frame list ASAP */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
-		uhci_unlink_isochronous_tds(uhci, urb);
-	uhci_unlink_qh(uhci, urbp-&gt;qh);
+		switch (usb_pipetype(urb-&gt;pipe)) {
+		case PIPE_CONTROL:
+			status = uhci_result_control(uhci, urb);
+			break;
+		case PIPE_ISOCHRONOUS:
+			status = uhci_result_isochronous(uhci, urb);
+			break;
+		default:	/* PIPE_BULK or PIPE_INTERRUPT */
+			status = uhci_result_common(uhci, urb);
+			break;
+		}
+		if (status == -EINPROGRESS)
+			break;
 
-done:
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-	return 0;
-}
+		spin_lock(&amp;urb-&gt;lock);
+		if (urb-&gt;status == -EINPROGRESS)	/* Not dequeued */
+			urb-&gt;status = status;
+		else
+			status = -ECONNRESET;
+		spin_unlock(&amp;urb-&gt;lock);
 
-static int uhci_fsbr_timeout(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct list_head *head;
-	struct uhci_td *td;
-	int count = 0;
+		/* Dequeued but completed URBs can't be given back unless
+		 * the QH is stopped or has finished unlinking. */
+		if (status == -ECONNRESET &amp;&amp;
+				!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
+			return;
 
-	uhci_dec_fsbr(uhci, urb);
+		uhci_giveback_urb(uhci, qh, urb, regs);
+		if (qh-&gt;is_stopped)
+			break;
+	}
 
-	urbp-&gt;fsbr_timeout = 1;
+	/* If the QH is neither stopped nor finished unlinking (normal case),
+	 * our work here is done. */
+ restart:
+	if (!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
+		return;
 
-	/*
-	 * Ideally we would want to fix qh-&gt;element as well, but it's
-	 * read/write by the HC, so that can introduce a race. It's not
-	 * really worth the hassle
-	 */
+	/* Otherwise give back each of the dequeued URBs */
+	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
+		urb = urbp-&gt;urb;
+		if (urb-&gt;status != -EINPROGRESS) {
+			uhci_save_toggle(qh, urb);
+			uhci_giveback_urb(uhci, qh, urb, regs);
+			goto restart;
+		}
+	}
+	qh-&gt;is_stopped = 0;
 
-	head = &amp;urbp-&gt;td_list;
-	list_for_each_entry(td, head, list) {
-		/*
-		 * Make sure we don't do the last one (since it'll have the
-		 * TERM bit set) as well as we skip every so many TDs to
-		 * make sure it doesn't hog the bandwidth
-		 */
-		if (td-&gt;list.next != head &amp;&amp; (count % DEPTH_INTERVAL) ==
-				(DEPTH_INTERVAL - 1))
-			td-&gt;link |= UHCI_PTR_DEPTH;
-
-		count++;
+	/* There are no more dequeued URBs.  If there are still URBs on the
+	 * queue, the QH can now be re-activated. */
+	if (!list_empty(&amp;qh-&gt;queue)) {
+		if (qh-&gt;needs_fixup)
+			uhci_fixup_toggles(qh, 0);
+		uhci_activate_qh(uhci, qh);
 	}
 
-	return 0;
+	/* The queue is empty.  The QH can become idle if it is fully
+	 * unlinked. */
+	else if (QH_FINISHED_UNLINKING(qh))
+		uhci_make_qh_idle(uhci, qh);
 }
 
 static void uhci_free_pending_tds(struct uhci_hcd *uhci)
@@ -1406,36 +1359,13 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci)
 	}
 }
 
-static void
-uhci_finish_urb(struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs)
-__releases(uhci-&gt;lock)
-__acquires(uhci-&gt;lock)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	uhci_free_urb_priv(uhci, (struct urb_priv *) (urb-&gt;hcpriv));
-
-	spin_unlock(&amp;uhci-&gt;lock);
-	usb_hcd_giveback_urb(hcd, urb, regs);
-	spin_lock(&amp;uhci-&gt;lock);
-}
-
-static void uhci_finish_completion(struct uhci_hcd *uhci, struct pt_regs *regs)
-{
-	struct urb_priv *urbp, *tmp;
-
-	list_for_each_entry_safe(urbp, tmp, &amp;uhci-&gt;complete_list, urb_list) {
-		struct urb *urb = urbp-&gt;urb;
-
-		list_del_init(&amp;urbp-&gt;urb_list);
-		uhci_finish_urb(uhci_to_hcd(uhci), urb, regs);
-	}
-}
-
-/* Process events in the schedule, but only in one thread at a time */
+/*
+ * Process events in the schedule, but only in one thread at a time
+ */
 static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 {
-	struct urb_priv *urbp, *tmp;
+	int i;
+	struct uhci_qh *qh;
 
 	/* Don't allow re-entrant calls */
 	if (uhci-&gt;scan_in_progress) {
@@ -1452,26 +1382,24 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age)
 		uhci_free_pending_tds(uhci);
 
-	/* Walk the list of pending URBs to see which ones completed
-	 * (must be _safe because uhci_transfer_result() dequeues URBs) */
-	list_for_each_entry_safe(urbp, tmp, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *urb = urbp-&gt;urb;
-
-		/* Checks the status and does all of the magic necessary */
-		uhci_transfer_result(uhci, urb);
+	/* Go through all the QH queues and process the URBs in each one */
+	for (i = 0; i &lt; UHCI_NUM_SKELQH - 1; ++i) {
+		uhci-&gt;next_qh = list_entry(uhci-&gt;skelqh[i]-&gt;node.next,
+				struct uhci_qh, node);
+		while ((qh = uhci-&gt;next_qh) != uhci-&gt;skelqh[i]) {
+			uhci-&gt;next_qh = list_entry(qh-&gt;node.next,
+					struct uhci_qh, node);
+			uhci_scan_qh(uhci, qh, regs);
+		}
 	}
-	uhci_finish_completion(uhci, regs);
-
-	/* If the controller is stopped, we can finish these off right now */
-	if (uhci-&gt;is_stopped)
-		uhci_free_pending_tds(uhci);
 
 	if (uhci-&gt;need_rescan)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	/* Check out the QHs waiting for unlinking */
-	uhci_scan_unlinking_qhs(uhci);
+	/* If the controller is stopped, we can finish these off right now */
+	if (uhci-&gt;is_stopped)
+		uhci_free_pending_tds(uhci);
 
 	if (list_empty(&amp;uhci-&gt;td_remove_list) &amp;&amp;
 			list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
@@ -1482,19 +1410,8 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 
 static void check_fsbr(struct uhci_hcd *uhci)
 {
-	struct urb_priv *up;
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		spin_lock(&amp;u-&gt;lock);
-
-		/* Check if the FSBR timed out */
-		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
-			uhci_fsbr_timeout(uhci, u);
-
-		spin_unlock(&amp;u-&gt;lock);
-	}
+	/* For now, don't scan URBs for FSBR timeouts.
+	 * Add it back in later... */
 
 	/* Really disable FSBR */
 	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {</pre><hr><pre>commit af0bb5998abe8ed28ee354dd4c71689cacdc91e9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Dec 17 18:00:12 2005 -0500

    [PATCH] UHCI: use dummy TDs
    
    This patch (as624) fixes a hardware race in uhci-hcd by adding a dummy
    TD to the end of each endpoint's queue.  Without the dummy the host
    controller will effectively turn off the queue when it reaches the end,
    which happens asynchronously.  This leads to a potential problem when
    new transfer descriptors are added to the end of the queue; they may
    never get used.
    
    With a dummy TD present the controller never turns off the queue;
    instead it just stops at the dummy and leaves the queue on but inactive.
    When new TDs are added to the end of the queue, the first new one gets
    written over the dummy.  Thus there's never any question about whether
    the queue is running or needs to be restarted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 3faccbd68547..6814783adf91 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -189,6 +189,11 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 					space, "", nurbs);
 	}
 
+	if (qh-&gt;udev) {
+		out += sprintf(out, "%*s  Dummy TD\n", space, "");
+		out += uhci_show_td(qh-&gt;dummy_td, out, len - (out - buf), 0);
+	}
+
 	return out - buf;
 }
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 7a9481c09a05..c057956667b5 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -128,6 +128,7 @@ struct uhci_qh {
 	struct usb_device *udev;
 	struct list_head queue;		/* Queue of urbps for this QH */
 	struct uhci_qh *skel;		/* Skeleton for this QH */
+	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index b1b551a3d14e..c4194182dcc4 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -48,10 +48,6 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 		return NULL;
 
 	td-&gt;dma_handle = dma_handle;
-
-	td-&gt;link = UHCI_PTR_TERM;
-	td-&gt;buffer = 0;
-
 	td-&gt;frame = -1;
 
 	INIT_LIST_HEAD(&amp;td-&gt;list);
@@ -221,6 +217,11 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 	INIT_LIST_HEAD(&amp;qh-&gt;node);
 
 	if (udev) {		/* Normal QH */
+		qh-&gt;dummy_td = uhci_alloc_td(uhci);
+		if (!qh-&gt;dummy_td) {
+			dma_pool_free(uhci-&gt;qh_pool, qh, dma_handle);
+			return NULL;
+		}
 		qh-&gt;state = QH_STATE_IDLE;
 		qh-&gt;hep = hep;
 		qh-&gt;udev = udev;
@@ -244,6 +245,7 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	if (qh-&gt;udev) {
 		qh-&gt;hep-&gt;hcpriv = NULL;
 		usb_put_dev(qh-&gt;udev);
+		uhci_free_td(uhci, qh-&gt;dummy_td);
 	}
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
@@ -531,22 +533,20 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
 
-	/* 3 errors */
-	status = TD_CTRL_ACTIVE | uhci_maxerr(3);
+	/* 3 errors, dummy TD remains inactive */
+	status = uhci_maxerr(3);
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		status |= TD_CTRL_LS;
 
 	/*
 	 * Build the TD for the control request setup packet
 	 */
-	td = uhci_alloc_td(uhci);
-	if (!td)
-		return -ENOMEM;
-
+	td = qh-&gt;dummy_td;
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status, destination | uhci_explen(8),
 			urb-&gt;setup_dma);
 	plink = &amp;td-&gt;link;
+	status |= TD_CTRL_ACTIVE;
 
 	/*
 	 * If direction is "send", change the packet ID from SETUP (0x2D)
@@ -568,7 +568,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 
 		td = uhci_alloc_td(uhci);
 		if (!td)
-			return -ENOMEM;
+			goto nomem;
 		*plink = cpu_to_le32(td-&gt;dma_handle);
 
 		/* Alternate Data0/1 (start with Data1) */
@@ -588,7 +588,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 */
 	td = uhci_alloc_td(uhci);
 	if (!td)
-		return -ENOMEM;
+		goto nomem;
 	*plink = cpu_to_le32(td-&gt;dma_handle);
 
 	/*
@@ -608,6 +608,20 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 			destination | uhci_explen(0), 0);
+	plink = &amp;td-&gt;link;
+
+	/*
+	 * Build the new dummy TD and activate the old one
+	 */
+	td = uhci_alloc_td(uhci);
+	if (!td)
+		goto nomem;
+	*plink = cpu_to_le32(td-&gt;dma_handle);
+
+	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
+	wmb();
+	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
+	qh-&gt;dummy_td = td;
 
 	/* Low-speed transfers get a different queue, and won't hog the bus.
 	 * Also, some devices enumerate better without FSBR; the easiest way
@@ -620,8 +634,12 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
 		uhci_inc_fsbr(uhci, urb);
 	}
-
 	return 0;
+
+nomem:
+	/* Remove the dummy TD from the td_list so it doesn't get freed */
+	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	return -ENOMEM;
 }
 
 /*
@@ -761,16 +779,19 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	int maxsze = le16_to_cpu(qh-&gt;hep-&gt;desc.wMaxPacketSize);
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
-	__le32 *plink, fake_link;
+	__le32 *plink;
+	unsigned int toggle;
 
 	if (len &lt; 0)
 		return -EINVAL;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
+	toggle = usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
+			 usb_pipeout(urb-&gt;pipe));
 
-	/* 3 errors */
-	status = TD_CTRL_ACTIVE | uhci_maxerr(3);
+	/* 3 errors, dummy TD remains inactive */
+	status = uhci_maxerr(3);
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		status |= TD_CTRL_LS;
 	if (usb_pipein(urb-&gt;pipe))
@@ -779,7 +800,8 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	/*
 	 * Build the DATA TDs
 	 */
-	plink = &amp;fake_link;
+	plink = NULL;
+	td = qh-&gt;dummy_td;
 	do {	/* Allow zero length packets */
 		int pktsze = maxsze;
 
@@ -789,24 +811,23 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 				status &amp;= ~TD_CTRL_SPD;
 		}
 
-		td = uhci_alloc_td(uhci);
-		if (!td)
-			return -ENOMEM;
-		*plink = cpu_to_le32(td-&gt;dma_handle);
-
+		if (plink) {
+			td = uhci_alloc_td(uhci);
+			if (!td)
+				goto nomem;
+			*plink = cpu_to_le32(td-&gt;dma_handle);
+		}
 		uhci_add_td_to_urb(urb, td);
 		uhci_fill_td(td, status,
-			destination | uhci_explen(pktsze) |
-			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
-			data);
+				destination | uhci_explen(pktsze) |
+					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
+				data);
 		plink = &amp;td-&gt;link;
+		status |= TD_CTRL_ACTIVE;
 
 		data += pktsze;
 		len -= maxsze;
-
-		usb_dotoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-			usb_pipeout(urb-&gt;pipe));
+		toggle ^= 1;
 	} while (len &gt; 0);
 
 	/*
@@ -821,17 +842,17 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 			urb-&gt;transfer_buffer_length &gt; 0) {
 		td = uhci_alloc_td(uhci);
 		if (!td)
-			return -ENOMEM;
+			goto nomem;
 		*plink = cpu_to_le32(td-&gt;dma_handle);
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(0) |
-			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
-			data);
+		uhci_fill_td(td, status,
+				destination | uhci_explen(0) |
+					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
+				data);
+		plink = &amp;td-&gt;link;
 
-		usb_dotoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-			usb_pipeout(urb-&gt;pipe));
+		toggle ^= 1;
 	}
 
 	/* Set the interrupt-on-completion flag on the last packet.
@@ -842,7 +863,27 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	 * flag setting. */
 	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
+	/*
+	 * Build the new dummy TD and activate the old one
+	 */
+	td = uhci_alloc_td(uhci);
+	if (!td)
+		goto nomem;
+	*plink = cpu_to_le32(td-&gt;dma_handle);
+
+	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
+	wmb();
+	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
+	qh-&gt;dummy_td = td;
+
+	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
+			usb_pipeout(urb-&gt;pipe), toggle);
 	return 0;
+
+nomem:
+	/* Remove the dummy TD from the td_list so it doesn't get freed */
+	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	return -ENOMEM;
 }
 
 /*
@@ -1169,31 +1210,6 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	 * become idle, so we can activate it right away. */
 	if (qh-&gt;queue.next == &amp;urbp-&gt;node)
 		uhci_activate_qh(uhci, qh);
-
-	/* If the QH is already active, we have a race with the hardware.
-	 * This won't get fixed until dummy TDs are added. */
-	else if (qh-&gt;state == QH_STATE_ACTIVE) {
-
-		/* If the URB isn't first on its queue, adjust the link pointer
-		 * of the last TD in the previous URB. */
-		if (urbp-&gt;node.prev != &amp;urbp-&gt;qh-&gt;queue) {
-			struct urb_priv *purbp = list_entry(urbp-&gt;node.prev,
-					struct urb_priv, node);
-			struct uhci_td *ptd = list_entry(purbp-&gt;td_list.prev,
-					struct uhci_td, list);
-			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
-					struct uhci_td, list);
-
-			ptd-&gt;link = cpu_to_le32(td-&gt;dma_handle);
-
-		}
-		if (qh_element(qh) == UHCI_PTR_TERM) {
-			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
-					struct uhci_td, list);
-
-			qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
-		}
-	}
 	goto done;
 
 err_submit_failed:</pre><hr><pre>commit dccf4a48d47120a42382ba526f1a0848c13ba2a4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Dec 17 17:58:46 2005 -0500

    [PATCH] UHCI: use one QH per endpoint, not per URB
    
    This patch (as623) changes the uhci-hcd driver to make it use one QH per
    device endpoint, instead of a QH per URB as it does now.  Numerous areas
    of the code are affected by this.  For example, the distinction between
    "queued" URBs and non-"queued" URBs no longer exists; all URBs belong to
    a queue and some just happen to be at the queue's head.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 5832953086f8..3faccbd68547 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -90,13 +90,60 @@ static int uhci_show_td(struct uhci_td *td, char *buf, int len, int space)
 	return out - buf;
 }
 
-static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
+static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 {
 	char *out = buf;
-	struct urb_priv *urbp;
-	struct list_head *head, *tmp;
 	struct uhci_td *td;
-	int i = 0, checked = 0, prevactive = 0;
+	int i, nactive, ninactive;
+
+	if (len &lt; 200)
+		return 0;
+
+	out += sprintf(out, "urb_priv [%p] ", urbp);
+	out += sprintf(out, "urb [%p] ", urbp-&gt;urb);
+	out += sprintf(out, "qh [%p] ", urbp-&gt;qh);
+	out += sprintf(out, "Dev=%d ", usb_pipedevice(urbp-&gt;urb-&gt;pipe));
+	out += sprintf(out, "EP=%x(%s) ", usb_pipeendpoint(urbp-&gt;urb-&gt;pipe),
+			(usb_pipein(urbp-&gt;urb-&gt;pipe) ? "IN" : "OUT"));
+
+	switch (usb_pipetype(urbp-&gt;urb-&gt;pipe)) {
+	case PIPE_ISOCHRONOUS: out += sprintf(out, "ISO"); break;
+	case PIPE_INTERRUPT: out += sprintf(out, "INT"); break;
+	case PIPE_BULK: out += sprintf(out, "BLK"); break;
+	case PIPE_CONTROL: out += sprintf(out, "CTL"); break;
+	}
+
+	out += sprintf(out, "%s", (urbp-&gt;fsbr ? " FSBR" : ""));
+	out += sprintf(out, "%s", (urbp-&gt;fsbr_timeout ? " FSBR_TO" : ""));
+
+	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
+		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
+	out += sprintf(out, "\n");
+
+	i = nactive = ninactive = 0;
+	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
+		if (++i &lt;= 10 || debug &gt; 2) {
+			out += sprintf(out, "%*s%d: ", space + 2, "", i);
+			out += uhci_show_td(td, out, len - (out - buf), 0);
+		} else {
+			if (td_status(td) &amp; TD_CTRL_ACTIVE)
+				++nactive;
+			else
+				++ninactive;
+		}
+	}
+	if (nactive + ninactive &gt; 0)
+		out += sprintf(out, "%*s[skipped %d inactive and %d active "
+				"TDs]\n",
+				space, "", ninactive, nactive);
+
+	return out - buf;
+}
+
+static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
+{
+	char *out = buf;
+	int i, nurbs;
 	__le32 element = qh_element(qh);
 
 	/* Try to make sure there's enough memory */
@@ -118,86 +165,36 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	if (!(element &amp; ~(UHCI_PTR_QH | UHCI_PTR_DEPTH)))
 		out += sprintf(out, "%*s  Element is NULL (bug?)\n", space, "");
 
-	if (!qh-&gt;urbp) {
-		out += sprintf(out, "%*s  urbp == NULL\n", space, "");
-		goto out;
-	}
-
-	urbp = qh-&gt;urbp;
-
-	head = &amp;urbp-&gt;td_list;
-	tmp = head-&gt;next;
-
-	td = list_entry(tmp, struct uhci_td, list);
-
-	if (cpu_to_le32(td-&gt;dma_handle) != (element &amp; ~UHCI_PTR_BITS))
-		out += sprintf(out, "%*s Element != First TD\n", space, "");
-
-	while (tmp != head) {
-		struct uhci_td *td = list_entry(tmp, struct uhci_td, list);
-
-		tmp = tmp-&gt;next;
-
-		out += sprintf(out, "%*s%d: ", space + 2, "", i++);
-		out += uhci_show_td(td, out, len - (out - buf), 0);
-
-		if (i &gt; 10 &amp;&amp; !checked &amp;&amp; prevactive &amp;&amp; tmp != head &amp;&amp;
-		    debug &lt;= 2) {
-			struct list_head *ntmp = tmp;
-			struct uhci_td *ntd = td;
-			int active = 1, ni = i;
-
-			checked = 1;
-
-			while (ntmp != head &amp;&amp; ntmp-&gt;next != head &amp;&amp; active) {
-				ntd = list_entry(ntmp, struct uhci_td, list);
-
-				ntmp = ntmp-&gt;next;
-
-				active = td_status(ntd) &amp; TD_CTRL_ACTIVE;
-
-				ni++;
-			}
-
-			if (active &amp;&amp; ni &gt; i) {
-				out += sprintf(out, "%*s[skipped %d active TDs]\n", space, "", ni - i);
-				tmp = ntmp;
-				td = ntd;
-				i = ni;
-			}
+	if (list_empty(&amp;qh-&gt;queue)) {
+		out += sprintf(out, "%*s  queue is empty\n", space, "");
+	} else {
+		struct urb_priv *urbp = list_entry(qh-&gt;queue.next,
+				struct urb_priv, node);
+		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+				struct uhci_td, list);
+
+		if (cpu_to_le32(td-&gt;dma_handle) != (element &amp; ~UHCI_PTR_BITS))
+			out += sprintf(out, "%*s Element != First TD\n",
+					space, "");
+		i = nurbs = 0;
+		list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
+			if (++i &lt;= 10)
+				out += uhci_show_urbp(urbp, out,
+						len - (out - buf), space + 2);
+			else
+				++nurbs;
 		}
-
-		prevactive = td_status(td) &amp; TD_CTRL_ACTIVE;
-	}
-
-	if (list_empty(&amp;urbp-&gt;queue_list) || urbp-&gt;queued)
-		goto out;
-
-	out += sprintf(out, "%*sQueued QHs:\n", -space, "--");
-
-	head = &amp;urbp-&gt;queue_list;
-	tmp = head-&gt;next;
-
-	while (tmp != head) {
-		struct urb_priv *nurbp = list_entry(tmp, struct urb_priv,
-						queue_list);
-		tmp = tmp-&gt;next;
-
-		out += uhci_show_qh(nurbp-&gt;qh, out, len - (out - buf), space);
+		if (nurbs &gt; 0)
+			out += sprintf(out, "%*s Skipped %d URBs\n",
+					space, "", nurbs);
 	}
 
-out:
 	return out - buf;
 }
 
-#define show_frame_num()	\
-	if (!shown) {		\
-	  shown = 1;		\
-	  out += sprintf(out, "- Frame %d\n", i); \
-	}
-
 #ifdef CONFIG_PROC_FS
 static const char * const qh_names[] = {
+  "skel_unlink_qh", "skel_iso_qh",
   "skel_int128_qh", "skel_int64_qh",
   "skel_int32_qh", "skel_int16_qh",
   "skel_int8_qh", "skel_int4_qh",
@@ -206,12 +203,6 @@ static const char * const qh_names[] = {
   "skel_bulk_qh", "skel_term_qh"
 };
 
-#define show_qh_name()		\
-	if (!shown) {		\
-	  shown = 1;		\
-	  out += sprintf(out, "- %s\n", qh_names[i]); \
-	}
-
 static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
 {
 	char *out = buf;
@@ -321,139 +312,29 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	return out - buf;
 }
 
-static int uhci_show_urbp(struct uhci_hcd *uhci, struct urb_priv *urbp, char *buf, int len)
-{
-	struct list_head *tmp;
-	char *out = buf;
-	int count = 0;
-
-	if (len &lt; 200)
-		return 0;
-
-	out += sprintf(out, "urb_priv [%p] ", urbp);
-	out += sprintf(out, "urb [%p] ", urbp-&gt;urb);
-	out += sprintf(out, "qh [%p] ", urbp-&gt;qh);
-	out += sprintf(out, "Dev=%d ", usb_pipedevice(urbp-&gt;urb-&gt;pipe));
-	out += sprintf(out, "EP=%x(%s) ", usb_pipeendpoint(urbp-&gt;urb-&gt;pipe), (usb_pipein(urbp-&gt;urb-&gt;pipe) ? "IN" : "OUT"));
-
-	switch (usb_pipetype(urbp-&gt;urb-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS: out += sprintf(out, "ISO "); break;
-	case PIPE_INTERRUPT: out += sprintf(out, "INT "); break;
-	case PIPE_BULK: out += sprintf(out, "BLK "); break;
-	case PIPE_CONTROL: out += sprintf(out, "CTL "); break;
-	}
-
-	out += sprintf(out, "%s", (urbp-&gt;fsbr ? "FSBR " : ""));
-	out += sprintf(out, "%s", (urbp-&gt;fsbr_timeout ? "FSBR_TO " : ""));
-
-	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
-		out += sprintf(out, "Status=%d ", urbp-&gt;urb-&gt;status);
-	//out += sprintf(out, "FSBRtime=%lx ",urbp-&gt;fsbrtime);
-
-	count = 0;
-	list_for_each(tmp, &amp;urbp-&gt;td_list)
-		count++;
-	out += sprintf(out, "TDs=%d ",count);
-
-	if (urbp-&gt;queued)
-		out += sprintf(out, "queued\n");
-	else {
-		count = 0;
-		list_for_each(tmp, &amp;urbp-&gt;queue_list)
-			count++;
-		out += sprintf(out, "queued URBs=%d\n", count);
-	}
-
-	return out - buf;
-}
-
-static int uhci_show_lists(struct uhci_hcd *uhci, char *buf, int len)
-{
-	char *out = buf;
-	struct list_head *head, *tmp;
-	int count;
-
-	out += sprintf(out, "Main list URBs:");
-	if (list_empty(&amp;uhci-&gt;urb_list))
-		out += sprintf(out, " Empty\n");
-	else {
-		out += sprintf(out, "\n");
-		count = 0;
-		head = &amp;uhci-&gt;urb_list;
-		tmp = head-&gt;next;
-		while (tmp != head) {
-			struct urb_priv *urbp = list_entry(tmp, struct urb_priv, urb_list);
-
-			out += sprintf(out, "  %d: ", ++count);
-			out += uhci_show_urbp(uhci, urbp, out, len - (out - buf));
-			tmp = tmp-&gt;next;
-		}
-	}
-
-	out += sprintf(out, "Remove list URBs:");
-	if (list_empty(&amp;uhci-&gt;urb_remove_list))
-		out += sprintf(out, " Empty\n");
-	else {
-		out += sprintf(out, "\n");
-		count = 0;
-		head = &amp;uhci-&gt;urb_remove_list;
-		tmp = head-&gt;next;
-		while (tmp != head) {
-			struct urb_priv *urbp = list_entry(tmp, struct urb_priv, urb_list);
-
-			out += sprintf(out, "  %d: ", ++count);
-			out += uhci_show_urbp(uhci, urbp, out, len - (out - buf));
-			tmp = tmp-&gt;next;
-		}
-	}
-
-	out += sprintf(out, "Complete list URBs:");
-	if (list_empty(&amp;uhci-&gt;complete_list))
-		out += sprintf(out, " Empty\n");
-	else {
-		out += sprintf(out, "\n");
-		count = 0;
-		head = &amp;uhci-&gt;complete_list;
-		tmp = head-&gt;next;
-		while (tmp != head) {
-			struct urb_priv *urbp = list_entry(tmp, struct urb_priv, urb_list);
-
-			out += sprintf(out, "  %d: ", ++count);
-			out += uhci_show_urbp(uhci, urbp, out, len - (out - buf));
-			tmp = tmp-&gt;next;
-		}
-	}
-
-	return out - buf;
-}
-
 static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 {
-	unsigned long flags;
 	char *out = buf;
 	int i, j;
 	struct uhci_qh *qh;
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
 
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
+	if (debug &lt;= 1)
+		return out - buf;
 
 	out += sprintf(out, "Frame List\n");
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
-		int shown = 0;
 		td = uhci-&gt;frame_cpu[i];
 		if (!td)
 			continue;
 
-		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;frame[i]) {
-			show_frame_num();
+		out += sprintf(out, "- Frame %d\n", i); \
+		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;frame[i])
 			out += sprintf(out, "    frame list does not match td-&gt;dma_handle!\n");
-		}
-		show_frame_num();
 
 		head = &amp;td-&gt;fl_list;
 		tmp = head;
@@ -467,14 +348,11 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "Skeleton QHs\n");
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
-		int shown = 0;
+		int cnt = 0;
 
 		qh = uhci-&gt;skelqh[i];
-
-		if (debug &gt; 1) {
-			show_qh_name();
-			out += uhci_show_qh(qh, out, len - (out - buf), 4);
-		}
+		out += sprintf(out, "- %s\n", qh_names[i]); \
+		out += uhci_show_qh(qh, out, len - (out - buf), 4);
 
 		/* Last QH is the Terminating QH, it's different */
 		if (i == UHCI_NUM_SKELQH - 1) {
@@ -487,44 +365,27 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			continue;
 		}
 
-		j = (i &lt; 7) ? 7 : i+1;		/* Next skeleton */
-		if (list_empty(&amp;qh-&gt;list)) {
-			if (i &lt; UHCI_NUM_SKELQH - 1) {
-				if (qh-&gt;link !=
-				    (cpu_to_le32(uhci-&gt;skelqh[j]-&gt;dma_handle) | UHCI_PTR_QH)) {
-					show_qh_name();
-					out += sprintf(out, "    skeleton QH not linked to next skeleton QH!\n");
-				}
-			}
-
-			continue;
-		}
-
-		show_qh_name();
-
-		head = &amp;qh-&gt;list;
+		j = (i &lt; 9) ? 9 : i+1;		/* Next skeleton */
+		head = &amp;qh-&gt;node;
 		tmp = head-&gt;next;
 
 		while (tmp != head) {
-			qh = list_entry(tmp, struct uhci_qh, list);
-
+			qh = list_entry(tmp, struct uhci_qh, node);
 			tmp = tmp-&gt;next;
-
-			out += uhci_show_qh(qh, out, len - (out - buf), 4);
+			if (++cnt &lt;= 10)
+				out += uhci_show_qh(qh, out,
+						len - (out - buf), 4);
 		}
+		if ((cnt -= 10) &gt; 0)
+			out += sprintf(out, "    Skipped %d QHs\n", cnt);
 
-		if (i &lt; UHCI_NUM_SKELQH - 1) {
+		if (i &gt; 1 &amp;&amp; i &lt; UHCI_NUM_SKELQH - 1) {
 			if (qh-&gt;link !=
 			    (cpu_to_le32(uhci-&gt;skelqh[j]-&gt;dma_handle) | UHCI_PTR_QH))
 				out += sprintf(out, "    last QH not linked to next skeleton!\n");
 		}
 	}
 
-	if (debug &gt; 2)
-		out += uhci_show_lists(uhci, out, len - (out - buf));
-
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-
 	return out - buf;
 }
 
@@ -541,6 +402,7 @@ static int uhci_debug_open(struct inode *inode, struct file *file)
 	struct uhci_hcd *uhci = inode-&gt;u.generic_ip;
 	struct uhci_debug *up;
 	int ret = -ENOMEM;
+	unsigned long flags;
 
 	lock_kernel();
 	up = kmalloc(sizeof(*up), GFP_KERNEL);
@@ -553,7 +415,9 @@ static int uhci_debug_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	up-&gt;size = uhci_sprint_schedule(uhci, up-&gt;data, MAX_OUTPUT);
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 
 	file-&gt;private_data = up;
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index dfe121d35887..1ff4b8806372 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -54,7 +54,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v2.3"
+#define DRIVER_VERSION "v3.0"
 #define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
 Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
@@ -489,15 +489,11 @@ static int uhci_start(struct usb_hcd *hcd)
 	uhci-&gt;fsbrtimeout = 0;
 
 	spin_lock_init(&amp;uhci-&gt;lock);
-	INIT_LIST_HEAD(&amp;uhci-&gt;qh_remove_list);
 
 	INIT_LIST_HEAD(&amp;uhci-&gt;td_remove_list);
-
-	INIT_LIST_HEAD(&amp;uhci-&gt;urb_remove_list);
-
 	INIT_LIST_HEAD(&amp;uhci-&gt;urb_list);
-
 	INIT_LIST_HEAD(&amp;uhci-&gt;complete_list);
+	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
@@ -540,7 +536,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	}
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
-		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci);
+		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci, NULL, NULL);
 		if (!uhci-&gt;skelqh[i]) {
 			dev_err(uhci_dev(uhci), "unable to allocate QH\n");
 			goto err_alloc_skelqh;
@@ -557,13 +553,17 @@ static int uhci_start(struct usb_hcd *hcd)
 			uhci-&gt;skel_int16_qh-&gt;link =
 			uhci-&gt;skel_int8_qh-&gt;link =
 			uhci-&gt;skel_int4_qh-&gt;link =
-			uhci-&gt;skel_int2_qh-&gt;link =
-			cpu_to_le32(uhci-&gt;skel_int1_qh-&gt;dma_handle) | UHCI_PTR_QH;
-	uhci-&gt;skel_int1_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_ls_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
-
-	uhci-&gt;skel_ls_control_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
-	uhci-&gt;skel_fs_control_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_bulk_qh-&gt;dma_handle) | UHCI_PTR_QH;
-	uhci-&gt;skel_bulk_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle) | UHCI_PTR_QH;
+			uhci-&gt;skel_int2_qh-&gt;link = UHCI_PTR_QH |
+			cpu_to_le32(uhci-&gt;skel_int1_qh-&gt;dma_handle);
+
+	uhci-&gt;skel_int1_qh-&gt;link = UHCI_PTR_QH |
+			cpu_to_le32(uhci-&gt;skel_ls_control_qh-&gt;dma_handle);
+	uhci-&gt;skel_ls_control_qh-&gt;link = UHCI_PTR_QH |
+			cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle);
+	uhci-&gt;skel_fs_control_qh-&gt;link = UHCI_PTR_QH |
+			cpu_to_le32(uhci-&gt;skel_bulk_qh-&gt;dma_handle);
+	uhci-&gt;skel_bulk_qh-&gt;link = UHCI_PTR_QH |
+			cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle);
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
@@ -589,15 +589,15 @@ static int uhci_start(struct usb_hcd *hcd)
 
 		/*
 		 * ffs (Find First bit Set) does exactly what we need:
-		 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[6],
-		 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[5], etc.
-		 * ffs &gt; 6 =&gt; not on any high-period queue, so use
-		 *	skel_int1_qh = skelqh[7].
+		 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
+		 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
+		 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
+		 *	skel_int1_qh = skelqh[9].
 		 * Add UHCI_NUMFRAMES to insure at least one bit is set.
 		 */
-		irq = 6 - (int) __ffs(i + UHCI_NUMFRAMES);
-		if (irq &lt; 0)
-			irq = 7;
+		irq = 8 - (int) __ffs(i + UHCI_NUMFRAMES);
+		if (irq &lt;= 1)
+			irq = 9;
 
 		/* Only place we don't use the frame list routines */
 		uhci-&gt;frame[i] = UHCI_PTR_QH |
@@ -767,13 +767,30 @@ static int uhci_resume(struct usb_hcd *hcd)
 }
 #endif
 
-/* Wait until all the URBs for a particular device/endpoint are gone */
+/* Wait until a particular device/endpoint's QH is idle, and free it */
 static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
-		struct usb_host_endpoint *ep)
+		struct usb_host_endpoint *hep)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	struct uhci_qh *qh;
+
+	spin_lock_irq(&amp;uhci-&gt;lock);
+	qh = (struct uhci_qh *) hep-&gt;hcpriv;
+	if (qh == NULL)
+		goto done;
 
-	wait_event_interruptible(uhci-&gt;waitqh, list_empty(&amp;ep-&gt;urb_list));
+	while (qh-&gt;state != QH_STATE_IDLE) {
+		++uhci-&gt;num_waiting;
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+		wait_event_interruptible(uhci-&gt;waitqh,
+				qh-&gt;state == QH_STATE_IDLE);
+		spin_lock_irq(&amp;uhci-&gt;lock);
+		--uhci-&gt;num_waiting;
+	}
+
+	uhci_free_qh(uhci, qh);
+done:
+	spin_unlock_irq(&amp;uhci-&gt;lock);
 }
 
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 8b4b887a7d41..7a9481c09a05 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -28,8 +28,9 @@
 #define   USBSTS_USBINT		0x0001	/* Interrupt due to IOC */
 #define   USBSTS_ERROR		0x0002	/* Interrupt due to error */
 #define   USBSTS_RD		0x0004	/* Resume Detect */
-#define   USBSTS_HSE		0x0008	/* Host System Error - basically PCI problems */
-#define   USBSTS_HCPE		0x0010	/* Host Controller Process Error - the scripts were buggy */
+#define   USBSTS_HSE		0x0008	/* Host System Error: PCI problems */
+#define   USBSTS_HCPE		0x0010	/* Host Controller Process Error:
+					 * the schedule is buggy */
 #define   USBSTS_HCH		0x0020	/* HC Halted */
 
 /* Interrupt enable register */
@@ -47,7 +48,8 @@
 /* USB port status and control registers */
 #define USBPORTSC1	16
 #define USBPORTSC2	18
-#define   USBPORTSC_CCS		0x0001	/* Current Connect Status ("device present") */
+#define   USBPORTSC_CCS		0x0001	/* Current Connect Status
+					 * ("device present") */
 #define   USBPORTSC_CSC		0x0002	/* Connect Status Change */
 #define   USBPORTSC_PE		0x0004	/* Port Enable */
 #define   USBPORTSC_PEC		0x0008	/* Port Enable Change */
@@ -71,15 +73,16 @@
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
-#define UHCI_PTR_BITS		cpu_to_le32(0x000F)
-#define UHCI_PTR_TERM		cpu_to_le32(0x0001)
-#define UHCI_PTR_QH		cpu_to_le32(0x0002)
-#define UHCI_PTR_DEPTH		cpu_to_le32(0x0004)
-#define UHCI_PTR_BREADTH	cpu_to_le32(0x0000)
+#define UHCI_PTR_BITS		__constant_cpu_to_le32(0x000F)
+#define UHCI_PTR_TERM		__constant_cpu_to_le32(0x0001)
+#define UHCI_PTR_QH		__constant_cpu_to_le32(0x0002)
+#define UHCI_PTR_DEPTH		__constant_cpu_to_le32(0x0004)
+#define UHCI_PTR_BREADTH	__constant_cpu_to_le32(0x0000)
 
 #define UHCI_NUMFRAMES		1024	/* in the frame list [array] */
 #define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
-#define CAN_SCHEDULE_FRAMES	1000	/* how far future frames can be scheduled */
+#define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
+					 * can be scheduled */
 
 
 /*
@@ -87,38 +90,54 @@
  */
 
 /*
- * One role of a QH is to hold a queue of TDs for some endpoint.  Each QH is
- * used with one URB, and qh-&gt;element (updated by the HC) is either:
- *   - the next unprocessed TD for the URB, or
- *   - UHCI_PTR_TERM (when there's no more traffic for this endpoint), or
- *   - the QH for the next URB queued to the same endpoint.
+ * One role of a QH is to hold a queue of TDs for some endpoint.  One QH goes
+ * with each endpoint, and qh-&gt;element (updated by the HC) is either:
+ *   - the next unprocessed TD in the endpoint's queue, or
+ *   - UHCI_PTR_TERM (when there's no more traffic for this endpoint).
  *
  * The other role of a QH is to serve as a "skeleton" framelist entry, so we
  * can easily splice a QH for some endpoint into the schedule at the right
  * place.  Then qh-&gt;element is UHCI_PTR_TERM.
  *
- * In the frame list, qh-&gt;link maintains a list of QHs seen by the HC:
+ * In the schedule, qh-&gt;link maintains a list of QHs seen by the HC:
  *     skel1 --&gt; ep1-qh --&gt; ep2-qh --&gt; ... --&gt; skel2 --&gt; ...
+ *
+ * qh-&gt;node is the software equivalent of qh-&gt;link.  The differences
+ * are that the software list is doubly-linked and QHs in the UNLINKING
+ * state are on the software list but not the hardware schedule.
+ *
+ * For bookkeeping purposes we maintain QHs even for Isochronous endpoints,
+ * but they never get added to the hardware schedule.
  */
+#define QH_STATE_IDLE		1	/* QH is not being used */
+#define QH_STATE_UNLINKING	2	/* QH has been removed from the
+					 * schedule but the hardware may
+					 * still be using it */
+#define QH_STATE_ACTIVE		3	/* QH is on the schedule */
+
 struct uhci_qh {
 	/* Hardware fields */
-	__le32 link;			/* Next queue */
-	__le32 element;			/* Queue element pointer */
+	__le32 link;			/* Next QH in the schedule */
+	__le32 element;			/* Queue element (TD) pointer */
 
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct urb_priv *urbp;
+	struct list_head node;		/* Node in the list of QHs */
+	struct usb_host_endpoint *hep;	/* Endpoint information */
+	struct usb_device *udev;
+	struct list_head queue;		/* Queue of urbps for this QH */
+	struct uhci_qh *skel;		/* Skeleton for this QH */
 
-	struct list_head list;
-	struct list_head remove_list;
+	unsigned int unlink_frame;	/* When the QH was unlinked */
+	int state;			/* QH_STATE_xxx; see above */
 } __attribute__((aligned(16)));
 
 /*
  * We need a special accessor for the element pointer because it is
  * subject to asynchronous updates by the controller.
  */
-static __le32 inline qh_element(struct uhci_qh *qh) {
+static inline __le32 qh_element(struct uhci_qh *qh) {
 	__le32 element = qh-&gt;element;
 
 	barrier();
@@ -149,11 +168,13 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
 #define TD_CTRL_ACTLEN_MASK	0x7FF	/* actual length, encoded as n - 1 */
 
 #define TD_CTRL_ANY_ERROR	(TD_CTRL_STALLED | TD_CTRL_DBUFERR | \
-				 TD_CTRL_BABBLE | TD_CTRL_CRCTIME | TD_CTRL_BITSTUFF)
+				 TD_CTRL_BABBLE | TD_CTRL_CRCTIME | \
+				 TD_CTRL_BITSTUFF)
 
 #define uhci_maxerr(err)		((err) &lt;&lt; TD_CTRL_C_ERR_SHIFT)
 #define uhci_status_bits(ctrl_sts)	((ctrl_sts) &amp; 0xF60000)
-#define uhci_actual_length(ctrl_sts)	(((ctrl_sts) + 1) &amp; TD_CTRL_ACTLEN_MASK) /* 1-based */
+#define uhci_actual_length(ctrl_sts)	(((ctrl_sts) + 1) &amp; \
+			TD_CTRL_ACTLEN_MASK)	/* 1-based */
 
 /*
  * for TD &lt;info&gt;: (a.k.a. Token)
@@ -163,7 +184,7 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
 #define TD_TOKEN_TOGGLE_SHIFT	19
 #define TD_TOKEN_TOGGLE		(1 &lt;&lt; 19)
 #define TD_TOKEN_EXPLEN_SHIFT	21
-#define TD_TOKEN_EXPLEN_MASK	0x7FF		/* expected length, encoded as n - 1 */
+#define TD_TOKEN_EXPLEN_MASK	0x7FF	/* expected length, encoded as n-1 */
 #define TD_TOKEN_PID_MASK	0xFF
 
 #define uhci_explen(len)	((((len) - 1) &amp; TD_TOKEN_EXPLEN_MASK) &lt;&lt; \
@@ -187,7 +208,7 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
  * sw space after the TD entry.
  *
  * td-&gt;link points to either another TD (not necessarily for the same urb or
- * even the same endpoint), or nothing (PTR_TERM), or a QH (for queued urbs).
+ * even the same endpoint), or nothing (PTR_TERM), or a QH.
  */
 struct uhci_td {
 	/* Hardware fields */
@@ -210,7 +231,7 @@ struct uhci_td {
  * We need a special accessor for the control/status word because it is
  * subject to asynchronous updates by the controller.
  */
-static u32 inline td_status(struct uhci_td *td) {
+static inline u32 td_status(struct uhci_td *td) {
 	__le32 status = td-&gt;status;
 
 	barrier();
@@ -223,17 +244,14 @@ static u32 inline td_status(struct uhci_td *td) {
  */
 
 /*
- * The UHCI driver places Interrupt, Control and Bulk into QHs both
- * to group together TDs for one transfer, and also to facilitate queuing
- * of URBs. To make it easy to insert entries into the schedule, we have
- * a skeleton of QHs for each predefined Interrupt latency, low-speed
- * control, full-speed control and terminating QH (see explanation for
- * the terminating QH below).
+ * The UHCI driver uses QHs with Interrupt, Control and Bulk URBs for
+ * automatic queuing. To make it easy to insert entries into the schedule,
+ * we have a skeleton of QHs for each predefined Interrupt latency,
+ * low-speed control, full-speed control, bulk, and terminating QH
+ * (see explanation for the terminating QH below).
  *
  * When we want to add a new QH, we add it to the end of the list for the
- * skeleton QH.
- *
- * For instance, the queue can look like this:
+ * skeleton QH.  For instance, the schedule list can look like this:
  *
  * skel int128 QH
  * dev 1 interrupt QH
@@ -256,26 +274,31 @@ static u32 inline td_status(struct uhci_td *td) {
  * - To loop back to the full-speed control queue for full-speed bandwidth
  *   reclamation.
  *
- * Isochronous transfers are stored before the start of the skeleton
- * schedule and don't use QHs. While the UHCI spec doesn't forbid the
- * use of QHs for Isochronous, it doesn't use them either. And the spec
- * says that queues never advance on an error completion status, which
- * makes them totally unsuitable for Isochronous transfers.
+ * There's a special skeleton QH for Isochronous QHs.  It never appears
+ * on the schedule, and Isochronous TDs go on the schedule before the
+ * the skeleton QHs.  The hardware accesses them directly rather than
+ * through their QH, which is used only for bookkeeping purposes.
+ * While the UHCI spec doesn't forbid the use of QHs for Isochronous,
+ * it doesn't use them either.  And the spec says that queues never
+ * advance on an error completion status, which makes them totally
+ * unsuitable for Isochronous transfers.
  */
 
-#define UHCI_NUM_SKELQH		12
-#define skel_int128_qh		skelqh[0]
-#define skel_int64_qh		skelqh[1]
-#define skel_int32_qh		skelqh[2]
-#define skel_int16_qh		skelqh[3]
-#define skel_int8_qh		skelqh[4]
-#define skel_int4_qh		skelqh[5]
-#define skel_int2_qh		skelqh[6]
-#define skel_int1_qh		skelqh[7]
-#define skel_ls_control_qh	skelqh[8]
-#define skel_fs_control_qh	skelqh[9]
-#define skel_bulk_qh		skelqh[10]
-#define skel_term_qh		skelqh[11]
+#define UHCI_NUM_SKELQH		14
+#define skel_unlink_qh		skelqh[0]
+#define skel_iso_qh		skelqh[1]
+#define skel_int128_qh		skelqh[2]
+#define skel_int64_qh		skelqh[3]
+#define skel_int32_qh		skelqh[4]
+#define skel_int16_qh		skelqh[5]
+#define skel_int8_qh		skelqh[6]
+#define skel_int4_qh		skelqh[7]
+#define skel_int2_qh		skelqh[8]
+#define skel_int1_qh		skelqh[9]
+#define skel_ls_control_qh	skelqh[10]
+#define skel_fs_control_qh	skelqh[11]
+#define skel_bulk_qh		skelqh[12]
+#define skel_term_qh		skelqh[13]
 
 /*
  * Search tree for determining where &lt;interval&gt; fits in the skelqh[]
@@ -293,21 +316,21 @@ static inline int __interval_to_skel(int interval)
 	if (interval &lt; 16) {
 		if (interval &lt; 4) {
 			if (interval &lt; 2)
-				return 7;	/* int1 for 0-1 ms */
-			return 6;		/* int2 for 2-3 ms */
+				return 9;	/* int1 for 0-1 ms */
+			return 8;		/* int2 for 2-3 ms */
 		}
 		if (interval &lt; 8)
-			return 5;		/* int4 for 4-7 ms */
-		return 4;			/* int8 for 8-15 ms */
+			return 7;		/* int4 for 4-7 ms */
+		return 6;			/* int8 for 8-15 ms */
 	}
 	if (interval &lt; 64) {
 		if (interval &lt; 32)
-			return 3;		/* int16 for 16-31 ms */
-		return 2;			/* int32 for 32-63 ms */
+			return 5;		/* int16 for 16-31 ms */
+		return 4;			/* int32 for 32-63 ms */
 	}
 	if (interval &lt; 128)
-		return 1;			/* int64 for 64-127 ms */
-	return 0;				/* int128 for 128-255 ms (Max.) */
+		return 3;			/* int64 for 64-127 ms */
+	return 2;				/* int128 for 128-255 ms (Max.) */
 }
 
 
@@ -363,12 +386,12 @@ struct uhci_hcd {
 
 	spinlock_t lock;
 
-	dma_addr_t frame_dma_handle;		/* Hardware frame list */
+	dma_addr_t frame_dma_handle;	/* Hardware frame list */
 	__le32 *frame;
-	void **frame_cpu;			/* CPU's frame list */
+	void **frame_cpu;		/* CPU's frame list */
 
-	int fsbr;				/* Full-speed bandwidth reclamation */
-	unsigned long fsbrtimeout;		/* FSBR delay */
+	int fsbr;			/* Full-speed bandwidth reclamation */
+	unsigned long fsbrtimeout;	/* FSBR delay */
 
 	enum uhci_rh_state rh_state;
 	unsigned long auto_stop_time;		/* When to AUTO_STOP */
@@ -392,24 +415,19 @@ struct uhci_hcd {
 	/* Main list of URBs currently controlled by this HC */
 	struct list_head urb_list;
 
-	/* List of QHs that are done, but waiting to be unlinked (race) */
-	struct list_head qh_remove_list;
-	unsigned int qh_remove_age;		/* Age in frames */
-
 	/* List of TDs that are done, but waiting to be freed (race) */
 	struct list_head td_remove_list;
 	unsigned int td_remove_age;		/* Age in frames */
 
-	/* List of asynchronously unlinked URBs */
-	struct list_head urb_remove_list;
-	unsigned int urb_remove_age;		/* Age in frames */
-
 	/* List of URBs awaiting completion callback */
 	struct list_head complete_list;
 
+	struct list_head idle_qh_list;		/* Where the idle QHs live */
+
 	int rh_numports;			/* Number of root-hub ports */
 
 	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
+	int num_waiting;			/* Number of waiters */
 };
 
 /* Convert between a usb_hcd pointer and the corresponding uhci_hcd */
@@ -430,22 +448,19 @@ static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
  */
 struct urb_priv {
 	struct list_head urb_list;
+	struct list_head node;		/* Node in the QH's urbp list */
 
 	struct urb *urb;
 
 	struct uhci_qh *qh;		/* QH for this URB */
 	struct list_head td_list;
 
-	unsigned fsbr : 1;		/* URB turned on FSBR */
-	unsigned fsbr_timeout : 1;	/* URB timed out on FSBR */
-	unsigned queued : 1;		/* QH was queued (not linked in) */
-	unsigned short_control_packet : 1;	/* If we get a short packet during */
-						/*  a control transfer, retrigger */
-						/*  the status phase */
-
 	unsigned long fsbrtime;		/* In jiffies */
 
-	struct list_head queue_list;
+	unsigned fsbr : 1;		/* URB turned on FSBR */
+	unsigned fsbr_timeout : 1;	/* URB timed out on FSBR */
+	unsigned short_transfer : 1;	/* URB got a short transfer, no
+					 * need to rescan */
 };
 
 
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 782398045f9f..b1b551a3d14e 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -13,13 +13,9 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
  */
 
-static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb);
-static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb);
-static void uhci_remove_pending_urbps(struct uhci_hcd *uhci);
-static void uhci_free_pending_qhs(struct uhci_hcd *uhci);
 static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 
 /*
@@ -30,7 +26,7 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci);
  * games with the FSBR code to make sure we get the correct order in all
  * the cases. I don't think it's worth the effort
  */
-static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
+static void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
 	if (uhci-&gt;is_stopped)
 		mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
@@ -42,12 +38,6 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 	uhci-&gt;term_td-&gt;status &amp;= ~cpu_to_le32(TD_CTRL_IOC);
 }
 
-static inline void uhci_moveto_complete(struct uhci_hcd *uhci, 
-					struct urb_priv *urbp)
-{
-	list_move_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;complete_list);
-}
-
 static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
@@ -71,6 +61,18 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 	return td;
 }
 
+static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
+{
+	if (!list_empty(&amp;td-&gt;list))
+		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
+	if (!list_empty(&amp;td-&gt;remove_list))
+		dev_warn(uhci_dev(uhci), "td %p still in remove_list!\n", td);
+	if (!list_empty(&amp;td-&gt;fl_list))
+		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
+
+	dma_pool_free(uhci-&gt;td_pool, td, td-&gt;dma_handle);
+}
+
 static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 		u32 token, u32 buffer)
 {
@@ -82,7 +84,8 @@ static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 /*
  * We insert Isochronous URBs directly into the frame list at the beginning
  */
-static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td, unsigned framenum)
+static inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,
+		struct uhci_td *td, unsigned framenum)
 {
 	framenum &amp;= (UHCI_NUMFRAMES - 1);
 
@@ -108,7 +111,7 @@ static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td,
 	}
 }
 
-static inline void uhci_remove_td_frame_list(struct uhci_hcd *uhci,
+static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
 		struct uhci_td *td)
 {
 	/* If it's not inserted, don't remove it */
@@ -139,48 +142,68 @@ static inline void uhci_remove_td_frame_list(struct uhci_hcd *uhci,
 	td-&gt;frame = -1;
 }
 
-static void unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
+/*
+ * Remove all the TDs for an Isochronous URB from the frame list
+ */
+static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 	struct uhci_td *td;
 
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list)
-		uhci_remove_td_frame_list(uhci, td);
+		uhci_remove_td_from_frame_list(uhci, td);
 	wmb();
 }
 
 /*
- * Inserts a td list into qh.
+ * Remove an URB's TDs from the hardware schedule
  */
-static void uhci_insert_tds_in_qh(struct uhci_qh *qh, struct urb *urb, __le32 breadth)
+static void uhci_remove_tds_from_schedule(struct uhci_hcd *uhci,
+		struct urb *urb, int status)
 {
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct uhci_td *td;
-	__le32 *plink;
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	/* Ordering isn't important here yet since the QH hasn't been */
-	/* inserted into the schedule yet */
-	plink = &amp;qh-&gt;element;
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		*plink = cpu_to_le32(td-&gt;dma_handle) | breadth;
-		plink = &amp;td-&gt;link;
+	/* Isochronous TDs get unlinked directly from the frame list */
+	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
+		uhci_unlink_isochronous_tds(uhci, urb);
+		return;
 	}
-	*plink = UHCI_PTR_TERM;
-}
 
-static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
-{
-	if (!list_empty(&amp;td-&gt;list))
-		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-	if (!list_empty(&amp;td-&gt;remove_list))
-		dev_warn(uhci_dev(uhci), "td %p still in remove_list!\n", td);
-	if (!list_empty(&amp;td-&gt;fl_list))
-		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
+	/* If the URB isn't first on its queue, adjust the link pointer
+	 * of the last TD in the previous URB. */
+	if (urbp-&gt;node.prev != &amp;urbp-&gt;qh-&gt;queue) {
+		struct urb_priv *purbp;
+		struct uhci_td *ptd, *ltd;
+
+		if (status == -EINPROGRESS)
+			status = 0;
+		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ptd-&gt;link = ltd-&gt;link;
+	}
 
-	dma_pool_free(uhci-&gt;td_pool, td, td-&gt;dma_handle);
+	/* If the URB completed with an error, then the QH element certainly
+	 * points to one of the URB's TDs.  If it completed normally then
+	 * the QH element has certainly moved on to the next URB.  And if
+	 * the URB is still in progress then it must have been dequeued.
+	 * The QH element either hasn't reached it yet or is somewhere in
+	 * the middle.  If the URB wasn't first we can assume that it
+	 * hasn't started yet (see above): Otherwise all the preceding URBs
+	 * would have completed and been removed from the queue, so this one
+	 * _would_ be first.
+	 *
+	 * If the QH element is inside this URB, clear it.  It will be
+	 * set properly when the QH is activated.
+	 */
+	if (status &lt; 0)
+		urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
 }
 
-static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci)
+static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
+		struct usb_device *udev, struct usb_host_endpoint *hep)
 {
 	dma_addr_t dma_handle;
 	struct uhci_qh *qh;
@@ -194,256 +217,120 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci)
 	qh-&gt;element = UHCI_PTR_TERM;
 	qh-&gt;link = UHCI_PTR_TERM;
 
-	qh-&gt;urbp = NULL;
+	INIT_LIST_HEAD(&amp;qh-&gt;queue);
+	INIT_LIST_HEAD(&amp;qh-&gt;node);
 
-	INIT_LIST_HEAD(&amp;qh-&gt;list);
-	INIT_LIST_HEAD(&amp;qh-&gt;remove_list);
+	if (udev) {		/* Normal QH */
+		qh-&gt;state = QH_STATE_IDLE;
+		qh-&gt;hep = hep;
+		qh-&gt;udev = udev;
+		hep-&gt;hcpriv = qh;
+		usb_get_dev(udev);
 
+	} else {		/* Skeleton QH */
+		qh-&gt;state = QH_STATE_ACTIVE;
+		qh-&gt;udev = NULL;
+	}
 	return qh;
 }
 
 static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	if (!list_empty(&amp;qh-&gt;list))
+	WARN_ON(qh-&gt;state != QH_STATE_IDLE &amp;&amp; qh-&gt;udev);
+	if (!list_empty(&amp;qh-&gt;queue))
 		dev_warn(uhci_dev(uhci), "qh %p list not empty!\n", qh);
-	if (!list_empty(&amp;qh-&gt;remove_list))
-		dev_warn(uhci_dev(uhci), "qh %p still in remove_list!\n", qh);
 
+	list_del(&amp;qh-&gt;node);
+	if (qh-&gt;udev) {
+		qh-&gt;hep-&gt;hcpriv = NULL;
+		usb_put_dev(qh-&gt;udev);
+	}
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
 
 /*
- * Append this urb's qh after the last qh in skelqh-&gt;list
- *
- * Note that urb_priv.queue_list doesn't have a separate queue head;
- * it's a ring with every element "live".
+ * Put a QH on the schedule in both hardware and software
  */
-static void uhci_insert_qh(struct uhci_hcd *uhci, struct uhci_qh *skelqh, struct urb *urb)
+static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct urb_priv *turbp;
-	struct uhci_qh *lqh;
+	struct uhci_qh *pqh;
 
-	/* Grab the last QH */
-	lqh = list_entry(skelqh-&gt;list.prev, struct uhci_qh, list);
+	WARN_ON(list_empty(&amp;qh-&gt;queue));
 
-	/* Point to the next skelqh */
-	urbp-&gt;qh-&gt;link = lqh-&gt;link;
-	wmb();				/* Ordering is important */
+	/* Set the element pointer if it isn't set already.
+	 * This isn't needed for Isochronous queues, but it doesn't hurt. */
+	if (qh_element(qh) == UHCI_PTR_TERM) {
+		struct urb_priv *urbp = list_entry(qh-&gt;queue.next,
+				struct urb_priv, node);
+		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+				struct uhci_td, list);
 
-	/*
-	 * Patch QHs for previous endpoint's queued URBs?  HC goes
-	 * here next, not to the next skelqh it now points to.
-	 *
-	 *    lqh --&gt; td ... --&gt; qh ... --&gt; td --&gt; qh ... --&gt; td
-	 *     |                 |                 |
-	 *     v                 v                 v
-	 *     +&lt;----------------+-----------------+
-	 *     v
-	 *    newqh --&gt; td ... --&gt; td
-	 *     |
-	 *     v
-	 *    ...
-	 *
-	 * The HC could see (and use!) any of these as we write them.
-	 */
-	lqh-&gt;link = cpu_to_le32(urbp-&gt;qh-&gt;dma_handle) | UHCI_PTR_QH;
-	if (lqh-&gt;urbp) {
-		list_for_each_entry(turbp, &amp;lqh-&gt;urbp-&gt;queue_list, queue_list)
-			turbp-&gt;qh-&gt;link = lqh-&gt;link;
+		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
 	}
 
-	list_add_tail(&amp;urbp-&gt;qh-&gt;list, &amp;skelqh-&gt;list);
+	if (qh-&gt;state == QH_STATE_ACTIVE)
+		return;
+	qh-&gt;state = QH_STATE_ACTIVE;
+
+	/* Move the QH from its old list to the end of the appropriate
+	 * skeleton's list */
+	list_move_tail(&amp;qh-&gt;node, &amp;qh-&gt;skel-&gt;node);
+
+	/* Link it into the schedule */
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+	qh-&gt;link = pqh-&gt;link;
+	wmb();
+	pqh-&gt;link = UHCI_PTR_QH | cpu_to_le32(qh-&gt;dma_handle);
 }
 
 /*
- * Start removal of QH from schedule; it finishes next frame.
- * TDs should be unlinked before this is called.
+ * Take a QH off the hardware schedule
  */
-static void uhci_remove_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
+static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	struct uhci_qh *pqh;
-	__le32 newlink;
 
-	if (!qh)
+	if (qh-&gt;state == QH_STATE_UNLINKING)
 		return;
+	WARN_ON(qh-&gt;state != QH_STATE_ACTIVE || !qh-&gt;udev);
+	qh-&gt;state = QH_STATE_UNLINKING;
 
-	/*
-	 * Only go through the hoops if it's actually linked in
-	 */
-	if (!list_empty(&amp;qh-&gt;list)) {
-
-		/* If our queue is nonempty, make the next URB the head */
-		if (!list_empty(&amp;qh-&gt;urbp-&gt;queue_list)) {
-			struct urb_priv *nurbp;
-
-			nurbp = list_entry(qh-&gt;urbp-&gt;queue_list.next,
-					struct urb_priv, queue_list);
-			nurbp-&gt;queued = 0;
-			list_add(&amp;nurbp-&gt;qh-&gt;list, &amp;qh-&gt;list);
-			newlink = cpu_to_le32(nurbp-&gt;qh-&gt;dma_handle) | UHCI_PTR_QH;
-		} else
-			newlink = qh-&gt;link;
-
-		/* Fix up the previous QH's queue to link to either
-		 * the new head of this queue or the start of the
-		 * next endpoint's queue. */
-		pqh = list_entry(qh-&gt;list.prev, struct uhci_qh, list);
-		pqh-&gt;link = newlink;
-		if (pqh-&gt;urbp) {
-			struct urb_priv *turbp;
-
-			list_for_each_entry(turbp, &amp;pqh-&gt;urbp-&gt;queue_list,
-					queue_list)
-				turbp-&gt;qh-&gt;link = newlink;
-		}
-		wmb();
-
-		/* Leave qh-&gt;link in case the HC is on the QH now, it will */
-		/* continue the rest of the schedule */
-		qh-&gt;element = UHCI_PTR_TERM;
-
-		list_del_init(&amp;qh-&gt;list);
-	}
-
-	list_del_init(&amp;qh-&gt;urbp-&gt;queue_list);
-	qh-&gt;urbp = NULL;
+	/* Unlink the QH from the schedule and record when we did it */
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+	pqh-&gt;link = qh-&gt;link;
+	mb();
 
 	uhci_get_current_frame_number(uhci);
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;qh_remove_age) {
-		uhci_free_pending_qhs(uhci);
-		uhci-&gt;qh_remove_age = uhci-&gt;frame_number;
-	}
+	qh-&gt;unlink_frame = uhci-&gt;frame_number;
 
-	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the QH */
-	if (list_empty(&amp;uhci-&gt;qh_remove_list))
+	/* Force an interrupt so we know when the QH is fully unlinked */
+	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_set_next_interrupt(uhci);
 
-	list_add(&amp;qh-&gt;remove_list, &amp;uhci-&gt;qh_remove_list);
+	/* Move the QH from its old list to the end of the unlinking list */
+	list_move_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skel_unlink_qh-&gt;node);
 }
 
-static int uhci_fixup_toggle(struct urb *urb, unsigned int toggle)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct uhci_td *td;
-
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		if (toggle)
-			td-&gt;token |= cpu_to_le32(TD_TOKEN_TOGGLE);
-		else
-			td-&gt;token &amp;= ~cpu_to_le32(TD_TOKEN_TOGGLE);
-
-		toggle ^= 1;
-	}
-
-	return toggle;
-}
-
-/* This function will append one URB's QH to another URB's QH. This is for */
-/* queuing interrupt, control or bulk transfers */
-static void uhci_append_queued_urb(struct uhci_hcd *uhci, struct urb *eurb, struct urb *urb)
-{
-	struct urb_priv *eurbp, *urbp, *furbp, *lurbp;
-	struct uhci_td *lltd;
-
-	eurbp = eurb-&gt;hcpriv;
-	urbp = urb-&gt;hcpriv;
-
-	/* Find the first URB in the queue */
-	furbp = eurbp;
-	if (eurbp-&gt;queued) {
-		list_for_each_entry(furbp, &amp;eurbp-&gt;queue_list, queue_list)
-			if (!furbp-&gt;queued)
-				break;
-	}
-
-	lurbp = list_entry(furbp-&gt;queue_list.prev, struct urb_priv, queue_list);
-
-	lltd = list_entry(lurbp-&gt;td_list.prev, struct uhci_td, list);
-
-	/* Control transfers always start with toggle 0 */
-	if (!usb_pipecontrol(urb-&gt;pipe))
-		usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-				usb_pipeout(urb-&gt;pipe),
-				uhci_fixup_toggle(urb,
-					uhci_toggle(td_token(lltd)) ^ 1));
-
-	/* All qhs in the queue need to link to the next queue */
-	urbp-&gt;qh-&gt;link = eurbp-&gt;qh-&gt;link;
-
-	wmb();			/* Make sure we flush everything */
-
-	lltd-&gt;link = cpu_to_le32(urbp-&gt;qh-&gt;dma_handle) | UHCI_PTR_QH;
-
-	list_add_tail(&amp;urbp-&gt;queue_list, &amp;furbp-&gt;queue_list);
-
-	urbp-&gt;queued = 1;
-}
-
-static void uhci_delete_queued_urb(struct uhci_hcd *uhci, struct urb *urb)
+/*
+ * When we and the controller are through with a QH, it becomes IDLE.
+ * This happens when a QH has been off the schedule (on the unlinking
+ * list) for more than one frame, or when an error occurs while adding
+ * the first URB onto a new QH.
+ */
+static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct urb_priv *urbp, *nurbp, *purbp, *turbp;
-	struct uhci_td *pltd;
-	unsigned int toggle;
-
-	urbp = urb-&gt;hcpriv;
-
-	if (list_empty(&amp;urbp-&gt;queue_list))
-		return;
-
-	nurbp = list_entry(urbp-&gt;queue_list.next, struct urb_priv, queue_list);
-
-	/*
-	 * Fix up the toggle for the following URBs in the queue.
-	 * Only needed for bulk and interrupt: control and isochronous
-	 * endpoints don't propagate toggles between messages.
-	 */
-	if (usb_pipebulk(urb-&gt;pipe) || usb_pipeint(urb-&gt;pipe)) {
-		if (!urbp-&gt;queued)
-			/* We just set the toggle in uhci_unlink_generic */
-			toggle = usb_gettoggle(urb-&gt;dev,
-					usb_pipeendpoint(urb-&gt;pipe),
-					usb_pipeout(urb-&gt;pipe));
-		else {
-			/* If we're in the middle of the queue, grab the */
-			/* toggle from the TD previous to us */
-			purbp = list_entry(urbp-&gt;queue_list.prev,
-					struct urb_priv, queue_list);
-			pltd = list_entry(purbp-&gt;td_list.prev,
-					struct uhci_td, list);
-			toggle = uhci_toggle(td_token(pltd)) ^ 1;
-		}
-
-		list_for_each_entry(turbp, &amp;urbp-&gt;queue_list, queue_list) {
-			if (!turbp-&gt;queued)
-				break;
-			toggle = uhci_fixup_toggle(turbp-&gt;urb, toggle);
-		}
+	WARN_ON(qh-&gt;state == QH_STATE_ACTIVE);
 
-		usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-				usb_pipeout(urb-&gt;pipe), toggle);
-	}
-
-	if (urbp-&gt;queued) {
-		/* We're somewhere in the middle (or end).  The case where
-		 * we're at the head is handled in uhci_remove_qh(). */
-		purbp = list_entry(urbp-&gt;queue_list.prev, struct urb_priv,
-				queue_list);
-
-		pltd = list_entry(purbp-&gt;td_list.prev, struct uhci_td, list);
-		if (nurbp-&gt;queued)
-			pltd-&gt;link = cpu_to_le32(nurbp-&gt;qh-&gt;dma_handle) | UHCI_PTR_QH;
-		else
-			/* The next URB happens to be the beginning, so */
-			/*  we're the last, end the chain */
-			pltd-&gt;link = UHCI_PTR_TERM;
-	}
+	list_move(&amp;qh-&gt;node, &amp;uhci-&gt;idle_qh_list);
+	qh-&gt;state = QH_STATE_IDLE;
 
-	/* urbp-&gt;queue_list is handled in uhci_remove_qh() */
+	/* If anyone is waiting for a QH to become idle, wake them up */
+	if (uhci-&gt;num_waiting)
+		wake_up_all(&amp;uhci-&gt;waitqh);
 }
 
-static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
+static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
+		struct urb *urb)
 {
 	struct urb_priv *urbp;
 
@@ -453,17 +340,14 @@ static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci, struct urb *u
 
 	memset((void *)urbp, 0, sizeof(*urbp));
 
-	urbp-&gt;fsbrtime = jiffies;
 	urbp-&gt;urb = urb;
+	urb-&gt;hcpriv = urbp;
+	urbp-&gt;fsbrtime = jiffies;
 	
+	INIT_LIST_HEAD(&amp;urbp-&gt;node);
 	INIT_LIST_HEAD(&amp;urbp-&gt;td_list);
-	INIT_LIST_HEAD(&amp;urbp-&gt;queue_list);
 	INIT_LIST_HEAD(&amp;urbp-&gt;urb_list);
 
-	list_add_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;urb_list);
-
-	urb-&gt;hcpriv = urbp;
-
 	return urbp;
 }
 
@@ -482,18 +366,17 @@ static void uhci_remove_td_from_urb(struct uhci_td *td)
 	list_del_init(&amp;td-&gt;list);
 }
 
-static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
+static void uhci_free_urb_priv(struct uhci_hcd *uhci,
+		struct urb_priv *urbp)
 {
 	struct uhci_td *td, *tmp;
-	struct urb_priv *urbp;
-
-	urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	if (!urbp)
-		return;
 
 	if (!list_empty(&amp;urbp-&gt;urb_list))
-		dev_warn(uhci_dev(uhci), "urb %p still on uhci-&gt;urb_list "
-				"or uhci-&gt;remove_list!\n", urb);
+		dev_warn(uhci_dev(uhci), "urb %p still on uhci-&gt;urb_list!\n",
+				urbp-&gt;urb);
+	if (!list_empty(&amp;urbp-&gt;node))
+		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
+				urbp-&gt;urb);
 
 	uhci_get_current_frame_number(uhci);
 	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age) {
@@ -502,7 +385,7 @@ static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 	}
 
 	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the TDs*/
+	/* to force an interrupt so we can remove the TDs. */
 	if (list_empty(&amp;uhci-&gt;td_remove_list))
 		uhci_set_next_interrupt(uhci);
 
@@ -511,7 +394,7 @@ static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
 	}
 
-	urb-&gt;hcpriv = NULL;
+	urbp-&gt;urb-&gt;hcpriv = NULL;
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
@@ -567,18 +450,83 @@ static int uhci_map_status(int status, int dir_out)
 	return 0;
 }
 
+/*
+ * Fix up the data toggles for URBs in a queue, when one of them
+ * terminates early (short transfer, error, or dequeued).
+ */
+static void uhci_fixup_toggles(struct urb *urb)
+{
+	struct list_head *head;
+	struct uhci_td *td;
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
+	int prevactive = 0;
+	unsigned int toggle = 0;
+	struct urb_priv *turbp, *list_end;
+
+	/*
+	 * We need to find out what the last successful toggle was so
+	 * we can update the data toggles for the following transfers.
+	 *
+	 * There are 2 ways the last successful completed TD is found:
+	 *
+	 * 1) The TD is NOT active and the actual length &lt; expected length
+	 * 2) The TD is NOT active and it's the last TD in the chain
+	 *
+	 * and a third way the first uncompleted TD is found:
+	 *
+	 * 3) The TD is active and the previous TD is NOT active
+	 */
+	head = &amp;urbp-&gt;td_list;
+	list_for_each_entry(td, head, list) {
+		unsigned int ctrlstat = td_status(td);
+
+		if (!(ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp;
+				(uhci_actual_length(ctrlstat) &lt;
+				 uhci_expected_length(td_token(td)) ||
+				td-&gt;list.next == head))
+			toggle = uhci_toggle(td_token(td)) ^ 1;
+		else if ((ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp; !prevactive)
+			toggle = uhci_toggle(td_token(td));
+
+		prevactive = ctrlstat &amp; TD_CTRL_ACTIVE;
+	}
+
+	/*
+	 * Fix up the toggle for the following URBs in the queue.
+	 *
+	 * We can stop as soon as we find an URB with toggles set correctly,
+	 * because then all the following URBs will be correct also.
+	 */
+	list_end = list_entry(&amp;urbp-&gt;qh-&gt;queue, struct urb_priv, node);
+	turbp = urbp;
+	while ((turbp = list_entry(turbp-&gt;node.next, struct urb_priv, node))
+			!= list_end) {
+		td = list_entry(turbp-&gt;td_list.next, struct uhci_td, list);
+		if (uhci_toggle(td_token(td)) == toggle)
+			return;
+
+		list_for_each_entry(td, &amp;turbp-&gt;td_list, list) {
+			td-&gt;token ^= __constant_cpu_to_le32(TD_TOKEN_TOGGLE);
+			toggle ^= 1;
+		}
+	}
+
+	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
+			usb_pipeout(urb-&gt;pipe), toggle);
+}
+
 /*
  * Control transfers
  */
-static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct urb *eurb)
+static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
 	struct uhci_td *td;
-	struct uhci_qh *qh, *skelqh;
 	unsigned long destination, status;
-	int maxsze = usb_maxpacket(urb-&gt;dev, urb-&gt;pipe, usb_pipeout(urb-&gt;pipe));
+	int maxsze = le16_to_cpu(qh-&gt;hep-&gt;desc.wMaxPacketSize);
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
+	__le32 *plink;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
@@ -597,7 +545,8 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status, destination | uhci_explen(8),
-		urb-&gt;setup_dma);
+			urb-&gt;setup_dma);
+	plink = &amp;td-&gt;link;
 
 	/*
 	 * If direction is "send", change the packet ID from SETUP (0x2D)
@@ -615,21 +564,20 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	 * Build the DATA TDs
 	 */
 	while (len &gt; 0) {
-		int pktsze = len;
-
-		if (pktsze &gt; maxsze)
-			pktsze = maxsze;
+		int pktsze = min(len, maxsze);
 
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
+		*plink = cpu_to_le32(td-&gt;dma_handle);
 
 		/* Alternate Data0/1 (start with Data1) */
 		destination ^= TD_TOKEN_TOGGLE;
 	
 		uhci_add_td_to_urb(urb, td);
 		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
-			data);
+				data);
+		plink = &amp;td-&gt;link;
 
 		data += pktsze;
 		len -= pktsze;
@@ -641,6 +589,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		return -ENOMEM;
+	*plink = cpu_to_le32(td-&gt;dma_handle);
 
 	/*
 	 * It's IN if the pipe is an output pipe or we're not expecting
@@ -658,16 +607,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
-		destination | uhci_explen(0), 0);
-
-	qh = uhci_alloc_qh(uhci);
-	if (!qh)
-		return -ENOMEM;
-
-	urbp-&gt;qh = qh;
-	qh-&gt;urbp = urbp;
-
-	uhci_insert_tds_in_qh(qh, urb, UHCI_PTR_BREADTH);
+			destination | uhci_explen(0), 0);
 
 	/* Low-speed transfers get a different queue, and won't hog the bus.
 	 * Also, some devices enumerate better without FSBR; the easiest way
@@ -675,18 +615,13 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	 * isn't in the CONFIGURED state. */
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW ||
 			urb-&gt;dev-&gt;state != USB_STATE_CONFIGURED)
-		skelqh = uhci-&gt;skel_ls_control_qh;
+		qh-&gt;skel = uhci-&gt;skel_ls_control_qh;
 	else {
-		skelqh = uhci-&gt;skel_fs_control_qh;
+		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
 		uhci_inc_fsbr(uhci, urb);
 	}
 
-	if (eurb)
-		uhci_append_queued_urb(uhci, eurb, urb);
-	else
-		uhci_insert_qh(uhci, skelqh, urb);
-
-	return -EINPROGRESS;
+	return 0;
 }
 
 /*
@@ -703,7 +638,7 @@ static int usb_control_retrigger_status(struct uhci_hcd *uhci, struct urb *urb)
 	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
 	struct uhci_td *td;
 
-	urbp-&gt;short_control_packet = 1;
+	urbp-&gt;short_transfer = 1;
 
 	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
 	urbp-&gt;qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
@@ -720,16 +655,14 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 	unsigned int status;
 	int ret = 0;
 
-	if (list_empty(&amp;urbp-&gt;td_list))
-		return -EINVAL;
-
 	head = &amp;urbp-&gt;td_list;
-
-	if (urbp-&gt;short_control_packet) {
+	if (urbp-&gt;short_transfer) {
 		tmp = head-&gt;prev;
 		goto status_stage;
 	}
 
+	urb-&gt;actual_length = 0;
+
 	tmp = head-&gt;next;
 	td = list_entry(tmp, struct uhci_td, list);
 
@@ -742,8 +675,6 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 	if (status)
 		goto td_error;
 
-	urb-&gt;actual_length = 0;
-
 	/* The rest of the TDs (but the last) are data */
 	tmp = tmp-&gt;next;
 	while (tmp != head &amp;&amp; tmp-&gt;next != head) {
@@ -770,10 +701,7 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 				goto err;
 			}
 
-			if (uhci_packetid(td_token(td)) == USB_PID_IN)
-				return usb_control_retrigger_status(uhci, urb);
-			else
-				return 0;
+			return usb_control_retrigger_status(uhci, urb);
 		}
 	}
 
@@ -825,15 +753,15 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 /*
  * Common submit for bulk and interrupt
  */
-static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb *eurb, struct uhci_qh *skelqh)
+static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
 	struct uhci_td *td;
-	struct uhci_qh *qh;
 	unsigned long destination, status;
-	int maxsze = usb_maxpacket(urb-&gt;dev, urb-&gt;pipe, usb_pipeout(urb-&gt;pipe));
+	int maxsze = le16_to_cpu(qh-&gt;hep-&gt;desc.wMaxPacketSize);
 	int len = urb-&gt;transfer_buffer_length;
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
 	dma_addr_t data = urb-&gt;transfer_dma;
+	__le32 *plink, fake_link;
 
 	if (len &lt; 0)
 		return -EINVAL;
@@ -841,7 +769,8 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
 
-	status = uhci_maxerr(3) | TD_CTRL_ACTIVE;
+	/* 3 errors */
+	status = TD_CTRL_ACTIVE | uhci_maxerr(3);
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		status |= TD_CTRL_LS;
 	if (usb_pipein(urb-&gt;pipe))
@@ -850,10 +779,11 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	/*
 	 * Build the DATA TDs
 	 */
+	plink = &amp;fake_link;
 	do {	/* Allow zero length packets */
 		int pktsze = maxsze;
 
-		if (pktsze &gt;= len) {
+		if (len &lt;= pktsze) {		/* The last packet */
 			pktsze = len;
 			if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
 				status &amp;= ~TD_CTRL_SPD;
@@ -862,12 +792,15 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
+		*plink = cpu_to_le32(td-&gt;dma_handle);
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze) |
+		uhci_fill_td(td, status,
+			destination | uhci_explen(pktsze) |
 			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
 			data);
+		plink = &amp;td-&gt;link;
 
 		data += pktsze;
 		len -= maxsze;
@@ -883,11 +816,13 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 * however, if transfer_length == 0, the zero packet was already
 	 * prepared above.
 	 */
-	if (usb_pipeout(urb-&gt;pipe) &amp;&amp; (urb-&gt;transfer_flags &amp; URB_ZERO_PACKET) &amp;&amp;
-	    !len &amp;&amp; urb-&gt;transfer_buffer_length) {
+	if ((urb-&gt;transfer_flags &amp; URB_ZERO_PACKET) &amp;&amp;
+			usb_pipeout(urb-&gt;pipe) &amp;&amp; len == 0 &amp;&amp;
+			urb-&gt;transfer_buffer_length &gt; 0) {
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
+		*plink = cpu_to_le32(td-&gt;dma_handle);
 
 		uhci_add_td_to_urb(urb, td);
 		uhci_fill_td(td, status, destination | uhci_explen(0) |
@@ -905,24 +840,9 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 * fast side but not enough to justify delaying an interrupt
 	 * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT
 	 * flag setting. */
-	td-&gt;status |= cpu_to_le32(TD_CTRL_IOC);
-
-	qh = uhci_alloc_qh(uhci);
-	if (!qh)
-		return -ENOMEM;
-
-	urbp-&gt;qh = qh;
-	qh-&gt;urbp = urbp;
+	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
-	/* Always breadth first */
-	uhci_insert_tds_in_qh(qh, urb, UHCI_PTR_BREADTH);
-
-	if (eurb)
-		uhci_append_queued_urb(uhci, eurb, urb);
-	else
-		uhci_insert_qh(uhci, skelqh, urb);
-
-	return -EINPROGRESS;
+	return 0;
 }
 
 /*
@@ -954,8 +874,24 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) {
 				ret = -EREMOTEIO;
 				goto err;
-			} else
-				return 0;
+			}
+
+			/*
+			 * This URB stopped short of its end.  We have to
+			 * fix up the toggles of the following URBs on the
+			 * queue and restart the queue.
+			 *
+			 * Do this only the first time we encounter the
+			 * short URB.
+			 */
+			if (!urbp-&gt;short_transfer) {
+				urbp-&gt;short_transfer = 1;
+				uhci_fixup_toggles(urb);
+				td = list_entry(urbp-&gt;td_list.prev,
+						struct uhci_td, list);
+				urbp-&gt;qh-&gt;element = td-&gt;link;
+			}
+			break;
 		}
 	}
 
@@ -988,7 +924,8 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 	return ret;
 }
 
-static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb, struct urb *eurb)
+static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
 	int ret;
 
@@ -996,21 +933,22 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb, struc
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		return -EINVAL;
 
-	ret = uhci_submit_common(uhci, urb, eurb, uhci-&gt;skel_bulk_qh);
-	if (ret == -EINPROGRESS)
+	qh-&gt;skel = uhci-&gt;skel_bulk_qh;
+	ret = uhci_submit_common(uhci, urb, qh);
+	if (ret == 0)
 		uhci_inc_fsbr(uhci, urb);
-
 	return ret;
 }
 
-static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb, struct urb *eurb)
+static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
-	/* USB 1.1 interrupt transfers only involve one packet per interval;
-	 * that's the uhci_submit_common() "breadth first" policy.  Drivers
-	 * can submit urbs of any length, but longer ones might need many
-	 * intervals to complete.
+	/* USB 1.1 interrupt transfers only involve one packet per interval.
+	 * Drivers can submit URBs of any length, but longer ones will need
+	 * multiple intervals to complete.
 	 */
-	return uhci_submit_common(uhci, urb, eurb, uhci-&gt;skelqh[__interval_to_skel(urb-&gt;interval)]);
+	qh-&gt;skel = uhci-&gt;skelqh[__interval_to_skel(urb-&gt;interval)];
+	return uhci_submit_common(uhci, urb, qh);
 }
 
 /*
@@ -1072,11 +1010,12 @@ static int isochronous_find_start(struct uhci_hcd *uhci, struct urb *urb)
 /*
  * Isochronous transfers
  */
-static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
+static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
+		struct uhci_qh *qh)
 {
-	struct uhci_td *td;
+	struct uhci_td *td = NULL;	/* Since urb-&gt;number_of_packets &gt; 0 */
 	int i, ret, frame;
-	int status, destination;
+	unsigned long destination, status;
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
@@ -1092,20 +1031,25 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(urb-&gt;iso_frame_desc[i].length),
-			urb-&gt;transfer_dma + urb-&gt;iso_frame_desc[i].offset);
-
-		if (i + 1 &gt;= urb-&gt;number_of_packets)
-			td-&gt;status |= cpu_to_le32(TD_CTRL_IOC);
+		uhci_fill_td(td, status, destination |
+				uhci_explen(urb-&gt;iso_frame_desc[i].length),
+				urb-&gt;transfer_dma +
+					urb-&gt;iso_frame_desc[i].offset);
 	}
 
+	/* Set the interrupt-on-completion flag on the last packet. */
+	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
+
+	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+
+	/* Add the TDs to the frame list */
 	frame = urb-&gt;start_frame;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		uhci_insert_td_frame_list(uhci, td, frame);
+		uhci_insert_td_in_frame_list(uhci, td, frame);
 		frame += urb-&gt;interval;
 	}
 
-	return -EINPROGRESS;
+	return 0;
 }
 
 static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
@@ -1139,80 +1083,67 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 
 		i++;
 	}
-	unlink_isochronous_tds(uhci, urb);
 
 	return ret;
 }
 
-static struct urb *uhci_find_urb_ep(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *up;
-
-	/* We don't match Isoc transfers since they are special */
-	if (usb_pipeisoc(urb-&gt;pipe))
-		return NULL;
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		if (u-&gt;dev == urb-&gt;dev &amp;&amp; u-&gt;status == -EINPROGRESS) {
-			/* For control, ignore the direction */
-			if (usb_pipecontrol(urb-&gt;pipe) &amp;&amp;
-			    (u-&gt;pipe &amp; ~USB_DIR_IN) == (urb-&gt;pipe &amp; ~USB_DIR_IN))
-				return u;
-			else if (u-&gt;pipe == urb-&gt;pipe)
-				return u;
-		}
-	}
-
-	return NULL;
-}
-
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
-		struct usb_host_endpoint *ep,
+		struct usb_host_endpoint *hep,
 		struct urb *urb, gfp_t mem_flags)
 {
 	int ret;
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	struct urb *eurb;
+	struct urb_priv *urbp;
+	struct uhci_qh *qh;
 	int bustime;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
 	ret = urb-&gt;status;
 	if (ret != -EINPROGRESS)		/* URB already unlinked! */
-		goto out;
+		goto done;
 
-	eurb = uhci_find_urb_ep(uhci, urb);
+	ret = -ENOMEM;
+	urbp = uhci_alloc_urb_priv(uhci, urb);
+	if (!urbp)
+		goto done;
 
-	if (!uhci_alloc_urb_priv(uhci, urb)) {
-		ret = -ENOMEM;
-		goto out;
+	if (hep-&gt;hcpriv)
+		qh = (struct uhci_qh *) hep-&gt;hcpriv;
+	else {
+		qh = uhci_alloc_qh(uhci, urb-&gt;dev, hep);
+		if (!qh)
+			goto err_no_qh;
 	}
+	urbp-&gt;qh = qh;
 
 	switch (usb_pipetype(urb-&gt;pipe)) {
 	case PIPE_CONTROL:
-		ret = uhci_submit_control(uhci, urb, eurb);
+		ret = uhci_submit_control(uhci, urb, qh);
+		break;
+	case PIPE_BULK:
+		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
 	case PIPE_INTERRUPT:
-		if (!eurb) {
+		if (list_empty(&amp;qh-&gt;queue)) {
 			bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 			if (bustime &lt; 0)
 				ret = bustime;
 			else {
-				ret = uhci_submit_interrupt(uhci, urb, eurb);
-				if (ret == -EINPROGRESS)
+				ret = uhci_submit_interrupt(uhci, urb, qh);
+				if (ret == 0)
 					usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 0);
 			}
 		} else {	/* inherit from parent */
-			urb-&gt;bandwidth = eurb-&gt;bandwidth;
-			ret = uhci_submit_interrupt(uhci, urb, eurb);
+			struct urb_priv *eurbp;
+
+			eurbp = list_entry(qh-&gt;queue.prev, struct urb_priv,
+					node);
+			urb-&gt;bandwidth = eurbp-&gt;urb-&gt;bandwidth;
+			ret = uhci_submit_interrupt(uhci, urb, qh);
 		}
 		break;
-	case PIPE_BULK:
-		ret = uhci_submit_bulk(uhci, urb, eurb);
-		break;
 	case PIPE_ISOCHRONOUS:
 		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 		if (bustime &lt; 0) {
@@ -1220,22 +1151,59 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 			break;
 		}
 
-		ret = uhci_submit_isochronous(uhci, urb);
-		if (ret == -EINPROGRESS)
+		ret = uhci_submit_isochronous(uhci, urb, qh);
+		if (ret == 0)
 			usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 1);
 		break;
 	}
+	if (ret != 0)
+		goto err_submit_failed;
 
-	if (ret != -EINPROGRESS) {
-		/* Submit failed, so delete it from the urb_list */
-		struct urb_priv *urbp = urb-&gt;hcpriv;
+	/* Add this URB to the QH */
+	urbp-&gt;qh = qh;
+	list_add_tail(&amp;urbp-&gt;node, &amp;qh-&gt;queue);
+	list_add_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;urb_list);
 
-		list_del_init(&amp;urbp-&gt;urb_list);
-		uhci_destroy_urb_priv(uhci, urb);
-	} else
-		ret = 0;
+	/* If the new URB is the first and only one on this QH then either
+	 * the QH is new and idle or else it's unlinked and waiting to
+	 * become idle, so we can activate it right away. */
+	if (qh-&gt;queue.next == &amp;urbp-&gt;node)
+		uhci_activate_qh(uhci, qh);
+
+	/* If the QH is already active, we have a race with the hardware.
+	 * This won't get fixed until dummy TDs are added. */
+	else if (qh-&gt;state == QH_STATE_ACTIVE) {
+
+		/* If the URB isn't first on its queue, adjust the link pointer
+		 * of the last TD in the previous URB. */
+		if (urbp-&gt;node.prev != &amp;urbp-&gt;qh-&gt;queue) {
+			struct urb_priv *purbp = list_entry(urbp-&gt;node.prev,
+					struct urb_priv, node);
+			struct uhci_td *ptd = list_entry(purbp-&gt;td_list.prev,
+					struct uhci_td, list);
+			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+					struct uhci_td, list);
+
+			ptd-&gt;link = cpu_to_le32(td-&gt;dma_handle);
+
+		}
+		if (qh_element(qh) == UHCI_PTR_TERM) {
+			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+					struct uhci_td, list);
+
+			qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		}
+	}
+	goto done;
+
+err_submit_failed:
+	if (qh-&gt;state == QH_STATE_IDLE)
+		uhci_make_qh_idle(uhci, qh);	/* Reclaim unused QH */
 
-out:
+err_no_qh:
+	uhci_free_urb_priv(uhci, urbp);
+
+done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 	return ret;
 }
@@ -1245,119 +1213,115 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
  */
 static void uhci_transfer_result(struct uhci_hcd *uhci, struct urb *urb)
 {
-	int ret = -EINPROGRESS;
-	struct urb_priv *urbp;
-
-	spin_lock(&amp;urb-&gt;lock);
-
-	urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	if (urb-&gt;status != -EINPROGRESS)	/* URB already dequeued */
-		goto out;
+	int status;
+	int okay_to_giveback = 0;
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	switch (usb_pipetype(urb-&gt;pipe)) {
 	case PIPE_CONTROL:
-		ret = uhci_result_control(uhci, urb);
-		break;
-	case PIPE_BULK:
-	case PIPE_INTERRUPT:
-		ret = uhci_result_common(uhci, urb);
+		status = uhci_result_control(uhci, urb);
 		break;
 	case PIPE_ISOCHRONOUS:
-		ret = uhci_result_isochronous(uhci, urb);
+		status = uhci_result_isochronous(uhci, urb);
+		break;
+	default:	/* PIPE_BULK or PIPE_INTERRUPT */
+		status = uhci_result_common(uhci, urb);
 		break;
 	}
 
-	if (ret == -EINPROGRESS)
-		goto out;
-	urb-&gt;status = ret;
+	spin_lock(&amp;urb-&gt;lock);
+	if (urb-&gt;status == -EINPROGRESS) {	/* Not yet dequeued */
+		if (status != -EINPROGRESS) {	/* URB has completed */
+			urb-&gt;status = status;
+
+			/* If the URB got a real error (as opposed to
+			 * simply being dequeued), we don't have to
+			 * unlink the QH.  Fix this later... */
+			if (status &lt; 0)
+				uhci_unlink_qh(uhci, urbp-&gt;qh);
+			else
+				okay_to_giveback = 1;
+		}
+	} else {				/* Already dequeued */
+		if (urbp-&gt;qh-&gt;state == QH_STATE_UNLINKING &amp;&amp;
+				uhci-&gt;frame_number + uhci-&gt;is_stopped !=
+				urbp-&gt;qh-&gt;unlink_frame)
+			okay_to_giveback = 1;
+	}
+	spin_unlock(&amp;urb-&gt;lock);
+	if (!okay_to_giveback)
+		return;
 
 	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_CONTROL:
-	case PIPE_BULK:
 	case PIPE_ISOCHRONOUS:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		if (urb-&gt;bandwidth)
 			usb_release_bandwidth(urb-&gt;dev, urb, 1);
-		uhci_unlink_generic(uhci, urb);
 		break;
 	case PIPE_INTERRUPT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
-		if (list_empty(&amp;urbp-&gt;queue_list) &amp;&amp; urb-&gt;bandwidth)
+		if (list_empty(&amp;urbp-&gt;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
 			usb_release_bandwidth(urb-&gt;dev, urb, 0);
 		else
 			/* bandwidth was passed on to queued URB, */
 			/* so don't let usb_unlink_urb() release it */
 			urb-&gt;bandwidth = 0;
-		uhci_unlink_generic(uhci, urb);
+		/* Falls through */
+	case PIPE_BULK:
+		if (status &lt; 0)
+			uhci_fixup_toggles(urb);
+		break;
+	default:	/* PIPE_CONTROL */
 		break;
-	default:
-		dev_info(uhci_dev(uhci), "%s: unknown pipe type %d "
-				"for urb %p\n",
-				__FUNCTION__, usb_pipetype(urb-&gt;pipe), urb);
 	}
 
-	/* Move it from uhci-&gt;urb_list to uhci-&gt;complete_list */
-	uhci_moveto_complete(uhci, urbp);
+	/* Take the URB's TDs off the hardware schedule */
+	uhci_remove_tds_from_schedule(uhci, urb, status);
 
-out:
-	spin_unlock(&amp;urb-&gt;lock);
-}
-
-static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct list_head *head;
-	struct uhci_td *td;
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	int prevactive = 0;
+	/* Take the URB off the QH's queue and see if the QH is now unused */
+	list_del_init(&amp;urbp-&gt;node);
+	if (list_empty(&amp;urbp-&gt;qh-&gt;queue))
+		uhci_unlink_qh(uhci, urbp-&gt;qh);
 
 	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 
-	/*
-	 * Now we need to find out what the last successful toggle was
-	 * so we can update the local data toggle for the next transfer
-	 *
-	 * There are 2 ways the last successful completed TD is found:
-	 *
-	 * 1) The TD is NOT active and the actual length &lt; expected length
-	 * 2) The TD is NOT active and it's the last TD in the chain
-	 *
-	 * and a third way the first uncompleted TD is found:
-	 *
-	 * 3) The TD is active and the previous TD is NOT active
-	 *
-	 * Control and Isochronous ignore the toggle, so this is safe
-	 * for all types
-	 *
-	 * FIXME: The toggle fixups won't be 100% reliable until we
-	 * change over to using a single queue for each endpoint and
-	 * stop the queue before unlinking.
-	 */
-	head = &amp;urbp-&gt;td_list;
-	list_for_each_entry(td, head, list) {
-		unsigned int ctrlstat = td_status(td);
+	/* Queue it for giving back */
+	list_move_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;complete_list);
+}
 
-		if (!(ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp;
-				(uhci_actual_length(ctrlstat) &lt;
-				 uhci_expected_length(td_token(td)) ||
-				td-&gt;list.next == head))
-			usb_settoggle(urb-&gt;dev, uhci_endpoint(td_token(td)),
-				uhci_packetout(td_token(td)),
-				uhci_toggle(td_token(td)) ^ 1);
-		else if ((ctrlstat &amp; TD_CTRL_ACTIVE) &amp;&amp; !prevactive)
-			usb_settoggle(urb-&gt;dev, uhci_endpoint(td_token(td)),
-				uhci_packetout(td_token(td)),
-				uhci_toggle(td_token(td)));
+/*
+ * Check out the QHs waiting to be fully unlinked
+ */
+static void uhci_scan_unlinking_qhs(struct uhci_hcd *uhci)
+{
+	struct uhci_qh *qh, *tmp;
 
-		prevactive = ctrlstat &amp; TD_CTRL_ACTIVE;
-	}
+	list_for_each_entry_safe(qh, tmp, &amp;uhci-&gt;skel_unlink_qh-&gt;node, node) {
 
-	uhci_delete_queued_urb(uhci, urb);
+		/* If the queue is empty and the QH is fully unlinked then
+		 * it can become IDLE. */
+		if (list_empty(&amp;qh-&gt;queue)) {
+			if (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
+					qh-&gt;unlink_frame)
+				uhci_make_qh_idle(uhci, qh);
 
-	/* The interrupt loop will reclaim the QHs */
-	uhci_remove_qh(uhci, urbp-&gt;qh);
-	urbp-&gt;qh = NULL;
+		/* If none of the QH's URBs have been dequeued then the QH
+		 * should be re-activated. */
+		} else {
+			struct urb_priv *urbp;
+			int any_dequeued = 0;
+
+			list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
+				if (urbp-&gt;urb-&gt;status != -EINPROGRESS) {
+					any_dequeued = 1;
+					break;
+				}
+			}
+			if (!any_dequeued)
+				uhci_activate_qh(uhci, qh);
+		}
+	}
 }
 
 static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
@@ -1370,22 +1334,11 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 	urbp = urb-&gt;hcpriv;
 	if (!urbp)			/* URB was never linked! */
 		goto done;
-	list_del_init(&amp;urbp-&gt;urb_list);
 
+	/* Remove Isochronous TDs from the frame list ASAP */
 	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
-		unlink_isochronous_tds(uhci, urb);
-	uhci_unlink_generic(uhci, urb);
-
-	uhci_get_current_frame_number(uhci);
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;urb_remove_age) {
-		uhci_remove_pending_urbps(uhci);
-		uhci-&gt;urb_remove_age = uhci-&gt;frame_number;
-	}
-
-	/* If we're the first, set the next interrupt bit */
-	if (list_empty(&amp;uhci-&gt;urb_remove_list))
-		uhci_set_next_interrupt(uhci);
-	list_add_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;urb_remove_list);
+		uhci_unlink_isochronous_tds(uhci, urb);
+	uhci_unlink_qh(uhci, urbp-&gt;qh);
 
 done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
@@ -1426,17 +1379,6 @@ static int uhci_fsbr_timeout(struct uhci_hcd *uhci, struct urb *urb)
 	return 0;
 }
 
-static void uhci_free_pending_qhs(struct uhci_hcd *uhci)
-{
-	struct uhci_qh *qh, *tmp;
-
-	list_for_each_entry_safe(qh, tmp, &amp;uhci-&gt;qh_remove_list, remove_list) {
-		list_del_init(&amp;qh-&gt;remove_list);
-
-		uhci_free_qh(uhci, qh);
-	}
-}
-
 static void uhci_free_pending_tds(struct uhci_hcd *uhci)
 {
 	struct uhci_td *td, *tmp;
@@ -1455,7 +1397,7 @@ __acquires(uhci-&gt;lock)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
-	uhci_destroy_urb_priv(uhci, urb);
+	uhci_free_urb_priv(uhci, (struct urb_priv *) (urb-&gt;hcpriv));
 
 	spin_unlock(&amp;uhci-&gt;lock);
 	usb_hcd_giveback_urb(hcd, urb, regs);
@@ -1474,13 +1416,6 @@ static void uhci_finish_completion(struct uhci_hcd *uhci, struct pt_regs *regs)
 	}
 }
 
-static void uhci_remove_pending_urbps(struct uhci_hcd *uhci)
-{
-
-	/* Splice the urb_remove_list onto the end of the complete_list */
-	list_splice_init(&amp;uhci-&gt;urb_remove_list, uhci-&gt;complete_list.prev);
-}
-
 /* Process events in the schedule, but only in one thread at a time */
 static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 {
@@ -1498,12 +1433,8 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
 
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;qh_remove_age)
-		uhci_free_pending_qhs(uhci);
 	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age)
 		uhci_free_pending_tds(uhci);
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;urb_remove_age)
-		uhci_remove_pending_urbps(uhci);
 
 	/* Walk the list of pending URBs to see which ones completed
 	 * (must be _safe because uhci_transfer_result() dequeues URBs) */
@@ -1516,25 +1447,21 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci_finish_completion(uhci, regs);
 
 	/* If the controller is stopped, we can finish these off right now */
-	if (uhci-&gt;is_stopped) {
-		uhci_free_pending_qhs(uhci);
+	if (uhci-&gt;is_stopped)
 		uhci_free_pending_tds(uhci);
-		uhci_remove_pending_urbps(uhci);
-	}
 
 	if (uhci-&gt;need_rescan)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	if (list_empty(&amp;uhci-&gt;urb_remove_list) &amp;&amp;
-	    list_empty(&amp;uhci-&gt;td_remove_list) &amp;&amp;
-	    list_empty(&amp;uhci-&gt;qh_remove_list))
+	/* Check out the QHs waiting for unlinking */
+	uhci_scan_unlinking_qhs(uhci);
+
+	if (list_empty(&amp;uhci-&gt;td_remove_list) &amp;&amp;
+			list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);
 	else
 		uhci_set_next_interrupt(uhci);
-
-	/* Wake up anyone waiting for an URB to complete */
-	wake_up_all(&amp;uhci-&gt;waitqh);
 }
 
 static void check_fsbr(struct uhci_hcd *uhci)</pre><hr><pre>commit aef4e266964bc15861b5835c1f5b9d2ebc155c2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 31 12:58:38 2006 -0500

    [PATCH] usbhid: add error handling
    
    This patch (as628c) adds error handling to the USB HID core.  When an
    error is reported for an interrupt URB, the driver will do delayed
    retries, at increasing intervals, for up to one second.  If that doesn't
    work, it will try to reset the device.  Testing by users has shown that
    both the retries and the resets end up getting used.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index f187a719f17e..6b8a51cad375 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -902,6 +902,99 @@ static int hid_input_report(int type, struct urb *urb, int interrupt, struct pt_
 	return 0;
 }
 
+/*
+ * Input submission and I/O error handler.
+ */
+
+static void hid_io_error(struct hid_device *hid);
+
+/* Start up the input URB */
+static int hid_start_in(struct hid_device *hid)
+{
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&amp;hid-&gt;inlock, flags);
+	if (hid-&gt;open &gt; 0 &amp;&amp; !test_bit(HID_SUSPENDED, &amp;hid-&gt;iofl) &amp;&amp;
+			!test_and_set_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl)) {
+		rc = usb_submit_urb(hid-&gt;urbin, GFP_ATOMIC);
+		if (rc != 0)
+			clear_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl);
+	}
+	spin_unlock_irqrestore(&amp;hid-&gt;inlock, flags);
+	return rc;
+}
+
+/* I/O retry timer routine */
+static void hid_retry_timeout(unsigned long _hid)
+{
+	struct hid_device *hid = (struct hid_device *) _hid;
+
+	dev_dbg(&amp;hid-&gt;intf-&gt;dev, "retrying intr urb\n");
+	if (hid_start_in(hid))
+		hid_io_error(hid);
+}
+
+/* Workqueue routine to reset the device */
+static void hid_reset(void *_hid)
+{
+	struct hid_device *hid = (struct hid_device *) _hid;
+	int rc_lock, rc;
+
+	dev_dbg(&amp;hid-&gt;intf-&gt;dev, "resetting device\n");
+	rc = rc_lock = usb_lock_device_for_reset(hid-&gt;dev, hid-&gt;intf);
+	if (rc_lock &gt;= 0) {
+		rc = usb_reset_device(hid-&gt;dev);
+		if (rc_lock)
+			usb_unlock_device(hid-&gt;dev);
+	}
+	clear_bit(HID_RESET_PENDING, &amp;hid-&gt;iofl);
+
+	if (rc == 0) {
+		hid-&gt;retry_delay = 0;
+		if (hid_start_in(hid))
+			hid_io_error(hid);
+	} else if (!(rc == -ENODEV || rc == -EHOSTUNREACH || rc == -EINTR))
+		err("can't reset device, %s-%s/input%d, status %d",
+				hid-&gt;dev-&gt;bus-&gt;bus_name,
+				hid-&gt;dev-&gt;devpath,
+				hid-&gt;ifnum, rc);
+}
+
+/* Main I/O error handler */
+static void hid_io_error(struct hid_device *hid)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;hid-&gt;inlock, flags);
+
+	/* Stop when disconnected */
+	if (usb_get_intfdata(hid-&gt;intf) == NULL)
+		goto done;
+
+	/* When an error occurs, retry at increasing intervals */
+	if (hid-&gt;retry_delay == 0) {
+		hid-&gt;retry_delay = 13;	/* Then 26, 52, 104, 104, ... */
+		hid-&gt;stop_retry = jiffies + msecs_to_jiffies(1000);
+	} else if (hid-&gt;retry_delay &lt; 100)
+		hid-&gt;retry_delay *= 2;
+
+	if (time_after(jiffies, hid-&gt;stop_retry)) {
+
+		/* Retries failed, so do a port reset */
+		if (!test_and_set_bit(HID_RESET_PENDING, &amp;hid-&gt;iofl)) {
+			if (schedule_work(&amp;hid-&gt;reset_work))
+				goto done;
+			clear_bit(HID_RESET_PENDING, &amp;hid-&gt;iofl);
+		}
+	}
+
+	mod_timer(&amp;hid-&gt;io_retry,
+			jiffies + msecs_to_jiffies(hid-&gt;retry_delay));
+done:
+	spin_unlock_irqrestore(&amp;hid-&gt;inlock, flags);
+}
+
 /*
  * Input interrupt completion handler.
  */
@@ -913,25 +1006,35 @@ static void hid_irq_in(struct urb *urb, struct pt_regs *regs)
 
 	switch (urb-&gt;status) {
 		case 0:			/* success */
+			hid-&gt;retry_delay = 0;
 			hid_input_report(HID_INPUT_REPORT, urb, 1, regs);
 			break;
 		case -ECONNRESET:	/* unlink */
 		case -ENOENT:
-		case -EPERM:
 		case -ESHUTDOWN:	/* unplug */
-		case -EILSEQ:		/* unplug timeout on uhci */
+			clear_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl);
 			return;
+		case -EILSEQ:		/* protocol error or unplug */
+		case -EPROTO:		/* protocol error or unplug */
 		case -ETIMEDOUT:	/* NAK */
-			break;
+			clear_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl);
+			hid_io_error(hid);
+			return;
 		default:		/* error */
 			warn("input irq status %d received", urb-&gt;status);
 	}
 
 	status = usb_submit_urb(urb, SLAB_ATOMIC);
-	if (status)
-		err("can't resubmit intr, %s-%s/input%d, status %d",
-				hid-&gt;dev-&gt;bus-&gt;bus_name, hid-&gt;dev-&gt;devpath,
-				hid-&gt;ifnum, status);
+	if (status) {
+		clear_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl);
+		if (status != -EPERM) {
+			err("can't resubmit intr, %s-%s/input%d, status %d",
+					hid-&gt;dev-&gt;bus-&gt;bus_name,
+					hid-&gt;dev-&gt;devpath,
+					hid-&gt;ifnum, status);
+			hid_io_error(hid);
+		}
+	}
 }
 
 /*
@@ -1093,8 +1196,9 @@ static void hid_irq_out(struct urb *urb, struct pt_regs *regs)
 		case 0:			/* success */
 			break;
 		case -ESHUTDOWN:	/* unplug */
-		case -EILSEQ:		/* unplug timeout on uhci */
 			unplug = 1;
+		case -EILSEQ:		/* protocol error or unplug */
+		case -EPROTO:		/* protocol error or unplug */
 		case -ECONNRESET:	/* unlink */
 		case -ENOENT:
 			break;
@@ -1141,8 +1245,9 @@ static void hid_ctrl(struct urb *urb, struct pt_regs *regs)
 				hid_input_report(hid-&gt;ctrl[hid-&gt;ctrltail].report-&gt;type, urb, 0, regs);
 			break;
 		case -ESHUTDOWN:	/* unplug */
-		case -EILSEQ:		/* unplug timectrl on uhci */
 			unplug = 1;
+		case -EILSEQ:		/* protocol error or unplug */
+		case -EPROTO:		/* protocol error or unplug */
 		case -ECONNRESET:	/* unlink */
 		case -ENOENT:
 		case -EPIPE:		/* report not available */
@@ -1255,14 +1360,9 @@ static int hid_get_class_descriptor(struct usb_device *dev, int ifnum,
 
 int hid_open(struct hid_device *hid)
 {
-	if (hid-&gt;open++)
-		return 0;
-
-	hid-&gt;urbin-&gt;dev = hid-&gt;dev;
-
-	if (usb_submit_urb(hid-&gt;urbin, GFP_KERNEL))
-		return -EIO;
-
+	++hid-&gt;open;
+	if (hid_start_in(hid))
+		hid_io_error(hid);
 	return 0;
 }
 
@@ -1787,6 +1887,10 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 
 	init_waitqueue_head(&amp;hid-&gt;wait);
 
+	INIT_WORK(&amp;hid-&gt;reset_work, hid_reset, hid);
+	setup_timer(&amp;hid-&gt;io_retry, hid_retry_timeout, (unsigned long) hid);
+
+	spin_lock_init(&amp;hid-&gt;inlock);
 	spin_lock_init(&amp;hid-&gt;outlock);
 	spin_lock_init(&amp;hid-&gt;ctrllock);
 
@@ -1855,11 +1959,16 @@ static void hid_disconnect(struct usb_interface *intf)
 	if (!hid)
 		return;
 
+	spin_lock_irq(&amp;hid-&gt;inlock);	/* Sync with error handler */
 	usb_set_intfdata(intf, NULL);
+	spin_unlock_irq(&amp;hid-&gt;inlock);
 	usb_kill_urb(hid-&gt;urbin);
 	usb_kill_urb(hid-&gt;urbout);
 	usb_kill_urb(hid-&gt;urbctrl);
 
+	del_timer_sync(&amp;hid-&gt;io_retry);
+	flush_scheduled_work();
+
 	if (hid-&gt;claimed &amp; HID_CLAIMED_INPUT)
 		hidinput_disconnect(hid);
 	if (hid-&gt;claimed &amp; HID_CLAIMED_HIDDEV)
@@ -1934,6 +2043,10 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct hid_device *hid = usb_get_intfdata (intf);
 
+	spin_lock_irq(&amp;hid-&gt;inlock);	/* Sync with error handler */
+	set_bit(HID_SUSPENDED, &amp;hid-&gt;iofl);
+	spin_unlock_irq(&amp;hid-&gt;inlock);
+	del_timer(&amp;hid-&gt;io_retry);
 	usb_kill_urb(hid-&gt;urbin);
 	dev_dbg(&amp;intf-&gt;dev, "suspend\n");
 	return 0;
@@ -1944,10 +2057,8 @@ static int hid_resume(struct usb_interface *intf)
 	struct hid_device *hid = usb_get_intfdata (intf);
 	int status;
 
-	if (hid-&gt;open)
-		status = usb_submit_urb(hid-&gt;urbin, GFP_NOIO);
-	else
-		status = 0;
+	clear_bit(HID_SUSPENDED, &amp;hid-&gt;iofl);
+	status = hid_start_in(hid);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return status;
 }
diff --git a/drivers/usb/input/hid.h b/drivers/usb/input/hid.h
index 8b0d4346ce9c..4e1b784fe527 100644
--- a/drivers/usb/input/hid.h
+++ b/drivers/usb/input/hid.h
@@ -31,6 +31,8 @@
 #include &lt;linux/types.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/timer.h&gt;
+#include &lt;linux/workqueue.h&gt;
 
 /*
  * USB HID (Human Interface Device) interface class code
@@ -370,6 +372,9 @@ struct hid_control_fifo {
 
 #define HID_CTRL_RUNNING	1
 #define HID_OUT_RUNNING		2
+#define HID_IN_RUNNING		3
+#define HID_RESET_PENDING	4
+#define HID_SUSPENDED		5
 
 struct hid_input {
 	struct list_head list;
@@ -393,12 +398,17 @@ struct hid_device {							/* device report descriptor */
 	int ifnum;							/* USB interface number */
 
 	unsigned long iofl;						/* I/O flags (CTRL_RUNNING, OUT_RUNNING) */
+	struct timer_list io_retry;					/* Retry timer */
+	unsigned long stop_retry;					/* Time to give up, in jiffies */
+	unsigned int retry_delay;					/* Delay length in ms */
+	struct work_struct reset_work;					/* Task context for resets */
 
 	unsigned int bufsize;						/* URB buffer size */
 
 	struct urb *urbin;						/* Input URB */
 	char *inbuf;							/* Input buffer */
 	dma_addr_t inbuf_dma;						/* Input buffer dma */
+	spinlock_t inlock;						/* Input fifo spinlock */
 
 	struct urb *urbctrl;						/* Control URB */
 	struct usb_ctrlrequest *cr;					/* Control request struct */</pre><hr><pre>commit 754501b324fc3c42522a46d3ace205e7a6a50e77
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 10:19:25 2006 -0500

    [PATCH] USB: unusual_devs entry for Lyra RCA RD1080
    
    This patch (as656) adds an unusual_devs.h entry for the Lyra RCA RD1080
    MP3 player.  Its card-reader firmware has the common
    report-one-too-many-sectors bug.  This fixes Novell bug #152175.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index e71c5ca1a07b..31ca92056c27 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -753,6 +753,13 @@ UNUSUAL_DEV(  0x0693, 0x0005, 0x0100, 0x0100,
 		"Flashgate",
 		US_SC_SCSI, US_PR_BULK, NULL, 0 ), 
 
+/* Reported by David Hamilton &lt;niftimusmaximus@lycos.com&gt; */
+UNUSUAL_DEV(  0x069b, 0x3004, 0x0001, 0x0001,
+		"Thomson Multimedia Inc.",
+		"RCA RD1080 MP3 Player",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY ),
+
 UNUSUAL_DEV(  0x0781, 0x0001, 0x0200, 0x0200, 
 		"Sandisk",
 		"ImageMate SDDR-05a",</pre><hr><pre>commit 1bfc5d9d5eb8e1a2efacc306bc55c248ed259a8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 9 15:26:18 2006 -0500

    [SCSI] Recognize missing LUNs for non-standard devices
    
    Some non-standard SCSI targets or protocols, such as USB UFI, report "no
    LUN present" by setting the Peripheral Device Type to 0x1f and the
    Peripheral Qualifier to 0 (not 3 as the standard requires) in the INQUIRY
    response.  This patch (as650b) adds a new target flag and code to
    accomodate such targets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 803c7b9690c5..94b86d5b1469 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -853,6 +853,19 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
 		goto out_free_result;
 	}
 
+	/*
+	 * Non-standard SCSI targets may set the PDT to 0x1f (unknown or
+	 * no device type) instead of using the Peripheral Qualifier to
+	 * indicate that no LUN is present.  For example, USB UFI does this.
+	 */
+	if (starget-&gt;pdt_1f_for_no_lun &amp;&amp; (result[0] &amp; 0x1f) == 0x1f) {
+		SCSI_LOG_SCAN_BUS(3, printk(KERN_INFO
+					"scsi scan: peripheral device type"
+					" of 31, no device added\n"));
+		res = SCSI_SCAN_TARGET_PRESENT;
+		goto out_free_result;
+	}
+
 	res = scsi_add_lun(sdev, result, &amp;bflags);
 	if (res == SCSI_SCAN_LUN_PRESENT) {
 		if (bflags &amp; BLIST_KEY) {
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index cde84b39bb65..8d77da932d2c 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -167,7 +167,10 @@ struct scsi_target {
 	unsigned int		channel;
 	unsigned int		id; /* target id ... replace
 				     * scsi_device.id eventually */
-	unsigned long		create:1; /* signal that it needs to be added */
+	unsigned int		create:1; /* signal that it needs to be added */
+	unsigned int		pdt_1f_for_no_lun;	/* PDT = 0x1f */
+						/* means no lun present */
+
 	char			scsi_level;
 	void 			*hostdata; /* available to low-level driver */
 	unsigned long		starget_data[0]; /* for the transport */</pre><hr><pre>commit 982db2a127b29c9e1f5896d2ba691e84446cc858
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 13 10:16:04 2006 -0500

    [PATCH] USB: unusual_devs.h entry: iAUDIO M5
    
    Another unusual_devs.h entry (as652).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1d8a739ccc96..7e1cb03c2ed7 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1098,6 +1098,13 @@ UNUSUAL_DEV(  0x0dda, 0x0301, 0x0012, 0x0012,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jim McCloskey &lt;mcclosk@ucsc.edu&gt; */
+UNUSUAL_DEV( 0x0e21, 0x0520, 0x0100, 0x0100,
+		"Cowon Systems",
+		"iAUDIO M5",
+		US_SC_DEVICE, US_PR_BULK, NULL,
+		0 ),
+
 /* Submitted by Antoine Mairesse &lt;antoine.mairesse@free.fr&gt; */
 UNUSUAL_DEV( 0x0ed1, 0x6660, 0x0100, 0x0300,
 		"USB",</pre><hr><pre>commit 1d614a4b0d2613d83f7bf0978e213ba29aebc44f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 13 10:15:22 2006 -0500

    [PATCH] USB: unusual_devs.h entry: TrekStor i.Beat
    
    A new unusual_devs.h entry (as651).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 6e326159c2dd..1d8a739ccc96 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -106,6 +106,13 @@ UNUSUAL_DEV(  0x0411, 0x001c, 0x0113, 0x0113,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
+/* Reported by Christian Leber &lt;christian@leber.de&gt; */
+UNUSUAL_DEV(  0x0419, 0xaaf5, 0x0100, 0x0100,
+		"TrekStor",
+		"i.Beat 115 2.0",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_IGNORE_RESIDUE | US_FL_NOT_LOCKABLE ),
+
 /* Reported by Stefan Werner &lt;dustbln@gmx.de&gt; */
 UNUSUAL_DEV(  0x0419, 0xaaf6, 0x0100, 0x0100,
 		"TrekStor",</pre><hr><pre>commit ba3e93ad3c6e511f68c1b3e46954feff6cdd5a62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 30 10:19:43 2006 -0500

    [PATCH] usb-storage: unusual_devs entry
    
    Here is a new entry for unusual_devs.h (as630).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index c5d6d84b9b2b..6e326159c2dd 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -946,6 +946,12 @@ UNUSUAL_DEV(  0x084d, 0x0011, 0x0110, 0x0110,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_BULK32),
 
+/* Submitted by Jan De Luyck &lt;lkml@kcore.org&gt; */
+UNUSUAL_DEV(  0x08bd, 0x1100, 0x0000, 0x0000,
+		"CITIZEN",
+		"X1DE-USB",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_SINGLE_LUN),
 
 /* Entry needed for flags. Moreover, all devices with this ID use
  * bulk-only transport, but _some_ falsely report Control/Bulk instead.</pre>
    <div class="pagination">
        <a href='2_128.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><span>[129]</span><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_130.html'>Next&gt;&gt;</a>
    <div>
</body>

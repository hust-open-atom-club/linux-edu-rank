<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of California, Berkeley</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of California, Berkeley</h1>
    <div class="pagination">
        <a href='31.html'>&lt;&lt;Prev</a><a href='31.html'>1</a><span>[2]</span><a href='31_3.html'>3</a><a href='31_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7eaae2828dadae3abde7f77734c874d4b74b313a
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Thu Jul 7 17:57:06 2005 -0700

    [PATCH] coverity: fs/locks.c flp null check
    
    We're dereferencing `flp' and then we're testing it for NULLness.
    
    Either the compiler accidentally saved us or the existing null-pointer checdk
    is redundant.
    
    This defect was found automatically by Coverity Prevent, a static analysis tool.
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: Matthew Wilcox &lt;willy@debian.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/locks.c b/fs/locks.c
index a0bc03495bd4..29fa5da6c117 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1276,7 +1276,7 @@ int fcntl_getlease(struct file *filp)
  */
 static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 {
-	struct file_lock *fl, **before, **my_before = NULL, *lease = *flp;
+	struct file_lock *fl, **before, **my_before = NULL, *lease;
 	struct dentry *dentry = filp-&gt;f_dentry;
 	struct inode *inode = dentry-&gt;d_inode;
 	int error, rdlease_count = 0, wrlease_count = 0;
@@ -1287,6 +1287,8 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 	if (!flp || !(*flp) || !(*flp)-&gt;fl_lmops || !(*flp)-&gt;fl_lmops-&gt;fl_break)
 		goto out;
 
+	lease = *flp;
+
 	error = -EAGAIN;
 	if ((arg == F_RDLCK) &amp;&amp; (atomic_read(&amp;inode-&gt;i_writecount) &gt; 0))
 		goto out;</pre><hr><pre>commit 8f96c95680bfe66ff00c91859d4c73edf539b854
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Thu Jul 7 17:57:05 2005 -0700

    [PATCH] coverity: fix fbsysfs null pointer check
    
    Correctly test for a null pointer before going and dereferencing it.
    
    This defect was found automatically by Coverity Prevent, a static analysis
    tool.
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: &lt;linux-fbdev-devel@lists.sourceforge.net&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/video/fbsysfs.c b/drivers/video/fbsysfs.c
index 7dfbf39b4ed3..ddc9443254d9 100644
--- a/drivers/video/fbsysfs.c
+++ b/drivers/video/fbsysfs.c
@@ -256,7 +256,7 @@ static ssize_t show_cmap(struct class_device *class_device, char *buf)
 	unsigned int offset = 0, i;
 
 	if (!fb_info-&gt;cmap.red || !fb_info-&gt;cmap.blue ||
-	    fb_info-&gt;cmap.green || fb_info-&gt;cmap.transp)
+	    !fb_info-&gt;cmap.green || !fb_info-&gt;cmap.transp)
 		return -EINVAL;
 
 	for (i = 0; i &lt; fb_info-&gt;cmap.len; i++) {</pre><hr><pre>commit 69f63c5c34d0b34ee2cbf10c5ff7fcff0404879e
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:12 2005 -0700

    [PATCH] coverity: tty_ldisc_ref return null check
    
    We add a check of the return value of tty_ldisc_ref(), which
    is checked 7 out of 8 times, e.g.:
    
    149             ld = tty_ldisc_ref(tty);
    150             if (ld != NULL) {
    151                     if (ld-&gt;set_termios)
    152                             (ld-&gt;set_termios)(tty, &amp;old_termios);
    153                     tty_ldisc_deref(ld);
    154             }
    
    This defect was found automatically by Coverity Prevent, a static analysis
    tool.
    
    (akpm: presumably `ld' is never NULL.  Oh well)
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/char/tty_ioctl.c b/drivers/char/tty_ioctl.c
index 58597993954f..f19cf9d7792d 100644
--- a/drivers/char/tty_ioctl.c
+++ b/drivers/char/tty_ioctl.c
@@ -476,11 +476,11 @@ int n_tty_ioctl(struct tty_struct * tty, struct file * file,
 			ld = tty_ldisc_ref(tty);
 			switch (arg) {
 			case TCIFLUSH:
-				if (ld-&gt;flush_buffer)
+				if (ld &amp;&amp; ld-&gt;flush_buffer)
 					ld-&gt;flush_buffer(tty);
 				break;
 			case TCIOFLUSH:
-				if (ld-&gt;flush_buffer)
+				if (ld &amp;&amp; ld-&gt;flush_buffer)
 					ld-&gt;flush_buffer(tty);
 				/* fall through */
 			case TCOFLUSH:</pre><hr><pre>commit c7f1721ef284c6e8257c7471a02148db76105036
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:11 2005 -0700

    [PATCH] coverity: fs/ext3/super.c: match_int return check
    
    The return value of  "match_int" is  checked  27 out of 28 times
    
    In lib/parser.c
    142     /**
    143      * match_int: - scan a decimal representation of an integer from a substring_t
    144      * @s: substring_t to be scanned
    145      * @result: resulting integer on success
    146      *
    147      * Description: Attempts to parse the &amp;substring_t @s as a decimal integer. On
    148      * success, sets @result to the integer represented by the string and returns 0.
    149      * Returns either -ENOMEM or -EINVAL on failure.
    150      */
    151     int match_int(substring_t *s, int *result)
    152     {
    153             return match_number(s, result, 0);
    154     }
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index b4b3e8a39131..a6d1779d7de4 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -944,7 +944,8 @@ static int parse_options (char * options, struct super_block *sb,
 					"for remount\n");
 				return 0;
 			}
-			match_int(&amp;args[0], &amp;option);
+			if (match_int(&amp;args[0], &amp;option) != 0)
+				return 0;
 			*n_blocks_count = option;
 			break;
 		case Opt_nobh:</pre><hr><pre>commit ec471dc484b8ca5352903ee28796b8b248313547
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:10 2005 -0700

    [PATCH] coverity: fs/udf/namei.c null check
    
    "dir" was dereferenced before null check
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/udf/namei.c b/fs/udf/namei.c
index 3f6dc7112bc6..4673157b262f 100644
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@ -159,7 +159,7 @@ udf_find_entry(struct inode *dir, struct dentry *dentry,
 	char *nameptr;
 	uint8_t lfi;
 	uint16_t liu;
-	loff_t size = (udf_ext0_offset(dir) + dir-&gt;i_size) &gt;&gt; 2;
+	loff_t size;
 	kernel_lb_addr bloc, eloc;
 	uint32_t extoffset, elen, offset;
 	struct buffer_head *bh = NULL;
@@ -167,6 +167,8 @@ udf_find_entry(struct inode *dir, struct dentry *dentry,
 	if (!dir)
 		return NULL;
 
+	size = (udf_ext0_offset(dir) + dir-&gt;i_size) &gt;&gt; 2;
+
 	f_pos = (udf_ext0_offset(dir) &gt;&gt; 2);
 
 	fibh-&gt;soffset = fibh-&gt;eoffset = (f_pos &amp; ((dir-&gt;i_sb-&gt;s_blocksize - 1) &gt;&gt; 2)) &lt;&lt; 2;</pre><hr><pre>commit 9c101fd439dab60d6eba76afb35fd2696f42c63d
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:08 2005 -0700

    [PATCH] coverity: ipmi_msghandler() channels array overrun fix
    
    We fix the check in 1084, which was
    
    1084                    if (addr-&gt;channel &gt; IPMI_NUM_CHANNELS) {
    1085                            spin_lock_irqsave(&amp;intf-&gt;counter_lock, flags);
    1086                            intf-&gt;sent_invalid_commands++;
    1087                            spin_unlock_irqrestore(&amp;intf-&gt;counter_lock, flags);
    1088                            rv = -EINVAL;
    1089                            goto out_err;
    1090                    }
    
    addr-&gt;channel is used in
    
    1092                    if (intf-&gt;channels[addr-&gt;channel].medium
    
    Definitions involved:
    
    221             struct ipmi_channel channels[IPMI_MAX_CHANNELS];
    
    134     #define IPMI_MAX_CHANNELS       8
    
    In /linux-2.6.12-rc6/include/linux/ipmi.h
    148     #define IPMI_NUM_CHANNELS 0x10
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: Corey Minyard &lt;minyard@acm.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index 1813d0d198f1..e16c13fe698d 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -1088,8 +1088,8 @@ static inline int i_ipmi_request(ipmi_user_t          user,
 		long                  seqid;
 		int                   broadcast = 0;
 
-		if (addr-&gt;channel &gt; IPMI_NUM_CHANNELS) {
-			spin_lock_irqsave(&amp;intf-&gt;counter_lock, flags);
+		if (addr-&gt;channel &gt;= IPMI_MAX_CHANNELS) {
+		        spin_lock_irqsave(&amp;intf-&gt;counter_lock, flags);
 			intf-&gt;sent_invalid_commands++;
 			spin_unlock_irqrestore(&amp;intf-&gt;counter_lock, flags);
 			rv = -EINVAL;</pre><hr><pre>commit a77e3362a224212d9d3b9e6fdec44df2eef6cf92
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:06 2005 -0700

    [PATCH] coverity: i386: scsi_lib buffer overrun fix
    
    The check in
    
    627             BUG_ON(index &gt; SG_MEMPOOL_NR);
    
    with SG_MEMPOOL_NR defined in
    
    32      #define SG_MEMPOOL_NR           (sizeof(scsi_sg_pools)/sizeof(struct scsi_host_sg_pool))
    
    was not sufficient.
    
    sgp, set in
    
    629             sgp = scsi_sg_pools + index;
    
    is dereferenced in
    
    630             mempool_free(sgl, sgp-&gt;pool);
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: &lt;linux-scsi@vger.kernel.org&gt;
    Cc: James Bottomley &lt;James.Bottomley@steeleye.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 621dee8b8cb2..10506f9cd0c9 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -632,7 +632,7 @@ static void scsi_free_sgtable(struct scatterlist *sgl, int index)
 {
 	struct scsi_host_sg_pool *sgp;
 
-	BUG_ON(index &gt; SG_MEMPOOL_NR);
+	BUG_ON(index &gt;= SG_MEMPOOL_NR);
 
 	sgp = scsi_sg_pools + index;
 	mempool_free(sgl, sgp-&gt;pool);</pre><hr><pre>commit a8f5034540195307362d071a8b387226b410469f
Author: KAMBAROV, ZAUR &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 28 20:45:06 2005 -0700

    [PATCH] coverity: i386: build.c: negative return to unsigned fix
    
    Variable "c" was declared as an unsigned int, but used in:
    
    125             for (i=0 ; (c=read(fd, buf, sizeof(buf)))&gt;0 ; i+=c )
    126                     if (write(1, buf, c) != c)
    127                             die("Write call failed");
    
    (akpm: read() can return -1.  If it does, we fill the disk up with garbage).
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/arch/i386/boot/tools/build.c b/arch/i386/boot/tools/build.c
index 4a17956512e1..6835f6d47c31 100644
--- a/arch/i386/boot/tools/build.c
+++ b/arch/i386/boot/tools/build.c
@@ -70,7 +70,8 @@ void usage(void)
 
 int main(int argc, char ** argv)
 {
-	unsigned int i, c, sz, setup_sectors;
+	unsigned int i, sz, setup_sectors;
+	int c;
 	u32 sys_size;
 	byte major_root, minor_root;
 	struct stat sb;</pre><hr><pre>commit 589777eab7360894b7ca1c4ba9d252e03b51225b
Author: Zaur Kambarov &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 21 17:14:31 2005 -0700

    [PATCH] coverity: idr_get_new_above_int() overrun fix
    
    This patch fixes overrun of array pa:
    92              struct idr_layer *pa[MAX_LEVEL];
    
    in
    
    98              l = idp-&gt;layers;
    99              pa[l--] = NULL;
    
    by passing idp-&gt;layers, set in
    202             idp-&gt;layers = layers;
    to function  sub_alloc in
    203             v = sub_alloc(idp, ptr, &amp;id);
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/lib/idr.c b/lib/idr.c
index 81fc430602ee..c5be889de449 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -175,7 +175,7 @@ static int idr_get_new_above_int(struct idr *idp, void *ptr, int starting_id)
 	 * Add a new layer to the top of the tree if the requested
 	 * id is larger than the currently allocated space.
 	 */
-	while ((layers &lt; MAX_LEVEL) &amp;&amp; (id &gt;= (1 &lt;&lt; (layers*IDR_BITS)))) {
+	while ((layers &lt; (MAX_LEVEL - 1)) &amp;&amp; (id &gt;= (1 &lt;&lt; (layers*IDR_BITS)))) {
 		layers++;
 		if (!p-&gt;count)
 			continue;</pre><hr><pre>commit 3a845099b20e81fb678521f034bbdcd69208da4e
Author: Zaur Kambarov &lt;kambarov@berkeley.edu&gt;
Date:   Tue Jun 21 17:14:30 2005 -0700

    [PATCH] coverity: ipmi: avoid overrun of ipmi_interfaces[]
    
    Fix overrun of static array "ipmi_interfaces" of size 4 at position 4 with
    index variable "if_num".
    
    Definitions involved:
    297     #define MAX_IPMI_INTERFACES 4
    298     static ipmi_smi_t ipmi_interfaces[MAX_IPMI_INTERFACES];
    
    Signed-off-by: Zaur Kambarov &lt;zkambarov@coverity.com&gt;
    Cc: Corey Minyard &lt;minyard@acm.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index d7fb452af7f9..0c81652eaba6 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -641,7 +641,7 @@ int ipmi_create_user(unsigned int          if_num,
 		return -ENOMEM;
 
 	down_read(&amp;interfaces_sem);
-	if ((if_num &gt; MAX_IPMI_INTERFACES) || ipmi_interfaces[if_num] == NULL)
+	if ((if_num &gt;= MAX_IPMI_INTERFACES) || ipmi_interfaces[if_num] == NULL)
 	{
 		rv = -EINVAL;
 		goto out_unlock;</pre>
    <div class="pagination">
        <a href='31.html'>&lt;&lt;Prev</a><a href='31.html'>1</a><span>[2]</span><a href='31_3.html'>3</a><a href='31_3.html'>Next&gt;&gt;</a>
    <div>
</body>
